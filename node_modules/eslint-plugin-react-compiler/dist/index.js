/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @lightSyntaxTransform
 * @noflow
 * @nolint
 * @preventMunge
 * @preserve-invariant-messages
 */

"use no memo";
"use strict";
var core$2 = require("@babel/core");
var PluginProposalPrivateMethods = require("@babel/plugin-proposal-private-methods");
var zod = require("zod");
var zodValidationError = require("zod-validation-error");
var crypto = require("crypto");
var HermesParser = require("hermes-parser");
function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== "default") {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(
          n,
          k,
          d.get
            ? d
            : {
                enumerable: true,
                get: function () {
                  return e[k];
                },
              }
        );
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}
var HermesParser__namespace = _interopNamespaceDefault(HermesParser);
var commonjsGlobal =
  typeof globalThis !== "undefined"
    ? globalThis
    : typeof window !== "undefined"
      ? window
      : typeof global !== "undefined"
        ? global
        : typeof self !== "undefined"
          ? self
          : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default")
    ? x["default"]
    : x;
}
var NODE_ENV = process.env.NODE_ENV;
var invariant = function (condition, format, a, b, c, d, e, f) {
  if (NODE_ENV !== "production") {
    if (format === undefined) {
      throw new Error("invariant requires an error message argument");
    }
  }
  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        "Minified exception occurred; use the non-minified dev environment " +
          "for the full error message and additional helpful warnings."
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function () {
          return args[argIndex++];
        })
      );
      error.name = "Invariant Violation";
    }
    error.framesToPop = 1;
    throw error;
  }
};
var invariant_1 = invariant;
var invariant$1 = getDefaultExportFromCjs(invariant_1);
var lib$5 = {};
var isReactComponent$2 = {};
var buildMatchMemberExpression$2 = {};
var matchesPattern$2 = {};
var generated$9 = {};
var shallowEqual$2 = {};
Object.defineProperty(shallowEqual$2, "__esModule", { value: true });
shallowEqual$2.default = shallowEqual$1;
function shallowEqual$1(actual, expected) {
  const keys = Object.keys(expected);
  for (const key of keys) {
    if (actual[key] !== expected[key]) {
      return false;
    }
  }
  return true;
}
Object.defineProperty(generated$9, "__esModule", { value: true });
generated$9.isAccessor = isAccessor;
generated$9.isAnyTypeAnnotation = isAnyTypeAnnotation;
generated$9.isArgumentPlaceholder = isArgumentPlaceholder;
generated$9.isArrayExpression = isArrayExpression;
generated$9.isArrayPattern = isArrayPattern;
generated$9.isArrayTypeAnnotation = isArrayTypeAnnotation;
generated$9.isArrowFunctionExpression = isArrowFunctionExpression;
generated$9.isAssignmentExpression = isAssignmentExpression;
generated$9.isAssignmentPattern = isAssignmentPattern;
generated$9.isAwaitExpression = isAwaitExpression;
generated$9.isBigIntLiteral = isBigIntLiteral;
generated$9.isBinary = isBinary;
generated$9.isBinaryExpression = isBinaryExpression;
generated$9.isBindExpression = isBindExpression;
generated$9.isBlock = isBlock;
generated$9.isBlockParent = isBlockParent;
generated$9.isBlockStatement = isBlockStatement;
generated$9.isBooleanLiteral = isBooleanLiteral;
generated$9.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
generated$9.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
generated$9.isBreakStatement = isBreakStatement;
generated$9.isCallExpression = isCallExpression;
generated$9.isCatchClause = isCatchClause;
generated$9.isClass = isClass;
generated$9.isClassAccessorProperty = isClassAccessorProperty;
generated$9.isClassBody = isClassBody;
generated$9.isClassDeclaration = isClassDeclaration;
generated$9.isClassExpression = isClassExpression;
generated$9.isClassImplements = isClassImplements;
generated$9.isClassMethod = isClassMethod;
generated$9.isClassPrivateMethod = isClassPrivateMethod;
generated$9.isClassPrivateProperty = isClassPrivateProperty;
generated$9.isClassProperty = isClassProperty;
generated$9.isCompletionStatement = isCompletionStatement;
generated$9.isConditional = isConditional;
generated$9.isConditionalExpression = isConditionalExpression;
generated$9.isContinueStatement = isContinueStatement;
generated$9.isDebuggerStatement = isDebuggerStatement;
generated$9.isDecimalLiteral = isDecimalLiteral;
generated$9.isDeclaration = isDeclaration;
generated$9.isDeclareClass = isDeclareClass;
generated$9.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
generated$9.isDeclareExportDeclaration = isDeclareExportDeclaration;
generated$9.isDeclareFunction = isDeclareFunction;
generated$9.isDeclareInterface = isDeclareInterface;
generated$9.isDeclareModule = isDeclareModule;
generated$9.isDeclareModuleExports = isDeclareModuleExports;
generated$9.isDeclareOpaqueType = isDeclareOpaqueType;
generated$9.isDeclareTypeAlias = isDeclareTypeAlias;
generated$9.isDeclareVariable = isDeclareVariable;
generated$9.isDeclaredPredicate = isDeclaredPredicate;
generated$9.isDecorator = isDecorator;
generated$9.isDirective = isDirective;
generated$9.isDirectiveLiteral = isDirectiveLiteral;
generated$9.isDoExpression = isDoExpression;
generated$9.isDoWhileStatement = isDoWhileStatement;
generated$9.isEmptyStatement = isEmptyStatement;
generated$9.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
generated$9.isEnumBody = isEnumBody;
generated$9.isEnumBooleanBody = isEnumBooleanBody;
generated$9.isEnumBooleanMember = isEnumBooleanMember;
generated$9.isEnumDeclaration = isEnumDeclaration;
generated$9.isEnumDefaultedMember = isEnumDefaultedMember;
generated$9.isEnumMember = isEnumMember;
generated$9.isEnumNumberBody = isEnumNumberBody;
generated$9.isEnumNumberMember = isEnumNumberMember;
generated$9.isEnumStringBody = isEnumStringBody;
generated$9.isEnumStringMember = isEnumStringMember;
generated$9.isEnumSymbolBody = isEnumSymbolBody;
generated$9.isExistsTypeAnnotation = isExistsTypeAnnotation;
generated$9.isExportAllDeclaration = isExportAllDeclaration;
generated$9.isExportDeclaration = isExportDeclaration;
generated$9.isExportDefaultDeclaration = isExportDefaultDeclaration;
generated$9.isExportDefaultSpecifier = isExportDefaultSpecifier;
generated$9.isExportNamedDeclaration = isExportNamedDeclaration;
generated$9.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
generated$9.isExportSpecifier = isExportSpecifier;
generated$9.isExpression = isExpression;
generated$9.isExpressionStatement = isExpressionStatement;
generated$9.isExpressionWrapper = isExpressionWrapper;
generated$9.isFile = isFile;
generated$9.isFlow = isFlow;
generated$9.isFlowBaseAnnotation = isFlowBaseAnnotation;
generated$9.isFlowDeclaration = isFlowDeclaration;
generated$9.isFlowPredicate = isFlowPredicate;
generated$9.isFlowType = isFlowType;
generated$9.isFor = isFor;
generated$9.isForInStatement = isForInStatement;
generated$9.isForOfStatement = isForOfStatement;
generated$9.isForStatement = isForStatement;
generated$9.isForXStatement = isForXStatement;
generated$9.isFunction = isFunction;
generated$9.isFunctionDeclaration = isFunctionDeclaration;
generated$9.isFunctionExpression = isFunctionExpression;
generated$9.isFunctionParent = isFunctionParent;
generated$9.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
generated$9.isFunctionTypeParam = isFunctionTypeParam;
generated$9.isGenericTypeAnnotation = isGenericTypeAnnotation;
generated$9.isIdentifier = isIdentifier;
generated$9.isIfStatement = isIfStatement;
generated$9.isImmutable = isImmutable$3;
generated$9.isImport = isImport;
generated$9.isImportAttribute = isImportAttribute;
generated$9.isImportDeclaration = isImportDeclaration;
generated$9.isImportDefaultSpecifier = isImportDefaultSpecifier;
generated$9.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
generated$9.isImportSpecifier = isImportSpecifier;
generated$9.isIndexedAccessType = isIndexedAccessType;
generated$9.isInferredPredicate = isInferredPredicate;
generated$9.isInterfaceDeclaration = isInterfaceDeclaration;
generated$9.isInterfaceExtends = isInterfaceExtends;
generated$9.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
generated$9.isInterpreterDirective = isInterpreterDirective;
generated$9.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
generated$9.isJSX = isJSX;
generated$9.isJSXAttribute = isJSXAttribute;
generated$9.isJSXClosingElement = isJSXClosingElement;
generated$9.isJSXClosingFragment = isJSXClosingFragment;
generated$9.isJSXElement = isJSXElement;
generated$9.isJSXEmptyExpression = isJSXEmptyExpression;
generated$9.isJSXExpressionContainer = isJSXExpressionContainer;
generated$9.isJSXFragment = isJSXFragment;
generated$9.isJSXIdentifier = isJSXIdentifier;
generated$9.isJSXMemberExpression = isJSXMemberExpression;
generated$9.isJSXNamespacedName = isJSXNamespacedName;
generated$9.isJSXOpeningElement = isJSXOpeningElement;
generated$9.isJSXOpeningFragment = isJSXOpeningFragment;
generated$9.isJSXSpreadAttribute = isJSXSpreadAttribute;
generated$9.isJSXSpreadChild = isJSXSpreadChild;
generated$9.isJSXText = isJSXText;
generated$9.isLVal = isLVal;
generated$9.isLabeledStatement = isLabeledStatement;
generated$9.isLiteral = isLiteral;
generated$9.isLogicalExpression = isLogicalExpression;
generated$9.isLoop = isLoop;
generated$9.isMemberExpression = isMemberExpression;
generated$9.isMetaProperty = isMetaProperty;
generated$9.isMethod = isMethod;
generated$9.isMiscellaneous = isMiscellaneous;
generated$9.isMixedTypeAnnotation = isMixedTypeAnnotation;
generated$9.isModuleDeclaration = isModuleDeclaration;
generated$9.isModuleExpression = isModuleExpression;
generated$9.isModuleSpecifier = isModuleSpecifier;
generated$9.isNewExpression = isNewExpression;
generated$9.isNoop = isNoop;
generated$9.isNullLiteral = isNullLiteral;
generated$9.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
generated$9.isNullableTypeAnnotation = isNullableTypeAnnotation;
generated$9.isNumberLiteral = isNumberLiteral;
generated$9.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
generated$9.isNumberTypeAnnotation = isNumberTypeAnnotation;
generated$9.isNumericLiteral = isNumericLiteral;
generated$9.isObjectExpression = isObjectExpression;
generated$9.isObjectMember = isObjectMember;
generated$9.isObjectMethod = isObjectMethod;
generated$9.isObjectPattern = isObjectPattern;
generated$9.isObjectProperty = isObjectProperty;
generated$9.isObjectTypeAnnotation = isObjectTypeAnnotation;
generated$9.isObjectTypeCallProperty = isObjectTypeCallProperty;
generated$9.isObjectTypeIndexer = isObjectTypeIndexer;
generated$9.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
generated$9.isObjectTypeProperty = isObjectTypeProperty;
generated$9.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
generated$9.isOpaqueType = isOpaqueType;
generated$9.isOptionalCallExpression = isOptionalCallExpression;
generated$9.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
generated$9.isOptionalMemberExpression = isOptionalMemberExpression;
generated$9.isParenthesizedExpression = isParenthesizedExpression;
generated$9.isPattern = isPattern;
generated$9.isPatternLike = isPatternLike;
generated$9.isPipelineBareFunction = isPipelineBareFunction;
generated$9.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
generated$9.isPipelineTopicExpression = isPipelineTopicExpression;
generated$9.isPlaceholder = isPlaceholder;
generated$9.isPrivate = isPrivate;
generated$9.isPrivateName = isPrivateName;
generated$9.isProgram = isProgram;
generated$9.isProperty = isProperty;
generated$9.isPureish = isPureish;
generated$9.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
generated$9.isRecordExpression = isRecordExpression;
generated$9.isRegExpLiteral = isRegExpLiteral;
generated$9.isRegexLiteral = isRegexLiteral;
generated$9.isRestElement = isRestElement;
generated$9.isRestProperty = isRestProperty;
generated$9.isReturnStatement = isReturnStatement;
generated$9.isScopable = isScopable;
generated$9.isSequenceExpression = isSequenceExpression;
generated$9.isSpreadElement = isSpreadElement;
generated$9.isSpreadProperty = isSpreadProperty;
generated$9.isStandardized = isStandardized;
generated$9.isStatement = isStatement;
generated$9.isStaticBlock = isStaticBlock;
generated$9.isStringLiteral = isStringLiteral;
generated$9.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
generated$9.isStringTypeAnnotation = isStringTypeAnnotation;
generated$9.isSuper = isSuper;
generated$9.isSwitchCase = isSwitchCase;
generated$9.isSwitchStatement = isSwitchStatement;
generated$9.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
generated$9.isTSAnyKeyword = isTSAnyKeyword;
generated$9.isTSArrayType = isTSArrayType;
generated$9.isTSAsExpression = isTSAsExpression;
generated$9.isTSBaseType = isTSBaseType;
generated$9.isTSBigIntKeyword = isTSBigIntKeyword;
generated$9.isTSBooleanKeyword = isTSBooleanKeyword;
generated$9.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
generated$9.isTSConditionalType = isTSConditionalType;
generated$9.isTSConstructSignatureDeclaration =
  isTSConstructSignatureDeclaration;
generated$9.isTSConstructorType = isTSConstructorType;
generated$9.isTSDeclareFunction = isTSDeclareFunction;
generated$9.isTSDeclareMethod = isTSDeclareMethod;
generated$9.isTSEntityName = isTSEntityName;
generated$9.isTSEnumDeclaration = isTSEnumDeclaration;
generated$9.isTSEnumMember = isTSEnumMember;
generated$9.isTSExportAssignment = isTSExportAssignment;
generated$9.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
generated$9.isTSExternalModuleReference = isTSExternalModuleReference;
generated$9.isTSFunctionType = isTSFunctionType;
generated$9.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
generated$9.isTSImportType = isTSImportType;
generated$9.isTSIndexSignature = isTSIndexSignature;
generated$9.isTSIndexedAccessType = isTSIndexedAccessType;
generated$9.isTSInferType = isTSInferType;
generated$9.isTSInstantiationExpression = isTSInstantiationExpression;
generated$9.isTSInterfaceBody = isTSInterfaceBody;
generated$9.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
generated$9.isTSIntersectionType = isTSIntersectionType;
generated$9.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
generated$9.isTSLiteralType = isTSLiteralType;
generated$9.isTSMappedType = isTSMappedType;
generated$9.isTSMethodSignature = isTSMethodSignature;
generated$9.isTSModuleBlock = isTSModuleBlock;
generated$9.isTSModuleDeclaration = isTSModuleDeclaration;
generated$9.isTSNamedTupleMember = isTSNamedTupleMember;
generated$9.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
generated$9.isTSNeverKeyword = isTSNeverKeyword;
generated$9.isTSNonNullExpression = isTSNonNullExpression;
generated$9.isTSNullKeyword = isTSNullKeyword;
generated$9.isTSNumberKeyword = isTSNumberKeyword;
generated$9.isTSObjectKeyword = isTSObjectKeyword;
generated$9.isTSOptionalType = isTSOptionalType;
generated$9.isTSParameterProperty = isTSParameterProperty;
generated$9.isTSParenthesizedType = isTSParenthesizedType;
generated$9.isTSPropertySignature = isTSPropertySignature;
generated$9.isTSQualifiedName = isTSQualifiedName;
generated$9.isTSRestType = isTSRestType;
generated$9.isTSStringKeyword = isTSStringKeyword;
generated$9.isTSSymbolKeyword = isTSSymbolKeyword;
generated$9.isTSThisType = isTSThisType;
generated$9.isTSTupleType = isTSTupleType;
generated$9.isTSType = isTSType;
generated$9.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
generated$9.isTSTypeAnnotation = isTSTypeAnnotation;
generated$9.isTSTypeAssertion = isTSTypeAssertion;
generated$9.isTSTypeElement = isTSTypeElement;
generated$9.isTSTypeLiteral = isTSTypeLiteral;
generated$9.isTSTypeOperator = isTSTypeOperator;
generated$9.isTSTypeParameter = isTSTypeParameter;
generated$9.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
generated$9.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
generated$9.isTSTypePredicate = isTSTypePredicate;
generated$9.isTSTypeQuery = isTSTypeQuery;
generated$9.isTSTypeReference = isTSTypeReference;
generated$9.isTSUndefinedKeyword = isTSUndefinedKeyword;
generated$9.isTSUnionType = isTSUnionType;
generated$9.isTSUnknownKeyword = isTSUnknownKeyword;
generated$9.isTSVoidKeyword = isTSVoidKeyword;
generated$9.isTaggedTemplateExpression = isTaggedTemplateExpression;
generated$9.isTemplateElement = isTemplateElement;
generated$9.isTemplateLiteral = isTemplateLiteral;
generated$9.isTerminatorless = isTerminatorless;
generated$9.isThisExpression = isThisExpression;
generated$9.isThisTypeAnnotation = isThisTypeAnnotation;
generated$9.isThrowStatement = isThrowStatement;
generated$9.isTopicReference = isTopicReference;
generated$9.isTryStatement = isTryStatement;
generated$9.isTupleExpression = isTupleExpression;
generated$9.isTupleTypeAnnotation = isTupleTypeAnnotation;
generated$9.isTypeAlias = isTypeAlias;
generated$9.isTypeAnnotation = isTypeAnnotation;
generated$9.isTypeCastExpression = isTypeCastExpression;
generated$9.isTypeParameter = isTypeParameter;
generated$9.isTypeParameterDeclaration = isTypeParameterDeclaration;
generated$9.isTypeParameterInstantiation = isTypeParameterInstantiation;
generated$9.isTypeScript = isTypeScript;
generated$9.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
generated$9.isUnaryExpression = isUnaryExpression;
generated$9.isUnaryLike = isUnaryLike;
generated$9.isUnionTypeAnnotation = isUnionTypeAnnotation;
generated$9.isUpdateExpression = isUpdateExpression;
generated$9.isUserWhitespacable = isUserWhitespacable;
generated$9.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
generated$9.isVariableDeclaration = isVariableDeclaration;
generated$9.isVariableDeclarator = isVariableDeclarator;
generated$9.isVariance = isVariance;
generated$9.isVoidTypeAnnotation = isVoidTypeAnnotation;
generated$9.isWhile = isWhile;
generated$9.isWhileStatement = isWhileStatement;
generated$9.isWithStatement = isWithStatement;
generated$9.isYieldExpression = isYieldExpression;
var _shallowEqual = shallowEqual$2;
function isArrayExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ArrayExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isAssignmentExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "AssignmentExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBinaryExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BinaryExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isInterpreterDirective(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "InterpreterDirective") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDirective(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Directive") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDirectiveLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DirectiveLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBlockStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BlockStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBreakStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BreakStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isCallExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "CallExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isCatchClause(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "CatchClause") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isConditionalExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ConditionalExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isContinueStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ContinueStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDebuggerStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DebuggerStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDoWhileStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DoWhileStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEmptyStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EmptyStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExpressionStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExpressionStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFile(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "File") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isForInStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ForInStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isForStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ForStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFunctionDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "FunctionDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFunctionExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "FunctionExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Identifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isIfStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "IfStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isLabeledStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "LabeledStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isStringLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "StringLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isNumericLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NumericLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isNullLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NullLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBooleanLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BooleanLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isRegExpLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "RegExpLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isLogicalExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "LogicalExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isMemberExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "MemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isNewExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NewExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isProgram(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Program") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isRestElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "RestElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isReturnStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ReturnStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isSequenceExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "SequenceExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isParenthesizedExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ParenthesizedExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isSwitchCase(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "SwitchCase") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isSwitchStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "SwitchStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isThisExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ThisExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isThrowStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ThrowStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTryStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TryStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isUnaryExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "UnaryExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isUpdateExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "UpdateExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isVariableDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "VariableDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isVariableDeclarator(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "VariableDeclarator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isWhileStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "WhileStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isWithStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "WithStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isAssignmentPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "AssignmentPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isArrayPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ArrayPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isArrowFunctionExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ArrowFunctionExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isClassBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isClassExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isClassDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExportAllDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExportAllDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExportDefaultDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExportDefaultDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExportNamedDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExportNamedDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExportSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExportSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isForOfStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ForOfStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isImportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ImportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isImportDefaultSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ImportDefaultSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isImportNamespaceSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ImportNamespaceSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isImportSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ImportSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isMetaProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "MetaProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isClassMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isSpreadElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "SpreadElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isSuper(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Super") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTaggedTemplateExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TaggedTemplateExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTemplateElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TemplateElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTemplateLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TemplateLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isYieldExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "YieldExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isAwaitExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "AwaitExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isImport(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Import") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBigIntLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BigIntLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExportNamespaceSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExportNamespaceSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isOptionalMemberExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "OptionalMemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isOptionalCallExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "OptionalCallExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isClassProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isClassAccessorProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassAccessorProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isClassPrivateProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassPrivateProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isClassPrivateMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassPrivateMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isPrivateName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "PrivateName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isStaticBlock(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "StaticBlock") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isAnyTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "AnyTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isArrayTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ArrayTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBooleanTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BooleanTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBooleanLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BooleanLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isNullLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NullLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isClassImplements(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassImplements") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclareClass(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareClass") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclareFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclareInterface(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareInterface") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclareModule(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareModule") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclareModuleExports(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareModuleExports") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclareTypeAlias(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareTypeAlias") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclareOpaqueType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareOpaqueType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclareVariable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareVariable") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclareExportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareExportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclareExportAllDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareExportAllDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclaredPredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclaredPredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExistsTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExistsTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFunctionTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "FunctionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFunctionTypeParam(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "FunctionTypeParam") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isGenericTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "GenericTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isInferredPredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "InferredPredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isInterfaceExtends(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "InterfaceExtends") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isInterfaceDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "InterfaceDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isInterfaceTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "InterfaceTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isIntersectionTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "IntersectionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isMixedTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "MixedTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEmptyTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EmptyTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isNullableTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NullableTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isNumberLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NumberLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isNumberTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NumberTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectTypeInternalSlot(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectTypeInternalSlot") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectTypeCallProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectTypeCallProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectTypeIndexer(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectTypeIndexer") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectTypeProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectTypeProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectTypeSpreadProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectTypeSpreadProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isOpaqueType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "OpaqueType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isQualifiedTypeIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "QualifiedTypeIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isStringLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "StringLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isStringTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "StringTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isSymbolTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "SymbolTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isThisTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ThisTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTupleTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TupleTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTypeofTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeofTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTypeAlias(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeAlias") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTypeCastExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeCastExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTypeParameter(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeParameter") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTypeParameterDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeParameterDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTypeParameterInstantiation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeParameterInstantiation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isUnionTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "UnionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isVariance(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Variance") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isVoidTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "VoidTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EnumDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumBooleanBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EnumBooleanBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumNumberBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EnumNumberBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumStringBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EnumStringBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumSymbolBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EnumSymbolBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumBooleanMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EnumBooleanMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumNumberMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EnumNumberMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumStringMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EnumStringMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumDefaultedMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EnumDefaultedMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isIndexedAccessType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "IndexedAccessType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isOptionalIndexedAccessType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "OptionalIndexedAccessType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXAttribute(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXClosingElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXClosingElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXEmptyExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXEmptyExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXExpressionContainer(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXExpressionContainer") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXSpreadChild(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXSpreadChild") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXMemberExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXMemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXNamespacedName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXNamespacedName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXOpeningElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXOpeningElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXSpreadAttribute(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXSpreadAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXText(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXText") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXFragment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXOpeningFragment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXOpeningFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSXClosingFragment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXClosingFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isNoop(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Noop") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isPlaceholder(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Placeholder") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isV8IntrinsicIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "V8IntrinsicIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isArgumentPlaceholder(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ArgumentPlaceholder") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBindExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BindExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isImportAttribute(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ImportAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDecorator(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Decorator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDoExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DoExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExportDefaultSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExportDefaultSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isRecordExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "RecordExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTupleExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TupleExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDecimalLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DecimalLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isModuleExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ModuleExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTopicReference(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TopicReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isPipelineTopicExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "PipelineTopicExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isPipelineBareFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "PipelineBareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isPipelinePrimaryTopicReference(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "PipelinePrimaryTopicReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSParameterProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSParameterProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSDeclareFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSDeclareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSDeclareMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSDeclareMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSQualifiedName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSQualifiedName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSCallSignatureDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSCallSignatureDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSConstructSignatureDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSConstructSignatureDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSPropertySignature(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSPropertySignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSMethodSignature(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSMethodSignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSIndexSignature(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSIndexSignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSAnyKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSAnyKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSBooleanKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSBooleanKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSBigIntKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSBigIntKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSIntrinsicKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSIntrinsicKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSNeverKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSNeverKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSNullKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSNullKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSNumberKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSNumberKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSObjectKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSObjectKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSStringKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSStringKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSSymbolKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSSymbolKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSUndefinedKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSUndefinedKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSUnknownKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSUnknownKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSVoidKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSVoidKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSThisType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSThisType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSFunctionType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSFunctionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSConstructorType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSConstructorType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeReference(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypePredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypePredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeQuery(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeQuery") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSArrayType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSArrayType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTupleType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTupleType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSOptionalType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSOptionalType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSRestType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSRestType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSNamedTupleMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSNamedTupleMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSUnionType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSUnionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSIntersectionType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSIntersectionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSConditionalType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSConditionalType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSInferType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSInferType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSParenthesizedType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSParenthesizedType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeOperator(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeOperator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSIndexedAccessType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSIndexedAccessType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSMappedType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSMappedType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSLiteralType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSLiteralType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSExpressionWithTypeArguments(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSExpressionWithTypeArguments") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSInterfaceDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSInterfaceDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSInterfaceBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSInterfaceBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeAliasDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeAliasDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSInstantiationExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSInstantiationExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSAsExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSAsExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeAssertion(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeAssertion") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSEnumDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSEnumDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSEnumMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSEnumMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSModuleDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSModuleDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSModuleBlock(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSModuleBlock") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSImportType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSImportType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSImportEqualsDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSImportEqualsDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSExternalModuleReference(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSExternalModuleReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSNonNullExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSNonNullExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSExportAssignment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSExportAssignment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSNamespaceExportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSNamespaceExportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeParameterInstantiation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeParameterInstantiation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeParameterDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeParameterDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeParameter(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeParameter") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isStandardized(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "ArrayExpression" === nodeType ||
    "AssignmentExpression" === nodeType ||
    "BinaryExpression" === nodeType ||
    "InterpreterDirective" === nodeType ||
    "Directive" === nodeType ||
    "DirectiveLiteral" === nodeType ||
    "BlockStatement" === nodeType ||
    "BreakStatement" === nodeType ||
    "CallExpression" === nodeType ||
    "CatchClause" === nodeType ||
    "ConditionalExpression" === nodeType ||
    "ContinueStatement" === nodeType ||
    "DebuggerStatement" === nodeType ||
    "DoWhileStatement" === nodeType ||
    "EmptyStatement" === nodeType ||
    "ExpressionStatement" === nodeType ||
    "File" === nodeType ||
    "ForInStatement" === nodeType ||
    "ForStatement" === nodeType ||
    "FunctionDeclaration" === nodeType ||
    "FunctionExpression" === nodeType ||
    "Identifier" === nodeType ||
    "IfStatement" === nodeType ||
    "LabeledStatement" === nodeType ||
    "StringLiteral" === nodeType ||
    "NumericLiteral" === nodeType ||
    "NullLiteral" === nodeType ||
    "BooleanLiteral" === nodeType ||
    "RegExpLiteral" === nodeType ||
    "LogicalExpression" === nodeType ||
    "MemberExpression" === nodeType ||
    "NewExpression" === nodeType ||
    "Program" === nodeType ||
    "ObjectExpression" === nodeType ||
    "ObjectMethod" === nodeType ||
    "ObjectProperty" === nodeType ||
    "RestElement" === nodeType ||
    "ReturnStatement" === nodeType ||
    "SequenceExpression" === nodeType ||
    "ParenthesizedExpression" === nodeType ||
    "SwitchCase" === nodeType ||
    "SwitchStatement" === nodeType ||
    "ThisExpression" === nodeType ||
    "ThrowStatement" === nodeType ||
    "TryStatement" === nodeType ||
    "UnaryExpression" === nodeType ||
    "UpdateExpression" === nodeType ||
    "VariableDeclaration" === nodeType ||
    "VariableDeclarator" === nodeType ||
    "WhileStatement" === nodeType ||
    "WithStatement" === nodeType ||
    "AssignmentPattern" === nodeType ||
    "ArrayPattern" === nodeType ||
    "ArrowFunctionExpression" === nodeType ||
    "ClassBody" === nodeType ||
    "ClassExpression" === nodeType ||
    "ClassDeclaration" === nodeType ||
    "ExportAllDeclaration" === nodeType ||
    "ExportDefaultDeclaration" === nodeType ||
    "ExportNamedDeclaration" === nodeType ||
    "ExportSpecifier" === nodeType ||
    "ForOfStatement" === nodeType ||
    "ImportDeclaration" === nodeType ||
    "ImportDefaultSpecifier" === nodeType ||
    "ImportNamespaceSpecifier" === nodeType ||
    "ImportSpecifier" === nodeType ||
    "MetaProperty" === nodeType ||
    "ClassMethod" === nodeType ||
    "ObjectPattern" === nodeType ||
    "SpreadElement" === nodeType ||
    "Super" === nodeType ||
    "TaggedTemplateExpression" === nodeType ||
    "TemplateElement" === nodeType ||
    "TemplateLiteral" === nodeType ||
    "YieldExpression" === nodeType ||
    "AwaitExpression" === nodeType ||
    "Import" === nodeType ||
    "BigIntLiteral" === nodeType ||
    "ExportNamespaceSpecifier" === nodeType ||
    "OptionalMemberExpression" === nodeType ||
    "OptionalCallExpression" === nodeType ||
    "ClassProperty" === nodeType ||
    "ClassAccessorProperty" === nodeType ||
    "ClassPrivateProperty" === nodeType ||
    "ClassPrivateMethod" === nodeType ||
    "PrivateName" === nodeType ||
    "StaticBlock" === nodeType ||
    (nodeType === "Placeholder" &&
      ("Identifier" === node.expectedNode ||
        "StringLiteral" === node.expectedNode ||
        "BlockStatement" === node.expectedNode ||
        "ClassBody" === node.expectedNode))
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "ArrayExpression" === nodeType ||
    "AssignmentExpression" === nodeType ||
    "BinaryExpression" === nodeType ||
    "CallExpression" === nodeType ||
    "ConditionalExpression" === nodeType ||
    "FunctionExpression" === nodeType ||
    "Identifier" === nodeType ||
    "StringLiteral" === nodeType ||
    "NumericLiteral" === nodeType ||
    "NullLiteral" === nodeType ||
    "BooleanLiteral" === nodeType ||
    "RegExpLiteral" === nodeType ||
    "LogicalExpression" === nodeType ||
    "MemberExpression" === nodeType ||
    "NewExpression" === nodeType ||
    "ObjectExpression" === nodeType ||
    "SequenceExpression" === nodeType ||
    "ParenthesizedExpression" === nodeType ||
    "ThisExpression" === nodeType ||
    "UnaryExpression" === nodeType ||
    "UpdateExpression" === nodeType ||
    "ArrowFunctionExpression" === nodeType ||
    "ClassExpression" === nodeType ||
    "MetaProperty" === nodeType ||
    "Super" === nodeType ||
    "TaggedTemplateExpression" === nodeType ||
    "TemplateLiteral" === nodeType ||
    "YieldExpression" === nodeType ||
    "AwaitExpression" === nodeType ||
    "Import" === nodeType ||
    "BigIntLiteral" === nodeType ||
    "OptionalMemberExpression" === nodeType ||
    "OptionalCallExpression" === nodeType ||
    "TypeCastExpression" === nodeType ||
    "JSXElement" === nodeType ||
    "JSXFragment" === nodeType ||
    "BindExpression" === nodeType ||
    "DoExpression" === nodeType ||
    "RecordExpression" === nodeType ||
    "TupleExpression" === nodeType ||
    "DecimalLiteral" === nodeType ||
    "ModuleExpression" === nodeType ||
    "TopicReference" === nodeType ||
    "PipelineTopicExpression" === nodeType ||
    "PipelineBareFunction" === nodeType ||
    "PipelinePrimaryTopicReference" === nodeType ||
    "TSInstantiationExpression" === nodeType ||
    "TSAsExpression" === nodeType ||
    "TSTypeAssertion" === nodeType ||
    "TSNonNullExpression" === nodeType ||
    (nodeType === "Placeholder" &&
      ("Expression" === node.expectedNode ||
        "Identifier" === node.expectedNode ||
        "StringLiteral" === node.expectedNode))
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBinary(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if ("BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isScopable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "BlockStatement" === nodeType ||
    "CatchClause" === nodeType ||
    "DoWhileStatement" === nodeType ||
    "ForInStatement" === nodeType ||
    "ForStatement" === nodeType ||
    "FunctionDeclaration" === nodeType ||
    "FunctionExpression" === nodeType ||
    "Program" === nodeType ||
    "ObjectMethod" === nodeType ||
    "SwitchStatement" === nodeType ||
    "WhileStatement" === nodeType ||
    "ArrowFunctionExpression" === nodeType ||
    "ClassExpression" === nodeType ||
    "ClassDeclaration" === nodeType ||
    "ForOfStatement" === nodeType ||
    "ClassMethod" === nodeType ||
    "ClassPrivateMethod" === nodeType ||
    "StaticBlock" === nodeType ||
    "TSModuleBlock" === nodeType ||
    (nodeType === "Placeholder" && "BlockStatement" === node.expectedNode)
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBlockParent(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "BlockStatement" === nodeType ||
    "CatchClause" === nodeType ||
    "DoWhileStatement" === nodeType ||
    "ForInStatement" === nodeType ||
    "ForStatement" === nodeType ||
    "FunctionDeclaration" === nodeType ||
    "FunctionExpression" === nodeType ||
    "Program" === nodeType ||
    "ObjectMethod" === nodeType ||
    "SwitchStatement" === nodeType ||
    "WhileStatement" === nodeType ||
    "ArrowFunctionExpression" === nodeType ||
    "ForOfStatement" === nodeType ||
    "ClassMethod" === nodeType ||
    "ClassPrivateMethod" === nodeType ||
    "StaticBlock" === nodeType ||
    "TSModuleBlock" === nodeType ||
    (nodeType === "Placeholder" && "BlockStatement" === node.expectedNode)
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isBlock(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "BlockStatement" === nodeType ||
    "Program" === nodeType ||
    "TSModuleBlock" === nodeType ||
    (nodeType === "Placeholder" && "BlockStatement" === node.expectedNode)
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "BlockStatement" === nodeType ||
    "BreakStatement" === nodeType ||
    "ContinueStatement" === nodeType ||
    "DebuggerStatement" === nodeType ||
    "DoWhileStatement" === nodeType ||
    "EmptyStatement" === nodeType ||
    "ExpressionStatement" === nodeType ||
    "ForInStatement" === nodeType ||
    "ForStatement" === nodeType ||
    "FunctionDeclaration" === nodeType ||
    "IfStatement" === nodeType ||
    "LabeledStatement" === nodeType ||
    "ReturnStatement" === nodeType ||
    "SwitchStatement" === nodeType ||
    "ThrowStatement" === nodeType ||
    "TryStatement" === nodeType ||
    "VariableDeclaration" === nodeType ||
    "WhileStatement" === nodeType ||
    "WithStatement" === nodeType ||
    "ClassDeclaration" === nodeType ||
    "ExportAllDeclaration" === nodeType ||
    "ExportDefaultDeclaration" === nodeType ||
    "ExportNamedDeclaration" === nodeType ||
    "ForOfStatement" === nodeType ||
    "ImportDeclaration" === nodeType ||
    "DeclareClass" === nodeType ||
    "DeclareFunction" === nodeType ||
    "DeclareInterface" === nodeType ||
    "DeclareModule" === nodeType ||
    "DeclareModuleExports" === nodeType ||
    "DeclareTypeAlias" === nodeType ||
    "DeclareOpaqueType" === nodeType ||
    "DeclareVariable" === nodeType ||
    "DeclareExportDeclaration" === nodeType ||
    "DeclareExportAllDeclaration" === nodeType ||
    "InterfaceDeclaration" === nodeType ||
    "OpaqueType" === nodeType ||
    "TypeAlias" === nodeType ||
    "EnumDeclaration" === nodeType ||
    "TSDeclareFunction" === nodeType ||
    "TSInterfaceDeclaration" === nodeType ||
    "TSTypeAliasDeclaration" === nodeType ||
    "TSEnumDeclaration" === nodeType ||
    "TSModuleDeclaration" === nodeType ||
    "TSImportEqualsDeclaration" === nodeType ||
    "TSExportAssignment" === nodeType ||
    "TSNamespaceExportDeclaration" === nodeType ||
    (nodeType === "Placeholder" &&
      ("Statement" === node.expectedNode ||
        "Declaration" === node.expectedNode ||
        "BlockStatement" === node.expectedNode))
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTerminatorless(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "BreakStatement" === nodeType ||
    "ContinueStatement" === nodeType ||
    "ReturnStatement" === nodeType ||
    "ThrowStatement" === nodeType ||
    "YieldExpression" === nodeType ||
    "AwaitExpression" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isCompletionStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "BreakStatement" === nodeType ||
    "ContinueStatement" === nodeType ||
    "ReturnStatement" === nodeType ||
    "ThrowStatement" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isConditional(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if ("ConditionalExpression" === nodeType || "IfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isLoop(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "DoWhileStatement" === nodeType ||
    "ForInStatement" === nodeType ||
    "ForStatement" === nodeType ||
    "WhileStatement" === nodeType ||
    "ForOfStatement" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isWhile(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if ("DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExpressionWrapper(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "ExpressionStatement" === nodeType ||
    "ParenthesizedExpression" === nodeType ||
    "TypeCastExpression" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFor(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "ForInStatement" === nodeType ||
    "ForStatement" === nodeType ||
    "ForOfStatement" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isForXStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if ("ForInStatement" === nodeType || "ForOfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "FunctionDeclaration" === nodeType ||
    "FunctionExpression" === nodeType ||
    "ObjectMethod" === nodeType ||
    "ArrowFunctionExpression" === nodeType ||
    "ClassMethod" === nodeType ||
    "ClassPrivateMethod" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFunctionParent(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "FunctionDeclaration" === nodeType ||
    "FunctionExpression" === nodeType ||
    "ObjectMethod" === nodeType ||
    "ArrowFunctionExpression" === nodeType ||
    "ClassMethod" === nodeType ||
    "ClassPrivateMethod" === nodeType ||
    "StaticBlock" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isPureish(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "FunctionDeclaration" === nodeType ||
    "FunctionExpression" === nodeType ||
    "StringLiteral" === nodeType ||
    "NumericLiteral" === nodeType ||
    "NullLiteral" === nodeType ||
    "BooleanLiteral" === nodeType ||
    "RegExpLiteral" === nodeType ||
    "ArrowFunctionExpression" === nodeType ||
    "BigIntLiteral" === nodeType ||
    "DecimalLiteral" === nodeType ||
    (nodeType === "Placeholder" && "StringLiteral" === node.expectedNode)
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "FunctionDeclaration" === nodeType ||
    "VariableDeclaration" === nodeType ||
    "ClassDeclaration" === nodeType ||
    "ExportAllDeclaration" === nodeType ||
    "ExportDefaultDeclaration" === nodeType ||
    "ExportNamedDeclaration" === nodeType ||
    "ImportDeclaration" === nodeType ||
    "DeclareClass" === nodeType ||
    "DeclareFunction" === nodeType ||
    "DeclareInterface" === nodeType ||
    "DeclareModule" === nodeType ||
    "DeclareModuleExports" === nodeType ||
    "DeclareTypeAlias" === nodeType ||
    "DeclareOpaqueType" === nodeType ||
    "DeclareVariable" === nodeType ||
    "DeclareExportDeclaration" === nodeType ||
    "DeclareExportAllDeclaration" === nodeType ||
    "InterfaceDeclaration" === nodeType ||
    "OpaqueType" === nodeType ||
    "TypeAlias" === nodeType ||
    "EnumDeclaration" === nodeType ||
    "TSDeclareFunction" === nodeType ||
    "TSInterfaceDeclaration" === nodeType ||
    "TSTypeAliasDeclaration" === nodeType ||
    "TSEnumDeclaration" === nodeType ||
    "TSModuleDeclaration" === nodeType ||
    (nodeType === "Placeholder" && "Declaration" === node.expectedNode)
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isPatternLike(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "Identifier" === nodeType ||
    "RestElement" === nodeType ||
    "AssignmentPattern" === nodeType ||
    "ArrayPattern" === nodeType ||
    "ObjectPattern" === nodeType ||
    "TSAsExpression" === nodeType ||
    "TSTypeAssertion" === nodeType ||
    "TSNonNullExpression" === nodeType ||
    (nodeType === "Placeholder" &&
      ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode))
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isLVal(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "Identifier" === nodeType ||
    "MemberExpression" === nodeType ||
    "RestElement" === nodeType ||
    "AssignmentPattern" === nodeType ||
    "ArrayPattern" === nodeType ||
    "ObjectPattern" === nodeType ||
    "TSParameterProperty" === nodeType ||
    "TSAsExpression" === nodeType ||
    "TSTypeAssertion" === nodeType ||
    "TSNonNullExpression" === nodeType ||
    (nodeType === "Placeholder" &&
      ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode))
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSEntityName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "Identifier" === nodeType ||
    "TSQualifiedName" === nodeType ||
    (nodeType === "Placeholder" && "Identifier" === node.expectedNode)
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "StringLiteral" === nodeType ||
    "NumericLiteral" === nodeType ||
    "NullLiteral" === nodeType ||
    "BooleanLiteral" === nodeType ||
    "RegExpLiteral" === nodeType ||
    "TemplateLiteral" === nodeType ||
    "BigIntLiteral" === nodeType ||
    "DecimalLiteral" === nodeType ||
    (nodeType === "Placeholder" && "StringLiteral" === node.expectedNode)
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isImmutable$3(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "StringLiteral" === nodeType ||
    "NumericLiteral" === nodeType ||
    "NullLiteral" === nodeType ||
    "BooleanLiteral" === nodeType ||
    "BigIntLiteral" === nodeType ||
    "JSXAttribute" === nodeType ||
    "JSXClosingElement" === nodeType ||
    "JSXElement" === nodeType ||
    "JSXExpressionContainer" === nodeType ||
    "JSXSpreadChild" === nodeType ||
    "JSXOpeningElement" === nodeType ||
    "JSXText" === nodeType ||
    "JSXFragment" === nodeType ||
    "JSXOpeningFragment" === nodeType ||
    "JSXClosingFragment" === nodeType ||
    "DecimalLiteral" === nodeType ||
    (nodeType === "Placeholder" && "StringLiteral" === node.expectedNode)
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isUserWhitespacable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "ObjectMethod" === nodeType ||
    "ObjectProperty" === nodeType ||
    "ObjectTypeInternalSlot" === nodeType ||
    "ObjectTypeCallProperty" === nodeType ||
    "ObjectTypeIndexer" === nodeType ||
    "ObjectTypeProperty" === nodeType ||
    "ObjectTypeSpreadProperty" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "ObjectMethod" === nodeType ||
    "ClassMethod" === nodeType ||
    "ClassPrivateMethod" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isObjectMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "ObjectProperty" === nodeType ||
    "ClassProperty" === nodeType ||
    "ClassAccessorProperty" === nodeType ||
    "ClassPrivateProperty" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isUnaryLike(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if ("UnaryExpression" === nodeType || "SpreadElement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "AssignmentPattern" === nodeType ||
    "ArrayPattern" === nodeType ||
    "ObjectPattern" === nodeType ||
    (nodeType === "Placeholder" && "Pattern" === node.expectedNode)
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isClass(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if ("ClassExpression" === nodeType || "ClassDeclaration" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isModuleDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "ExportAllDeclaration" === nodeType ||
    "ExportDefaultDeclaration" === nodeType ||
    "ExportNamedDeclaration" === nodeType ||
    "ImportDeclaration" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isExportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "ExportAllDeclaration" === nodeType ||
    "ExportDefaultDeclaration" === nodeType ||
    "ExportNamedDeclaration" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isModuleSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "ExportSpecifier" === nodeType ||
    "ImportDefaultSpecifier" === nodeType ||
    "ImportNamespaceSpecifier" === nodeType ||
    "ImportSpecifier" === nodeType ||
    "ExportNamespaceSpecifier" === nodeType ||
    "ExportDefaultSpecifier" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isAccessor(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if ("ClassAccessorProperty" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isPrivate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "ClassPrivateProperty" === nodeType ||
    "ClassPrivateMethod" === nodeType ||
    "PrivateName" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFlow(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "AnyTypeAnnotation" === nodeType ||
    "ArrayTypeAnnotation" === nodeType ||
    "BooleanTypeAnnotation" === nodeType ||
    "BooleanLiteralTypeAnnotation" === nodeType ||
    "NullLiteralTypeAnnotation" === nodeType ||
    "ClassImplements" === nodeType ||
    "DeclareClass" === nodeType ||
    "DeclareFunction" === nodeType ||
    "DeclareInterface" === nodeType ||
    "DeclareModule" === nodeType ||
    "DeclareModuleExports" === nodeType ||
    "DeclareTypeAlias" === nodeType ||
    "DeclareOpaqueType" === nodeType ||
    "DeclareVariable" === nodeType ||
    "DeclareExportDeclaration" === nodeType ||
    "DeclareExportAllDeclaration" === nodeType ||
    "DeclaredPredicate" === nodeType ||
    "ExistsTypeAnnotation" === nodeType ||
    "FunctionTypeAnnotation" === nodeType ||
    "FunctionTypeParam" === nodeType ||
    "GenericTypeAnnotation" === nodeType ||
    "InferredPredicate" === nodeType ||
    "InterfaceExtends" === nodeType ||
    "InterfaceDeclaration" === nodeType ||
    "InterfaceTypeAnnotation" === nodeType ||
    "IntersectionTypeAnnotation" === nodeType ||
    "MixedTypeAnnotation" === nodeType ||
    "EmptyTypeAnnotation" === nodeType ||
    "NullableTypeAnnotation" === nodeType ||
    "NumberLiteralTypeAnnotation" === nodeType ||
    "NumberTypeAnnotation" === nodeType ||
    "ObjectTypeAnnotation" === nodeType ||
    "ObjectTypeInternalSlot" === nodeType ||
    "ObjectTypeCallProperty" === nodeType ||
    "ObjectTypeIndexer" === nodeType ||
    "ObjectTypeProperty" === nodeType ||
    "ObjectTypeSpreadProperty" === nodeType ||
    "OpaqueType" === nodeType ||
    "QualifiedTypeIdentifier" === nodeType ||
    "StringLiteralTypeAnnotation" === nodeType ||
    "StringTypeAnnotation" === nodeType ||
    "SymbolTypeAnnotation" === nodeType ||
    "ThisTypeAnnotation" === nodeType ||
    "TupleTypeAnnotation" === nodeType ||
    "TypeofTypeAnnotation" === nodeType ||
    "TypeAlias" === nodeType ||
    "TypeAnnotation" === nodeType ||
    "TypeCastExpression" === nodeType ||
    "TypeParameter" === nodeType ||
    "TypeParameterDeclaration" === nodeType ||
    "TypeParameterInstantiation" === nodeType ||
    "UnionTypeAnnotation" === nodeType ||
    "Variance" === nodeType ||
    "VoidTypeAnnotation" === nodeType ||
    "EnumDeclaration" === nodeType ||
    "EnumBooleanBody" === nodeType ||
    "EnumNumberBody" === nodeType ||
    "EnumStringBody" === nodeType ||
    "EnumSymbolBody" === nodeType ||
    "EnumBooleanMember" === nodeType ||
    "EnumNumberMember" === nodeType ||
    "EnumStringMember" === nodeType ||
    "EnumDefaultedMember" === nodeType ||
    "IndexedAccessType" === nodeType ||
    "OptionalIndexedAccessType" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFlowType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "AnyTypeAnnotation" === nodeType ||
    "ArrayTypeAnnotation" === nodeType ||
    "BooleanTypeAnnotation" === nodeType ||
    "BooleanLiteralTypeAnnotation" === nodeType ||
    "NullLiteralTypeAnnotation" === nodeType ||
    "ExistsTypeAnnotation" === nodeType ||
    "FunctionTypeAnnotation" === nodeType ||
    "GenericTypeAnnotation" === nodeType ||
    "InterfaceTypeAnnotation" === nodeType ||
    "IntersectionTypeAnnotation" === nodeType ||
    "MixedTypeAnnotation" === nodeType ||
    "EmptyTypeAnnotation" === nodeType ||
    "NullableTypeAnnotation" === nodeType ||
    "NumberLiteralTypeAnnotation" === nodeType ||
    "NumberTypeAnnotation" === nodeType ||
    "ObjectTypeAnnotation" === nodeType ||
    "StringLiteralTypeAnnotation" === nodeType ||
    "StringTypeAnnotation" === nodeType ||
    "SymbolTypeAnnotation" === nodeType ||
    "ThisTypeAnnotation" === nodeType ||
    "TupleTypeAnnotation" === nodeType ||
    "TypeofTypeAnnotation" === nodeType ||
    "UnionTypeAnnotation" === nodeType ||
    "VoidTypeAnnotation" === nodeType ||
    "IndexedAccessType" === nodeType ||
    "OptionalIndexedAccessType" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFlowBaseAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "AnyTypeAnnotation" === nodeType ||
    "BooleanTypeAnnotation" === nodeType ||
    "NullLiteralTypeAnnotation" === nodeType ||
    "MixedTypeAnnotation" === nodeType ||
    "EmptyTypeAnnotation" === nodeType ||
    "NumberTypeAnnotation" === nodeType ||
    "StringTypeAnnotation" === nodeType ||
    "SymbolTypeAnnotation" === nodeType ||
    "ThisTypeAnnotation" === nodeType ||
    "VoidTypeAnnotation" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFlowDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "DeclareClass" === nodeType ||
    "DeclareFunction" === nodeType ||
    "DeclareInterface" === nodeType ||
    "DeclareModule" === nodeType ||
    "DeclareModuleExports" === nodeType ||
    "DeclareTypeAlias" === nodeType ||
    "DeclareOpaqueType" === nodeType ||
    "DeclareVariable" === nodeType ||
    "DeclareExportDeclaration" === nodeType ||
    "DeclareExportAllDeclaration" === nodeType ||
    "InterfaceDeclaration" === nodeType ||
    "OpaqueType" === nodeType ||
    "TypeAlias" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isFlowPredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if ("DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "EnumBooleanBody" === nodeType ||
    "EnumNumberBody" === nodeType ||
    "EnumStringBody" === nodeType ||
    "EnumSymbolBody" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isEnumMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "EnumBooleanMember" === nodeType ||
    "EnumNumberMember" === nodeType ||
    "EnumStringMember" === nodeType ||
    "EnumDefaultedMember" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isJSX(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "JSXAttribute" === nodeType ||
    "JSXClosingElement" === nodeType ||
    "JSXElement" === nodeType ||
    "JSXEmptyExpression" === nodeType ||
    "JSXExpressionContainer" === nodeType ||
    "JSXSpreadChild" === nodeType ||
    "JSXIdentifier" === nodeType ||
    "JSXMemberExpression" === nodeType ||
    "JSXNamespacedName" === nodeType ||
    "JSXOpeningElement" === nodeType ||
    "JSXSpreadAttribute" === nodeType ||
    "JSXText" === nodeType ||
    "JSXFragment" === nodeType ||
    "JSXOpeningFragment" === nodeType ||
    "JSXClosingFragment" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isMiscellaneous(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "Noop" === nodeType ||
    "Placeholder" === nodeType ||
    "V8IntrinsicIdentifier" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTypeScript(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "TSParameterProperty" === nodeType ||
    "TSDeclareFunction" === nodeType ||
    "TSDeclareMethod" === nodeType ||
    "TSQualifiedName" === nodeType ||
    "TSCallSignatureDeclaration" === nodeType ||
    "TSConstructSignatureDeclaration" === nodeType ||
    "TSPropertySignature" === nodeType ||
    "TSMethodSignature" === nodeType ||
    "TSIndexSignature" === nodeType ||
    "TSAnyKeyword" === nodeType ||
    "TSBooleanKeyword" === nodeType ||
    "TSBigIntKeyword" === nodeType ||
    "TSIntrinsicKeyword" === nodeType ||
    "TSNeverKeyword" === nodeType ||
    "TSNullKeyword" === nodeType ||
    "TSNumberKeyword" === nodeType ||
    "TSObjectKeyword" === nodeType ||
    "TSStringKeyword" === nodeType ||
    "TSSymbolKeyword" === nodeType ||
    "TSUndefinedKeyword" === nodeType ||
    "TSUnknownKeyword" === nodeType ||
    "TSVoidKeyword" === nodeType ||
    "TSThisType" === nodeType ||
    "TSFunctionType" === nodeType ||
    "TSConstructorType" === nodeType ||
    "TSTypeReference" === nodeType ||
    "TSTypePredicate" === nodeType ||
    "TSTypeQuery" === nodeType ||
    "TSTypeLiteral" === nodeType ||
    "TSArrayType" === nodeType ||
    "TSTupleType" === nodeType ||
    "TSOptionalType" === nodeType ||
    "TSRestType" === nodeType ||
    "TSNamedTupleMember" === nodeType ||
    "TSUnionType" === nodeType ||
    "TSIntersectionType" === nodeType ||
    "TSConditionalType" === nodeType ||
    "TSInferType" === nodeType ||
    "TSParenthesizedType" === nodeType ||
    "TSTypeOperator" === nodeType ||
    "TSIndexedAccessType" === nodeType ||
    "TSMappedType" === nodeType ||
    "TSLiteralType" === nodeType ||
    "TSExpressionWithTypeArguments" === nodeType ||
    "TSInterfaceDeclaration" === nodeType ||
    "TSInterfaceBody" === nodeType ||
    "TSTypeAliasDeclaration" === nodeType ||
    "TSInstantiationExpression" === nodeType ||
    "TSAsExpression" === nodeType ||
    "TSTypeAssertion" === nodeType ||
    "TSEnumDeclaration" === nodeType ||
    "TSEnumMember" === nodeType ||
    "TSModuleDeclaration" === nodeType ||
    "TSModuleBlock" === nodeType ||
    "TSImportType" === nodeType ||
    "TSImportEqualsDeclaration" === nodeType ||
    "TSExternalModuleReference" === nodeType ||
    "TSNonNullExpression" === nodeType ||
    "TSExportAssignment" === nodeType ||
    "TSNamespaceExportDeclaration" === nodeType ||
    "TSTypeAnnotation" === nodeType ||
    "TSTypeParameterInstantiation" === nodeType ||
    "TSTypeParameterDeclaration" === nodeType ||
    "TSTypeParameter" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSTypeElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "TSCallSignatureDeclaration" === nodeType ||
    "TSConstructSignatureDeclaration" === nodeType ||
    "TSPropertySignature" === nodeType ||
    "TSMethodSignature" === nodeType ||
    "TSIndexSignature" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "TSAnyKeyword" === nodeType ||
    "TSBooleanKeyword" === nodeType ||
    "TSBigIntKeyword" === nodeType ||
    "TSIntrinsicKeyword" === nodeType ||
    "TSNeverKeyword" === nodeType ||
    "TSNullKeyword" === nodeType ||
    "TSNumberKeyword" === nodeType ||
    "TSObjectKeyword" === nodeType ||
    "TSStringKeyword" === nodeType ||
    "TSSymbolKeyword" === nodeType ||
    "TSUndefinedKeyword" === nodeType ||
    "TSUnknownKeyword" === nodeType ||
    "TSVoidKeyword" === nodeType ||
    "TSThisType" === nodeType ||
    "TSFunctionType" === nodeType ||
    "TSConstructorType" === nodeType ||
    "TSTypeReference" === nodeType ||
    "TSTypePredicate" === nodeType ||
    "TSTypeQuery" === nodeType ||
    "TSTypeLiteral" === nodeType ||
    "TSArrayType" === nodeType ||
    "TSTupleType" === nodeType ||
    "TSOptionalType" === nodeType ||
    "TSRestType" === nodeType ||
    "TSUnionType" === nodeType ||
    "TSIntersectionType" === nodeType ||
    "TSConditionalType" === nodeType ||
    "TSInferType" === nodeType ||
    "TSParenthesizedType" === nodeType ||
    "TSTypeOperator" === nodeType ||
    "TSIndexedAccessType" === nodeType ||
    "TSMappedType" === nodeType ||
    "TSLiteralType" === nodeType ||
    "TSExpressionWithTypeArguments" === nodeType ||
    "TSImportType" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isTSBaseType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;
  if (
    "TSAnyKeyword" === nodeType ||
    "TSBooleanKeyword" === nodeType ||
    "TSBigIntKeyword" === nodeType ||
    "TSIntrinsicKeyword" === nodeType ||
    "TSNeverKeyword" === nodeType ||
    "TSNullKeyword" === nodeType ||
    "TSNumberKeyword" === nodeType ||
    "TSObjectKeyword" === nodeType ||
    "TSStringKeyword" === nodeType ||
    "TSSymbolKeyword" === nodeType ||
    "TSUndefinedKeyword" === nodeType ||
    "TSUnknownKeyword" === nodeType ||
    "TSVoidKeyword" === nodeType ||
    "TSThisType" === nodeType ||
    "TSLiteralType" === nodeType
  ) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isNumberLiteral(node, opts) {
  console.trace(
    "The node type NumberLiteral has been renamed to NumericLiteral"
  );
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NumberLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isRegexLiteral(node, opts) {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "RegexLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isRestProperty(node, opts) {
  console.trace("The node type RestProperty has been renamed to RestElement");
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "RestProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
function isSpreadProperty(node, opts) {
  console.trace(
    "The node type SpreadProperty has been renamed to SpreadElement"
  );
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "SpreadProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return false;
}
Object.defineProperty(matchesPattern$2, "__esModule", { value: true });
matchesPattern$2.default = matchesPattern$1;
var _generated$c = generated$9;
function matchesPattern$1(member, match, allowPartial) {
  if (!(0, _generated$c.isMemberExpression)(member)) return false;
  const parts = Array.isArray(match) ? match : match.split(".");
  const nodes = [];
  let node;
  for (
    node = member;
    (0, _generated$c.isMemberExpression)(node);
    node = node.object
  ) {
    nodes.push(node.property);
  }
  nodes.push(node);
  if (nodes.length < parts.length) return false;
  if (!allowPartial && nodes.length > parts.length) return false;
  for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
    const node = nodes[j];
    let value;
    if ((0, _generated$c.isIdentifier)(node)) {
      value = node.name;
    } else if ((0, _generated$c.isStringLiteral)(node)) {
      value = node.value;
    } else if ((0, _generated$c.isThisExpression)(node)) {
      value = "this";
    } else {
      return false;
    }
    if (parts[i] !== value) return false;
  }
  return true;
}
Object.defineProperty(buildMatchMemberExpression$2, "__esModule", {
  value: true,
});
buildMatchMemberExpression$2.default = buildMatchMemberExpression$1;
var _matchesPattern = matchesPattern$2;
function buildMatchMemberExpression$1(match, allowPartial) {
  const parts = match.split(".");
  return (member) => (0, _matchesPattern.default)(member, parts, allowPartial);
}
Object.defineProperty(isReactComponent$2, "__esModule", { value: true });
isReactComponent$2.default = void 0;
var _buildMatchMemberExpression = buildMatchMemberExpression$2;
const isReactComponent$1 = (0, _buildMatchMemberExpression.default)(
  "React.Component"
);
var _default$a = isReactComponent$1;
isReactComponent$2.default = _default$a;
var isCompatTag$2 = {};
Object.defineProperty(isCompatTag$2, "__esModule", { value: true });
isCompatTag$2.default = isCompatTag$1;
function isCompatTag$1(tagName) {
  return !!tagName && /^[a-z]/.test(tagName);
}
var buildChildren$1 = {};
var cleanJSXElementLiteralChild$1 = {};
var generated$8 = {};
var validateNode$1 = {};
var validate$2 = {};
var definitions$1 = {};
let fastProto = null;
function FastObject(o) {
  if (fastProto !== null && typeof fastProto.property) {
    const result = fastProto;
    fastProto = FastObject.prototype = null;
    return result;
  }
  fastProto = FastObject.prototype = o == null ? Object.create(null) : o;
  return new FastObject();
}
FastObject();
var toFastProperties = function toFastproperties(o) {
  return FastObject(o);
};
var core$1 = {};
var is$1 = {};
var isType$2 = {};
var hasRequiredIsType$1;
function requireIsType$1() {
  if (hasRequiredIsType$1) return isType$2;
  hasRequiredIsType$1 = 1;
  Object.defineProperty(isType$2, "__esModule", { value: true });
  isType$2.default = isType;
  var _definitions = requireDefinitions$1();
  function isType(nodeType, targetType) {
    if (nodeType === targetType) return true;
    if (_definitions.ALIAS_KEYS[targetType]) return false;
    const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];
    if (aliases) {
      if (aliases[0] === nodeType) return true;
      for (const alias of aliases) {
        if (nodeType === alias) return true;
      }
    }
    return false;
  }
  return isType$2;
}
var isPlaceholderType$1 = {};
var hasRequiredIsPlaceholderType$1;
function requireIsPlaceholderType$1() {
  if (hasRequiredIsPlaceholderType$1) return isPlaceholderType$1;
  hasRequiredIsPlaceholderType$1 = 1;
  Object.defineProperty(isPlaceholderType$1, "__esModule", { value: true });
  isPlaceholderType$1.default = isPlaceholderType;
  var _definitions = requireDefinitions$1();
  function isPlaceholderType(placeholderType, targetType) {
    if (placeholderType === targetType) return true;
    const aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];
    if (aliases) {
      for (const alias of aliases) {
        if (targetType === alias) return true;
      }
    }
    return false;
  }
  return isPlaceholderType$1;
}
var hasRequiredIs$1;
function requireIs$1() {
  if (hasRequiredIs$1) return is$1;
  hasRequiredIs$1 = 1;
  Object.defineProperty(is$1, "__esModule", { value: true });
  is$1.default = is;
  var _shallowEqual = shallowEqual$2;
  var _isType = requireIsType$1();
  var _isPlaceholderType = requireIsPlaceholderType$1();
  var _definitions = requireDefinitions$1();
  function is(type, node, opts) {
    if (!node) return false;
    const matches = (0, _isType.default)(node.type, type);
    if (!matches) {
      if (
        !opts &&
        node.type === "Placeholder" &&
        type in _definitions.FLIPPED_ALIAS_KEYS
      ) {
        return (0, _isPlaceholderType.default)(node.expectedNode, type);
      }
      return false;
    }
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return is$1;
}
var isValidIdentifier$2 = {};
var lib$4 = {};
var identifier = {};
Object.defineProperty(identifier, "__esModule", { value: true });
identifier.isIdentifierChar = isIdentifierChar;
identifier.isIdentifierName = isIdentifierName;
identifier.isIdentifierStart = isIdentifierStart;
let nonASCIIidentifierStartChars =
  "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
let nonASCIIidentifierChars =
  "-----------------------------------------------------------------------------------------------------------------------------------------------------";
const nonASCIIidentifierStart = new RegExp(
  "[" + nonASCIIidentifierStartChars + "]"
);
const nonASCIIidentifier = new RegExp(
  "[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]"
);
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
const astralIdentifierStartCodes = [
  0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48,
  31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39,
  9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21,
  11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10,
  30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43,
  28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14,
  50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13,
  52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15,
  3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46,
  39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21,
  2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26,
  38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7,
  3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8,
  2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0,
  328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96,
  16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3,
  32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237,
  43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309,
  106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0,
  2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24,
  2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30,
  7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3,
  2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2,
  3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2,
  0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2,
  16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938,
  6, 4191,
];
const astralIdentifierCodes = [
  509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574,
  3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3,
  46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2,
  11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0,
  11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1,
  83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3,
  2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47,
  15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9,
  49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7,
  14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1,
  19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49,
  513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4,
  101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9,
  787719, 239,
];
function isInAstralSet(code, set) {
  let pos = 65536;
  for (let i = 0, length = set.length; i < length; i += 2) {
    pos += set[i];
    if (pos > code) return false;
    pos += set[i + 1];
    if (pos >= code) return true;
  }
  return false;
}
function isIdentifierStart(code) {
  if (code < 65) return code === 36;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;
  if (code <= 65535) {
    return (
      code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code))
    );
  }
  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
  }
  return (
    isInAstralSet(code, astralIdentifierStartCodes) ||
    isInAstralSet(code, astralIdentifierCodes)
  );
}
function isIdentifierName(name) {
  let isFirst = true;
  for (let i = 0; i < name.length; i++) {
    let cp = name.charCodeAt(i);
    if ((cp & 64512) === 55296 && i + 1 < name.length) {
      const trail = name.charCodeAt(++i);
      if ((trail & 64512) === 56320) {
        cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
      }
    }
    if (isFirst) {
      isFirst = false;
      if (!isIdentifierStart(cp)) {
        return false;
      }
    } else if (!isIdentifierChar(cp)) {
      return false;
    }
  }
  return !isFirst;
}
var keyword = {};
Object.defineProperty(keyword, "__esModule", { value: true });
keyword.isKeyword = isKeyword;
keyword.isReservedWord = isReservedWord;
keyword.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
keyword.isStrictBindReservedWord = isStrictBindReservedWord;
keyword.isStrictReservedWord = isStrictReservedWord;
const reservedWords = {
  keyword: [
    "break",
    "case",
    "catch",
    "continue",
    "debugger",
    "default",
    "do",
    "else",
    "finally",
    "for",
    "function",
    "if",
    "return",
    "switch",
    "throw",
    "try",
    "var",
    "const",
    "while",
    "with",
    "new",
    "this",
    "super",
    "class",
    "extends",
    "export",
    "import",
    "null",
    "true",
    "false",
    "in",
    "instanceof",
    "typeof",
    "void",
    "delete",
  ],
  strict: [
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    "yield",
  ],
  strictBind: ["eval", "arguments"],
};
const keywords = new Set(reservedWords.keyword);
const reservedWordsStrictSet = new Set(reservedWords.strict);
const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
function isReservedWord(word, inModule) {
  return (inModule && word === "await") || word === "enum";
}
function isStrictReservedWord(word, inModule) {
  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}
function isStrictBindOnlyReservedWord(word) {
  return reservedWordsStrictBindSet.has(word);
}
function isStrictBindReservedWord(word, inModule) {
  return (
    isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word)
  );
}
function isKeyword(word) {
  return keywords.has(word);
}
(function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  Object.defineProperty(exports, "isIdentifierChar", {
    enumerable: true,
    get: function () {
      return _identifier.isIdentifierChar;
    },
  });
  Object.defineProperty(exports, "isIdentifierName", {
    enumerable: true,
    get: function () {
      return _identifier.isIdentifierName;
    },
  });
  Object.defineProperty(exports, "isIdentifierStart", {
    enumerable: true,
    get: function () {
      return _identifier.isIdentifierStart;
    },
  });
  Object.defineProperty(exports, "isKeyword", {
    enumerable: true,
    get: function () {
      return _keyword.isKeyword;
    },
  });
  Object.defineProperty(exports, "isReservedWord", {
    enumerable: true,
    get: function () {
      return _keyword.isReservedWord;
    },
  });
  Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
    enumerable: true,
    get: function () {
      return _keyword.isStrictBindOnlyReservedWord;
    },
  });
  Object.defineProperty(exports, "isStrictBindReservedWord", {
    enumerable: true,
    get: function () {
      return _keyword.isStrictBindReservedWord;
    },
  });
  Object.defineProperty(exports, "isStrictReservedWord", {
    enumerable: true,
    get: function () {
      return _keyword.isStrictReservedWord;
    },
  });
  var _identifier = identifier;
  var _keyword = keyword;
})(lib$4);
Object.defineProperty(isValidIdentifier$2, "__esModule", { value: true });
isValidIdentifier$2.default = isValidIdentifier$1;
var _helperValidatorIdentifier$1 = lib$4;
function isValidIdentifier$1(name, reserved = true) {
  if (typeof name !== "string") return false;
  if (reserved) {
    if (
      (0, _helperValidatorIdentifier$1.isKeyword)(name) ||
      (0, _helperValidatorIdentifier$1.isStrictReservedWord)(name, true)
    ) {
      return false;
    }
  }
  return (0, _helperValidatorIdentifier$1.isIdentifierName)(name);
}
var lib$3 = {};
var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib$3;
  hasRequiredLib$3 = 1;
  Object.defineProperty(lib$3, "__esModule", { value: true });
  lib$3.readCodePoint = readCodePoint;
  lib$3.readInt = readInt;
  lib$3.readStringContents = readStringContents;
  var _isDigit = function isDigit(code) {
    return code >= 48 && code <= 57;
  };
  const forbiddenNumericSeparatorSiblings = {
    decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: new Set([46, 88, 95, 120]),
  };
  const isAllowedNumericSeparatorSibling = {
    bin: (ch) => ch === 48 || ch === 49,
    oct: (ch) => ch >= 48 && ch <= 55,
    dec: (ch) => ch >= 48 && ch <= 57,
    hex: (ch) =>
      (ch >= 48 && ch <= 57) ||
      (ch >= 65 && ch <= 70) ||
      (ch >= 97 && ch <= 102),
  };
  function readStringContents(type, input, pos, lineStart, curLine, errors) {
    const initialPos = pos;
    const initialLineStart = lineStart;
    const initialCurLine = curLine;
    let out = "";
    let containsInvalid = false;
    let chunkStart = pos;
    const { length: length } = input;
    for (;;) {
      if (pos >= length) {
        errors.unterminated(initialPos, initialLineStart, initialCurLine);
        out += input.slice(chunkStart, pos);
        break;
      }
      const ch = input.charCodeAt(pos);
      if (isStringEnd(type, ch, input, pos)) {
        out += input.slice(chunkStart, pos);
        break;
      }
      if (ch === 92) {
        out += input.slice(chunkStart, pos);
        let escaped;
        ({
          ch: escaped,
          pos: pos,
          lineStart: lineStart,
          curLine: curLine,
        } = readEscapedChar(
          input,
          pos,
          lineStart,
          curLine,
          type === "template",
          errors
        ));
        if (escaped === null) {
          containsInvalid = true;
        } else {
          out += escaped;
        }
        chunkStart = pos;
      } else if (ch === 8232 || ch === 8233) {
        ++pos;
        ++curLine;
        lineStart = pos;
      } else if (ch === 10 || ch === 13) {
        if (type === "template") {
          out += input.slice(chunkStart, pos) + "\n";
          ++pos;
          if (ch === 13 && input.charCodeAt(pos) === 10) {
            ++pos;
          }
          ++curLine;
          chunkStart = lineStart = pos;
        } else {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
        }
      } else {
        ++pos;
      }
    }
    return {
      pos: pos,
      str: out,
      containsInvalid: containsInvalid,
      lineStart: lineStart,
      curLine: curLine,
    };
  }
  function isStringEnd(type, ch, input, pos) {
    if (type === "template") {
      return ch === 96 || (ch === 36 && input.charCodeAt(pos + 1) === 123);
    }
    return ch === (type === "double" ? 34 : 39);
  }
  function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
    const throwOnInvalid = !inTemplate;
    pos++;
    const res = (ch) => ({
      pos: pos,
      ch: ch,
      lineStart: lineStart,
      curLine: curLine,
    });
    const ch = input.charCodeAt(pos++);
    switch (ch) {
      case 110:
        return res("\n");
      case 114:
        return res("\r");
      case 120: {
        let code;
        ({ code: code, pos: pos } = readHexChar(
          input,
          pos,
          lineStart,
          curLine,
          2,
          false,
          throwOnInvalid,
          errors
        ));
        return res(code === null ? null : String.fromCharCode(code));
      }
      case 117: {
        let code;
        ({ code: code, pos: pos } = readCodePoint(
          input,
          pos,
          lineStart,
          curLine,
          throwOnInvalid,
          errors
        ));
        return res(code === null ? null : String.fromCodePoint(code));
      }
      case 116:
        return res("\t");
      case 98:
        return res("\b");
      case 118:
        return res("\v");
      case 102:
        return res("\f");
      case 13:
        if (input.charCodeAt(pos) === 10) {
          ++pos;
        }
      case 10:
        lineStart = pos;
        ++curLine;
      case 8232:
      case 8233:
        return res("");
      case 56:
      case 57:
        if (inTemplate) {
          return res(null);
        } else {
          errors.strictNumericEscape(pos - 1, lineStart, curLine);
        }
      default:
        if (ch >= 48 && ch <= 55) {
          const startPos = pos - 1;
          const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
          let octalStr = match[0];
          let octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          pos += octalStr.length - 1;
          const next = input.charCodeAt(pos);
          if (octalStr !== "0" || next === 56 || next === 57) {
            if (inTemplate) {
              return res(null);
            } else {
              errors.strictNumericEscape(startPos, lineStart, curLine);
            }
          }
          return res(String.fromCharCode(octal));
        }
        return res(String.fromCharCode(ch));
    }
  }
  function readHexChar(
    input,
    pos,
    lineStart,
    curLine,
    len,
    forceLen,
    throwOnInvalid,
    errors
  ) {
    const initialPos = pos;
    let n;
    ({ n: n, pos: pos } = readInt(
      input,
      pos,
      lineStart,
      curLine,
      16,
      len,
      forceLen,
      false,
      errors
    ));
    if (n === null) {
      if (throwOnInvalid) {
        errors.invalidEscapeSequence(initialPos, lineStart, curLine);
      } else {
        pos = initialPos - 1;
      }
    }
    return { code: n, pos: pos };
  }
  function readInt(
    input,
    pos,
    lineStart,
    curLine,
    radix,
    len,
    forceLen,
    allowNumSeparator,
    errors
  ) {
    const start = pos;
    const forbiddenSiblings =
      radix === 16
        ? forbiddenNumericSeparatorSiblings.hex
        : forbiddenNumericSeparatorSiblings.decBinOct;
    const isAllowedSibling =
      radix === 16
        ? isAllowedNumericSeparatorSibling.hex
        : radix === 10
          ? isAllowedNumericSeparatorSibling.dec
          : radix === 8
            ? isAllowedNumericSeparatorSibling.oct
            : isAllowedNumericSeparatorSibling.bin;
    let invalid = false;
    let total = 0;
    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      const code = input.charCodeAt(pos);
      let val;
      if (code === 95 && allowNumSeparator !== "bail") {
        const prev = input.charCodeAt(pos - 1);
        const next = input.charCodeAt(pos + 1);
        if (!allowNumSeparator) {
          errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
        } else if (
          Number.isNaN(next) ||
          !isAllowedSibling(next) ||
          forbiddenSiblings.has(prev) ||
          forbiddenSiblings.has(next)
        ) {
          errors.unexpectedNumericSeparator(pos, lineStart, curLine);
        }
        ++pos;
        continue;
      }
      if (code >= 97) {
        val = code - 97 + 10;
      } else if (code >= 65) {
        val = code - 65 + 10;
      } else if (_isDigit(code)) {
        val = code - 48;
      } else {
        val = Infinity;
      }
      if (val >= radix) {
        if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
          val = 0;
        } else if (forceLen) {
          val = 0;
          invalid = true;
        } else {
          break;
        }
      }
      ++pos;
      total = total * radix + val;
    }
    if (pos === start || (len != null && pos - start !== len) || invalid) {
      return { n: null, pos: pos };
    }
    return { n: total, pos: pos };
  }
  function readCodePoint(
    input,
    pos,
    lineStart,
    curLine,
    throwOnInvalid,
    errors
  ) {
    const ch = input.charCodeAt(pos);
    let code;
    if (ch === 123) {
      ++pos;
      ({ code: code, pos: pos } = readHexChar(
        input,
        pos,
        lineStart,
        curLine,
        input.indexOf("}", pos) - pos,
        true,
        throwOnInvalid,
        errors
      ));
      ++pos;
      if (code !== null && code > 1114111) {
        if (throwOnInvalid) {
          errors.invalidCodePoint(pos, lineStart, curLine);
        } else {
          return { code: null, pos: pos };
        }
      }
    } else {
      ({ code: code, pos: pos } = readHexChar(
        input,
        pos,
        lineStart,
        curLine,
        4,
        false,
        throwOnInvalid,
        errors
      ));
    }
    return { code: code, pos: pos };
  }
  return lib$3;
}
var constants$1 = {};
Object.defineProperty(constants$1, "__esModule", { value: true });
constants$1.UPDATE_OPERATORS =
  constants$1.UNARY_OPERATORS =
  constants$1.STRING_UNARY_OPERATORS =
  constants$1.STATEMENT_OR_BLOCK_KEYS =
  constants$1.NUMBER_UNARY_OPERATORS =
  constants$1.NUMBER_BINARY_OPERATORS =
  constants$1.NOT_LOCAL_BINDING =
  constants$1.LOGICAL_OPERATORS =
  constants$1.INHERIT_KEYS =
  constants$1.FOR_INIT_KEYS =
  constants$1.FLATTENABLE_KEYS =
  constants$1.EQUALITY_BINARY_OPERATORS =
  constants$1.COMPARISON_BINARY_OPERATORS =
  constants$1.COMMENT_KEYS =
  constants$1.BOOLEAN_UNARY_OPERATORS =
  constants$1.BOOLEAN_NUMBER_BINARY_OPERATORS =
  constants$1.BOOLEAN_BINARY_OPERATORS =
  constants$1.BLOCK_SCOPED_SYMBOL =
  constants$1.BINARY_OPERATORS =
  constants$1.ASSIGNMENT_OPERATORS =
    void 0;
const STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
constants$1.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
const FLATTENABLE_KEYS = ["body", "expressions"];
constants$1.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
const FOR_INIT_KEYS = ["left", "init"];
constants$1.FOR_INIT_KEYS = FOR_INIT_KEYS;
const COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
constants$1.COMMENT_KEYS = COMMENT_KEYS;
const LOGICAL_OPERATORS = ["||", "&&", "??"];
constants$1.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
const UPDATE_OPERATORS = ["++", "--"];
constants$1.UPDATE_OPERATORS = UPDATE_OPERATORS;
const BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
constants$1.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
const EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
constants$1.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
const COMPARISON_BINARY_OPERATORS = [
  ...EQUALITY_BINARY_OPERATORS,
  "in",
  "instanceof",
];
constants$1.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
const BOOLEAN_BINARY_OPERATORS = [
  ...COMPARISON_BINARY_OPERATORS,
  ...BOOLEAN_NUMBER_BINARY_OPERATORS,
];
constants$1.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
const NUMBER_BINARY_OPERATORS = [
  "-",
  "/",
  "%",
  "*",
  "**",
  "&",
  "|",
  ">>",
  ">>>",
  "<<",
  "^",
];
constants$1.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
const BINARY_OPERATORS = [
  "+",
  ...NUMBER_BINARY_OPERATORS,
  ...BOOLEAN_BINARY_OPERATORS,
  "|>",
];
constants$1.BINARY_OPERATORS = BINARY_OPERATORS;
const ASSIGNMENT_OPERATORS = [
  "=",
  "+=",
  ...NUMBER_BINARY_OPERATORS.map((op) => op + "="),
  ...LOGICAL_OPERATORS.map((op) => op + "="),
];
constants$1.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
const BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
constants$1.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
const NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
constants$1.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
const STRING_UNARY_OPERATORS = ["typeof"];
constants$1.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
const UNARY_OPERATORS = [
  "void",
  "throw",
  ...BOOLEAN_UNARY_OPERATORS,
  ...NUMBER_UNARY_OPERATORS,
  ...STRING_UNARY_OPERATORS,
];
constants$1.UNARY_OPERATORS = UNARY_OPERATORS;
const INHERIT_KEYS = {
  optional: ["typeAnnotation", "typeParameters", "returnType"],
  force: ["start", "loc", "end"],
};
constants$1.INHERIT_KEYS = INHERIT_KEYS;
const BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
constants$1.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
const NOT_LOCAL_BINDING = Symbol.for(
  "should not be considered a local binding"
);
constants$1.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;
var utils$1 = {};
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  Object.defineProperty(utils$1, "__esModule", { value: true });
  utils$1.VISITOR_KEYS =
    utils$1.NODE_PARENT_VALIDATIONS =
    utils$1.NODE_FIELDS =
    utils$1.FLIPPED_ALIAS_KEYS =
    utils$1.DEPRECATED_KEYS =
    utils$1.BUILDER_KEYS =
    utils$1.ALIAS_KEYS =
      void 0;
  utils$1.arrayOf = arrayOf;
  utils$1.arrayOfType = arrayOfType;
  utils$1.assertEach = assertEach;
  utils$1.assertNodeOrValueType = assertNodeOrValueType;
  utils$1.assertNodeType = assertNodeType;
  utils$1.assertOneOf = assertOneOf;
  utils$1.assertOptionalChainStart = assertOptionalChainStart;
  utils$1.assertShape = assertShape;
  utils$1.assertValueType = assertValueType;
  utils$1.chain = chain;
  utils$1.default = defineType;
  utils$1.defineAliasedType = defineAliasedType;
  utils$1.typeIs = typeIs;
  utils$1.validate = validate;
  utils$1.validateArrayOfType = validateArrayOfType;
  utils$1.validateOptional = validateOptional;
  utils$1.validateOptionalType = validateOptionalType;
  utils$1.validateType = validateType;
  var _is = requireIs$1();
  var _validate = requireValidate$1();
  const VISITOR_KEYS = {};
  utils$1.VISITOR_KEYS = VISITOR_KEYS;
  const ALIAS_KEYS = {};
  utils$1.ALIAS_KEYS = ALIAS_KEYS;
  const FLIPPED_ALIAS_KEYS = {};
  utils$1.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
  const NODE_FIELDS = {};
  utils$1.NODE_FIELDS = NODE_FIELDS;
  const BUILDER_KEYS = {};
  utils$1.BUILDER_KEYS = BUILDER_KEYS;
  const DEPRECATED_KEYS = {};
  utils$1.DEPRECATED_KEYS = DEPRECATED_KEYS;
  const NODE_PARENT_VALIDATIONS = {};
  utils$1.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;
  function getType(val) {
    if (Array.isArray(val)) {
      return "array";
    } else if (val === null) {
      return "null";
    } else {
      return typeof val;
    }
  }
  function validate(validate) {
    return { validate: validate };
  }
  function typeIs(typeName) {
    return typeof typeName === "string"
      ? assertNodeType(typeName)
      : assertNodeType(...typeName);
  }
  function validateType(typeName) {
    return validate(typeIs(typeName));
  }
  function validateOptional(validate) {
    return { validate: validate, optional: true };
  }
  function validateOptionalType(typeName) {
    return { validate: typeIs(typeName), optional: true };
  }
  function arrayOf(elementType) {
    return chain(assertValueType("array"), assertEach(elementType));
  }
  function arrayOfType(typeName) {
    return arrayOf(typeIs(typeName));
  }
  function validateArrayOfType(typeName) {
    return validate(arrayOfType(typeName));
  }
  function assertEach(callback) {
    function validator(node, key, val) {
      if (!Array.isArray(val)) return;
      for (let i = 0; i < val.length; i++) {
        const subkey = `${key}[${i}]`;
        const v = val[i];
        callback(node, subkey, v);
        if (process.env.BABEL_TYPES_8_BREAKING)
          (0, _validate.validateChild)(node, subkey, v);
      }
    }
    validator.each = callback;
    return validator;
  }
  function assertOneOf(...values) {
    function validate(node, key, val) {
      if (values.indexOf(val) < 0) {
        throw new TypeError(
          `Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`
        );
      }
    }
    validate.oneOf = values;
    return validate;
  }
  function assertNodeType(...types) {
    function validate(node, key, val) {
      for (const type of types) {
        if ((0, _is.default)(type, val)) {
          (0, _validate.validateChild)(node, key, val);
          return;
        }
      }
      throw new TypeError(
        `Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`
      );
    }
    validate.oneOfNodeTypes = types;
    return validate;
  }
  function assertNodeOrValueType(...types) {
    function validate(node, key, val) {
      for (const type of types) {
        if (getType(val) === type || (0, _is.default)(type, val)) {
          (0, _validate.validateChild)(node, key, val);
          return;
        }
      }
      throw new TypeError(
        `Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`
      );
    }
    validate.oneOfNodeOrValueTypes = types;
    return validate;
  }
  function assertValueType(type) {
    function validate(node, key, val) {
      const valid = getType(val) === type;
      if (!valid) {
        throw new TypeError(
          `Property ${key} expected type of ${type} but got ${getType(val)}`
        );
      }
    }
    validate.type = type;
    return validate;
  }
  function assertShape(shape) {
    function validate(node, key, val) {
      const errors = [];
      for (const property of Object.keys(shape)) {
        try {
          (0, _validate.validateField)(
            node,
            property,
            val[property],
            shape[property]
          );
        } catch (error) {
          if (error instanceof TypeError) {
            errors.push(error.message);
            continue;
          }
          throw error;
        }
      }
      if (errors.length) {
        throw new TypeError(
          `Property ${key} of ${node.type} expected to have the following:\n${errors.join("\n")}`
        );
      }
    }
    validate.shapeOf = shape;
    return validate;
  }
  function assertOptionalChainStart() {
    function validate(node) {
      var _current;
      let current = node;
      while (node) {
        const { type: type } = current;
        if (type === "OptionalCallExpression") {
          if (current.optional) return;
          current = current.callee;
          continue;
        }
        if (type === "OptionalMemberExpression") {
          if (current.optional) return;
          current = current.object;
          continue;
        }
        break;
      }
      throw new TypeError(
        `Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`
      );
    }
    return validate;
  }
  function chain(...fns) {
    function validate(...args) {
      for (const fn of fns) {
        fn(...args);
      }
    }
    validate.chainOf = fns;
    if (
      fns.length >= 2 &&
      "type" in fns[0] &&
      fns[0].type === "array" &&
      !("each" in fns[1])
    ) {
      throw new Error(
        `An assertValueType("array") validator can only be followed by an assertEach(...) validator.`
      );
    }
    return validate;
  }
  const validTypeOpts = [
    "aliases",
    "builder",
    "deprecatedAlias",
    "fields",
    "inherits",
    "visitor",
    "validate",
  ];
  const validFieldKeys = ["default", "optional", "validate"];
  function defineAliasedType(...aliases) {
    return (type, opts = {}) => {
      let defined = opts.aliases;
      if (!defined) {
        var _store$opts$inherits$, _defined;
        if (opts.inherits)
          defined =
            (_store$opts$inherits$ = store[opts.inherits].aliases) == null
              ? void 0
              : _store$opts$inherits$.slice();
        (_defined = defined) != null ? _defined : (defined = []);
        opts.aliases = defined;
      }
      const additional = aliases.filter((a) => !defined.includes(a));
      defined.unshift(...additional);
      return defineType(type, opts);
    };
  }
  function defineType(type, opts = {}) {
    const inherits = (opts.inherits && store[opts.inherits]) || {};
    let fields = opts.fields;
    if (!fields) {
      fields = {};
      if (inherits.fields) {
        const keys = Object.getOwnPropertyNames(inherits.fields);
        for (const key of keys) {
          const field = inherits.fields[key];
          const def = field.default;
          if (
            Array.isArray(def) ? def.length > 0 : def && typeof def === "object"
          ) {
            throw new Error(
              "field defaults can only be primitives or empty arrays currently"
            );
          }
          fields[key] = {
            default: Array.isArray(def) ? [] : def,
            optional: field.optional,
            validate: field.validate,
          };
        }
      }
    }
    const visitor = opts.visitor || inherits.visitor || [];
    const aliases = opts.aliases || inherits.aliases || [];
    const builder = opts.builder || inherits.builder || opts.visitor || [];
    for (const k of Object.keys(opts)) {
      if (validTypeOpts.indexOf(k) === -1) {
        throw new Error(`Unknown type option "${k}" on ${type}`);
      }
    }
    if (opts.deprecatedAlias) {
      DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    }
    for (const key of visitor.concat(builder)) {
      fields[key] = fields[key] || {};
    }
    for (const key of Object.keys(fields)) {
      const field = fields[key];
      if (field.default !== undefined && builder.indexOf(key) === -1) {
        field.optional = true;
      }
      if (field.default === undefined) {
        field.default = null;
      } else if (!field.validate && field.default != null) {
        field.validate = assertValueType(getType(field.default));
      }
      for (const k of Object.keys(field)) {
        if (validFieldKeys.indexOf(k) === -1) {
          throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
        }
      }
    }
    VISITOR_KEYS[type] = opts.visitor = visitor;
    BUILDER_KEYS[type] = opts.builder = builder;
    NODE_FIELDS[type] = opts.fields = fields;
    ALIAS_KEYS[type] = opts.aliases = aliases;
    aliases.forEach((alias) => {
      FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
      FLIPPED_ALIAS_KEYS[alias].push(type);
    });
    if (opts.validate) {
      NODE_PARENT_VALIDATIONS[type] = opts.validate;
    }
    store[type] = opts;
  }
  const store = {};
  return utils$1;
}
var hasRequiredCore$1;
function requireCore$1() {
  if (hasRequiredCore$1) return core$1;
  hasRequiredCore$1 = 1;
  Object.defineProperty(core$1, "__esModule", { value: true });
  core$1.patternLikeCommon =
    core$1.functionTypeAnnotationCommon =
    core$1.functionDeclarationCommon =
    core$1.functionCommon =
    core$1.classMethodOrPropertyCommon =
    core$1.classMethodOrDeclareMethodCommon =
      void 0;
  var _is = requireIs$1();
  var _isValidIdentifier = isValidIdentifier$2;
  var _helperValidatorIdentifier = lib$4;
  var _helperStringParser = requireLib$3();
  var _constants = constants$1;
  var _utils = requireUtils$1();
  const defineType = (0, _utils.defineAliasedType)("Standardized");
  defineType("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeOrValueType)(
              "null",
              "Expression",
              "SpreadElement"
            )
          )
        ),
        default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined,
      },
    },
    visitor: ["elements"],
    aliases: ["Expression"],
  });
  defineType("AssignmentExpression", {
    fields: {
      operator: {
        validate: (function () {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return (0, _utils.assertValueType)("string");
          }
          const identifier = (0, _utils.assertOneOf)(
            ..._constants.ASSIGNMENT_OPERATORS
          );
          const pattern = (0, _utils.assertOneOf)("=");
          return function (node, key, val) {
            const validator = (0, _is.default)("Pattern", node.left)
              ? pattern
              : identifier;
            validator(node, key, val);
          };
        })(),
      },
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING
          ? (0, _utils.assertNodeType)("LVal")
          : (0, _utils.assertNodeType)(
              "Identifier",
              "MemberExpression",
              "ArrayPattern",
              "ObjectPattern",
              "TSAsExpression",
              "TSTypeAssertion",
              "TSNonNullExpression"
            ),
      },
      right: { validate: (0, _utils.assertNodeType)("Expression") },
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"],
  });
  defineType("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS),
      },
      left: {
        validate: (function () {
          const expression = (0, _utils.assertNodeType)("Expression");
          const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
          const validator = Object.assign(
            function (node, key, val) {
              const validator = node.operator === "in" ? inOp : expression;
              validator(node, key, val);
            },
            { oneOfNodeTypes: ["Expression", "PrivateName"] }
          );
          return validator;
        })(),
      },
      right: { validate: (0, _utils.assertNodeType)("Expression") },
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
  });
  defineType("InterpreterDirective", {
    builder: ["value"],
    fields: { value: { validate: (0, _utils.assertValueType)("string") } },
  });
  defineType("Directive", {
    visitor: ["value"],
    fields: {
      value: { validate: (0, _utils.assertNodeType)("DirectiveLiteral") },
    },
  });
  defineType("DirectiveLiteral", {
    builder: ["value"],
    fields: { value: { validate: (0, _utils.assertValueType)("string") } },
  });
  defineType("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))
        ),
        default: [],
      },
      body: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement"))
        ),
      },
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"],
  });
  defineType("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true,
      },
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  });
  defineType("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign(
      {
        callee: {
          validate: (0, _utils.assertNodeType)(
            "Expression",
            "Super",
            "V8IntrinsicIdentifier"
          ),
        },
        arguments: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)("array"),
            (0, _utils.assertEach)(
              (0, _utils.assertNodeType)(
                "Expression",
                "SpreadElement",
                "JSXNamespacedName",
                "ArgumentPlaceholder"
              )
            )
          ),
        },
      },
      !process.env.BABEL_TYPES_8_BREAKING
        ? {
            optional: {
              validate: (0, _utils.assertOneOf)(true, false),
              optional: true,
            },
          }
        : {},
      {
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true,
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true,
        },
      }
    ),
  });
  defineType("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, _utils.assertNodeType)(
          "Identifier",
          "ArrayPattern",
          "ObjectPattern"
        ),
        optional: true,
      },
      body: { validate: (0, _utils.assertNodeType)("BlockStatement") },
    },
    aliases: ["Scopable", "BlockParent"],
  });
  defineType("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: { validate: (0, _utils.assertNodeType)("Expression") },
      consequent: { validate: (0, _utils.assertNodeType)("Expression") },
      alternate: { validate: (0, _utils.assertNodeType)("Expression") },
    },
    aliases: ["Expression", "Conditional"],
  });
  defineType("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true,
      },
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  });
  defineType("DebuggerStatement", { aliases: ["Statement"] });
  defineType("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: { validate: (0, _utils.assertNodeType)("Expression") },
      body: { validate: (0, _utils.assertNodeType)("Statement") },
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
  });
  defineType("EmptyStatement", { aliases: ["Statement"] });
  defineType("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: { validate: (0, _utils.assertNodeType)("Expression") },
    },
    aliases: ["Statement", "ExpressionWrapper"],
  });
  defineType("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: { validate: (0, _utils.assertNodeType)("Program") },
      comments: {
        validate: !process.env.BABEL_TYPES_8_BREAKING
          ? Object.assign(() => {}, {
              each: { oneOfNodeTypes: ["CommentBlock", "CommentLine"] },
            })
          : (0, _utils.assertEach)(
              (0, _utils.assertNodeType)("CommentBlock", "CommentLine")
            ),
        optional: true,
      },
      tokens: {
        validate: (0, _utils.assertEach)(
          Object.assign(() => {}, { type: "any" })
        ),
        optional: true,
      },
    },
  });
  defineType("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: [
      "Scopable",
      "Statement",
      "For",
      "BlockParent",
      "Loop",
      "ForXStatement",
    ],
    fields: {
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING
          ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal")
          : (0, _utils.assertNodeType)(
              "VariableDeclaration",
              "Identifier",
              "MemberExpression",
              "ArrayPattern",
              "ObjectPattern",
              "TSAsExpression",
              "TSTypeAssertion",
              "TSNonNullExpression"
            ),
      },
      right: { validate: (0, _utils.assertNodeType)("Expression") },
      body: { validate: (0, _utils.assertNodeType)("Statement") },
    },
  });
  defineType("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, _utils.assertNodeType)(
          "VariableDeclaration",
          "Expression"
        ),
        optional: true,
      },
      test: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true,
      },
      update: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true,
      },
      body: { validate: (0, _utils.assertNodeType)("Statement") },
    },
  });
  const functionCommon = () => ({
    params: {
      validate: (0, _utils.chain)(
        (0, _utils.assertValueType)("array"),
        (0, _utils.assertEach)(
          (0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement")
        )
      ),
    },
    generator: { default: false },
    async: { default: false },
  });
  core$1.functionCommon = functionCommon;
  const functionTypeAnnotationCommon = () => ({
    returnType: {
      validate: (0, _utils.assertNodeType)(
        "TypeAnnotation",
        "TSTypeAnnotation",
        "Noop"
      ),
      optional: true,
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)(
        "TypeParameterDeclaration",
        "TSTypeParameterDeclaration",
        "Noop"
      ),
      optional: true,
    },
  });
  core$1.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
  const functionDeclarationCommon = () =>
    Object.assign({}, functionCommon(), {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true,
      },
    });
  core$1.functionDeclarationCommon = functionDeclarationCommon;
  defineType("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign(
      {},
      functionDeclarationCommon(),
      functionTypeAnnotationCommon(),
      {
        body: { validate: (0, _utils.assertNodeType)("BlockStatement") },
        predicate: {
          validate: (0, _utils.assertNodeType)(
            "DeclaredPredicate",
            "InferredPredicate"
          ),
          optional: true,
        },
      }
    ),
    aliases: [
      "Scopable",
      "Function",
      "BlockParent",
      "FunctionParent",
      "Statement",
      "Pureish",
      "Declaration",
    ],
    validate: (function () {
      if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};
      const identifier = (0, _utils.assertNodeType)("Identifier");
      return function (parent, key, node) {
        if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
          identifier(node, "id", node.id);
        }
      };
    })(),
  });
  defineType("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: [
      "Scopable",
      "Function",
      "BlockParent",
      "FunctionParent",
      "Expression",
      "Pureish",
    ],
    fields: Object.assign(
      {},
      functionCommon(),
      functionTypeAnnotationCommon(),
      {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true,
        },
        body: { validate: (0, _utils.assertNodeType)("BlockStatement") },
        predicate: {
          validate: (0, _utils.assertNodeType)(
            "DeclaredPredicate",
            "InferredPredicate"
          ),
          optional: true,
        },
      }
    ),
  });
  const patternLikeCommon = () => ({
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)(
        "TypeAnnotation",
        "TSTypeAnnotation",
        "Noop"
      ),
      optional: true,
    },
    decorators: {
      validate: (0, _utils.chain)(
        (0, _utils.assertValueType)("array"),
        (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
      ),
      optional: true,
    },
  });
  core$1.patternLikeCommon = patternLikeCommon;
  defineType("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, patternLikeCommon(), {
      name: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("string"),
          Object.assign(
            function (node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING) return;
              if (!(0, _isValidIdentifier.default)(val, false)) {
                throw new TypeError(`"${val}" is not a valid identifier name`);
              }
            },
            { type: "string" }
          )
        ),
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
    }),
    validate(parent, key, node) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      const match = /\.(\w+)$/.exec(key);
      if (!match) return;
      const [, parentKey] = match;
      const nonComp = { computed: false };
      if (parentKey === "property") {
        if ((0, _is.default)("MemberExpression", parent, nonComp)) return;
        if ((0, _is.default)("OptionalMemberExpression", parent, nonComp))
          return;
      } else if (parentKey === "key") {
        if ((0, _is.default)("Property", parent, nonComp)) return;
        if ((0, _is.default)("Method", parent, nonComp)) return;
      } else if (parentKey === "exported") {
        if ((0, _is.default)("ExportSpecifier", parent)) return;
      } else if (parentKey === "imported") {
        if ((0, _is.default)("ImportSpecifier", parent, { imported: node }))
          return;
      } else if (parentKey === "meta") {
        if ((0, _is.default)("MetaProperty", parent, { meta: node })) return;
      }
      if (
        ((0, _helperValidatorIdentifier.isKeyword)(node.name) ||
          (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) &&
        node.name !== "this"
      ) {
        throw new TypeError(`"${node.name}" is not a valid identifier`);
      }
    },
  });
  defineType("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: { validate: (0, _utils.assertNodeType)("Expression") },
      consequent: { validate: (0, _utils.assertNodeType)("Statement") },
      alternate: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Statement"),
      },
    },
  });
  defineType("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: { validate: (0, _utils.assertNodeType)("Identifier") },
      body: { validate: (0, _utils.assertNodeType)("Statement") },
    },
  });
  defineType("StringLiteral", {
    builder: ["value"],
    fields: { value: { validate: (0, _utils.assertValueType)("string") } },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"],
  });
  defineType("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: { value: { validate: (0, _utils.assertValueType)("number") } },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"],
  });
  defineType("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"],
  });
  defineType("BooleanLiteral", {
    builder: ["value"],
    fields: { value: { validate: (0, _utils.assertValueType)("boolean") } },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"],
  });
  defineType("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: { validate: (0, _utils.assertValueType)("string") },
      flags: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("string"),
          Object.assign(
            function (node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING) return;
              const invalid = /[^gimsuy]/.exec(val);
              if (invalid) {
                throw new TypeError(
                  `"${invalid[0]}" is not a valid RegExp flag`
                );
              }
            },
            { type: "string" }
          )
        ),
        default: "",
      },
    },
  });
  defineType("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS),
      },
      left: { validate: (0, _utils.assertNodeType)("Expression") },
      right: { validate: (0, _utils.assertNodeType)("Expression") },
    },
  });
  defineType("MemberExpression", {
    builder: [
      "object",
      "property",
      "computed",
      ...(!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : []),
    ],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign(
      {
        object: { validate: (0, _utils.assertNodeType)("Expression", "Super") },
        property: {
          validate: (function () {
            const normal = (0, _utils.assertNodeType)(
              "Identifier",
              "PrivateName"
            );
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function (node, key, val) {
              const validator = node.computed ? computed : normal;
              validator(node, key, val);
            };
            validator.oneOfNodeTypes = [
              "Expression",
              "Identifier",
              "PrivateName",
            ];
            return validator;
          })(),
        },
        computed: { default: false },
      },
      !process.env.BABEL_TYPES_8_BREAKING
        ? {
            optional: {
              validate: (0, _utils.assertOneOf)(true, false),
              optional: true,
            },
          }
        : {}
    ),
  });
  defineType("NewExpression", { inherits: "CallExpression" });
  defineType("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceFile: { validate: (0, _utils.assertValueType)("string") },
      sourceType: {
        validate: (0, _utils.assertOneOf)("script", "module"),
        default: "script",
      },
      interpreter: {
        validate: (0, _utils.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: true,
      },
      directives: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))
        ),
        default: [],
      },
      body: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement"))
        ),
      },
    },
    aliases: ["Scopable", "BlockParent", "Block"],
  });
  defineType("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)(
              "ObjectMethod",
              "ObjectProperty",
              "SpreadElement"
            )
          )
        ),
      },
    },
  });
  defineType("ObjectMethod", {
    builder: [
      "kind",
      "key",
      "params",
      "body",
      "computed",
      "generator",
      "async",
    ],
    fields: Object.assign(
      {},
      functionCommon(),
      functionTypeAnnotationCommon(),
      {
        kind: Object.assign(
          { validate: (0, _utils.assertOneOf)("method", "get", "set") },
          !process.env.BABEL_TYPES_8_BREAKING ? { default: "method" } : {}
        ),
        computed: { default: false },
        key: {
          validate: (function () {
            const normal = (0, _utils.assertNodeType)(
              "Identifier",
              "StringLiteral",
              "NumericLiteral",
              "BigIntLiteral"
            );
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function (node, key, val) {
              const validator = node.computed ? computed : normal;
              validator(node, key, val);
            };
            validator.oneOfNodeTypes = [
              "Expression",
              "Identifier",
              "StringLiteral",
              "NumericLiteral",
              "BigIntLiteral",
            ];
            return validator;
          })(),
        },
        decorators: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)("array"),
            (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
          ),
          optional: true,
        },
        body: { validate: (0, _utils.assertNodeType)("BlockStatement") },
      }
    ),
    visitor: [
      "key",
      "params",
      "body",
      "decorators",
      "returnType",
      "typeParameters",
    ],
    aliases: [
      "UserWhitespacable",
      "Function",
      "Scopable",
      "BlockParent",
      "FunctionParent",
      "Method",
      "ObjectMember",
    ],
  });
  defineType("ObjectProperty", {
    builder: [
      "key",
      "value",
      "computed",
      "shorthand",
      ...(!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []),
    ],
    fields: {
      computed: { default: false },
      key: {
        validate: (function () {
          const normal = (0, _utils.assertNodeType)(
            "Identifier",
            "StringLiteral",
            "NumericLiteral",
            "BigIntLiteral",
            "DecimalLiteral",
            "PrivateName"
          );
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator = Object.assign(
            function (node, key, val) {
              const validator = node.computed ? computed : normal;
              validator(node, key, val);
            },
            {
              oneOfNodeTypes: [
                "Expression",
                "Identifier",
                "StringLiteral",
                "NumericLiteral",
                "BigIntLiteral",
                "DecimalLiteral",
                "PrivateName",
              ],
            }
          );
          return validator;
        })(),
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression", "PatternLike"),
      },
      shorthand: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("boolean"),
          Object.assign(
            function (node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING) return;
              if (val && node.computed) {
                throw new TypeError(
                  "Property shorthand of ObjectProperty cannot be true if computed is true"
                );
              }
            },
            { type: "boolean" }
          ),
          function (node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING) return;
            if (val && !(0, _is.default)("Identifier", node.key)) {
              throw new TypeError(
                "Property shorthand of ObjectProperty cannot be true if key is not an Identifier"
              );
            }
          }
        ),
        default: false,
      },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
        ),
        optional: true,
      },
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: (function () {
      const pattern = (0, _utils.assertNodeType)(
        "Identifier",
        "Pattern",
        "TSAsExpression",
        "TSNonNullExpression",
        "TSTypeAssertion"
      );
      const expression = (0, _utils.assertNodeType)("Expression");
      return function (parent, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        const validator = (0, _is.default)("ObjectPattern", parent)
          ? pattern
          : expression;
        validator(node, "value", node.value);
      };
    })(),
  });
  defineType("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, patternLikeCommon(), {
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING
          ? (0, _utils.assertNodeType)("LVal")
          : (0, _utils.assertNodeType)(
              "Identifier",
              "ArrayPattern",
              "ObjectPattern",
              "MemberExpression",
              "TSAsExpression",
              "TSTypeAssertion",
              "TSNonNullExpression"
            ),
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
    }),
    validate(parent, key) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      const match = /(\w+)\[(\d+)\]/.exec(key);
      if (!match) throw new Error("Internal Babel error: malformed key.");
      const [, listKey, index] = match;
      if (parent[listKey].length > +index + 1) {
        throw new TypeError(`RestElement must be last element of ${listKey}`);
      }
    },
  });
  defineType("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true,
      },
    },
  });
  defineType("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression"))
        ),
      },
    },
    aliases: ["Expression"],
  });
  defineType("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: { validate: (0, _utils.assertNodeType)("Expression") },
    },
  });
  defineType("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true,
      },
      consequent: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement"))
        ),
      },
    },
  });
  defineType("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: { validate: (0, _utils.assertNodeType)("Expression") },
      cases: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase"))
        ),
      },
    },
  });
  defineType("ThisExpression", { aliases: ["Expression"] });
  defineType("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: { validate: (0, _utils.assertNodeType)("Expression") },
    },
  });
  defineType("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: (0, _utils.chain)(
          (0, _utils.assertNodeType)("BlockStatement"),
          Object.assign(
            function (node) {
              if (!process.env.BABEL_TYPES_8_BREAKING) return;
              if (!node.handler && !node.finalizer) {
                throw new TypeError(
                  "TryStatement expects either a handler or finalizer, or both"
                );
              }
            },
            { oneOfNodeTypes: ["BlockStatement"] }
          )
        ),
      },
      handler: {
        optional: true,
        validate: (0, _utils.assertNodeType)("CatchClause"),
      },
      finalizer: {
        optional: true,
        validate: (0, _utils.assertNodeType)("BlockStatement"),
      },
    },
  });
  defineType("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: { default: true },
      argument: { validate: (0, _utils.assertNodeType)("Expression") },
      operator: {
        validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS),
      },
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"],
  });
  defineType("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: { default: false },
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING
          ? (0, _utils.assertNodeType)("Expression")
          : (0, _utils.assertNodeType)("Identifier", "MemberExpression"),
      },
      operator: {
        validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS),
      },
    },
    visitor: ["argument"],
    aliases: ["Expression"],
  });
  defineType("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      kind: { validate: (0, _utils.assertOneOf)("var", "let", "const") },
      declarations: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)("VariableDeclarator")
          )
        ),
      },
    },
    validate(parent, key, node) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      if (!(0, _is.default)("ForXStatement", parent, { left: node })) return;
      if (node.declarations.length !== 1) {
        throw new TypeError(
          `Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`
        );
      }
    },
  });
  defineType("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: (function () {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return (0, _utils.assertNodeType)("LVal");
          }
          const normal = (0, _utils.assertNodeType)(
            "Identifier",
            "ArrayPattern",
            "ObjectPattern"
          );
          const without = (0, _utils.assertNodeType)("Identifier");
          return function (node, key, val) {
            const validator = node.init ? normal : without;
            validator(node, key, val);
          };
        })(),
      },
      definite: {
        optional: true,
        validate: (0, _utils.assertValueType)("boolean"),
      },
      init: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression"),
      },
    },
  });
  defineType("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: { validate: (0, _utils.assertNodeType)("Expression") },
      body: { validate: (0, _utils.assertNodeType)("Statement") },
    },
  });
  defineType("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: { validate: (0, _utils.assertNodeType)("Expression") },
      body: { validate: (0, _utils.assertNodeType)("Statement") },
    },
  });
  defineType("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      left: {
        validate: (0, _utils.assertNodeType)(
          "Identifier",
          "ObjectPattern",
          "ArrayPattern",
          "MemberExpression",
          "TSAsExpression",
          "TSTypeAssertion",
          "TSNonNullExpression"
        ),
      },
      right: { validate: (0, _utils.assertNodeType)("Expression") },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
        ),
        optional: true,
      },
    }),
  });
  defineType("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      elements: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")
          )
        ),
      },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
        ),
        optional: true,
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
    }),
  });
  defineType("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: [
      "Scopable",
      "Function",
      "BlockParent",
      "FunctionParent",
      "Expression",
      "Pureish",
    ],
    fields: Object.assign(
      {},
      functionCommon(),
      functionTypeAnnotationCommon(),
      {
        expression: { validate: (0, _utils.assertValueType)("boolean") },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement", "Expression"),
        },
        predicate: {
          validate: (0, _utils.assertNodeType)(
            "DeclaredPredicate",
            "InferredPredicate"
          ),
          optional: true,
        },
      }
    ),
  });
  defineType("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)(
              "ClassMethod",
              "ClassPrivateMethod",
              "ClassProperty",
              "ClassPrivateProperty",
              "ClassAccessorProperty",
              "TSDeclareMethod",
              "TSIndexSignature",
              "StaticBlock"
            )
          )
        ),
      },
    },
  });
  defineType("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: [
      "id",
      "body",
      "superClass",
      "mixins",
      "typeParameters",
      "superTypeParameters",
      "implements",
      "decorators",
    ],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true,
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)(
          "TypeParameterDeclaration",
          "TSTypeParameterDeclaration",
          "Noop"
        ),
        optional: true,
      },
      body: { validate: (0, _utils.assertNodeType)("ClassBody") },
      superClass: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression"),
      },
      superTypeParameters: {
        validate: (0, _utils.assertNodeType)(
          "TypeParameterInstantiation",
          "TSTypeParameterInstantiation"
        ),
        optional: true,
      },
      implements: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)(
              "TSExpressionWithTypeArguments",
              "ClassImplements"
            )
          )
        ),
        optional: true,
      },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
        ),
        optional: true,
      },
      mixins: {
        validate: (0, _utils.assertNodeType)("InterfaceExtends"),
        optional: true,
      },
    },
  });
  defineType("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: { validate: (0, _utils.assertNodeType)("Identifier") },
      typeParameters: {
        validate: (0, _utils.assertNodeType)(
          "TypeParameterDeclaration",
          "TSTypeParameterDeclaration",
          "Noop"
        ),
        optional: true,
      },
      body: { validate: (0, _utils.assertNodeType)("ClassBody") },
      superClass: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression"),
      },
      superTypeParameters: {
        validate: (0, _utils.assertNodeType)(
          "TypeParameterInstantiation",
          "TSTypeParameterInstantiation"
        ),
        optional: true,
      },
      implements: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)(
              "TSExpressionWithTypeArguments",
              "ClassImplements"
            )
          )
        ),
        optional: true,
      },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
        ),
        optional: true,
      },
      mixins: {
        validate: (0, _utils.assertNodeType)("InterfaceExtends"),
        optional: true,
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      abstract: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
    },
    validate: (function () {
      const identifier = (0, _utils.assertNodeType)("Identifier");
      return function (parent, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
          identifier(node, "id", node.id);
        }
      };
    })(),
  });
  defineType("ExportAllDeclaration", {
    visitor: ["source"],
    aliases: [
      "Statement",
      "Declaration",
      "ModuleDeclaration",
      "ExportDeclaration",
    ],
    fields: {
      source: { validate: (0, _utils.assertNodeType)("StringLiteral") },
      exportKind: (0, _utils.validateOptional)(
        (0, _utils.assertOneOf)("type", "value")
      ),
      assertions: {
        optional: true,
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute"))
        ),
      },
    },
  });
  defineType("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: [
      "Statement",
      "Declaration",
      "ModuleDeclaration",
      "ExportDeclaration",
    ],
    fields: {
      declaration: {
        validate: (0, _utils.assertNodeType)(
          "TSDeclareFunction",
          "FunctionDeclaration",
          "ClassDeclaration",
          "Expression"
        ),
      },
      exportKind: (0, _utils.validateOptional)(
        (0, _utils.assertOneOf)("value")
      ),
    },
  });
  defineType("ExportNamedDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: [
      "Statement",
      "Declaration",
      "ModuleDeclaration",
      "ExportDeclaration",
    ],
    fields: {
      declaration: {
        optional: true,
        validate: (0, _utils.chain)(
          (0, _utils.assertNodeType)("Declaration"),
          Object.assign(
            function (node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING) return;
              if (val && node.specifiers.length) {
                throw new TypeError(
                  "Only declaration or specifiers is allowed on ExportNamedDeclaration"
                );
              }
            },
            { oneOfNodeTypes: ["Declaration"] }
          ),
          function (node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING) return;
            if (val && node.source) {
              throw new TypeError("Cannot export a declaration from a source");
            }
          }
        ),
      },
      assertions: {
        optional: true,
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute"))
        ),
      },
      specifiers: {
        default: [],
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (function () {
              const sourced = (0, _utils.assertNodeType)(
                "ExportSpecifier",
                "ExportDefaultSpecifier",
                "ExportNamespaceSpecifier"
              );
              const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
              if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;
              return function (node, key, val) {
                const validator = node.source ? sourced : sourceless;
                validator(node, key, val);
              };
            })()
          )
        ),
      },
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral"),
        optional: true,
      },
      exportKind: (0, _utils.validateOptional)(
        (0, _utils.assertOneOf)("type", "value")
      ),
    },
  });
  defineType("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: { validate: (0, _utils.assertNodeType)("Identifier") },
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral"),
      },
      exportKind: {
        validate: (0, _utils.assertOneOf)("type", "value"),
        optional: true,
      },
    },
  });
  defineType("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: [
      "Scopable",
      "Statement",
      "For",
      "BlockParent",
      "Loop",
      "ForXStatement",
    ],
    fields: {
      left: {
        validate: (function () {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
          }
          const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
          const lval = (0, _utils.assertNodeType)(
            "Identifier",
            "MemberExpression",
            "ArrayPattern",
            "ObjectPattern",
            "TSAsExpression",
            "TSTypeAssertion",
            "TSNonNullExpression"
          );
          return function (node, key, val) {
            if ((0, _is.default)("VariableDeclaration", val)) {
              declaration(node, key, val);
            } else {
              lval(node, key, val);
            }
          };
        })(),
      },
      right: { validate: (0, _utils.assertNodeType)("Expression") },
      body: { validate: (0, _utils.assertNodeType)("Statement") },
      await: { default: false },
    },
  });
  defineType("ImportDeclaration", {
    visitor: ["specifiers", "source"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration"],
    fields: {
      assertions: {
        optional: true,
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute"))
        ),
      },
      specifiers: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)(
              "ImportSpecifier",
              "ImportDefaultSpecifier",
              "ImportNamespaceSpecifier"
            )
          )
        ),
      },
      source: { validate: (0, _utils.assertNodeType)("StringLiteral") },
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
        optional: true,
      },
    },
  });
  defineType("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: { local: { validate: (0, _utils.assertNodeType)("Identifier") } },
  });
  defineType("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: { local: { validate: (0, _utils.assertNodeType)("Identifier") } },
  });
  defineType("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: { validate: (0, _utils.assertNodeType)("Identifier") },
      imported: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral"),
      },
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
        optional: true,
      },
    },
  });
  defineType("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: (0, _utils.chain)(
          (0, _utils.assertNodeType)("Identifier"),
          Object.assign(
            function (node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING) return;
              let property;
              switch (val.name) {
                case "function":
                  property = "sent";
                  break;
                case "new":
                  property = "target";
                  break;
                case "import":
                  property = "meta";
                  break;
              }
              if (
                !(0, _is.default)("Identifier", node.property, {
                  name: property,
                })
              ) {
                throw new TypeError("Unrecognised MetaProperty");
              }
            },
            { oneOfNodeTypes: ["Identifier"] }
          )
        ),
      },
      property: { validate: (0, _utils.assertNodeType)("Identifier") },
    },
  });
  const classMethodOrPropertyCommon = () => ({
    abstract: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true,
    },
    accessibility: {
      validate: (0, _utils.assertOneOf)("public", "private", "protected"),
      optional: true,
    },
    static: { default: false },
    override: { default: false },
    computed: { default: false },
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true,
    },
    key: {
      validate: (0, _utils.chain)(
        (function () {
          const normal = (0, _utils.assertNodeType)(
            "Identifier",
            "StringLiteral",
            "NumericLiteral"
          );
          const computed = (0, _utils.assertNodeType)("Expression");
          return function (node, key, val) {
            const validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
        })(),
        (0, _utils.assertNodeType)(
          "Identifier",
          "StringLiteral",
          "NumericLiteral",
          "BigIntLiteral",
          "Expression"
        )
      ),
    },
  });
  core$1.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
  const classMethodOrDeclareMethodCommon = () =>
    Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
      params: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)(
              "Identifier",
              "Pattern",
              "RestElement",
              "TSParameterProperty"
            )
          )
        ),
      },
      kind: {
        validate: (0, _utils.assertOneOf)(
          "get",
          "set",
          "method",
          "constructor"
        ),
        default: "method",
      },
      access: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("string"),
          (0, _utils.assertOneOf)("public", "private", "protected")
        ),
        optional: true,
      },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
        ),
        optional: true,
      },
    });
  core$1.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
  defineType("ClassMethod", {
    aliases: [
      "Function",
      "Scopable",
      "BlockParent",
      "FunctionParent",
      "Method",
    ],
    builder: [
      "kind",
      "key",
      "params",
      "body",
      "computed",
      "static",
      "generator",
      "async",
    ],
    visitor: [
      "key",
      "params",
      "body",
      "decorators",
      "returnType",
      "typeParameters",
    ],
    fields: Object.assign(
      {},
      classMethodOrDeclareMethodCommon(),
      functionTypeAnnotationCommon(),
      { body: { validate: (0, _utils.assertNodeType)("BlockStatement") } }
    ),
  });
  defineType("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      properties: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)("RestElement", "ObjectProperty")
          )
        ),
      },
    }),
  });
  defineType("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: { validate: (0, _utils.assertNodeType)("Expression") },
    },
  });
  defineType("Super", { aliases: ["Expression"] });
  defineType("TaggedTemplateExpression", {
    visitor: ["tag", "quasi", "typeParameters"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: { validate: (0, _utils.assertNodeType)("Expression") },
      quasi: { validate: (0, _utils.assertNodeType)("TemplateLiteral") },
      typeParameters: {
        validate: (0, _utils.assertNodeType)(
          "TypeParameterInstantiation",
          "TSTypeParameterInstantiation"
        ),
        optional: true,
      },
    },
  });
  defineType("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, _utils.chain)(
          (0, _utils.assertShape)({
            raw: { validate: (0, _utils.assertValueType)("string") },
            cooked: {
              validate: (0, _utils.assertValueType)("string"),
              optional: true,
            },
          }),
          function templateElementCookedValidator(node) {
            const raw = node.value.raw;
            let str,
              containsInvalid,
              unterminatedCalled = false;
            try {
              const error = () => {
                throw new Error();
              };
              ({ str: str, containsInvalid: containsInvalid } = (0,
              _helperStringParser.readStringContents)(
                "template",
                raw,
                0,
                0,
                0,
                {
                  unterminated() {
                    unterminatedCalled = true;
                  },
                  strictNumericEscape: error,
                  invalidEscapeSequence: error,
                  numericSeparatorInEscapeSequence: error,
                  unexpectedNumericSeparator: error,
                  invalidDigit: error,
                  invalidCodePoint: error,
                }
              ));
            } catch (_unused) {
              unterminatedCalled = true;
              containsInvalid = true;
            }
            if (!unterminatedCalled) throw new Error("Invalid raw");
            node.value.cooked = containsInvalid ? null : str;
          }
        ),
      },
      tail: { default: false },
    },
  });
  defineType("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement"))
        ),
      },
      expressions: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)("Expression", "TSType")
          ),
          function (node, key, val) {
            if (node.quasis.length !== val.length + 1) {
              throw new TypeError(
                `Number of ${node.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`
              );
            }
          }
        ),
      },
    },
  });
  defineType("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("boolean"),
          Object.assign(
            function (node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING) return;
              if (val && !node.argument) {
                throw new TypeError(
                  "Property delegate of YieldExpression cannot be true if there is no argument"
                );
              }
            },
            { type: "boolean" }
          )
        ),
        default: false,
      },
      argument: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression"),
      },
    },
  });
  defineType("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: { validate: (0, _utils.assertNodeType)("Expression") },
    },
  });
  defineType("Import", { aliases: ["Expression"] });
  defineType("BigIntLiteral", {
    builder: ["value"],
    fields: { value: { validate: (0, _utils.assertValueType)("string") } },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"],
  });
  defineType("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: { validate: (0, _utils.assertNodeType)("Identifier") },
    },
  });
  defineType("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: { validate: (0, _utils.assertNodeType)("Expression") },
      property: {
        validate: (function () {
          const normal = (0, _utils.assertNodeType)("Identifier");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator = Object.assign(
            function (node, key, val) {
              const validator = node.computed ? computed : normal;
              validator(node, key, val);
            },
            { oneOfNodeTypes: ["Expression", "Identifier"] }
          );
          return validator;
        })(),
      },
      computed: { default: false },
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING
          ? (0, _utils.assertValueType)("boolean")
          : (0, _utils.chain)(
              (0, _utils.assertValueType)("boolean"),
              (0, _utils.assertOptionalChainStart)()
            ),
      },
    },
  });
  defineType("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: { validate: (0, _utils.assertNodeType)("Expression") },
      arguments: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)(
              "Expression",
              "SpreadElement",
              "JSXNamespacedName",
              "ArgumentPlaceholder"
            )
          )
        ),
      },
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING
          ? (0, _utils.assertValueType)("boolean")
          : (0, _utils.chain)(
              (0, _utils.assertValueType)("boolean"),
              (0, _utils.assertOptionalChainStart)()
            ),
      },
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
        optional: true,
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true,
      },
    },
  });
  defineType("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: [
      "key",
      "value",
      "typeAnnotation",
      "decorators",
      "computed",
      "static",
    ],
    aliases: ["Property"],
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true,
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)(
          "TypeAnnotation",
          "TSTypeAnnotation",
          "Noop"
        ),
        optional: true,
      },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
        ),
        optional: true,
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true,
      },
    }),
  });
  defineType("ClassAccessorProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: [
      "key",
      "value",
      "typeAnnotation",
      "decorators",
      "computed",
      "static",
    ],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
      key: {
        validate: (0, _utils.chain)(
          (function () {
            const normal = (0, _utils.assertNodeType)(
              "Identifier",
              "StringLiteral",
              "NumericLiteral",
              "BigIntLiteral",
              "PrivateName"
            );
            const computed = (0, _utils.assertNodeType)("Expression");
            return function (node, key, val) {
              const validator = node.computed ? computed : normal;
              validator(node, key, val);
            };
          })(),
          (0, _utils.assertNodeType)(
            "Identifier",
            "StringLiteral",
            "NumericLiteral",
            "BigIntLiteral",
            "Expression",
            "PrivateName"
          )
        ),
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true,
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)(
          "TypeAnnotation",
          "TSTypeAnnotation",
          "Noop"
        ),
        optional: true,
      },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
        ),
        optional: true,
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true,
      },
    }),
  });
  defineType("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators", "typeAnnotation"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: { validate: (0, _utils.assertNodeType)("PrivateName") },
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true,
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)(
          "TypeAnnotation",
          "TSTypeAnnotation",
          "Noop"
        ),
        optional: true,
      },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
        ),
        optional: true,
      },
      static: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false,
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true,
      },
    },
  });
  defineType("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: [
      "key",
      "params",
      "body",
      "decorators",
      "returnType",
      "typeParameters",
    ],
    aliases: [
      "Function",
      "Scopable",
      "BlockParent",
      "FunctionParent",
      "Method",
      "Private",
    ],
    fields: Object.assign(
      {},
      classMethodOrDeclareMethodCommon(),
      functionTypeAnnotationCommon(),
      {
        kind: {
          validate: (0, _utils.assertOneOf)("get", "set", "method"),
          default: "method",
        },
        key: { validate: (0, _utils.assertNodeType)("PrivateName") },
        body: { validate: (0, _utils.assertNodeType)("BlockStatement") },
      }
    ),
  });
  defineType("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: { id: { validate: (0, _utils.assertNodeType)("Identifier") } },
  });
  defineType("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement"))
        ),
      },
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"],
  });
  return core$1;
}
var flow$2 = {};
var hasRequiredFlow$1;
function requireFlow$1() {
  if (hasRequiredFlow$1) return flow$2;
  hasRequiredFlow$1 = 1;
  var _utils = requireUtils$1();
  const defineType = (0, _utils.defineAliasedType)("Flow");
  const defineInterfaceishType = (name) => {
    defineType(name, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: [
        "id",
        "typeParameters",
        "extends",
        "mixins",
        "implements",
        "body",
      ],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)(
          "TypeParameterDeclaration"
        ),
        extends: (0, _utils.validateOptional)(
          (0, _utils.arrayOfType)("InterfaceExtends")
        ),
        mixins: (0, _utils.validateOptional)(
          (0, _utils.arrayOfType)("InterfaceExtends")
        ),
        implements: (0, _utils.validateOptional)(
          (0, _utils.arrayOfType)("ClassImplements")
        ),
        body: (0, _utils.validateType)("ObjectTypeAnnotation"),
      },
    });
  };
  defineType("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"],
  });
  defineType("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: { elementType: (0, _utils.validateType)("FlowType") },
  });
  defineType("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"],
  });
  defineType("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    },
  });
  defineType("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"],
  });
  defineType("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TypeParameterInstantiation"
      ),
    },
  });
  defineInterfaceishType("DeclareClass");
  defineType("DeclareFunction", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      predicate: (0, _utils.validateOptionalType)("DeclaredPredicate"),
    },
  });
  defineInterfaceishType("DeclareInterface");
  defineType("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
      body: (0, _utils.validateType)("BlockStatement"),
      kind: (0, _utils.validateOptional)(
        (0, _utils.assertOneOf)("CommonJS", "ES")
      ),
    },
  });
  defineType("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: { typeAnnotation: (0, _utils.validateType)("TypeAnnotation") },
  });
  defineType("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TypeParameterDeclaration"
      ),
      right: (0, _utils.validateType)("FlowType"),
    },
  });
  defineType("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TypeParameterDeclaration"
      ),
      supertype: (0, _utils.validateOptionalType)("FlowType"),
      impltype: (0, _utils.validateOptionalType)("FlowType"),
    },
  });
  defineType("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: { id: (0, _utils.validateType)("Identifier") },
  });
  defineType("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: (0, _utils.validateOptionalType)("Flow"),
      specifiers: (0, _utils.validateOptional)(
        (0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])
      ),
      source: (0, _utils.validateOptionalType)("StringLiteral"),
      default: (0, _utils.validateOptional)(
        (0, _utils.assertValueType)("boolean")
      ),
    },
  });
  defineType("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: (0, _utils.validateType)("StringLiteral"),
      exportKind: (0, _utils.validateOptional)(
        (0, _utils.assertOneOf)("type", "value")
      ),
    },
  });
  defineType("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: { value: (0, _utils.validateType)("Flow") },
  });
  defineType("ExistsTypeAnnotation", { aliases: ["FlowType"] });
  defineType("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, _utils.validateOptionalType)(
        "TypeParameterDeclaration"
      ),
      params: (0, _utils.validate)(
        (0, _utils.arrayOfType)("FunctionTypeParam")
      ),
      rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
      this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, _utils.validateType)("FlowType"),
    },
  });
  defineType("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, _utils.validateOptionalType)("Identifier"),
      typeAnnotation: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validateOptional)(
        (0, _utils.assertValueType)("boolean")
      ),
    },
  });
  defineType("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, _utils.validateOptionalType)(
        "TypeParameterInstantiation"
      ),
    },
  });
  defineType("InferredPredicate", { aliases: ["FlowPredicate"] });
  defineType("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, _utils.validateOptionalType)(
        "TypeParameterInstantiation"
      ),
    },
  });
  defineInterfaceishType("InterfaceDeclaration");
  defineType("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, _utils.validateOptional)(
        (0, _utils.arrayOfType)("InterfaceExtends")
      ),
      body: (0, _utils.validateType)("ObjectTypeAnnotation"),
    },
  });
  defineType("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType")),
    },
  });
  defineType("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"],
  });
  defineType("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"],
  });
  defineType("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: { typeAnnotation: (0, _utils.validateType)("FlowType") },
  });
  defineType("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("number")),
    },
  });
  defineType("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"],
  });
  defineType("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: [
      "properties",
      "indexers",
      "callProperties",
      "internalSlots",
      "exact",
    ],
    fields: {
      properties: (0, _utils.validate)(
        (0, _utils.arrayOfType)([
          "ObjectTypeProperty",
          "ObjectTypeSpreadProperty",
        ])
      ),
      indexers: {
        validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
        optional: true,
        default: [],
      },
      callProperties: {
        validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
        optional: true,
        default: [],
      },
      internalSlots: {
        validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
        optional: true,
        default: [],
      },
      exact: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false,
      },
      inexact: (0, _utils.validateOptional)(
        (0, _utils.assertValueType)("boolean")
      ),
    },
  });
  defineType("ObjectTypeInternalSlot", {
    visitor: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      value: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      method: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    },
  });
  defineType("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, _utils.validateType)("FlowType"),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    },
  });
  defineType("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, _utils.validateOptionalType)("Identifier"),
      key: (0, _utils.validateType)("FlowType"),
      value: (0, _utils.validateType)("FlowType"),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      variance: (0, _utils.validateOptionalType)("Variance"),
    },
  });
  defineType("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
      value: (0, _utils.validateType)("FlowType"),
      kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      variance: (0, _utils.validateOptionalType)("Variance"),
      method: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    },
  });
  defineType("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: { argument: (0, _utils.validateType)("FlowType") },
  });
  defineType("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TypeParameterDeclaration"
      ),
      supertype: (0, _utils.validateOptionalType)("FlowType"),
      impltype: (0, _utils.validateType)("FlowType"),
    },
  });
  defineType("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      qualification: (0, _utils.validateType)([
        "Identifier",
        "QualifiedTypeIdentifier",
      ]),
    },
  });
  defineType("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("string")),
    },
  });
  defineType("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"],
  });
  defineType("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"],
  });
  defineType("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"],
  });
  defineType("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType")),
    },
  });
  defineType("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: { argument: (0, _utils.validateType)("FlowType") },
  });
  defineType("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TypeParameterDeclaration"
      ),
      right: (0, _utils.validateType)("FlowType"),
    },
  });
  defineType("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: { typeAnnotation: (0, _utils.validateType)("FlowType") },
  });
  defineType("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeAnnotation: (0, _utils.validateType)("TypeAnnotation"),
    },
  });
  defineType("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
      bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
      default: (0, _utils.validateOptionalType)("FlowType"),
      variance: (0, _utils.validateOptionalType)("Variance"),
    },
  });
  defineType("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter")),
    },
  });
  defineType("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType")),
    },
  });
  defineType("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType")),
    },
  });
  defineType("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus")),
    },
  });
  defineType("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"],
  });
  defineType("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      body: (0, _utils.validateType)([
        "EnumBooleanBody",
        "EnumNumberBody",
        "EnumStringBody",
        "EnumSymbolBody",
      ]),
    },
  });
  defineType("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)(
        (0, _utils.assertValueType)("boolean")
      ),
      members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, _utils.validate)(
        (0, _utils.assertValueType)("boolean")
      ),
    },
  });
  defineType("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)(
        (0, _utils.assertValueType)("boolean")
      ),
      members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, _utils.validate)(
        (0, _utils.assertValueType)("boolean")
      ),
    },
  });
  defineType("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)(
        (0, _utils.assertValueType)("boolean")
      ),
      members: (0, _utils.validateArrayOfType)([
        "EnumStringMember",
        "EnumDefaultedMember",
      ]),
      hasUnknownMembers: (0, _utils.validate)(
        (0, _utils.assertValueType)("boolean")
      ),
    },
  });
  defineType("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, _utils.validate)(
        (0, _utils.assertValueType)("boolean")
      ),
    },
  });
  defineType("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("BooleanLiteral"),
    },
  });
  defineType("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("NumericLiteral"),
    },
  });
  defineType("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("StringLiteral"),
    },
  });
  defineType("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: { id: (0, _utils.validateType)("Identifier") },
  });
  defineType("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, _utils.validateType)("FlowType"),
      indexType: (0, _utils.validateType)("FlowType"),
    },
  });
  defineType("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, _utils.validateType)("FlowType"),
      indexType: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    },
  });
  return flow$2;
}
var jsx$2 = {};
var hasRequiredJsx$1;
function requireJsx$1() {
  if (hasRequiredJsx$1) return jsx$2;
  hasRequiredJsx$1 = 1;
  var _utils = requireUtils$1();
  const defineType = (0, _utils.defineAliasedType)("JSX");
  defineType("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)(
          "JSXIdentifier",
          "JSXNamespacedName"
        ),
      },
      value: {
        optional: true,
        validate: (0, _utils.assertNodeType)(
          "JSXElement",
          "JSXFragment",
          "StringLiteral",
          "JSXExpressionContainer"
        ),
      },
    },
  });
  defineType("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)(
          "JSXIdentifier",
          "JSXMemberExpression",
          "JSXNamespacedName"
        ),
      },
    },
  });
  defineType("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign(
      {
        openingElement: {
          validate: (0, _utils.assertNodeType)("JSXOpeningElement"),
        },
        closingElement: {
          optional: true,
          validate: (0, _utils.assertNodeType)("JSXClosingElement"),
        },
        children: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)("array"),
            (0, _utils.assertEach)(
              (0, _utils.assertNodeType)(
                "JSXText",
                "JSXExpressionContainer",
                "JSXSpreadChild",
                "JSXElement",
                "JSXFragment"
              )
            )
          ),
        },
      },
      {
        selfClosing: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true,
        },
      }
    ),
  });
  defineType("JSXEmptyExpression", {});
  defineType("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)(
          "Expression",
          "JSXEmptyExpression"
        ),
      },
    },
  });
  defineType("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: { validate: (0, _utils.assertNodeType)("Expression") },
    },
  });
  defineType("JSXIdentifier", {
    builder: ["name"],
    fields: { name: { validate: (0, _utils.assertValueType)("string") } },
  });
  defineType("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)(
          "JSXMemberExpression",
          "JSXIdentifier"
        ),
      },
      property: { validate: (0, _utils.assertNodeType)("JSXIdentifier") },
    },
  });
  defineType("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: { validate: (0, _utils.assertNodeType)("JSXIdentifier") },
      name: { validate: (0, _utils.assertNodeType)("JSXIdentifier") },
    },
  });
  defineType("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)(
          "JSXIdentifier",
          "JSXMemberExpression",
          "JSXNamespacedName"
        ),
      },
      selfClosing: { default: false },
      attributes: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")
          )
        ),
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)(
          "TypeParameterInstantiation",
          "TSTypeParameterInstantiation"
        ),
        optional: true,
      },
    },
  });
  defineType("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: { validate: (0, _utils.assertNodeType)("Expression") },
    },
  });
  defineType("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: { value: { validate: (0, _utils.assertValueType)("string") } },
  });
  defineType("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, _utils.assertNodeType)("JSXOpeningFragment"),
      },
      closingFragment: {
        validate: (0, _utils.assertNodeType)("JSXClosingFragment"),
      },
      children: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)(
              "JSXText",
              "JSXExpressionContainer",
              "JSXSpreadChild",
              "JSXElement",
              "JSXFragment"
            )
          )
        ),
      },
    },
  });
  defineType("JSXOpeningFragment", { aliases: ["Immutable"] });
  defineType("JSXClosingFragment", { aliases: ["Immutable"] });
  return jsx$2;
}
var misc$1 = {};
var placeholders$1 = {};
var hasRequiredPlaceholders$1;
function requirePlaceholders$1() {
  if (hasRequiredPlaceholders$1) return placeholders$1;
  hasRequiredPlaceholders$1 = 1;
  Object.defineProperty(placeholders$1, "__esModule", { value: true });
  placeholders$1.PLACEHOLDERS_FLIPPED_ALIAS =
    placeholders$1.PLACEHOLDERS_ALIAS =
    placeholders$1.PLACEHOLDERS =
      void 0;
  var _utils = requireUtils$1();
  const PLACEHOLDERS = [
    "Identifier",
    "StringLiteral",
    "Expression",
    "Statement",
    "Declaration",
    "BlockStatement",
    "ClassBody",
    "Pattern",
  ];
  placeholders$1.PLACEHOLDERS = PLACEHOLDERS;
  const PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"],
  };
  placeholders$1.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;
  for (const type of PLACEHOLDERS) {
    const alias = _utils.ALIAS_KEYS[type];
    if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;
  }
  const PLACEHOLDERS_FLIPPED_ALIAS = {};
  placeholders$1.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;
  Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
    PLACEHOLDERS_ALIAS[type].forEach((alias) => {
      if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
        PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
      }
      PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
    });
  });
  return placeholders$1;
}
var hasRequiredMisc$1;
function requireMisc$1() {
  if (hasRequiredMisc$1) return misc$1;
  hasRequiredMisc$1 = 1;
  var _utils = requireUtils$1();
  var _placeholders = requirePlaceholders$1();
  const defineType = (0, _utils.defineAliasedType)("Miscellaneous");
  {
    defineType("Noop", { visitor: [] });
  }
  defineType("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: { validate: (0, _utils.assertNodeType)("Identifier") },
      expectedNode: {
        validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS),
      },
    },
  });
  defineType("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: { name: { validate: (0, _utils.assertValueType)("string") } },
  });
  return misc$1;
}
var experimental$1 = {};
var hasRequiredExperimental$1;
function requireExperimental$1() {
  if (hasRequiredExperimental$1) return experimental$1;
  hasRequiredExperimental$1 = 1;
  var _utils = requireUtils$1();
  (0, _utils.default)("ArgumentPlaceholder", {});
  (0, _utils.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: !process.env.BABEL_TYPES_8_BREAKING
      ? {
          object: {
            validate: Object.assign(() => {}, {
              oneOfNodeTypes: ["Expression"],
            }),
          },
          callee: {
            validate: Object.assign(() => {}, {
              oneOfNodeTypes: ["Expression"],
            }),
          },
        }
      : {
          object: { validate: (0, _utils.assertNodeType)("Expression") },
          callee: { validate: (0, _utils.assertNodeType)("Expression") },
        },
  });
  (0, _utils.default)("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral"),
      },
      value: { validate: (0, _utils.assertNodeType)("StringLiteral") },
    },
  });
  (0, _utils.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: { validate: (0, _utils.assertNodeType)("Expression") },
    },
  });
  (0, _utils.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: { validate: (0, _utils.assertNodeType)("BlockStatement") },
      async: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false,
      },
    },
  });
  (0, _utils.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: { validate: (0, _utils.assertNodeType)("Identifier") },
    },
  });
  (0, _utils.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)("ObjectProperty", "SpreadElement")
          )
        ),
      },
    },
  });
  (0, _utils.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)("Expression", "SpreadElement")
          )
        ),
        default: [],
      },
    },
    visitor: ["elements"],
    aliases: ["Expression"],
  });
  (0, _utils.default)("DecimalLiteral", {
    builder: ["value"],
    fields: { value: { validate: (0, _utils.assertValueType)("string") } },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"],
  });
  (0, _utils.default)("ModuleExpression", {
    visitor: ["body"],
    fields: { body: { validate: (0, _utils.assertNodeType)("Program") } },
    aliases: ["Expression"],
  });
  (0, _utils.default)("TopicReference", { aliases: ["Expression"] });
  (0, _utils.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: { validate: (0, _utils.assertNodeType)("Expression") },
    },
    aliases: ["Expression"],
  });
  (0, _utils.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: { callee: { validate: (0, _utils.assertNodeType)("Expression") } },
    aliases: ["Expression"],
  });
  (0, _utils.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"],
  });
  return experimental$1;
}
var typescript$2 = {};
var hasRequiredTypescript$1;
function requireTypescript$1() {
  if (hasRequiredTypescript$1) return typescript$2;
  hasRequiredTypescript$1 = 1;
  var _utils = requireUtils$1();
  var _core = requireCore$1();
  var _is = requireIs$1();
  const defineType = (0, _utils.defineAliasedType)("TypeScript");
  const bool = (0, _utils.assertValueType)("boolean");
  const tSFunctionTypeAnnotationCommon = () => ({
    returnType: {
      validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: true,
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)(
        "TSTypeParameterDeclaration",
        "Noop"
      ),
      optional: true,
    },
  });
  defineType("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true,
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      parameter: {
        validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern"),
      },
      override: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
        ),
        optional: true,
      },
    },
  });
  defineType("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign(
      {},
      (0, _core.functionDeclarationCommon)(),
      tSFunctionTypeAnnotationCommon()
    ),
  });
  defineType("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign(
      {},
      (0, _core.classMethodOrDeclareMethodCommon)(),
      tSFunctionTypeAnnotationCommon()
    ),
  });
  defineType("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, _utils.validateType)("TSEntityName"),
      right: (0, _utils.validateType)("Identifier"),
    },
  });
  const signatureDeclarationCommon = () => ({
    typeParameters: (0, _utils.validateOptionalType)(
      "TSTypeParameterDeclaration"
    ),
    ["parameters"]: (0, _utils.validateArrayOfType)([
      "Identifier",
      "RestElement",
    ]),
    ["typeAnnotation"]: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
  });
  const callConstructSignatureDeclaration = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: signatureDeclarationCommon(),
  };
  defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
  defineType(
    "TSConstructSignatureDeclaration",
    callConstructSignatureDeclaration
  );
  const namedTypeElementCommon = () => ({
    key: (0, _utils.validateType)("Expression"),
    computed: { default: false },
    optional: (0, _utils.validateOptional)(bool),
  });
  defineType("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation", "initializer"],
    fields: Object.assign({}, namedTypeElementCommon(), {
      readonly: (0, _utils.validateOptional)(bool),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
      initializer: (0, _utils.validateOptionalType)("Expression"),
      kind: { validate: (0, _utils.assertOneOf)("get", "set") },
    }),
  });
  defineType("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign(
      {},
      signatureDeclarationCommon(),
      namedTypeElementCommon(),
      { kind: { validate: (0, _utils.assertOneOf)("method", "get", "set") } }
    ),
  });
  defineType("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, _utils.validateOptional)(bool),
      static: (0, _utils.validateOptional)(bool),
      parameters: (0, _utils.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
    },
  });
  const tsKeywordTypes = [
    "TSAnyKeyword",
    "TSBooleanKeyword",
    "TSBigIntKeyword",
    "TSIntrinsicKeyword",
    "TSNeverKeyword",
    "TSNullKeyword",
    "TSNumberKeyword",
    "TSObjectKeyword",
    "TSStringKeyword",
    "TSSymbolKeyword",
    "TSUndefinedKeyword",
    "TSUnknownKeyword",
    "TSVoidKeyword",
  ];
  for (const type of tsKeywordTypes) {
    defineType(type, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {},
    });
  }
  defineType("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {},
  });
  const fnOrCtrBase = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
  };
  defineType(
    "TSFunctionType",
    Object.assign({}, fnOrCtrBase, { fields: signatureDeclarationCommon() })
  );
  defineType(
    "TSConstructorType",
    Object.assign({}, fnOrCtrBase, {
      fields: Object.assign({}, signatureDeclarationCommon(), {
        abstract: (0, _utils.validateOptional)(bool),
      }),
    })
  );
  defineType("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, _utils.validateType)("TSEntityName"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TSTypeParameterInstantiation"
      ),
    },
  });
  defineType("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, _utils.validateOptional)(bool),
    },
  });
  defineType("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"]),
      typeParameters: (0, _utils.validateOptionalType)(
        "TSTypeParameterInstantiation"
      ),
    },
  });
  defineType("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: { members: (0, _utils.validateArrayOfType)("TSTypeElement") },
  });
  defineType("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: { elementType: (0, _utils.validateType)("TSType") },
  });
  defineType("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, _utils.validateArrayOfType)([
        "TSType",
        "TSNamedTupleMember",
      ]),
    },
  });
  defineType("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: { typeAnnotation: (0, _utils.validateType)("TSType") },
  });
  defineType("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: { typeAnnotation: (0, _utils.validateType)("TSType") },
  });
  defineType("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, _utils.validateType)("Identifier"),
      optional: { validate: bool, default: false },
      elementType: (0, _utils.validateType)("TSType"),
    },
  });
  const unionOrIntersection = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: { types: (0, _utils.validateArrayOfType)("TSType") },
  };
  defineType("TSUnionType", unionOrIntersection);
  defineType("TSIntersectionType", unionOrIntersection);
  defineType("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, _utils.validateType)("TSType"),
      extendsType: (0, _utils.validateType)("TSType"),
      trueType: (0, _utils.validateType)("TSType"),
      falseType: (0, _utils.validateType)("TSType"),
    },
  });
  defineType("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: { typeParameter: (0, _utils.validateType)("TSTypeParameter") },
  });
  defineType("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: { typeAnnotation: (0, _utils.validateType)("TSType") },
  });
  defineType("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
      typeAnnotation: (0, _utils.validateType)("TSType"),
    },
  });
  defineType("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, _utils.validateType)("TSType"),
      indexType: (0, _utils.validateType)("TSType"),
    },
  });
  defineType("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation", "nameType"],
    fields: {
      readonly: (0, _utils.validateOptional)(
        (0, _utils.assertOneOf)(true, false, "+", "-")
      ),
      typeParameter: (0, _utils.validateType)("TSTypeParameter"),
      optional: (0, _utils.validateOptional)(
        (0, _utils.assertOneOf)(true, false, "+", "-")
      ),
      typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
      nameType: (0, _utils.validateOptionalType)("TSType"),
    },
  });
  defineType("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: (function () {
          const unaryExpression = (0, _utils.assertNodeType)(
            "NumericLiteral",
            "BigIntLiteral"
          );
          const unaryOperator = (0, _utils.assertOneOf)("-");
          const literal = (0, _utils.assertNodeType)(
            "NumericLiteral",
            "StringLiteral",
            "BooleanLiteral",
            "BigIntLiteral",
            "TemplateLiteral"
          );
          function validator(parent, key, node) {
            if ((0, _is.default)("UnaryExpression", node)) {
              unaryOperator(node, "operator", node.operator);
              unaryExpression(node, "argument", node.argument);
            } else {
              literal(parent, key, node);
            }
          }
          validator.oneOfNodeTypes = [
            "NumericLiteral",
            "StringLiteral",
            "BooleanLiteral",
            "BigIntLiteral",
            "TemplateLiteral",
            "UnaryExpression",
          ];
          return validator;
        })(),
      },
    },
  });
  defineType("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, _utils.validateType)("TSEntityName"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TSTypeParameterInstantiation"
      ),
    },
  });
  defineType("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TSTypeParameterDeclaration"
      ),
      extends: (0, _utils.validateOptional)(
        (0, _utils.arrayOfType)("TSExpressionWithTypeArguments")
      ),
      body: (0, _utils.validateType)("TSInterfaceBody"),
    },
  });
  defineType("TSInterfaceBody", {
    visitor: ["body"],
    fields: { body: (0, _utils.validateArrayOfType)("TSTypeElement") },
  });
  defineType("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TSTypeParameterDeclaration"
      ),
      typeAnnotation: (0, _utils.validateType)("TSType"),
    },
  });
  defineType("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TSTypeParameterInstantiation"
      ),
    },
  });
  defineType("TSAsExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeAnnotation: (0, _utils.validateType)("TSType"),
    },
  });
  defineType("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType"),
      expression: (0, _utils.validateType)("Expression"),
    },
  });
  defineType("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      const: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      members: (0, _utils.validateArrayOfType)("TSEnumMember"),
      initializer: (0, _utils.validateOptionalType)("Expression"),
    },
  });
  defineType("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
      initializer: (0, _utils.validateOptionalType)("Expression"),
    },
  });
  defineType("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      global: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
      body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"]),
    },
  });
  defineType("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent"],
    visitor: ["body"],
    fields: { body: (0, _utils.validateArrayOfType)("Statement") },
  });
  defineType("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: (0, _utils.validateType)("StringLiteral"),
      qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TSTypeParameterInstantiation"
      ),
    },
  });
  defineType("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: (0, _utils.validate)(bool),
      id: (0, _utils.validateType)("Identifier"),
      moduleReference: (0, _utils.validateType)([
        "TSEntityName",
        "TSExternalModuleReference",
      ]),
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "value"),
        optional: true,
      },
    },
  });
  defineType("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: { expression: (0, _utils.validateType)("StringLiteral") },
  });
  defineType("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: { expression: (0, _utils.validateType)("Expression") },
  });
  defineType("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: { expression: (0, _utils.validateType)("Expression") },
  });
  defineType("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: { id: (0, _utils.validateType)("Identifier") },
  });
  defineType("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: { validate: (0, _utils.assertNodeType)("TSType") },
    },
  });
  defineType("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType"))
        ),
      },
    },
  });
  defineType("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter"))
        ),
      },
    },
  });
  defineType("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: { validate: (0, _utils.assertValueType)("string") },
      in: { validate: (0, _utils.assertValueType)("boolean"), optional: true },
      out: { validate: (0, _utils.assertValueType)("boolean"), optional: true },
      constraint: {
        validate: (0, _utils.assertNodeType)("TSType"),
        optional: true,
      },
      default: {
        validate: (0, _utils.assertNodeType)("TSType"),
        optional: true,
      },
    },
  });
  return typescript$2;
}
var hasRequiredDefinitions$1;
function requireDefinitions$1() {
  if (hasRequiredDefinitions$1) return definitions$1;
  hasRequiredDefinitions$1 = 1;
  (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "ALIAS_KEYS", {
      enumerable: true,
      get: function () {
        return _utils.ALIAS_KEYS;
      },
    });
    Object.defineProperty(exports, "BUILDER_KEYS", {
      enumerable: true,
      get: function () {
        return _utils.BUILDER_KEYS;
      },
    });
    Object.defineProperty(exports, "DEPRECATED_KEYS", {
      enumerable: true,
      get: function () {
        return _utils.DEPRECATED_KEYS;
      },
    });
    Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
      enumerable: true,
      get: function () {
        return _utils.FLIPPED_ALIAS_KEYS;
      },
    });
    Object.defineProperty(exports, "NODE_FIELDS", {
      enumerable: true,
      get: function () {
        return _utils.NODE_FIELDS;
      },
    });
    Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
      enumerable: true,
      get: function () {
        return _utils.NODE_PARENT_VALIDATIONS;
      },
    });
    Object.defineProperty(exports, "PLACEHOLDERS", {
      enumerable: true,
      get: function () {
        return _placeholders.PLACEHOLDERS;
      },
    });
    Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
      enumerable: true,
      get: function () {
        return _placeholders.PLACEHOLDERS_ALIAS;
      },
    });
    Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
      enumerable: true,
      get: function () {
        return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
      },
    });
    exports.TYPES = void 0;
    Object.defineProperty(exports, "VISITOR_KEYS", {
      enumerable: true,
      get: function () {
        return _utils.VISITOR_KEYS;
      },
    });
    var _toFastProperties = toFastProperties;
    requireCore$1();
    requireFlow$1();
    requireJsx$1();
    requireMisc$1();
    requireExperimental$1();
    requireTypescript$1();
    var _utils = requireUtils$1();
    var _placeholders = requirePlaceholders$1();
    _toFastProperties(_utils.VISITOR_KEYS);
    _toFastProperties(_utils.ALIAS_KEYS);
    _toFastProperties(_utils.FLIPPED_ALIAS_KEYS);
    _toFastProperties(_utils.NODE_FIELDS);
    _toFastProperties(_utils.BUILDER_KEYS);
    _toFastProperties(_utils.DEPRECATED_KEYS);
    _toFastProperties(_placeholders.PLACEHOLDERS_ALIAS);
    _toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
    const TYPES = [].concat(
      Object.keys(_utils.VISITOR_KEYS),
      Object.keys(_utils.FLIPPED_ALIAS_KEYS),
      Object.keys(_utils.DEPRECATED_KEYS)
    );
    exports.TYPES = TYPES;
  })(definitions$1);
  return definitions$1;
}
var hasRequiredValidate$1;
function requireValidate$1() {
  if (hasRequiredValidate$1) return validate$2;
  hasRequiredValidate$1 = 1;
  Object.defineProperty(validate$2, "__esModule", { value: true });
  validate$2.default = validate;
  validate$2.validateChild = validateChild;
  validate$2.validateField = validateField;
  var _definitions = requireDefinitions$1();
  function validate(node, key, val) {
    if (!node) return;
    const fields = _definitions.NODE_FIELDS[node.type];
    if (!fields) return;
    const field = fields[key];
    validateField(node, key, val, field);
    validateChild(node, key, val);
  }
  function validateField(node, key, val, field) {
    if (!(field != null && field.validate)) return;
    if (field.optional && val == null) return;
    field.validate(node, key, val);
  }
  function validateChild(node, key, val) {
    if (val == null) return;
    const validate = _definitions.NODE_PARENT_VALIDATIONS[val.type];
    if (!validate) return;
    validate(node, key, val);
  }
  return validate$2;
}
var hasRequiredValidateNode$1;
function requireValidateNode$1() {
  if (hasRequiredValidateNode$1) return validateNode$1;
  hasRequiredValidateNode$1 = 1;
  Object.defineProperty(validateNode$1, "__esModule", { value: true });
  validateNode$1.default = validateNode;
  var _validate = requireValidate$1();
  var _ = requireLib$2();
  function validateNode(node) {
    const keys = _.BUILDER_KEYS[node.type];
    for (const key of keys) {
      (0, _validate.default)(node, key, node[key]);
    }
    return node;
  }
  return validateNode$1;
}
var hasRequiredGenerated$5;
function requireGenerated$5() {
  if (hasRequiredGenerated$5) return generated$8;
  hasRequiredGenerated$5 = 1;
  Object.defineProperty(generated$8, "__esModule", { value: true });
  generated$8.anyTypeAnnotation = anyTypeAnnotation;
  generated$8.argumentPlaceholder = argumentPlaceholder;
  generated$8.arrayExpression = arrayExpression;
  generated$8.arrayPattern = arrayPattern;
  generated$8.arrayTypeAnnotation = arrayTypeAnnotation;
  generated$8.arrowFunctionExpression = arrowFunctionExpression;
  generated$8.assignmentExpression = assignmentExpression;
  generated$8.assignmentPattern = assignmentPattern;
  generated$8.awaitExpression = awaitExpression;
  generated$8.bigIntLiteral = bigIntLiteral;
  generated$8.binaryExpression = binaryExpression;
  generated$8.bindExpression = bindExpression;
  generated$8.blockStatement = blockStatement;
  generated$8.booleanLiteral = booleanLiteral;
  generated$8.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
  generated$8.booleanTypeAnnotation = booleanTypeAnnotation;
  generated$8.breakStatement = breakStatement;
  generated$8.callExpression = callExpression;
  generated$8.catchClause = catchClause;
  generated$8.classAccessorProperty = classAccessorProperty;
  generated$8.classBody = classBody;
  generated$8.classDeclaration = classDeclaration;
  generated$8.classExpression = classExpression;
  generated$8.classImplements = classImplements;
  generated$8.classMethod = classMethod;
  generated$8.classPrivateMethod = classPrivateMethod;
  generated$8.classPrivateProperty = classPrivateProperty;
  generated$8.classProperty = classProperty;
  generated$8.conditionalExpression = conditionalExpression;
  generated$8.continueStatement = continueStatement;
  generated$8.debuggerStatement = debuggerStatement;
  generated$8.decimalLiteral = decimalLiteral;
  generated$8.declareClass = declareClass;
  generated$8.declareExportAllDeclaration = declareExportAllDeclaration;
  generated$8.declareExportDeclaration = declareExportDeclaration;
  generated$8.declareFunction = declareFunction;
  generated$8.declareInterface = declareInterface;
  generated$8.declareModule = declareModule;
  generated$8.declareModuleExports = declareModuleExports;
  generated$8.declareOpaqueType = declareOpaqueType;
  generated$8.declareTypeAlias = declareTypeAlias;
  generated$8.declareVariable = declareVariable;
  generated$8.declaredPredicate = declaredPredicate;
  generated$8.decorator = decorator;
  generated$8.directive = directive;
  generated$8.directiveLiteral = directiveLiteral;
  generated$8.doExpression = doExpression;
  generated$8.doWhileStatement = doWhileStatement;
  generated$8.emptyStatement = emptyStatement;
  generated$8.emptyTypeAnnotation = emptyTypeAnnotation;
  generated$8.enumBooleanBody = enumBooleanBody;
  generated$8.enumBooleanMember = enumBooleanMember;
  generated$8.enumDeclaration = enumDeclaration;
  generated$8.enumDefaultedMember = enumDefaultedMember;
  generated$8.enumNumberBody = enumNumberBody;
  generated$8.enumNumberMember = enumNumberMember;
  generated$8.enumStringBody = enumStringBody;
  generated$8.enumStringMember = enumStringMember;
  generated$8.enumSymbolBody = enumSymbolBody;
  generated$8.existsTypeAnnotation = existsTypeAnnotation;
  generated$8.exportAllDeclaration = exportAllDeclaration;
  generated$8.exportDefaultDeclaration = exportDefaultDeclaration;
  generated$8.exportDefaultSpecifier = exportDefaultSpecifier;
  generated$8.exportNamedDeclaration = exportNamedDeclaration;
  generated$8.exportNamespaceSpecifier = exportNamespaceSpecifier;
  generated$8.exportSpecifier = exportSpecifier;
  generated$8.expressionStatement = expressionStatement;
  generated$8.file = file;
  generated$8.forInStatement = forInStatement;
  generated$8.forOfStatement = forOfStatement;
  generated$8.forStatement = forStatement;
  generated$8.functionDeclaration = functionDeclaration;
  generated$8.functionExpression = functionExpression;
  generated$8.functionTypeAnnotation = functionTypeAnnotation;
  generated$8.functionTypeParam = functionTypeParam;
  generated$8.genericTypeAnnotation = genericTypeAnnotation;
  generated$8.identifier = identifier;
  generated$8.ifStatement = ifStatement;
  generated$8.import = _import;
  generated$8.importAttribute = importAttribute;
  generated$8.importDeclaration = importDeclaration;
  generated$8.importDefaultSpecifier = importDefaultSpecifier;
  generated$8.importNamespaceSpecifier = importNamespaceSpecifier;
  generated$8.importSpecifier = importSpecifier;
  generated$8.indexedAccessType = indexedAccessType;
  generated$8.inferredPredicate = inferredPredicate;
  generated$8.interfaceDeclaration = interfaceDeclaration;
  generated$8.interfaceExtends = interfaceExtends;
  generated$8.interfaceTypeAnnotation = interfaceTypeAnnotation;
  generated$8.interpreterDirective = interpreterDirective;
  generated$8.intersectionTypeAnnotation = intersectionTypeAnnotation;
  generated$8.jSXAttribute = generated$8.jsxAttribute = jsxAttribute;
  generated$8.jSXClosingElement = generated$8.jsxClosingElement =
    jsxClosingElement;
  generated$8.jSXClosingFragment = generated$8.jsxClosingFragment =
    jsxClosingFragment;
  generated$8.jSXElement = generated$8.jsxElement = jsxElement;
  generated$8.jSXEmptyExpression = generated$8.jsxEmptyExpression =
    jsxEmptyExpression;
  generated$8.jSXExpressionContainer = generated$8.jsxExpressionContainer =
    jsxExpressionContainer;
  generated$8.jSXFragment = generated$8.jsxFragment = jsxFragment;
  generated$8.jSXIdentifier = generated$8.jsxIdentifier = jsxIdentifier;
  generated$8.jSXMemberExpression = generated$8.jsxMemberExpression =
    jsxMemberExpression;
  generated$8.jSXNamespacedName = generated$8.jsxNamespacedName =
    jsxNamespacedName;
  generated$8.jSXOpeningElement = generated$8.jsxOpeningElement =
    jsxOpeningElement;
  generated$8.jSXOpeningFragment = generated$8.jsxOpeningFragment =
    jsxOpeningFragment;
  generated$8.jSXSpreadAttribute = generated$8.jsxSpreadAttribute =
    jsxSpreadAttribute;
  generated$8.jSXSpreadChild = generated$8.jsxSpreadChild = jsxSpreadChild;
  generated$8.jSXText = generated$8.jsxText = jsxText;
  generated$8.labeledStatement = labeledStatement;
  generated$8.logicalExpression = logicalExpression;
  generated$8.memberExpression = memberExpression;
  generated$8.metaProperty = metaProperty;
  generated$8.mixedTypeAnnotation = mixedTypeAnnotation;
  generated$8.moduleExpression = moduleExpression;
  generated$8.newExpression = newExpression;
  generated$8.noop = noop;
  generated$8.nullLiteral = nullLiteral;
  generated$8.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
  generated$8.nullableTypeAnnotation = nullableTypeAnnotation;
  generated$8.numberLiteral = NumberLiteral;
  generated$8.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
  generated$8.numberTypeAnnotation = numberTypeAnnotation;
  generated$8.numericLiteral = numericLiteral;
  generated$8.objectExpression = objectExpression;
  generated$8.objectMethod = objectMethod;
  generated$8.objectPattern = objectPattern;
  generated$8.objectProperty = objectProperty;
  generated$8.objectTypeAnnotation = objectTypeAnnotation;
  generated$8.objectTypeCallProperty = objectTypeCallProperty;
  generated$8.objectTypeIndexer = objectTypeIndexer;
  generated$8.objectTypeInternalSlot = objectTypeInternalSlot;
  generated$8.objectTypeProperty = objectTypeProperty;
  generated$8.objectTypeSpreadProperty = objectTypeSpreadProperty;
  generated$8.opaqueType = opaqueType;
  generated$8.optionalCallExpression = optionalCallExpression;
  generated$8.optionalIndexedAccessType = optionalIndexedAccessType;
  generated$8.optionalMemberExpression = optionalMemberExpression;
  generated$8.parenthesizedExpression = parenthesizedExpression;
  generated$8.pipelineBareFunction = pipelineBareFunction;
  generated$8.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
  generated$8.pipelineTopicExpression = pipelineTopicExpression;
  generated$8.placeholder = placeholder;
  generated$8.privateName = privateName;
  generated$8.program = program;
  generated$8.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
  generated$8.recordExpression = recordExpression;
  generated$8.regExpLiteral = regExpLiteral;
  generated$8.regexLiteral = RegexLiteral;
  generated$8.restElement = restElement;
  generated$8.restProperty = RestProperty;
  generated$8.returnStatement = returnStatement;
  generated$8.sequenceExpression = sequenceExpression;
  generated$8.spreadElement = spreadElement;
  generated$8.spreadProperty = SpreadProperty;
  generated$8.staticBlock = staticBlock;
  generated$8.stringLiteral = stringLiteral;
  generated$8.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
  generated$8.stringTypeAnnotation = stringTypeAnnotation;
  generated$8.super = _super;
  generated$8.switchCase = switchCase;
  generated$8.switchStatement = switchStatement;
  generated$8.symbolTypeAnnotation = symbolTypeAnnotation;
  generated$8.taggedTemplateExpression = taggedTemplateExpression;
  generated$8.templateElement = templateElement;
  generated$8.templateLiteral = templateLiteral;
  generated$8.thisExpression = thisExpression;
  generated$8.thisTypeAnnotation = thisTypeAnnotation;
  generated$8.throwStatement = throwStatement;
  generated$8.topicReference = topicReference;
  generated$8.tryStatement = tryStatement;
  generated$8.tSAnyKeyword = generated$8.tsAnyKeyword = tsAnyKeyword;
  generated$8.tSArrayType = generated$8.tsArrayType = tsArrayType;
  generated$8.tSAsExpression = generated$8.tsAsExpression = tsAsExpression;
  generated$8.tSBigIntKeyword = generated$8.tsBigIntKeyword = tsBigIntKeyword;
  generated$8.tSBooleanKeyword = generated$8.tsBooleanKeyword =
    tsBooleanKeyword;
  generated$8.tSCallSignatureDeclaration =
    generated$8.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
  generated$8.tSConditionalType = generated$8.tsConditionalType =
    tsConditionalType;
  generated$8.tSConstructSignatureDeclaration =
    generated$8.tsConstructSignatureDeclaration =
      tsConstructSignatureDeclaration;
  generated$8.tSConstructorType = generated$8.tsConstructorType =
    tsConstructorType;
  generated$8.tSDeclareFunction = generated$8.tsDeclareFunction =
    tsDeclareFunction;
  generated$8.tSDeclareMethod = generated$8.tsDeclareMethod = tsDeclareMethod;
  generated$8.tSEnumDeclaration = generated$8.tsEnumDeclaration =
    tsEnumDeclaration;
  generated$8.tSEnumMember = generated$8.tsEnumMember = tsEnumMember;
  generated$8.tSExportAssignment = generated$8.tsExportAssignment =
    tsExportAssignment;
  generated$8.tSExpressionWithTypeArguments =
    generated$8.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
  generated$8.tSExternalModuleReference =
    generated$8.tsExternalModuleReference = tsExternalModuleReference;
  generated$8.tSFunctionType = generated$8.tsFunctionType = tsFunctionType;
  generated$8.tSImportEqualsDeclaration =
    generated$8.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
  generated$8.tSImportType = generated$8.tsImportType = tsImportType;
  generated$8.tSIndexSignature = generated$8.tsIndexSignature =
    tsIndexSignature;
  generated$8.tSIndexedAccessType = generated$8.tsIndexedAccessType =
    tsIndexedAccessType;
  generated$8.tSInferType = generated$8.tsInferType = tsInferType;
  generated$8.tSInstantiationExpression =
    generated$8.tsInstantiationExpression = tsInstantiationExpression;
  generated$8.tSInterfaceBody = generated$8.tsInterfaceBody = tsInterfaceBody;
  generated$8.tSInterfaceDeclaration = generated$8.tsInterfaceDeclaration =
    tsInterfaceDeclaration;
  generated$8.tSIntersectionType = generated$8.tsIntersectionType =
    tsIntersectionType;
  generated$8.tSIntrinsicKeyword = generated$8.tsIntrinsicKeyword =
    tsIntrinsicKeyword;
  generated$8.tSLiteralType = generated$8.tsLiteralType = tsLiteralType;
  generated$8.tSMappedType = generated$8.tsMappedType = tsMappedType;
  generated$8.tSMethodSignature = generated$8.tsMethodSignature =
    tsMethodSignature;
  generated$8.tSModuleBlock = generated$8.tsModuleBlock = tsModuleBlock;
  generated$8.tSModuleDeclaration = generated$8.tsModuleDeclaration =
    tsModuleDeclaration;
  generated$8.tSNamedTupleMember = generated$8.tsNamedTupleMember =
    tsNamedTupleMember;
  generated$8.tSNamespaceExportDeclaration =
    generated$8.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
  generated$8.tSNeverKeyword = generated$8.tsNeverKeyword = tsNeverKeyword;
  generated$8.tSNonNullExpression = generated$8.tsNonNullExpression =
    tsNonNullExpression;
  generated$8.tSNullKeyword = generated$8.tsNullKeyword = tsNullKeyword;
  generated$8.tSNumberKeyword = generated$8.tsNumberKeyword = tsNumberKeyword;
  generated$8.tSObjectKeyword = generated$8.tsObjectKeyword = tsObjectKeyword;
  generated$8.tSOptionalType = generated$8.tsOptionalType = tsOptionalType;
  generated$8.tSParameterProperty = generated$8.tsParameterProperty =
    tsParameterProperty;
  generated$8.tSParenthesizedType = generated$8.tsParenthesizedType =
    tsParenthesizedType;
  generated$8.tSPropertySignature = generated$8.tsPropertySignature =
    tsPropertySignature;
  generated$8.tSQualifiedName = generated$8.tsQualifiedName = tsQualifiedName;
  generated$8.tSRestType = generated$8.tsRestType = tsRestType;
  generated$8.tSStringKeyword = generated$8.tsStringKeyword = tsStringKeyword;
  generated$8.tSSymbolKeyword = generated$8.tsSymbolKeyword = tsSymbolKeyword;
  generated$8.tSThisType = generated$8.tsThisType = tsThisType;
  generated$8.tSTupleType = generated$8.tsTupleType = tsTupleType;
  generated$8.tSTypeAliasDeclaration = generated$8.tsTypeAliasDeclaration =
    tsTypeAliasDeclaration;
  generated$8.tSTypeAnnotation = generated$8.tsTypeAnnotation =
    tsTypeAnnotation;
  generated$8.tSTypeAssertion = generated$8.tsTypeAssertion = tsTypeAssertion;
  generated$8.tSTypeLiteral = generated$8.tsTypeLiteral = tsTypeLiteral;
  generated$8.tSTypeOperator = generated$8.tsTypeOperator = tsTypeOperator;
  generated$8.tSTypeParameter = generated$8.tsTypeParameter = tsTypeParameter;
  generated$8.tSTypeParameterDeclaration =
    generated$8.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
  generated$8.tSTypeParameterInstantiation =
    generated$8.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
  generated$8.tSTypePredicate = generated$8.tsTypePredicate = tsTypePredicate;
  generated$8.tSTypeQuery = generated$8.tsTypeQuery = tsTypeQuery;
  generated$8.tSTypeReference = generated$8.tsTypeReference = tsTypeReference;
  generated$8.tSUndefinedKeyword = generated$8.tsUndefinedKeyword =
    tsUndefinedKeyword;
  generated$8.tSUnionType = generated$8.tsUnionType = tsUnionType;
  generated$8.tSUnknownKeyword = generated$8.tsUnknownKeyword =
    tsUnknownKeyword;
  generated$8.tSVoidKeyword = generated$8.tsVoidKeyword = tsVoidKeyword;
  generated$8.tupleExpression = tupleExpression;
  generated$8.tupleTypeAnnotation = tupleTypeAnnotation;
  generated$8.typeAlias = typeAlias;
  generated$8.typeAnnotation = typeAnnotation;
  generated$8.typeCastExpression = typeCastExpression;
  generated$8.typeParameter = typeParameter;
  generated$8.typeParameterDeclaration = typeParameterDeclaration;
  generated$8.typeParameterInstantiation = typeParameterInstantiation;
  generated$8.typeofTypeAnnotation = typeofTypeAnnotation;
  generated$8.unaryExpression = unaryExpression;
  generated$8.unionTypeAnnotation = unionTypeAnnotation;
  generated$8.updateExpression = updateExpression;
  generated$8.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
  generated$8.variableDeclaration = variableDeclaration;
  generated$8.variableDeclarator = variableDeclarator;
  generated$8.variance = variance;
  generated$8.voidTypeAnnotation = voidTypeAnnotation;
  generated$8.whileStatement = whileStatement;
  generated$8.withStatement = withStatement;
  generated$8.yieldExpression = yieldExpression;
  var _validateNode = requireValidateNode$1();
  function arrayExpression(elements = []) {
    return (0, _validateNode.default)({
      type: "ArrayExpression",
      elements: elements,
    });
  }
  function assignmentExpression(operator, left, right) {
    return (0, _validateNode.default)({
      type: "AssignmentExpression",
      operator: operator,
      left: left,
      right: right,
    });
  }
  function binaryExpression(operator, left, right) {
    return (0, _validateNode.default)({
      type: "BinaryExpression",
      operator: operator,
      left: left,
      right: right,
    });
  }
  function interpreterDirective(value) {
    return (0, _validateNode.default)({
      type: "InterpreterDirective",
      value: value,
    });
  }
  function directive(value) {
    return (0, _validateNode.default)({ type: "Directive", value: value });
  }
  function directiveLiteral(value) {
    return (0, _validateNode.default)({
      type: "DirectiveLiteral",
      value: value,
    });
  }
  function blockStatement(body, directives = []) {
    return (0, _validateNode.default)({
      type: "BlockStatement",
      body: body,
      directives: directives,
    });
  }
  function breakStatement(label = null) {
    return (0, _validateNode.default)({ type: "BreakStatement", label: label });
  }
  function callExpression(callee, _arguments) {
    return (0, _validateNode.default)({
      type: "CallExpression",
      callee: callee,
      arguments: _arguments,
    });
  }
  function catchClause(param = null, body) {
    return (0, _validateNode.default)({
      type: "CatchClause",
      param: param,
      body: body,
    });
  }
  function conditionalExpression(test, consequent, alternate) {
    return (0, _validateNode.default)({
      type: "ConditionalExpression",
      test: test,
      consequent: consequent,
      alternate: alternate,
    });
  }
  function continueStatement(label = null) {
    return (0, _validateNode.default)({
      type: "ContinueStatement",
      label: label,
    });
  }
  function debuggerStatement() {
    return { type: "DebuggerStatement" };
  }
  function doWhileStatement(test, body) {
    return (0, _validateNode.default)({
      type: "DoWhileStatement",
      test: test,
      body: body,
    });
  }
  function emptyStatement() {
    return { type: "EmptyStatement" };
  }
  function expressionStatement(expression) {
    return (0, _validateNode.default)({
      type: "ExpressionStatement",
      expression: expression,
    });
  }
  function file(program, comments = null, tokens = null) {
    return (0, _validateNode.default)({
      type: "File",
      program: program,
      comments: comments,
      tokens: tokens,
    });
  }
  function forInStatement(left, right, body) {
    return (0, _validateNode.default)({
      type: "ForInStatement",
      left: left,
      right: right,
      body: body,
    });
  }
  function forStatement(init = null, test = null, update = null, body) {
    return (0, _validateNode.default)({
      type: "ForStatement",
      init: init,
      test: test,
      update: update,
      body: body,
    });
  }
  function functionDeclaration(
    id = null,
    params,
    body,
    generator = false,
    async = false
  ) {
    return (0, _validateNode.default)({
      type: "FunctionDeclaration",
      id: id,
      params: params,
      body: body,
      generator: generator,
      async: async,
    });
  }
  function functionExpression(
    id = null,
    params,
    body,
    generator = false,
    async = false
  ) {
    return (0, _validateNode.default)({
      type: "FunctionExpression",
      id: id,
      params: params,
      body: body,
      generator: generator,
      async: async,
    });
  }
  function identifier(name) {
    return (0, _validateNode.default)({ type: "Identifier", name: name });
  }
  function ifStatement(test, consequent, alternate = null) {
    return (0, _validateNode.default)({
      type: "IfStatement",
      test: test,
      consequent: consequent,
      alternate: alternate,
    });
  }
  function labeledStatement(label, body) {
    return (0, _validateNode.default)({
      type: "LabeledStatement",
      label: label,
      body: body,
    });
  }
  function stringLiteral(value) {
    return (0, _validateNode.default)({ type: "StringLiteral", value: value });
  }
  function numericLiteral(value) {
    return (0, _validateNode.default)({ type: "NumericLiteral", value: value });
  }
  function nullLiteral() {
    return { type: "NullLiteral" };
  }
  function booleanLiteral(value) {
    return (0, _validateNode.default)({ type: "BooleanLiteral", value: value });
  }
  function regExpLiteral(pattern, flags = "") {
    return (0, _validateNode.default)({
      type: "RegExpLiteral",
      pattern: pattern,
      flags: flags,
    });
  }
  function logicalExpression(operator, left, right) {
    return (0, _validateNode.default)({
      type: "LogicalExpression",
      operator: operator,
      left: left,
      right: right,
    });
  }
  function memberExpression(
    object,
    property,
    computed = false,
    optional = null
  ) {
    return (0, _validateNode.default)({
      type: "MemberExpression",
      object: object,
      property: property,
      computed: computed,
      optional: optional,
    });
  }
  function newExpression(callee, _arguments) {
    return (0, _validateNode.default)({
      type: "NewExpression",
      callee: callee,
      arguments: _arguments,
    });
  }
  function program(
    body,
    directives = [],
    sourceType = "script",
    interpreter = null
  ) {
    return (0, _validateNode.default)({
      type: "Program",
      body: body,
      directives: directives,
      sourceType: sourceType,
      interpreter: interpreter,
      sourceFile: null,
    });
  }
  function objectExpression(properties) {
    return (0, _validateNode.default)({
      type: "ObjectExpression",
      properties: properties,
    });
  }
  function objectMethod(
    kind = "method",
    key,
    params,
    body,
    computed = false,
    generator = false,
    async = false
  ) {
    return (0, _validateNode.default)({
      type: "ObjectMethod",
      kind: kind,
      key: key,
      params: params,
      body: body,
      computed: computed,
      generator: generator,
      async: async,
    });
  }
  function objectProperty(
    key,
    value,
    computed = false,
    shorthand = false,
    decorators = null
  ) {
    return (0, _validateNode.default)({
      type: "ObjectProperty",
      key: key,
      value: value,
      computed: computed,
      shorthand: shorthand,
      decorators: decorators,
    });
  }
  function restElement(argument) {
    return (0, _validateNode.default)({
      type: "RestElement",
      argument: argument,
    });
  }
  function returnStatement(argument = null) {
    return (0, _validateNode.default)({
      type: "ReturnStatement",
      argument: argument,
    });
  }
  function sequenceExpression(expressions) {
    return (0, _validateNode.default)({
      type: "SequenceExpression",
      expressions: expressions,
    });
  }
  function parenthesizedExpression(expression) {
    return (0, _validateNode.default)({
      type: "ParenthesizedExpression",
      expression: expression,
    });
  }
  function switchCase(test = null, consequent) {
    return (0, _validateNode.default)({
      type: "SwitchCase",
      test: test,
      consequent: consequent,
    });
  }
  function switchStatement(discriminant, cases) {
    return (0, _validateNode.default)({
      type: "SwitchStatement",
      discriminant: discriminant,
      cases: cases,
    });
  }
  function thisExpression() {
    return { type: "ThisExpression" };
  }
  function throwStatement(argument) {
    return (0, _validateNode.default)({
      type: "ThrowStatement",
      argument: argument,
    });
  }
  function tryStatement(block, handler = null, finalizer = null) {
    return (0, _validateNode.default)({
      type: "TryStatement",
      block: block,
      handler: handler,
      finalizer: finalizer,
    });
  }
  function unaryExpression(operator, argument, prefix = true) {
    return (0, _validateNode.default)({
      type: "UnaryExpression",
      operator: operator,
      argument: argument,
      prefix: prefix,
    });
  }
  function updateExpression(operator, argument, prefix = false) {
    return (0, _validateNode.default)({
      type: "UpdateExpression",
      operator: operator,
      argument: argument,
      prefix: prefix,
    });
  }
  function variableDeclaration(kind, declarations) {
    return (0, _validateNode.default)({
      type: "VariableDeclaration",
      kind: kind,
      declarations: declarations,
    });
  }
  function variableDeclarator(id, init = null) {
    return (0, _validateNode.default)({
      type: "VariableDeclarator",
      id: id,
      init: init,
    });
  }
  function whileStatement(test, body) {
    return (0, _validateNode.default)({
      type: "WhileStatement",
      test: test,
      body: body,
    });
  }
  function withStatement(object, body) {
    return (0, _validateNode.default)({
      type: "WithStatement",
      object: object,
      body: body,
    });
  }
  function assignmentPattern(left, right) {
    return (0, _validateNode.default)({
      type: "AssignmentPattern",
      left: left,
      right: right,
    });
  }
  function arrayPattern(elements) {
    return (0, _validateNode.default)({
      type: "ArrayPattern",
      elements: elements,
    });
  }
  function arrowFunctionExpression(params, body, async = false) {
    return (0, _validateNode.default)({
      type: "ArrowFunctionExpression",
      params: params,
      body: body,
      async: async,
      expression: null,
    });
  }
  function classBody(body) {
    return (0, _validateNode.default)({ type: "ClassBody", body: body });
  }
  function classExpression(
    id = null,
    superClass = null,
    body,
    decorators = null
  ) {
    return (0, _validateNode.default)({
      type: "ClassExpression",
      id: id,
      superClass: superClass,
      body: body,
      decorators: decorators,
    });
  }
  function classDeclaration(id, superClass = null, body, decorators = null) {
    return (0, _validateNode.default)({
      type: "ClassDeclaration",
      id: id,
      superClass: superClass,
      body: body,
      decorators: decorators,
    });
  }
  function exportAllDeclaration(source) {
    return (0, _validateNode.default)({
      type: "ExportAllDeclaration",
      source: source,
    });
  }
  function exportDefaultDeclaration(declaration) {
    return (0, _validateNode.default)({
      type: "ExportDefaultDeclaration",
      declaration: declaration,
    });
  }
  function exportNamedDeclaration(
    declaration = null,
    specifiers = [],
    source = null
  ) {
    return (0, _validateNode.default)({
      type: "ExportNamedDeclaration",
      declaration: declaration,
      specifiers: specifiers,
      source: source,
    });
  }
  function exportSpecifier(local, exported) {
    return (0, _validateNode.default)({
      type: "ExportSpecifier",
      local: local,
      exported: exported,
    });
  }
  function forOfStatement(left, right, body, _await = false) {
    return (0, _validateNode.default)({
      type: "ForOfStatement",
      left: left,
      right: right,
      body: body,
      await: _await,
    });
  }
  function importDeclaration(specifiers, source) {
    return (0, _validateNode.default)({
      type: "ImportDeclaration",
      specifiers: specifiers,
      source: source,
    });
  }
  function importDefaultSpecifier(local) {
    return (0, _validateNode.default)({
      type: "ImportDefaultSpecifier",
      local: local,
    });
  }
  function importNamespaceSpecifier(local) {
    return (0, _validateNode.default)({
      type: "ImportNamespaceSpecifier",
      local: local,
    });
  }
  function importSpecifier(local, imported) {
    return (0, _validateNode.default)({
      type: "ImportSpecifier",
      local: local,
      imported: imported,
    });
  }
  function metaProperty(meta, property) {
    return (0, _validateNode.default)({
      type: "MetaProperty",
      meta: meta,
      property: property,
    });
  }
  function classMethod(
    kind = "method",
    key,
    params,
    body,
    computed = false,
    _static = false,
    generator = false,
    async = false
  ) {
    return (0, _validateNode.default)({
      type: "ClassMethod",
      kind: kind,
      key: key,
      params: params,
      body: body,
      computed: computed,
      static: _static,
      generator: generator,
      async: async,
    });
  }
  function objectPattern(properties) {
    return (0, _validateNode.default)({
      type: "ObjectPattern",
      properties: properties,
    });
  }
  function spreadElement(argument) {
    return (0, _validateNode.default)({
      type: "SpreadElement",
      argument: argument,
    });
  }
  function _super() {
    return { type: "Super" };
  }
  function taggedTemplateExpression(tag, quasi) {
    return (0, _validateNode.default)({
      type: "TaggedTemplateExpression",
      tag: tag,
      quasi: quasi,
    });
  }
  function templateElement(value, tail = false) {
    return (0, _validateNode.default)({
      type: "TemplateElement",
      value: value,
      tail: tail,
    });
  }
  function templateLiteral(quasis, expressions) {
    return (0, _validateNode.default)({
      type: "TemplateLiteral",
      quasis: quasis,
      expressions: expressions,
    });
  }
  function yieldExpression(argument = null, delegate = false) {
    return (0, _validateNode.default)({
      type: "YieldExpression",
      argument: argument,
      delegate: delegate,
    });
  }
  function awaitExpression(argument) {
    return (0, _validateNode.default)({
      type: "AwaitExpression",
      argument: argument,
    });
  }
  function _import() {
    return { type: "Import" };
  }
  function bigIntLiteral(value) {
    return (0, _validateNode.default)({ type: "BigIntLiteral", value: value });
  }
  function exportNamespaceSpecifier(exported) {
    return (0, _validateNode.default)({
      type: "ExportNamespaceSpecifier",
      exported: exported,
    });
  }
  function optionalMemberExpression(
    object,
    property,
    computed = false,
    optional
  ) {
    return (0, _validateNode.default)({
      type: "OptionalMemberExpression",
      object: object,
      property: property,
      computed: computed,
      optional: optional,
    });
  }
  function optionalCallExpression(callee, _arguments, optional) {
    return (0, _validateNode.default)({
      type: "OptionalCallExpression",
      callee: callee,
      arguments: _arguments,
      optional: optional,
    });
  }
  function classProperty(
    key,
    value = null,
    typeAnnotation = null,
    decorators = null,
    computed = false,
    _static = false
  ) {
    return (0, _validateNode.default)({
      type: "ClassProperty",
      key: key,
      value: value,
      typeAnnotation: typeAnnotation,
      decorators: decorators,
      computed: computed,
      static: _static,
    });
  }
  function classAccessorProperty(
    key,
    value = null,
    typeAnnotation = null,
    decorators = null,
    computed = false,
    _static = false
  ) {
    return (0, _validateNode.default)({
      type: "ClassAccessorProperty",
      key: key,
      value: value,
      typeAnnotation: typeAnnotation,
      decorators: decorators,
      computed: computed,
      static: _static,
    });
  }
  function classPrivateProperty(
    key,
    value = null,
    decorators = null,
    _static = false
  ) {
    return (0, _validateNode.default)({
      type: "ClassPrivateProperty",
      key: key,
      value: value,
      decorators: decorators,
      static: _static,
    });
  }
  function classPrivateMethod(
    kind = "method",
    key,
    params,
    body,
    _static = false
  ) {
    return (0, _validateNode.default)({
      type: "ClassPrivateMethod",
      kind: kind,
      key: key,
      params: params,
      body: body,
      static: _static,
    });
  }
  function privateName(id) {
    return (0, _validateNode.default)({ type: "PrivateName", id: id });
  }
  function staticBlock(body) {
    return (0, _validateNode.default)({ type: "StaticBlock", body: body });
  }
  function anyTypeAnnotation() {
    return { type: "AnyTypeAnnotation" };
  }
  function arrayTypeAnnotation(elementType) {
    return (0, _validateNode.default)({
      type: "ArrayTypeAnnotation",
      elementType: elementType,
    });
  }
  function booleanTypeAnnotation() {
    return { type: "BooleanTypeAnnotation" };
  }
  function booleanLiteralTypeAnnotation(value) {
    return (0, _validateNode.default)({
      type: "BooleanLiteralTypeAnnotation",
      value: value,
    });
  }
  function nullLiteralTypeAnnotation() {
    return { type: "NullLiteralTypeAnnotation" };
  }
  function classImplements(id, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "ClassImplements",
      id: id,
      typeParameters: typeParameters,
    });
  }
  function declareClass(id, typeParameters = null, _extends = null, body) {
    return (0, _validateNode.default)({
      type: "DeclareClass",
      id: id,
      typeParameters: typeParameters,
      extends: _extends,
      body: body,
    });
  }
  function declareFunction(id) {
    return (0, _validateNode.default)({ type: "DeclareFunction", id: id });
  }
  function declareInterface(id, typeParameters = null, _extends = null, body) {
    return (0, _validateNode.default)({
      type: "DeclareInterface",
      id: id,
      typeParameters: typeParameters,
      extends: _extends,
      body: body,
    });
  }
  function declareModule(id, body, kind = null) {
    return (0, _validateNode.default)({
      type: "DeclareModule",
      id: id,
      body: body,
      kind: kind,
    });
  }
  function declareModuleExports(typeAnnotation) {
    return (0, _validateNode.default)({
      type: "DeclareModuleExports",
      typeAnnotation: typeAnnotation,
    });
  }
  function declareTypeAlias(id, typeParameters = null, right) {
    return (0, _validateNode.default)({
      type: "DeclareTypeAlias",
      id: id,
      typeParameters: typeParameters,
      right: right,
    });
  }
  function declareOpaqueType(id, typeParameters = null, supertype = null) {
    return (0, _validateNode.default)({
      type: "DeclareOpaqueType",
      id: id,
      typeParameters: typeParameters,
      supertype: supertype,
    });
  }
  function declareVariable(id) {
    return (0, _validateNode.default)({ type: "DeclareVariable", id: id });
  }
  function declareExportDeclaration(
    declaration = null,
    specifiers = null,
    source = null
  ) {
    return (0, _validateNode.default)({
      type: "DeclareExportDeclaration",
      declaration: declaration,
      specifiers: specifiers,
      source: source,
    });
  }
  function declareExportAllDeclaration(source) {
    return (0, _validateNode.default)({
      type: "DeclareExportAllDeclaration",
      source: source,
    });
  }
  function declaredPredicate(value) {
    return (0, _validateNode.default)({
      type: "DeclaredPredicate",
      value: value,
    });
  }
  function existsTypeAnnotation() {
    return { type: "ExistsTypeAnnotation" };
  }
  function functionTypeAnnotation(
    typeParameters = null,
    params,
    rest = null,
    returnType
  ) {
    return (0, _validateNode.default)({
      type: "FunctionTypeAnnotation",
      typeParameters: typeParameters,
      params: params,
      rest: rest,
      returnType: returnType,
    });
  }
  function functionTypeParam(name = null, typeAnnotation) {
    return (0, _validateNode.default)({
      type: "FunctionTypeParam",
      name: name,
      typeAnnotation: typeAnnotation,
    });
  }
  function genericTypeAnnotation(id, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "GenericTypeAnnotation",
      id: id,
      typeParameters: typeParameters,
    });
  }
  function inferredPredicate() {
    return { type: "InferredPredicate" };
  }
  function interfaceExtends(id, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "InterfaceExtends",
      id: id,
      typeParameters: typeParameters,
    });
  }
  function interfaceDeclaration(
    id,
    typeParameters = null,
    _extends = null,
    body
  ) {
    return (0, _validateNode.default)({
      type: "InterfaceDeclaration",
      id: id,
      typeParameters: typeParameters,
      extends: _extends,
      body: body,
    });
  }
  function interfaceTypeAnnotation(_extends = null, body) {
    return (0, _validateNode.default)({
      type: "InterfaceTypeAnnotation",
      extends: _extends,
      body: body,
    });
  }
  function intersectionTypeAnnotation(types) {
    return (0, _validateNode.default)({
      type: "IntersectionTypeAnnotation",
      types: types,
    });
  }
  function mixedTypeAnnotation() {
    return { type: "MixedTypeAnnotation" };
  }
  function emptyTypeAnnotation() {
    return { type: "EmptyTypeAnnotation" };
  }
  function nullableTypeAnnotation(typeAnnotation) {
    return (0, _validateNode.default)({
      type: "NullableTypeAnnotation",
      typeAnnotation: typeAnnotation,
    });
  }
  function numberLiteralTypeAnnotation(value) {
    return (0, _validateNode.default)({
      type: "NumberLiteralTypeAnnotation",
      value: value,
    });
  }
  function numberTypeAnnotation() {
    return { type: "NumberTypeAnnotation" };
  }
  function objectTypeAnnotation(
    properties,
    indexers = [],
    callProperties = [],
    internalSlots = [],
    exact = false
  ) {
    return (0, _validateNode.default)({
      type: "ObjectTypeAnnotation",
      properties: properties,
      indexers: indexers,
      callProperties: callProperties,
      internalSlots: internalSlots,
      exact: exact,
    });
  }
  function objectTypeInternalSlot(id, value, optional, _static, method) {
    return (0, _validateNode.default)({
      type: "ObjectTypeInternalSlot",
      id: id,
      value: value,
      optional: optional,
      static: _static,
      method: method,
    });
  }
  function objectTypeCallProperty(value) {
    return (0, _validateNode.default)({
      type: "ObjectTypeCallProperty",
      value: value,
      static: null,
    });
  }
  function objectTypeIndexer(id = null, key, value, variance = null) {
    return (0, _validateNode.default)({
      type: "ObjectTypeIndexer",
      id: id,
      key: key,
      value: value,
      variance: variance,
      static: null,
    });
  }
  function objectTypeProperty(key, value, variance = null) {
    return (0, _validateNode.default)({
      type: "ObjectTypeProperty",
      key: key,
      value: value,
      variance: variance,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null,
    });
  }
  function objectTypeSpreadProperty(argument) {
    return (0, _validateNode.default)({
      type: "ObjectTypeSpreadProperty",
      argument: argument,
    });
  }
  function opaqueType(id, typeParameters = null, supertype = null, impltype) {
    return (0, _validateNode.default)({
      type: "OpaqueType",
      id: id,
      typeParameters: typeParameters,
      supertype: supertype,
      impltype: impltype,
    });
  }
  function qualifiedTypeIdentifier(id, qualification) {
    return (0, _validateNode.default)({
      type: "QualifiedTypeIdentifier",
      id: id,
      qualification: qualification,
    });
  }
  function stringLiteralTypeAnnotation(value) {
    return (0, _validateNode.default)({
      type: "StringLiteralTypeAnnotation",
      value: value,
    });
  }
  function stringTypeAnnotation() {
    return { type: "StringTypeAnnotation" };
  }
  function symbolTypeAnnotation() {
    return { type: "SymbolTypeAnnotation" };
  }
  function thisTypeAnnotation() {
    return { type: "ThisTypeAnnotation" };
  }
  function tupleTypeAnnotation(types) {
    return (0, _validateNode.default)({
      type: "TupleTypeAnnotation",
      types: types,
    });
  }
  function typeofTypeAnnotation(argument) {
    return (0, _validateNode.default)({
      type: "TypeofTypeAnnotation",
      argument: argument,
    });
  }
  function typeAlias(id, typeParameters = null, right) {
    return (0, _validateNode.default)({
      type: "TypeAlias",
      id: id,
      typeParameters: typeParameters,
      right: right,
    });
  }
  function typeAnnotation(typeAnnotation) {
    return (0, _validateNode.default)({
      type: "TypeAnnotation",
      typeAnnotation: typeAnnotation,
    });
  }
  function typeCastExpression(expression, typeAnnotation) {
    return (0, _validateNode.default)({
      type: "TypeCastExpression",
      expression: expression,
      typeAnnotation: typeAnnotation,
    });
  }
  function typeParameter(bound = null, _default = null, variance = null) {
    return (0, _validateNode.default)({
      type: "TypeParameter",
      bound: bound,
      default: _default,
      variance: variance,
      name: null,
    });
  }
  function typeParameterDeclaration(params) {
    return (0, _validateNode.default)({
      type: "TypeParameterDeclaration",
      params: params,
    });
  }
  function typeParameterInstantiation(params) {
    return (0, _validateNode.default)({
      type: "TypeParameterInstantiation",
      params: params,
    });
  }
  function unionTypeAnnotation(types) {
    return (0, _validateNode.default)({
      type: "UnionTypeAnnotation",
      types: types,
    });
  }
  function variance(kind) {
    return (0, _validateNode.default)({ type: "Variance", kind: kind });
  }
  function voidTypeAnnotation() {
    return { type: "VoidTypeAnnotation" };
  }
  function enumDeclaration(id, body) {
    return (0, _validateNode.default)({
      type: "EnumDeclaration",
      id: id,
      body: body,
    });
  }
  function enumBooleanBody(members) {
    return (0, _validateNode.default)({
      type: "EnumBooleanBody",
      members: members,
      explicitType: null,
      hasUnknownMembers: null,
    });
  }
  function enumNumberBody(members) {
    return (0, _validateNode.default)({
      type: "EnumNumberBody",
      members: members,
      explicitType: null,
      hasUnknownMembers: null,
    });
  }
  function enumStringBody(members) {
    return (0, _validateNode.default)({
      type: "EnumStringBody",
      members: members,
      explicitType: null,
      hasUnknownMembers: null,
    });
  }
  function enumSymbolBody(members) {
    return (0, _validateNode.default)({
      type: "EnumSymbolBody",
      members: members,
      hasUnknownMembers: null,
    });
  }
  function enumBooleanMember(id) {
    return (0, _validateNode.default)({
      type: "EnumBooleanMember",
      id: id,
      init: null,
    });
  }
  function enumNumberMember(id, init) {
    return (0, _validateNode.default)({
      type: "EnumNumberMember",
      id: id,
      init: init,
    });
  }
  function enumStringMember(id, init) {
    return (0, _validateNode.default)({
      type: "EnumStringMember",
      id: id,
      init: init,
    });
  }
  function enumDefaultedMember(id) {
    return (0, _validateNode.default)({ type: "EnumDefaultedMember", id: id });
  }
  function indexedAccessType(objectType, indexType) {
    return (0, _validateNode.default)({
      type: "IndexedAccessType",
      objectType: objectType,
      indexType: indexType,
    });
  }
  function optionalIndexedAccessType(objectType, indexType) {
    return (0, _validateNode.default)({
      type: "OptionalIndexedAccessType",
      objectType: objectType,
      indexType: indexType,
      optional: null,
    });
  }
  function jsxAttribute(name, value = null) {
    return (0, _validateNode.default)({
      type: "JSXAttribute",
      name: name,
      value: value,
    });
  }
  function jsxClosingElement(name) {
    return (0, _validateNode.default)({
      type: "JSXClosingElement",
      name: name,
    });
  }
  function jsxElement(
    openingElement,
    closingElement = null,
    children,
    selfClosing = null
  ) {
    return (0, _validateNode.default)({
      type: "JSXElement",
      openingElement: openingElement,
      closingElement: closingElement,
      children: children,
      selfClosing: selfClosing,
    });
  }
  function jsxEmptyExpression() {
    return { type: "JSXEmptyExpression" };
  }
  function jsxExpressionContainer(expression) {
    return (0, _validateNode.default)({
      type: "JSXExpressionContainer",
      expression: expression,
    });
  }
  function jsxSpreadChild(expression) {
    return (0, _validateNode.default)({
      type: "JSXSpreadChild",
      expression: expression,
    });
  }
  function jsxIdentifier(name) {
    return (0, _validateNode.default)({ type: "JSXIdentifier", name: name });
  }
  function jsxMemberExpression(object, property) {
    return (0, _validateNode.default)({
      type: "JSXMemberExpression",
      object: object,
      property: property,
    });
  }
  function jsxNamespacedName(namespace, name) {
    return (0, _validateNode.default)({
      type: "JSXNamespacedName",
      namespace: namespace,
      name: name,
    });
  }
  function jsxOpeningElement(name, attributes, selfClosing = false) {
    return (0, _validateNode.default)({
      type: "JSXOpeningElement",
      name: name,
      attributes: attributes,
      selfClosing: selfClosing,
    });
  }
  function jsxSpreadAttribute(argument) {
    return (0, _validateNode.default)({
      type: "JSXSpreadAttribute",
      argument: argument,
    });
  }
  function jsxText(value) {
    return (0, _validateNode.default)({ type: "JSXText", value: value });
  }
  function jsxFragment(openingFragment, closingFragment, children) {
    return (0, _validateNode.default)({
      type: "JSXFragment",
      openingFragment: openingFragment,
      closingFragment: closingFragment,
      children: children,
    });
  }
  function jsxOpeningFragment() {
    return { type: "JSXOpeningFragment" };
  }
  function jsxClosingFragment() {
    return { type: "JSXClosingFragment" };
  }
  function noop() {
    return { type: "Noop" };
  }
  function placeholder(expectedNode, name) {
    return (0, _validateNode.default)({
      type: "Placeholder",
      expectedNode: expectedNode,
      name: name,
    });
  }
  function v8IntrinsicIdentifier(name) {
    return (0, _validateNode.default)({
      type: "V8IntrinsicIdentifier",
      name: name,
    });
  }
  function argumentPlaceholder() {
    return { type: "ArgumentPlaceholder" };
  }
  function bindExpression(object, callee) {
    return (0, _validateNode.default)({
      type: "BindExpression",
      object: object,
      callee: callee,
    });
  }
  function importAttribute(key, value) {
    return (0, _validateNode.default)({
      type: "ImportAttribute",
      key: key,
      value: value,
    });
  }
  function decorator(expression) {
    return (0, _validateNode.default)({
      type: "Decorator",
      expression: expression,
    });
  }
  function doExpression(body, async = false) {
    return (0, _validateNode.default)({
      type: "DoExpression",
      body: body,
      async: async,
    });
  }
  function exportDefaultSpecifier(exported) {
    return (0, _validateNode.default)({
      type: "ExportDefaultSpecifier",
      exported: exported,
    });
  }
  function recordExpression(properties) {
    return (0, _validateNode.default)({
      type: "RecordExpression",
      properties: properties,
    });
  }
  function tupleExpression(elements = []) {
    return (0, _validateNode.default)({
      type: "TupleExpression",
      elements: elements,
    });
  }
  function decimalLiteral(value) {
    return (0, _validateNode.default)({ type: "DecimalLiteral", value: value });
  }
  function moduleExpression(body) {
    return (0, _validateNode.default)({ type: "ModuleExpression", body: body });
  }
  function topicReference() {
    return { type: "TopicReference" };
  }
  function pipelineTopicExpression(expression) {
    return (0, _validateNode.default)({
      type: "PipelineTopicExpression",
      expression: expression,
    });
  }
  function pipelineBareFunction(callee) {
    return (0, _validateNode.default)({
      type: "PipelineBareFunction",
      callee: callee,
    });
  }
  function pipelinePrimaryTopicReference() {
    return { type: "PipelinePrimaryTopicReference" };
  }
  function tsParameterProperty(parameter) {
    return (0, _validateNode.default)({
      type: "TSParameterProperty",
      parameter: parameter,
    });
  }
  function tsDeclareFunction(
    id = null,
    typeParameters = null,
    params,
    returnType = null
  ) {
    return (0, _validateNode.default)({
      type: "TSDeclareFunction",
      id: id,
      typeParameters: typeParameters,
      params: params,
      returnType: returnType,
    });
  }
  function tsDeclareMethod(
    decorators = null,
    key,
    typeParameters = null,
    params,
    returnType = null
  ) {
    return (0, _validateNode.default)({
      type: "TSDeclareMethod",
      decorators: decorators,
      key: key,
      typeParameters: typeParameters,
      params: params,
      returnType: returnType,
    });
  }
  function tsQualifiedName(left, right) {
    return (0, _validateNode.default)({
      type: "TSQualifiedName",
      left: left,
      right: right,
    });
  }
  function tsCallSignatureDeclaration(
    typeParameters = null,
    parameters,
    typeAnnotation = null
  ) {
    return (0, _validateNode.default)({
      type: "TSCallSignatureDeclaration",
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation,
    });
  }
  function tsConstructSignatureDeclaration(
    typeParameters = null,
    parameters,
    typeAnnotation = null
  ) {
    return (0, _validateNode.default)({
      type: "TSConstructSignatureDeclaration",
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation,
    });
  }
  function tsPropertySignature(key, typeAnnotation = null, initializer = null) {
    return (0, _validateNode.default)({
      type: "TSPropertySignature",
      key: key,
      typeAnnotation: typeAnnotation,
      initializer: initializer,
      kind: null,
    });
  }
  function tsMethodSignature(
    key,
    typeParameters = null,
    parameters,
    typeAnnotation = null
  ) {
    return (0, _validateNode.default)({
      type: "TSMethodSignature",
      key: key,
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation,
      kind: null,
    });
  }
  function tsIndexSignature(parameters, typeAnnotation = null) {
    return (0, _validateNode.default)({
      type: "TSIndexSignature",
      parameters: parameters,
      typeAnnotation: typeAnnotation,
    });
  }
  function tsAnyKeyword() {
    return { type: "TSAnyKeyword" };
  }
  function tsBooleanKeyword() {
    return { type: "TSBooleanKeyword" };
  }
  function tsBigIntKeyword() {
    return { type: "TSBigIntKeyword" };
  }
  function tsIntrinsicKeyword() {
    return { type: "TSIntrinsicKeyword" };
  }
  function tsNeverKeyword() {
    return { type: "TSNeverKeyword" };
  }
  function tsNullKeyword() {
    return { type: "TSNullKeyword" };
  }
  function tsNumberKeyword() {
    return { type: "TSNumberKeyword" };
  }
  function tsObjectKeyword() {
    return { type: "TSObjectKeyword" };
  }
  function tsStringKeyword() {
    return { type: "TSStringKeyword" };
  }
  function tsSymbolKeyword() {
    return { type: "TSSymbolKeyword" };
  }
  function tsUndefinedKeyword() {
    return { type: "TSUndefinedKeyword" };
  }
  function tsUnknownKeyword() {
    return { type: "TSUnknownKeyword" };
  }
  function tsVoidKeyword() {
    return { type: "TSVoidKeyword" };
  }
  function tsThisType() {
    return { type: "TSThisType" };
  }
  function tsFunctionType(
    typeParameters = null,
    parameters,
    typeAnnotation = null
  ) {
    return (0, _validateNode.default)({
      type: "TSFunctionType",
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation,
    });
  }
  function tsConstructorType(
    typeParameters = null,
    parameters,
    typeAnnotation = null
  ) {
    return (0, _validateNode.default)({
      type: "TSConstructorType",
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation,
    });
  }
  function tsTypeReference(typeName, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "TSTypeReference",
      typeName: typeName,
      typeParameters: typeParameters,
    });
  }
  function tsTypePredicate(
    parameterName,
    typeAnnotation = null,
    asserts = null
  ) {
    return (0, _validateNode.default)({
      type: "TSTypePredicate",
      parameterName: parameterName,
      typeAnnotation: typeAnnotation,
      asserts: asserts,
    });
  }
  function tsTypeQuery(exprName, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "TSTypeQuery",
      exprName: exprName,
      typeParameters: typeParameters,
    });
  }
  function tsTypeLiteral(members) {
    return (0, _validateNode.default)({
      type: "TSTypeLiteral",
      members: members,
    });
  }
  function tsArrayType(elementType) {
    return (0, _validateNode.default)({
      type: "TSArrayType",
      elementType: elementType,
    });
  }
  function tsTupleType(elementTypes) {
    return (0, _validateNode.default)({
      type: "TSTupleType",
      elementTypes: elementTypes,
    });
  }
  function tsOptionalType(typeAnnotation) {
    return (0, _validateNode.default)({
      type: "TSOptionalType",
      typeAnnotation: typeAnnotation,
    });
  }
  function tsRestType(typeAnnotation) {
    return (0, _validateNode.default)({
      type: "TSRestType",
      typeAnnotation: typeAnnotation,
    });
  }
  function tsNamedTupleMember(label, elementType, optional = false) {
    return (0, _validateNode.default)({
      type: "TSNamedTupleMember",
      label: label,
      elementType: elementType,
      optional: optional,
    });
  }
  function tsUnionType(types) {
    return (0, _validateNode.default)({ type: "TSUnionType", types: types });
  }
  function tsIntersectionType(types) {
    return (0, _validateNode.default)({
      type: "TSIntersectionType",
      types: types,
    });
  }
  function tsConditionalType(checkType, extendsType, trueType, falseType) {
    return (0, _validateNode.default)({
      type: "TSConditionalType",
      checkType: checkType,
      extendsType: extendsType,
      trueType: trueType,
      falseType: falseType,
    });
  }
  function tsInferType(typeParameter) {
    return (0, _validateNode.default)({
      type: "TSInferType",
      typeParameter: typeParameter,
    });
  }
  function tsParenthesizedType(typeAnnotation) {
    return (0, _validateNode.default)({
      type: "TSParenthesizedType",
      typeAnnotation: typeAnnotation,
    });
  }
  function tsTypeOperator(typeAnnotation) {
    return (0, _validateNode.default)({
      type: "TSTypeOperator",
      typeAnnotation: typeAnnotation,
      operator: null,
    });
  }
  function tsIndexedAccessType(objectType, indexType) {
    return (0, _validateNode.default)({
      type: "TSIndexedAccessType",
      objectType: objectType,
      indexType: indexType,
    });
  }
  function tsMappedType(typeParameter, typeAnnotation = null, nameType = null) {
    return (0, _validateNode.default)({
      type: "TSMappedType",
      typeParameter: typeParameter,
      typeAnnotation: typeAnnotation,
      nameType: nameType,
    });
  }
  function tsLiteralType(literal) {
    return (0, _validateNode.default)({
      type: "TSLiteralType",
      literal: literal,
    });
  }
  function tsExpressionWithTypeArguments(expression, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "TSExpressionWithTypeArguments",
      expression: expression,
      typeParameters: typeParameters,
    });
  }
  function tsInterfaceDeclaration(
    id,
    typeParameters = null,
    _extends = null,
    body
  ) {
    return (0, _validateNode.default)({
      type: "TSInterfaceDeclaration",
      id: id,
      typeParameters: typeParameters,
      extends: _extends,
      body: body,
    });
  }
  function tsInterfaceBody(body) {
    return (0, _validateNode.default)({ type: "TSInterfaceBody", body: body });
  }
  function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation) {
    return (0, _validateNode.default)({
      type: "TSTypeAliasDeclaration",
      id: id,
      typeParameters: typeParameters,
      typeAnnotation: typeAnnotation,
    });
  }
  function tsInstantiationExpression(expression, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "TSInstantiationExpression",
      expression: expression,
      typeParameters: typeParameters,
    });
  }
  function tsAsExpression(expression, typeAnnotation) {
    return (0, _validateNode.default)({
      type: "TSAsExpression",
      expression: expression,
      typeAnnotation: typeAnnotation,
    });
  }
  function tsTypeAssertion(typeAnnotation, expression) {
    return (0, _validateNode.default)({
      type: "TSTypeAssertion",
      typeAnnotation: typeAnnotation,
      expression: expression,
    });
  }
  function tsEnumDeclaration(id, members) {
    return (0, _validateNode.default)({
      type: "TSEnumDeclaration",
      id: id,
      members: members,
    });
  }
  function tsEnumMember(id, initializer = null) {
    return (0, _validateNode.default)({
      type: "TSEnumMember",
      id: id,
      initializer: initializer,
    });
  }
  function tsModuleDeclaration(id, body) {
    return (0, _validateNode.default)({
      type: "TSModuleDeclaration",
      id: id,
      body: body,
    });
  }
  function tsModuleBlock(body) {
    return (0, _validateNode.default)({ type: "TSModuleBlock", body: body });
  }
  function tsImportType(argument, qualifier = null, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "TSImportType",
      argument: argument,
      qualifier: qualifier,
      typeParameters: typeParameters,
    });
  }
  function tsImportEqualsDeclaration(id, moduleReference) {
    return (0, _validateNode.default)({
      type: "TSImportEqualsDeclaration",
      id: id,
      moduleReference: moduleReference,
      isExport: null,
    });
  }
  function tsExternalModuleReference(expression) {
    return (0, _validateNode.default)({
      type: "TSExternalModuleReference",
      expression: expression,
    });
  }
  function tsNonNullExpression(expression) {
    return (0, _validateNode.default)({
      type: "TSNonNullExpression",
      expression: expression,
    });
  }
  function tsExportAssignment(expression) {
    return (0, _validateNode.default)({
      type: "TSExportAssignment",
      expression: expression,
    });
  }
  function tsNamespaceExportDeclaration(id) {
    return (0, _validateNode.default)({
      type: "TSNamespaceExportDeclaration",
      id: id,
    });
  }
  function tsTypeAnnotation(typeAnnotation) {
    return (0, _validateNode.default)({
      type: "TSTypeAnnotation",
      typeAnnotation: typeAnnotation,
    });
  }
  function tsTypeParameterInstantiation(params) {
    return (0, _validateNode.default)({
      type: "TSTypeParameterInstantiation",
      params: params,
    });
  }
  function tsTypeParameterDeclaration(params) {
    return (0, _validateNode.default)({
      type: "TSTypeParameterDeclaration",
      params: params,
    });
  }
  function tsTypeParameter(constraint = null, _default = null, name) {
    return (0, _validateNode.default)({
      type: "TSTypeParameter",
      constraint: constraint,
      default: _default,
      name: name,
    });
  }
  function NumberLiteral(value) {
    console.trace(
      "The node type NumberLiteral has been renamed to NumericLiteral"
    );
    return numericLiteral(value);
  }
  function RegexLiteral(pattern, flags = "") {
    console.trace(
      "The node type RegexLiteral has been renamed to RegExpLiteral"
    );
    return regExpLiteral(pattern, flags);
  }
  function RestProperty(argument) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    return restElement(argument);
  }
  function SpreadProperty(argument) {
    console.trace(
      "The node type SpreadProperty has been renamed to SpreadElement"
    );
    return spreadElement(argument);
  }
  return generated$8;
}
var hasRequiredCleanJSXElementLiteralChild$1;
function requireCleanJSXElementLiteralChild$1() {
  if (hasRequiredCleanJSXElementLiteralChild$1)
    return cleanJSXElementLiteralChild$1;
  hasRequiredCleanJSXElementLiteralChild$1 = 1;
  Object.defineProperty(cleanJSXElementLiteralChild$1, "__esModule", {
    value: true,
  });
  cleanJSXElementLiteralChild$1.default = cleanJSXElementLiteralChild;
  var _generated = requireGenerated$5();
  function cleanJSXElementLiteralChild(child, args) {
    const lines = child.value.split(/\r\n|\n|\r/);
    let lastNonEmptyLine = 0;
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].match(/[^ \t]/)) {
        lastNonEmptyLine = i;
      }
    }
    let str = "";
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const isFirstLine = i === 0;
      const isLastLine = i === lines.length - 1;
      const isLastNonEmptyLine = i === lastNonEmptyLine;
      let trimmedLine = line.replace(/\t/g, " ");
      if (!isFirstLine) {
        trimmedLine = trimmedLine.replace(/^[ ]+/, "");
      }
      if (!isLastLine) {
        trimmedLine = trimmedLine.replace(/[ ]+$/, "");
      }
      if (trimmedLine) {
        if (!isLastNonEmptyLine) {
          trimmedLine += " ";
        }
        str += trimmedLine;
      }
    }
    if (str) args.push((0, _generated.stringLiteral)(str));
  }
  return cleanJSXElementLiteralChild$1;
}
var hasRequiredBuildChildren$1;
function requireBuildChildren$1() {
  if (hasRequiredBuildChildren$1) return buildChildren$1;
  hasRequiredBuildChildren$1 = 1;
  Object.defineProperty(buildChildren$1, "__esModule", { value: true });
  buildChildren$1.default = buildChildren;
  var _generated = generated$9;
  var _cleanJSXElementLiteralChild = requireCleanJSXElementLiteralChild$1();
  function buildChildren(node) {
    const elements = [];
    for (let i = 0; i < node.children.length; i++) {
      let child = node.children[i];
      if ((0, _generated.isJSXText)(child)) {
        (0, _cleanJSXElementLiteralChild.default)(child, elements);
        continue;
      }
      if ((0, _generated.isJSXExpressionContainer)(child))
        child = child.expression;
      if ((0, _generated.isJSXEmptyExpression)(child)) continue;
      elements.push(child);
    }
    return elements;
  }
  return buildChildren$1;
}
var assertNode$2 = {};
var isNode$2 = {};
Object.defineProperty(isNode$2, "__esModule", { value: true });
isNode$2.default = isNode$1;
var _definitions$5 = requireDefinitions$1();
function isNode$1(node) {
  return !!(node && _definitions$5.VISITOR_KEYS[node.type]);
}
Object.defineProperty(assertNode$2, "__esModule", { value: true });
assertNode$2.default = assertNode$1;
var _isNode = isNode$2;
function assertNode$1(node) {
  if (!(0, _isNode.default)(node)) {
    var _node$type;
    const type =
      (_node$type = node == null ? void 0 : node.type) != null
        ? _node$type
        : JSON.stringify(node);
    throw new TypeError(`Not a valid node of type "${type}"`);
  }
}
var generated$7 = {};
Object.defineProperty(generated$7, "__esModule", { value: true });
generated$7.assertAccessor = assertAccessor;
generated$7.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
generated$7.assertArgumentPlaceholder = assertArgumentPlaceholder;
generated$7.assertArrayExpression = assertArrayExpression;
generated$7.assertArrayPattern = assertArrayPattern;
generated$7.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
generated$7.assertArrowFunctionExpression = assertArrowFunctionExpression;
generated$7.assertAssignmentExpression = assertAssignmentExpression;
generated$7.assertAssignmentPattern = assertAssignmentPattern;
generated$7.assertAwaitExpression = assertAwaitExpression;
generated$7.assertBigIntLiteral = assertBigIntLiteral;
generated$7.assertBinary = assertBinary;
generated$7.assertBinaryExpression = assertBinaryExpression;
generated$7.assertBindExpression = assertBindExpression;
generated$7.assertBlock = assertBlock;
generated$7.assertBlockParent = assertBlockParent;
generated$7.assertBlockStatement = assertBlockStatement;
generated$7.assertBooleanLiteral = assertBooleanLiteral;
generated$7.assertBooleanLiteralTypeAnnotation =
  assertBooleanLiteralTypeAnnotation;
generated$7.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
generated$7.assertBreakStatement = assertBreakStatement;
generated$7.assertCallExpression = assertCallExpression;
generated$7.assertCatchClause = assertCatchClause;
generated$7.assertClass = assertClass;
generated$7.assertClassAccessorProperty = assertClassAccessorProperty;
generated$7.assertClassBody = assertClassBody;
generated$7.assertClassDeclaration = assertClassDeclaration;
generated$7.assertClassExpression = assertClassExpression;
generated$7.assertClassImplements = assertClassImplements;
generated$7.assertClassMethod = assertClassMethod;
generated$7.assertClassPrivateMethod = assertClassPrivateMethod;
generated$7.assertClassPrivateProperty = assertClassPrivateProperty;
generated$7.assertClassProperty = assertClassProperty;
generated$7.assertCompletionStatement = assertCompletionStatement;
generated$7.assertConditional = assertConditional;
generated$7.assertConditionalExpression = assertConditionalExpression;
generated$7.assertContinueStatement = assertContinueStatement;
generated$7.assertDebuggerStatement = assertDebuggerStatement;
generated$7.assertDecimalLiteral = assertDecimalLiteral;
generated$7.assertDeclaration = assertDeclaration;
generated$7.assertDeclareClass = assertDeclareClass;
generated$7.assertDeclareExportAllDeclaration =
  assertDeclareExportAllDeclaration;
generated$7.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
generated$7.assertDeclareFunction = assertDeclareFunction;
generated$7.assertDeclareInterface = assertDeclareInterface;
generated$7.assertDeclareModule = assertDeclareModule;
generated$7.assertDeclareModuleExports = assertDeclareModuleExports;
generated$7.assertDeclareOpaqueType = assertDeclareOpaqueType;
generated$7.assertDeclareTypeAlias = assertDeclareTypeAlias;
generated$7.assertDeclareVariable = assertDeclareVariable;
generated$7.assertDeclaredPredicate = assertDeclaredPredicate;
generated$7.assertDecorator = assertDecorator;
generated$7.assertDirective = assertDirective;
generated$7.assertDirectiveLiteral = assertDirectiveLiteral;
generated$7.assertDoExpression = assertDoExpression;
generated$7.assertDoWhileStatement = assertDoWhileStatement;
generated$7.assertEmptyStatement = assertEmptyStatement;
generated$7.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
generated$7.assertEnumBody = assertEnumBody;
generated$7.assertEnumBooleanBody = assertEnumBooleanBody;
generated$7.assertEnumBooleanMember = assertEnumBooleanMember;
generated$7.assertEnumDeclaration = assertEnumDeclaration;
generated$7.assertEnumDefaultedMember = assertEnumDefaultedMember;
generated$7.assertEnumMember = assertEnumMember;
generated$7.assertEnumNumberBody = assertEnumNumberBody;
generated$7.assertEnumNumberMember = assertEnumNumberMember;
generated$7.assertEnumStringBody = assertEnumStringBody;
generated$7.assertEnumStringMember = assertEnumStringMember;
generated$7.assertEnumSymbolBody = assertEnumSymbolBody;
generated$7.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
generated$7.assertExportAllDeclaration = assertExportAllDeclaration;
generated$7.assertExportDeclaration = assertExportDeclaration;
generated$7.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
generated$7.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
generated$7.assertExportNamedDeclaration = assertExportNamedDeclaration;
generated$7.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
generated$7.assertExportSpecifier = assertExportSpecifier;
generated$7.assertExpression = assertExpression;
generated$7.assertExpressionStatement = assertExpressionStatement;
generated$7.assertExpressionWrapper = assertExpressionWrapper;
generated$7.assertFile = assertFile;
generated$7.assertFlow = assertFlow;
generated$7.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
generated$7.assertFlowDeclaration = assertFlowDeclaration;
generated$7.assertFlowPredicate = assertFlowPredicate;
generated$7.assertFlowType = assertFlowType;
generated$7.assertFor = assertFor;
generated$7.assertForInStatement = assertForInStatement;
generated$7.assertForOfStatement = assertForOfStatement;
generated$7.assertForStatement = assertForStatement;
generated$7.assertForXStatement = assertForXStatement;
generated$7.assertFunction = assertFunction;
generated$7.assertFunctionDeclaration = assertFunctionDeclaration;
generated$7.assertFunctionExpression = assertFunctionExpression;
generated$7.assertFunctionParent = assertFunctionParent;
generated$7.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
generated$7.assertFunctionTypeParam = assertFunctionTypeParam;
generated$7.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
generated$7.assertIdentifier = assertIdentifier;
generated$7.assertIfStatement = assertIfStatement;
generated$7.assertImmutable = assertImmutable;
generated$7.assertImport = assertImport;
generated$7.assertImportAttribute = assertImportAttribute;
generated$7.assertImportDeclaration = assertImportDeclaration;
generated$7.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
generated$7.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
generated$7.assertImportSpecifier = assertImportSpecifier;
generated$7.assertIndexedAccessType = assertIndexedAccessType;
generated$7.assertInferredPredicate = assertInferredPredicate;
generated$7.assertInterfaceDeclaration = assertInterfaceDeclaration;
generated$7.assertInterfaceExtends = assertInterfaceExtends;
generated$7.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
generated$7.assertInterpreterDirective = assertInterpreterDirective;
generated$7.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
generated$7.assertJSX = assertJSX;
generated$7.assertJSXAttribute = assertJSXAttribute;
generated$7.assertJSXClosingElement = assertJSXClosingElement;
generated$7.assertJSXClosingFragment = assertJSXClosingFragment;
generated$7.assertJSXElement = assertJSXElement;
generated$7.assertJSXEmptyExpression = assertJSXEmptyExpression;
generated$7.assertJSXExpressionContainer = assertJSXExpressionContainer;
generated$7.assertJSXFragment = assertJSXFragment;
generated$7.assertJSXIdentifier = assertJSXIdentifier;
generated$7.assertJSXMemberExpression = assertJSXMemberExpression;
generated$7.assertJSXNamespacedName = assertJSXNamespacedName;
generated$7.assertJSXOpeningElement = assertJSXOpeningElement;
generated$7.assertJSXOpeningFragment = assertJSXOpeningFragment;
generated$7.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
generated$7.assertJSXSpreadChild = assertJSXSpreadChild;
generated$7.assertJSXText = assertJSXText;
generated$7.assertLVal = assertLVal;
generated$7.assertLabeledStatement = assertLabeledStatement;
generated$7.assertLiteral = assertLiteral;
generated$7.assertLogicalExpression = assertLogicalExpression;
generated$7.assertLoop = assertLoop;
generated$7.assertMemberExpression = assertMemberExpression;
generated$7.assertMetaProperty = assertMetaProperty;
generated$7.assertMethod = assertMethod;
generated$7.assertMiscellaneous = assertMiscellaneous;
generated$7.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
generated$7.assertModuleDeclaration = assertModuleDeclaration;
generated$7.assertModuleExpression = assertModuleExpression;
generated$7.assertModuleSpecifier = assertModuleSpecifier;
generated$7.assertNewExpression = assertNewExpression;
generated$7.assertNoop = assertNoop;
generated$7.assertNullLiteral = assertNullLiteral;
generated$7.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
generated$7.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
generated$7.assertNumberLiteral = assertNumberLiteral;
generated$7.assertNumberLiteralTypeAnnotation =
  assertNumberLiteralTypeAnnotation;
generated$7.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
generated$7.assertNumericLiteral = assertNumericLiteral;
generated$7.assertObjectExpression = assertObjectExpression;
generated$7.assertObjectMember = assertObjectMember;
generated$7.assertObjectMethod = assertObjectMethod;
generated$7.assertObjectPattern = assertObjectPattern;
generated$7.assertObjectProperty = assertObjectProperty;
generated$7.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
generated$7.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
generated$7.assertObjectTypeIndexer = assertObjectTypeIndexer;
generated$7.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
generated$7.assertObjectTypeProperty = assertObjectTypeProperty;
generated$7.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
generated$7.assertOpaqueType = assertOpaqueType;
generated$7.assertOptionalCallExpression = assertOptionalCallExpression;
generated$7.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
generated$7.assertOptionalMemberExpression = assertOptionalMemberExpression;
generated$7.assertParenthesizedExpression = assertParenthesizedExpression;
generated$7.assertPattern = assertPattern;
generated$7.assertPatternLike = assertPatternLike;
generated$7.assertPipelineBareFunction = assertPipelineBareFunction;
generated$7.assertPipelinePrimaryTopicReference =
  assertPipelinePrimaryTopicReference;
generated$7.assertPipelineTopicExpression = assertPipelineTopicExpression;
generated$7.assertPlaceholder = assertPlaceholder;
generated$7.assertPrivate = assertPrivate;
generated$7.assertPrivateName = assertPrivateName;
generated$7.assertProgram = assertProgram;
generated$7.assertProperty = assertProperty;
generated$7.assertPureish = assertPureish;
generated$7.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
generated$7.assertRecordExpression = assertRecordExpression;
generated$7.assertRegExpLiteral = assertRegExpLiteral;
generated$7.assertRegexLiteral = assertRegexLiteral;
generated$7.assertRestElement = assertRestElement;
generated$7.assertRestProperty = assertRestProperty;
generated$7.assertReturnStatement = assertReturnStatement;
generated$7.assertScopable = assertScopable;
generated$7.assertSequenceExpression = assertSequenceExpression;
generated$7.assertSpreadElement = assertSpreadElement;
generated$7.assertSpreadProperty = assertSpreadProperty;
generated$7.assertStandardized = assertStandardized;
generated$7.assertStatement = assertStatement;
generated$7.assertStaticBlock = assertStaticBlock;
generated$7.assertStringLiteral = assertStringLiteral;
generated$7.assertStringLiteralTypeAnnotation =
  assertStringLiteralTypeAnnotation;
generated$7.assertStringTypeAnnotation = assertStringTypeAnnotation;
generated$7.assertSuper = assertSuper;
generated$7.assertSwitchCase = assertSwitchCase;
generated$7.assertSwitchStatement = assertSwitchStatement;
generated$7.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
generated$7.assertTSAnyKeyword = assertTSAnyKeyword;
generated$7.assertTSArrayType = assertTSArrayType;
generated$7.assertTSAsExpression = assertTSAsExpression;
generated$7.assertTSBaseType = assertTSBaseType;
generated$7.assertTSBigIntKeyword = assertTSBigIntKeyword;
generated$7.assertTSBooleanKeyword = assertTSBooleanKeyword;
generated$7.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
generated$7.assertTSConditionalType = assertTSConditionalType;
generated$7.assertTSConstructSignatureDeclaration =
  assertTSConstructSignatureDeclaration;
generated$7.assertTSConstructorType = assertTSConstructorType;
generated$7.assertTSDeclareFunction = assertTSDeclareFunction;
generated$7.assertTSDeclareMethod = assertTSDeclareMethod;
generated$7.assertTSEntityName = assertTSEntityName;
generated$7.assertTSEnumDeclaration = assertTSEnumDeclaration;
generated$7.assertTSEnumMember = assertTSEnumMember;
generated$7.assertTSExportAssignment = assertTSExportAssignment;
generated$7.assertTSExpressionWithTypeArguments =
  assertTSExpressionWithTypeArguments;
generated$7.assertTSExternalModuleReference = assertTSExternalModuleReference;
generated$7.assertTSFunctionType = assertTSFunctionType;
generated$7.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
generated$7.assertTSImportType = assertTSImportType;
generated$7.assertTSIndexSignature = assertTSIndexSignature;
generated$7.assertTSIndexedAccessType = assertTSIndexedAccessType;
generated$7.assertTSInferType = assertTSInferType;
generated$7.assertTSInstantiationExpression = assertTSInstantiationExpression;
generated$7.assertTSInterfaceBody = assertTSInterfaceBody;
generated$7.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
generated$7.assertTSIntersectionType = assertTSIntersectionType;
generated$7.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
generated$7.assertTSLiteralType = assertTSLiteralType;
generated$7.assertTSMappedType = assertTSMappedType;
generated$7.assertTSMethodSignature = assertTSMethodSignature;
generated$7.assertTSModuleBlock = assertTSModuleBlock;
generated$7.assertTSModuleDeclaration = assertTSModuleDeclaration;
generated$7.assertTSNamedTupleMember = assertTSNamedTupleMember;
generated$7.assertTSNamespaceExportDeclaration =
  assertTSNamespaceExportDeclaration;
generated$7.assertTSNeverKeyword = assertTSNeverKeyword;
generated$7.assertTSNonNullExpression = assertTSNonNullExpression;
generated$7.assertTSNullKeyword = assertTSNullKeyword;
generated$7.assertTSNumberKeyword = assertTSNumberKeyword;
generated$7.assertTSObjectKeyword = assertTSObjectKeyword;
generated$7.assertTSOptionalType = assertTSOptionalType;
generated$7.assertTSParameterProperty = assertTSParameterProperty;
generated$7.assertTSParenthesizedType = assertTSParenthesizedType;
generated$7.assertTSPropertySignature = assertTSPropertySignature;
generated$7.assertTSQualifiedName = assertTSQualifiedName;
generated$7.assertTSRestType = assertTSRestType;
generated$7.assertTSStringKeyword = assertTSStringKeyword;
generated$7.assertTSSymbolKeyword = assertTSSymbolKeyword;
generated$7.assertTSThisType = assertTSThisType;
generated$7.assertTSTupleType = assertTSTupleType;
generated$7.assertTSType = assertTSType;
generated$7.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
generated$7.assertTSTypeAnnotation = assertTSTypeAnnotation;
generated$7.assertTSTypeAssertion = assertTSTypeAssertion;
generated$7.assertTSTypeElement = assertTSTypeElement;
generated$7.assertTSTypeLiteral = assertTSTypeLiteral;
generated$7.assertTSTypeOperator = assertTSTypeOperator;
generated$7.assertTSTypeParameter = assertTSTypeParameter;
generated$7.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
generated$7.assertTSTypeParameterInstantiation =
  assertTSTypeParameterInstantiation;
generated$7.assertTSTypePredicate = assertTSTypePredicate;
generated$7.assertTSTypeQuery = assertTSTypeQuery;
generated$7.assertTSTypeReference = assertTSTypeReference;
generated$7.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
generated$7.assertTSUnionType = assertTSUnionType;
generated$7.assertTSUnknownKeyword = assertTSUnknownKeyword;
generated$7.assertTSVoidKeyword = assertTSVoidKeyword;
generated$7.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
generated$7.assertTemplateElement = assertTemplateElement;
generated$7.assertTemplateLiteral = assertTemplateLiteral;
generated$7.assertTerminatorless = assertTerminatorless;
generated$7.assertThisExpression = assertThisExpression;
generated$7.assertThisTypeAnnotation = assertThisTypeAnnotation;
generated$7.assertThrowStatement = assertThrowStatement;
generated$7.assertTopicReference = assertTopicReference;
generated$7.assertTryStatement = assertTryStatement;
generated$7.assertTupleExpression = assertTupleExpression;
generated$7.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
generated$7.assertTypeAlias = assertTypeAlias;
generated$7.assertTypeAnnotation = assertTypeAnnotation;
generated$7.assertTypeCastExpression = assertTypeCastExpression;
generated$7.assertTypeParameter = assertTypeParameter;
generated$7.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
generated$7.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
generated$7.assertTypeScript = assertTypeScript;
generated$7.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
generated$7.assertUnaryExpression = assertUnaryExpression;
generated$7.assertUnaryLike = assertUnaryLike;
generated$7.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
generated$7.assertUpdateExpression = assertUpdateExpression;
generated$7.assertUserWhitespacable = assertUserWhitespacable;
generated$7.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
generated$7.assertVariableDeclaration = assertVariableDeclaration;
generated$7.assertVariableDeclarator = assertVariableDeclarator;
generated$7.assertVariance = assertVariance;
generated$7.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
generated$7.assertWhile = assertWhile;
generated$7.assertWhileStatement = assertWhileStatement;
generated$7.assertWithStatement = assertWithStatement;
generated$7.assertYieldExpression = assertYieldExpression;
var _is = requireIs$1();
function assert(type, node, opts) {
  if (!(0, _is.default)(type, node, opts)) {
    throw new Error(
      `Expected type "${type}" with option ${JSON.stringify(opts)}, ` +
        `but instead got "${node.type}".`
    );
  }
}
function assertArrayExpression(node, opts) {
  assert("ArrayExpression", node, opts);
}
function assertAssignmentExpression(node, opts) {
  assert("AssignmentExpression", node, opts);
}
function assertBinaryExpression(node, opts) {
  assert("BinaryExpression", node, opts);
}
function assertInterpreterDirective(node, opts) {
  assert("InterpreterDirective", node, opts);
}
function assertDirective(node, opts) {
  assert("Directive", node, opts);
}
function assertDirectiveLiteral(node, opts) {
  assert("DirectiveLiteral", node, opts);
}
function assertBlockStatement(node, opts) {
  assert("BlockStatement", node, opts);
}
function assertBreakStatement(node, opts) {
  assert("BreakStatement", node, opts);
}
function assertCallExpression(node, opts) {
  assert("CallExpression", node, opts);
}
function assertCatchClause(node, opts) {
  assert("CatchClause", node, opts);
}
function assertConditionalExpression(node, opts) {
  assert("ConditionalExpression", node, opts);
}
function assertContinueStatement(node, opts) {
  assert("ContinueStatement", node, opts);
}
function assertDebuggerStatement(node, opts) {
  assert("DebuggerStatement", node, opts);
}
function assertDoWhileStatement(node, opts) {
  assert("DoWhileStatement", node, opts);
}
function assertEmptyStatement(node, opts) {
  assert("EmptyStatement", node, opts);
}
function assertExpressionStatement(node, opts) {
  assert("ExpressionStatement", node, opts);
}
function assertFile(node, opts) {
  assert("File", node, opts);
}
function assertForInStatement(node, opts) {
  assert("ForInStatement", node, opts);
}
function assertForStatement(node, opts) {
  assert("ForStatement", node, opts);
}
function assertFunctionDeclaration(node, opts) {
  assert("FunctionDeclaration", node, opts);
}
function assertFunctionExpression(node, opts) {
  assert("FunctionExpression", node, opts);
}
function assertIdentifier(node, opts) {
  assert("Identifier", node, opts);
}
function assertIfStatement(node, opts) {
  assert("IfStatement", node, opts);
}
function assertLabeledStatement(node, opts) {
  assert("LabeledStatement", node, opts);
}
function assertStringLiteral(node, opts) {
  assert("StringLiteral", node, opts);
}
function assertNumericLiteral(node, opts) {
  assert("NumericLiteral", node, opts);
}
function assertNullLiteral(node, opts) {
  assert("NullLiteral", node, opts);
}
function assertBooleanLiteral(node, opts) {
  assert("BooleanLiteral", node, opts);
}
function assertRegExpLiteral(node, opts) {
  assert("RegExpLiteral", node, opts);
}
function assertLogicalExpression(node, opts) {
  assert("LogicalExpression", node, opts);
}
function assertMemberExpression(node, opts) {
  assert("MemberExpression", node, opts);
}
function assertNewExpression(node, opts) {
  assert("NewExpression", node, opts);
}
function assertProgram(node, opts) {
  assert("Program", node, opts);
}
function assertObjectExpression(node, opts) {
  assert("ObjectExpression", node, opts);
}
function assertObjectMethod(node, opts) {
  assert("ObjectMethod", node, opts);
}
function assertObjectProperty(node, opts) {
  assert("ObjectProperty", node, opts);
}
function assertRestElement(node, opts) {
  assert("RestElement", node, opts);
}
function assertReturnStatement(node, opts) {
  assert("ReturnStatement", node, opts);
}
function assertSequenceExpression(node, opts) {
  assert("SequenceExpression", node, opts);
}
function assertParenthesizedExpression(node, opts) {
  assert("ParenthesizedExpression", node, opts);
}
function assertSwitchCase(node, opts) {
  assert("SwitchCase", node, opts);
}
function assertSwitchStatement(node, opts) {
  assert("SwitchStatement", node, opts);
}
function assertThisExpression(node, opts) {
  assert("ThisExpression", node, opts);
}
function assertThrowStatement(node, opts) {
  assert("ThrowStatement", node, opts);
}
function assertTryStatement(node, opts) {
  assert("TryStatement", node, opts);
}
function assertUnaryExpression(node, opts) {
  assert("UnaryExpression", node, opts);
}
function assertUpdateExpression(node, opts) {
  assert("UpdateExpression", node, opts);
}
function assertVariableDeclaration(node, opts) {
  assert("VariableDeclaration", node, opts);
}
function assertVariableDeclarator(node, opts) {
  assert("VariableDeclarator", node, opts);
}
function assertWhileStatement(node, opts) {
  assert("WhileStatement", node, opts);
}
function assertWithStatement(node, opts) {
  assert("WithStatement", node, opts);
}
function assertAssignmentPattern(node, opts) {
  assert("AssignmentPattern", node, opts);
}
function assertArrayPattern(node, opts) {
  assert("ArrayPattern", node, opts);
}
function assertArrowFunctionExpression(node, opts) {
  assert("ArrowFunctionExpression", node, opts);
}
function assertClassBody(node, opts) {
  assert("ClassBody", node, opts);
}
function assertClassExpression(node, opts) {
  assert("ClassExpression", node, opts);
}
function assertClassDeclaration(node, opts) {
  assert("ClassDeclaration", node, opts);
}
function assertExportAllDeclaration(node, opts) {
  assert("ExportAllDeclaration", node, opts);
}
function assertExportDefaultDeclaration(node, opts) {
  assert("ExportDefaultDeclaration", node, opts);
}
function assertExportNamedDeclaration(node, opts) {
  assert("ExportNamedDeclaration", node, opts);
}
function assertExportSpecifier(node, opts) {
  assert("ExportSpecifier", node, opts);
}
function assertForOfStatement(node, opts) {
  assert("ForOfStatement", node, opts);
}
function assertImportDeclaration(node, opts) {
  assert("ImportDeclaration", node, opts);
}
function assertImportDefaultSpecifier(node, opts) {
  assert("ImportDefaultSpecifier", node, opts);
}
function assertImportNamespaceSpecifier(node, opts) {
  assert("ImportNamespaceSpecifier", node, opts);
}
function assertImportSpecifier(node, opts) {
  assert("ImportSpecifier", node, opts);
}
function assertMetaProperty(node, opts) {
  assert("MetaProperty", node, opts);
}
function assertClassMethod(node, opts) {
  assert("ClassMethod", node, opts);
}
function assertObjectPattern(node, opts) {
  assert("ObjectPattern", node, opts);
}
function assertSpreadElement(node, opts) {
  assert("SpreadElement", node, opts);
}
function assertSuper(node, opts) {
  assert("Super", node, opts);
}
function assertTaggedTemplateExpression(node, opts) {
  assert("TaggedTemplateExpression", node, opts);
}
function assertTemplateElement(node, opts) {
  assert("TemplateElement", node, opts);
}
function assertTemplateLiteral(node, opts) {
  assert("TemplateLiteral", node, opts);
}
function assertYieldExpression(node, opts) {
  assert("YieldExpression", node, opts);
}
function assertAwaitExpression(node, opts) {
  assert("AwaitExpression", node, opts);
}
function assertImport(node, opts) {
  assert("Import", node, opts);
}
function assertBigIntLiteral(node, opts) {
  assert("BigIntLiteral", node, opts);
}
function assertExportNamespaceSpecifier(node, opts) {
  assert("ExportNamespaceSpecifier", node, opts);
}
function assertOptionalMemberExpression(node, opts) {
  assert("OptionalMemberExpression", node, opts);
}
function assertOptionalCallExpression(node, opts) {
  assert("OptionalCallExpression", node, opts);
}
function assertClassProperty(node, opts) {
  assert("ClassProperty", node, opts);
}
function assertClassAccessorProperty(node, opts) {
  assert("ClassAccessorProperty", node, opts);
}
function assertClassPrivateProperty(node, opts) {
  assert("ClassPrivateProperty", node, opts);
}
function assertClassPrivateMethod(node, opts) {
  assert("ClassPrivateMethod", node, opts);
}
function assertPrivateName(node, opts) {
  assert("PrivateName", node, opts);
}
function assertStaticBlock(node, opts) {
  assert("StaticBlock", node, opts);
}
function assertAnyTypeAnnotation(node, opts) {
  assert("AnyTypeAnnotation", node, opts);
}
function assertArrayTypeAnnotation(node, opts) {
  assert("ArrayTypeAnnotation", node, opts);
}
function assertBooleanTypeAnnotation(node, opts) {
  assert("BooleanTypeAnnotation", node, opts);
}
function assertBooleanLiteralTypeAnnotation(node, opts) {
  assert("BooleanLiteralTypeAnnotation", node, opts);
}
function assertNullLiteralTypeAnnotation(node, opts) {
  assert("NullLiteralTypeAnnotation", node, opts);
}
function assertClassImplements(node, opts) {
  assert("ClassImplements", node, opts);
}
function assertDeclareClass(node, opts) {
  assert("DeclareClass", node, opts);
}
function assertDeclareFunction(node, opts) {
  assert("DeclareFunction", node, opts);
}
function assertDeclareInterface(node, opts) {
  assert("DeclareInterface", node, opts);
}
function assertDeclareModule(node, opts) {
  assert("DeclareModule", node, opts);
}
function assertDeclareModuleExports(node, opts) {
  assert("DeclareModuleExports", node, opts);
}
function assertDeclareTypeAlias(node, opts) {
  assert("DeclareTypeAlias", node, opts);
}
function assertDeclareOpaqueType(node, opts) {
  assert("DeclareOpaqueType", node, opts);
}
function assertDeclareVariable(node, opts) {
  assert("DeclareVariable", node, opts);
}
function assertDeclareExportDeclaration(node, opts) {
  assert("DeclareExportDeclaration", node, opts);
}
function assertDeclareExportAllDeclaration(node, opts) {
  assert("DeclareExportAllDeclaration", node, opts);
}
function assertDeclaredPredicate(node, opts) {
  assert("DeclaredPredicate", node, opts);
}
function assertExistsTypeAnnotation(node, opts) {
  assert("ExistsTypeAnnotation", node, opts);
}
function assertFunctionTypeAnnotation(node, opts) {
  assert("FunctionTypeAnnotation", node, opts);
}
function assertFunctionTypeParam(node, opts) {
  assert("FunctionTypeParam", node, opts);
}
function assertGenericTypeAnnotation(node, opts) {
  assert("GenericTypeAnnotation", node, opts);
}
function assertInferredPredicate(node, opts) {
  assert("InferredPredicate", node, opts);
}
function assertInterfaceExtends(node, opts) {
  assert("InterfaceExtends", node, opts);
}
function assertInterfaceDeclaration(node, opts) {
  assert("InterfaceDeclaration", node, opts);
}
function assertInterfaceTypeAnnotation(node, opts) {
  assert("InterfaceTypeAnnotation", node, opts);
}
function assertIntersectionTypeAnnotation(node, opts) {
  assert("IntersectionTypeAnnotation", node, opts);
}
function assertMixedTypeAnnotation(node, opts) {
  assert("MixedTypeAnnotation", node, opts);
}
function assertEmptyTypeAnnotation(node, opts) {
  assert("EmptyTypeAnnotation", node, opts);
}
function assertNullableTypeAnnotation(node, opts) {
  assert("NullableTypeAnnotation", node, opts);
}
function assertNumberLiteralTypeAnnotation(node, opts) {
  assert("NumberLiteralTypeAnnotation", node, opts);
}
function assertNumberTypeAnnotation(node, opts) {
  assert("NumberTypeAnnotation", node, opts);
}
function assertObjectTypeAnnotation(node, opts) {
  assert("ObjectTypeAnnotation", node, opts);
}
function assertObjectTypeInternalSlot(node, opts) {
  assert("ObjectTypeInternalSlot", node, opts);
}
function assertObjectTypeCallProperty(node, opts) {
  assert("ObjectTypeCallProperty", node, opts);
}
function assertObjectTypeIndexer(node, opts) {
  assert("ObjectTypeIndexer", node, opts);
}
function assertObjectTypeProperty(node, opts) {
  assert("ObjectTypeProperty", node, opts);
}
function assertObjectTypeSpreadProperty(node, opts) {
  assert("ObjectTypeSpreadProperty", node, opts);
}
function assertOpaqueType(node, opts) {
  assert("OpaqueType", node, opts);
}
function assertQualifiedTypeIdentifier(node, opts) {
  assert("QualifiedTypeIdentifier", node, opts);
}
function assertStringLiteralTypeAnnotation(node, opts) {
  assert("StringLiteralTypeAnnotation", node, opts);
}
function assertStringTypeAnnotation(node, opts) {
  assert("StringTypeAnnotation", node, opts);
}
function assertSymbolTypeAnnotation(node, opts) {
  assert("SymbolTypeAnnotation", node, opts);
}
function assertThisTypeAnnotation(node, opts) {
  assert("ThisTypeAnnotation", node, opts);
}
function assertTupleTypeAnnotation(node, opts) {
  assert("TupleTypeAnnotation", node, opts);
}
function assertTypeofTypeAnnotation(node, opts) {
  assert("TypeofTypeAnnotation", node, opts);
}
function assertTypeAlias(node, opts) {
  assert("TypeAlias", node, opts);
}
function assertTypeAnnotation(node, opts) {
  assert("TypeAnnotation", node, opts);
}
function assertTypeCastExpression(node, opts) {
  assert("TypeCastExpression", node, opts);
}
function assertTypeParameter(node, opts) {
  assert("TypeParameter", node, opts);
}
function assertTypeParameterDeclaration(node, opts) {
  assert("TypeParameterDeclaration", node, opts);
}
function assertTypeParameterInstantiation(node, opts) {
  assert("TypeParameterInstantiation", node, opts);
}
function assertUnionTypeAnnotation(node, opts) {
  assert("UnionTypeAnnotation", node, opts);
}
function assertVariance(node, opts) {
  assert("Variance", node, opts);
}
function assertVoidTypeAnnotation(node, opts) {
  assert("VoidTypeAnnotation", node, opts);
}
function assertEnumDeclaration(node, opts) {
  assert("EnumDeclaration", node, opts);
}
function assertEnumBooleanBody(node, opts) {
  assert("EnumBooleanBody", node, opts);
}
function assertEnumNumberBody(node, opts) {
  assert("EnumNumberBody", node, opts);
}
function assertEnumStringBody(node, opts) {
  assert("EnumStringBody", node, opts);
}
function assertEnumSymbolBody(node, opts) {
  assert("EnumSymbolBody", node, opts);
}
function assertEnumBooleanMember(node, opts) {
  assert("EnumBooleanMember", node, opts);
}
function assertEnumNumberMember(node, opts) {
  assert("EnumNumberMember", node, opts);
}
function assertEnumStringMember(node, opts) {
  assert("EnumStringMember", node, opts);
}
function assertEnumDefaultedMember(node, opts) {
  assert("EnumDefaultedMember", node, opts);
}
function assertIndexedAccessType(node, opts) {
  assert("IndexedAccessType", node, opts);
}
function assertOptionalIndexedAccessType(node, opts) {
  assert("OptionalIndexedAccessType", node, opts);
}
function assertJSXAttribute(node, opts) {
  assert("JSXAttribute", node, opts);
}
function assertJSXClosingElement(node, opts) {
  assert("JSXClosingElement", node, opts);
}
function assertJSXElement(node, opts) {
  assert("JSXElement", node, opts);
}
function assertJSXEmptyExpression(node, opts) {
  assert("JSXEmptyExpression", node, opts);
}
function assertJSXExpressionContainer(node, opts) {
  assert("JSXExpressionContainer", node, opts);
}
function assertJSXSpreadChild(node, opts) {
  assert("JSXSpreadChild", node, opts);
}
function assertJSXIdentifier(node, opts) {
  assert("JSXIdentifier", node, opts);
}
function assertJSXMemberExpression(node, opts) {
  assert("JSXMemberExpression", node, opts);
}
function assertJSXNamespacedName(node, opts) {
  assert("JSXNamespacedName", node, opts);
}
function assertJSXOpeningElement(node, opts) {
  assert("JSXOpeningElement", node, opts);
}
function assertJSXSpreadAttribute(node, opts) {
  assert("JSXSpreadAttribute", node, opts);
}
function assertJSXText(node, opts) {
  assert("JSXText", node, opts);
}
function assertJSXFragment(node, opts) {
  assert("JSXFragment", node, opts);
}
function assertJSXOpeningFragment(node, opts) {
  assert("JSXOpeningFragment", node, opts);
}
function assertJSXClosingFragment(node, opts) {
  assert("JSXClosingFragment", node, opts);
}
function assertNoop(node, opts) {
  assert("Noop", node, opts);
}
function assertPlaceholder(node, opts) {
  assert("Placeholder", node, opts);
}
function assertV8IntrinsicIdentifier(node, opts) {
  assert("V8IntrinsicIdentifier", node, opts);
}
function assertArgumentPlaceholder(node, opts) {
  assert("ArgumentPlaceholder", node, opts);
}
function assertBindExpression(node, opts) {
  assert("BindExpression", node, opts);
}
function assertImportAttribute(node, opts) {
  assert("ImportAttribute", node, opts);
}
function assertDecorator(node, opts) {
  assert("Decorator", node, opts);
}
function assertDoExpression(node, opts) {
  assert("DoExpression", node, opts);
}
function assertExportDefaultSpecifier(node, opts) {
  assert("ExportDefaultSpecifier", node, opts);
}
function assertRecordExpression(node, opts) {
  assert("RecordExpression", node, opts);
}
function assertTupleExpression(node, opts) {
  assert("TupleExpression", node, opts);
}
function assertDecimalLiteral(node, opts) {
  assert("DecimalLiteral", node, opts);
}
function assertModuleExpression(node, opts) {
  assert("ModuleExpression", node, opts);
}
function assertTopicReference(node, opts) {
  assert("TopicReference", node, opts);
}
function assertPipelineTopicExpression(node, opts) {
  assert("PipelineTopicExpression", node, opts);
}
function assertPipelineBareFunction(node, opts) {
  assert("PipelineBareFunction", node, opts);
}
function assertPipelinePrimaryTopicReference(node, opts) {
  assert("PipelinePrimaryTopicReference", node, opts);
}
function assertTSParameterProperty(node, opts) {
  assert("TSParameterProperty", node, opts);
}
function assertTSDeclareFunction(node, opts) {
  assert("TSDeclareFunction", node, opts);
}
function assertTSDeclareMethod(node, opts) {
  assert("TSDeclareMethod", node, opts);
}
function assertTSQualifiedName(node, opts) {
  assert("TSQualifiedName", node, opts);
}
function assertTSCallSignatureDeclaration(node, opts) {
  assert("TSCallSignatureDeclaration", node, opts);
}
function assertTSConstructSignatureDeclaration(node, opts) {
  assert("TSConstructSignatureDeclaration", node, opts);
}
function assertTSPropertySignature(node, opts) {
  assert("TSPropertySignature", node, opts);
}
function assertTSMethodSignature(node, opts) {
  assert("TSMethodSignature", node, opts);
}
function assertTSIndexSignature(node, opts) {
  assert("TSIndexSignature", node, opts);
}
function assertTSAnyKeyword(node, opts) {
  assert("TSAnyKeyword", node, opts);
}
function assertTSBooleanKeyword(node, opts) {
  assert("TSBooleanKeyword", node, opts);
}
function assertTSBigIntKeyword(node, opts) {
  assert("TSBigIntKeyword", node, opts);
}
function assertTSIntrinsicKeyword(node, opts) {
  assert("TSIntrinsicKeyword", node, opts);
}
function assertTSNeverKeyword(node, opts) {
  assert("TSNeverKeyword", node, opts);
}
function assertTSNullKeyword(node, opts) {
  assert("TSNullKeyword", node, opts);
}
function assertTSNumberKeyword(node, opts) {
  assert("TSNumberKeyword", node, opts);
}
function assertTSObjectKeyword(node, opts) {
  assert("TSObjectKeyword", node, opts);
}
function assertTSStringKeyword(node, opts) {
  assert("TSStringKeyword", node, opts);
}
function assertTSSymbolKeyword(node, opts) {
  assert("TSSymbolKeyword", node, opts);
}
function assertTSUndefinedKeyword(node, opts) {
  assert("TSUndefinedKeyword", node, opts);
}
function assertTSUnknownKeyword(node, opts) {
  assert("TSUnknownKeyword", node, opts);
}
function assertTSVoidKeyword(node, opts) {
  assert("TSVoidKeyword", node, opts);
}
function assertTSThisType(node, opts) {
  assert("TSThisType", node, opts);
}
function assertTSFunctionType(node, opts) {
  assert("TSFunctionType", node, opts);
}
function assertTSConstructorType(node, opts) {
  assert("TSConstructorType", node, opts);
}
function assertTSTypeReference(node, opts) {
  assert("TSTypeReference", node, opts);
}
function assertTSTypePredicate(node, opts) {
  assert("TSTypePredicate", node, opts);
}
function assertTSTypeQuery(node, opts) {
  assert("TSTypeQuery", node, opts);
}
function assertTSTypeLiteral(node, opts) {
  assert("TSTypeLiteral", node, opts);
}
function assertTSArrayType(node, opts) {
  assert("TSArrayType", node, opts);
}
function assertTSTupleType(node, opts) {
  assert("TSTupleType", node, opts);
}
function assertTSOptionalType(node, opts) {
  assert("TSOptionalType", node, opts);
}
function assertTSRestType(node, opts) {
  assert("TSRestType", node, opts);
}
function assertTSNamedTupleMember(node, opts) {
  assert("TSNamedTupleMember", node, opts);
}
function assertTSUnionType(node, opts) {
  assert("TSUnionType", node, opts);
}
function assertTSIntersectionType(node, opts) {
  assert("TSIntersectionType", node, opts);
}
function assertTSConditionalType(node, opts) {
  assert("TSConditionalType", node, opts);
}
function assertTSInferType(node, opts) {
  assert("TSInferType", node, opts);
}
function assertTSParenthesizedType(node, opts) {
  assert("TSParenthesizedType", node, opts);
}
function assertTSTypeOperator(node, opts) {
  assert("TSTypeOperator", node, opts);
}
function assertTSIndexedAccessType(node, opts) {
  assert("TSIndexedAccessType", node, opts);
}
function assertTSMappedType(node, opts) {
  assert("TSMappedType", node, opts);
}
function assertTSLiteralType(node, opts) {
  assert("TSLiteralType", node, opts);
}
function assertTSExpressionWithTypeArguments(node, opts) {
  assert("TSExpressionWithTypeArguments", node, opts);
}
function assertTSInterfaceDeclaration(node, opts) {
  assert("TSInterfaceDeclaration", node, opts);
}
function assertTSInterfaceBody(node, opts) {
  assert("TSInterfaceBody", node, opts);
}
function assertTSTypeAliasDeclaration(node, opts) {
  assert("TSTypeAliasDeclaration", node, opts);
}
function assertTSInstantiationExpression(node, opts) {
  assert("TSInstantiationExpression", node, opts);
}
function assertTSAsExpression(node, opts) {
  assert("TSAsExpression", node, opts);
}
function assertTSTypeAssertion(node, opts) {
  assert("TSTypeAssertion", node, opts);
}
function assertTSEnumDeclaration(node, opts) {
  assert("TSEnumDeclaration", node, opts);
}
function assertTSEnumMember(node, opts) {
  assert("TSEnumMember", node, opts);
}
function assertTSModuleDeclaration(node, opts) {
  assert("TSModuleDeclaration", node, opts);
}
function assertTSModuleBlock(node, opts) {
  assert("TSModuleBlock", node, opts);
}
function assertTSImportType(node, opts) {
  assert("TSImportType", node, opts);
}
function assertTSImportEqualsDeclaration(node, opts) {
  assert("TSImportEqualsDeclaration", node, opts);
}
function assertTSExternalModuleReference(node, opts) {
  assert("TSExternalModuleReference", node, opts);
}
function assertTSNonNullExpression(node, opts) {
  assert("TSNonNullExpression", node, opts);
}
function assertTSExportAssignment(node, opts) {
  assert("TSExportAssignment", node, opts);
}
function assertTSNamespaceExportDeclaration(node, opts) {
  assert("TSNamespaceExportDeclaration", node, opts);
}
function assertTSTypeAnnotation(node, opts) {
  assert("TSTypeAnnotation", node, opts);
}
function assertTSTypeParameterInstantiation(node, opts) {
  assert("TSTypeParameterInstantiation", node, opts);
}
function assertTSTypeParameterDeclaration(node, opts) {
  assert("TSTypeParameterDeclaration", node, opts);
}
function assertTSTypeParameter(node, opts) {
  assert("TSTypeParameter", node, opts);
}
function assertStandardized(node, opts) {
  assert("Standardized", node, opts);
}
function assertExpression(node, opts) {
  assert("Expression", node, opts);
}
function assertBinary(node, opts) {
  assert("Binary", node, opts);
}
function assertScopable(node, opts) {
  assert("Scopable", node, opts);
}
function assertBlockParent(node, opts) {
  assert("BlockParent", node, opts);
}
function assertBlock(node, opts) {
  assert("Block", node, opts);
}
function assertStatement(node, opts) {
  assert("Statement", node, opts);
}
function assertTerminatorless(node, opts) {
  assert("Terminatorless", node, opts);
}
function assertCompletionStatement(node, opts) {
  assert("CompletionStatement", node, opts);
}
function assertConditional(node, opts) {
  assert("Conditional", node, opts);
}
function assertLoop(node, opts) {
  assert("Loop", node, opts);
}
function assertWhile(node, opts) {
  assert("While", node, opts);
}
function assertExpressionWrapper(node, opts) {
  assert("ExpressionWrapper", node, opts);
}
function assertFor(node, opts) {
  assert("For", node, opts);
}
function assertForXStatement(node, opts) {
  assert("ForXStatement", node, opts);
}
function assertFunction(node, opts) {
  assert("Function", node, opts);
}
function assertFunctionParent(node, opts) {
  assert("FunctionParent", node, opts);
}
function assertPureish(node, opts) {
  assert("Pureish", node, opts);
}
function assertDeclaration(node, opts) {
  assert("Declaration", node, opts);
}
function assertPatternLike(node, opts) {
  assert("PatternLike", node, opts);
}
function assertLVal(node, opts) {
  assert("LVal", node, opts);
}
function assertTSEntityName(node, opts) {
  assert("TSEntityName", node, opts);
}
function assertLiteral(node, opts) {
  assert("Literal", node, opts);
}
function assertImmutable(node, opts) {
  assert("Immutable", node, opts);
}
function assertUserWhitespacable(node, opts) {
  assert("UserWhitespacable", node, opts);
}
function assertMethod(node, opts) {
  assert("Method", node, opts);
}
function assertObjectMember(node, opts) {
  assert("ObjectMember", node, opts);
}
function assertProperty(node, opts) {
  assert("Property", node, opts);
}
function assertUnaryLike(node, opts) {
  assert("UnaryLike", node, opts);
}
function assertPattern(node, opts) {
  assert("Pattern", node, opts);
}
function assertClass(node, opts) {
  assert("Class", node, opts);
}
function assertModuleDeclaration(node, opts) {
  assert("ModuleDeclaration", node, opts);
}
function assertExportDeclaration(node, opts) {
  assert("ExportDeclaration", node, opts);
}
function assertModuleSpecifier(node, opts) {
  assert("ModuleSpecifier", node, opts);
}
function assertAccessor(node, opts) {
  assert("Accessor", node, opts);
}
function assertPrivate(node, opts) {
  assert("Private", node, opts);
}
function assertFlow(node, opts) {
  assert("Flow", node, opts);
}
function assertFlowType(node, opts) {
  assert("FlowType", node, opts);
}
function assertFlowBaseAnnotation(node, opts) {
  assert("FlowBaseAnnotation", node, opts);
}
function assertFlowDeclaration(node, opts) {
  assert("FlowDeclaration", node, opts);
}
function assertFlowPredicate(node, opts) {
  assert("FlowPredicate", node, opts);
}
function assertEnumBody(node, opts) {
  assert("EnumBody", node, opts);
}
function assertEnumMember(node, opts) {
  assert("EnumMember", node, opts);
}
function assertJSX(node, opts) {
  assert("JSX", node, opts);
}
function assertMiscellaneous(node, opts) {
  assert("Miscellaneous", node, opts);
}
function assertTypeScript(node, opts) {
  assert("TypeScript", node, opts);
}
function assertTSTypeElement(node, opts) {
  assert("TSTypeElement", node, opts);
}
function assertTSType(node, opts) {
  assert("TSType", node, opts);
}
function assertTSBaseType(node, opts) {
  assert("TSBaseType", node, opts);
}
function assertNumberLiteral(node, opts) {
  console.trace(
    "The node type NumberLiteral has been renamed to NumericLiteral"
  );
  assert("NumberLiteral", node, opts);
}
function assertRegexLiteral(node, opts) {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  assert("RegexLiteral", node, opts);
}
function assertRestProperty(node, opts) {
  console.trace("The node type RestProperty has been renamed to RestElement");
  assert("RestProperty", node, opts);
}
function assertSpreadProperty(node, opts) {
  console.trace(
    "The node type SpreadProperty has been renamed to SpreadElement"
  );
  assert("SpreadProperty", node, opts);
}
var createTypeAnnotationBasedOnTypeof$1 = {};
var hasRequiredCreateTypeAnnotationBasedOnTypeof$1;
function requireCreateTypeAnnotationBasedOnTypeof$1() {
  if (hasRequiredCreateTypeAnnotationBasedOnTypeof$1)
    return createTypeAnnotationBasedOnTypeof$1;
  hasRequiredCreateTypeAnnotationBasedOnTypeof$1 = 1;
  Object.defineProperty(createTypeAnnotationBasedOnTypeof$1, "__esModule", {
    value: true,
  });
  createTypeAnnotationBasedOnTypeof$1.default = void 0;
  var _generated = requireGenerated$5();
  var _default = createTypeAnnotationBasedOnTypeof;
  createTypeAnnotationBasedOnTypeof$1.default = _default;
  function createTypeAnnotationBasedOnTypeof(type) {
    switch (type) {
      case "string":
        return (0, _generated.stringTypeAnnotation)();
      case "number":
        return (0, _generated.numberTypeAnnotation)();
      case "undefined":
        return (0, _generated.voidTypeAnnotation)();
      case "boolean":
        return (0, _generated.booleanTypeAnnotation)();
      case "function":
        return (0, _generated.genericTypeAnnotation)(
          (0, _generated.identifier)("Function")
        );
      case "object":
        return (0, _generated.genericTypeAnnotation)(
          (0, _generated.identifier)("Object")
        );
      case "symbol":
        return (0, _generated.genericTypeAnnotation)(
          (0, _generated.identifier)("Symbol")
        );
      case "bigint":
        return (0, _generated.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + type);
  }
  return createTypeAnnotationBasedOnTypeof$1;
}
var createFlowUnionType$1 = {};
var removeTypeDuplicates$5 = {};
Object.defineProperty(removeTypeDuplicates$5, "__esModule", { value: true });
removeTypeDuplicates$5.default = removeTypeDuplicates$4;
var _generated$b = generated$9;
function getQualifiedName$1(node) {
  return (0, _generated$b.isIdentifier)(node)
    ? node.name
    : `${node.id.name}.${getQualifiedName$1(node.qualification)}`;
}
function removeTypeDuplicates$4(nodes) {
  const generics = new Map();
  const bases = new Map();
  const typeGroups = new Set();
  const types = [];
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (!node) continue;
    if (types.indexOf(node) >= 0) {
      continue;
    }
    if ((0, _generated$b.isAnyTypeAnnotation)(node)) {
      return [node];
    }
    if ((0, _generated$b.isFlowBaseAnnotation)(node)) {
      bases.set(node.type, node);
      continue;
    }
    if ((0, _generated$b.isUnionTypeAnnotation)(node)) {
      if (!typeGroups.has(node.types)) {
        nodes = nodes.concat(node.types);
        typeGroups.add(node.types);
      }
      continue;
    }
    if ((0, _generated$b.isGenericTypeAnnotation)(node)) {
      const name = getQualifiedName$1(node.id);
      if (generics.has(name)) {
        let existing = generics.get(name);
        if (existing.typeParameters) {
          if (node.typeParameters) {
            existing.typeParameters.params = removeTypeDuplicates$4(
              existing.typeParameters.params.concat(node.typeParameters.params)
            );
          }
        } else {
          existing = node.typeParameters;
        }
      } else {
        generics.set(name, node);
      }
      continue;
    }
    types.push(node);
  }
  for (const [, baseType] of bases) {
    types.push(baseType);
  }
  for (const [, genericName] of generics) {
    types.push(genericName);
  }
  return types;
}
var hasRequiredCreateFlowUnionType$1;
function requireCreateFlowUnionType$1() {
  if (hasRequiredCreateFlowUnionType$1) return createFlowUnionType$1;
  hasRequiredCreateFlowUnionType$1 = 1;
  Object.defineProperty(createFlowUnionType$1, "__esModule", { value: true });
  createFlowUnionType$1.default = createFlowUnionType;
  var _generated = requireGenerated$5();
  var _removeTypeDuplicates = removeTypeDuplicates$5;
  function createFlowUnionType(types) {
    const flattened = (0, _removeTypeDuplicates.default)(types);
    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return (0, _generated.unionTypeAnnotation)(flattened);
    }
  }
  return createFlowUnionType$1;
}
var createTSUnionType$1 = {};
var removeTypeDuplicates$3 = {};
Object.defineProperty(removeTypeDuplicates$3, "__esModule", { value: true });
removeTypeDuplicates$3.default = removeTypeDuplicates$2;
var _generated$a = generated$9;
function getQualifiedName(node) {
  return (0, _generated$a.isIdentifier)(node)
    ? node.name
    : `${node.right.name}.${getQualifiedName(node.left)}`;
}
function removeTypeDuplicates$2(nodes) {
  const generics = new Map();
  const bases = new Map();
  const typeGroups = new Set();
  const types = [];
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (!node) continue;
    if (types.indexOf(node) >= 0) {
      continue;
    }
    if ((0, _generated$a.isTSAnyKeyword)(node)) {
      return [node];
    }
    if ((0, _generated$a.isTSBaseType)(node)) {
      bases.set(node.type, node);
      continue;
    }
    if ((0, _generated$a.isTSUnionType)(node)) {
      if (!typeGroups.has(node.types)) {
        nodes.push(...node.types);
        typeGroups.add(node.types);
      }
      continue;
    }
    if ((0, _generated$a.isTSTypeReference)(node) && node.typeParameters) {
      const name = getQualifiedName(node.typeName);
      if (generics.has(name)) {
        let existing = generics.get(name);
        if (existing.typeParameters) {
          if (node.typeParameters) {
            existing.typeParameters.params = removeTypeDuplicates$2(
              existing.typeParameters.params.concat(node.typeParameters.params)
            );
          }
        } else {
          existing = node.typeParameters;
        }
      } else {
        generics.set(name, node);
      }
      continue;
    }
    types.push(node);
  }
  for (const [, baseType] of bases) {
    types.push(baseType);
  }
  for (const [, genericName] of generics) {
    types.push(genericName);
  }
  return types;
}
var hasRequiredCreateTSUnionType$1;
function requireCreateTSUnionType$1() {
  if (hasRequiredCreateTSUnionType$1) return createTSUnionType$1;
  hasRequiredCreateTSUnionType$1 = 1;
  Object.defineProperty(createTSUnionType$1, "__esModule", { value: true });
  createTSUnionType$1.default = createTSUnionType;
  var _generated = requireGenerated$5();
  var _removeTypeDuplicates = removeTypeDuplicates$3;
  var _index = generated$9;
  function createTSUnionType(typeAnnotations) {
    const types = typeAnnotations.map((type) =>
      (0, _index.isTSTypeAnnotation)(type) ? type.typeAnnotation : type
    );
    const flattened = (0, _removeTypeDuplicates.default)(types);
    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return (0, _generated.tsUnionType)(flattened);
    }
  }
  return createTSUnionType$1;
}
var uppercase$1 = {};
var hasRequiredUppercase$1;
function requireUppercase$1() {
  if (hasRequiredUppercase$1) return uppercase$1;
  hasRequiredUppercase$1 = 1;
  (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "AnyTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.anyTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "ArgumentPlaceholder", {
      enumerable: true,
      get: function () {
        return _index.argumentPlaceholder;
      },
    });
    Object.defineProperty(exports, "ArrayExpression", {
      enumerable: true,
      get: function () {
        return _index.arrayExpression;
      },
    });
    Object.defineProperty(exports, "ArrayPattern", {
      enumerable: true,
      get: function () {
        return _index.arrayPattern;
      },
    });
    Object.defineProperty(exports, "ArrayTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.arrayTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "ArrowFunctionExpression", {
      enumerable: true,
      get: function () {
        return _index.arrowFunctionExpression;
      },
    });
    Object.defineProperty(exports, "AssignmentExpression", {
      enumerable: true,
      get: function () {
        return _index.assignmentExpression;
      },
    });
    Object.defineProperty(exports, "AssignmentPattern", {
      enumerable: true,
      get: function () {
        return _index.assignmentPattern;
      },
    });
    Object.defineProperty(exports, "AwaitExpression", {
      enumerable: true,
      get: function () {
        return _index.awaitExpression;
      },
    });
    Object.defineProperty(exports, "BigIntLiteral", {
      enumerable: true,
      get: function () {
        return _index.bigIntLiteral;
      },
    });
    Object.defineProperty(exports, "BinaryExpression", {
      enumerable: true,
      get: function () {
        return _index.binaryExpression;
      },
    });
    Object.defineProperty(exports, "BindExpression", {
      enumerable: true,
      get: function () {
        return _index.bindExpression;
      },
    });
    Object.defineProperty(exports, "BlockStatement", {
      enumerable: true,
      get: function () {
        return _index.blockStatement;
      },
    });
    Object.defineProperty(exports, "BooleanLiteral", {
      enumerable: true,
      get: function () {
        return _index.booleanLiteral;
      },
    });
    Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.booleanLiteralTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "BooleanTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.booleanTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "BreakStatement", {
      enumerable: true,
      get: function () {
        return _index.breakStatement;
      },
    });
    Object.defineProperty(exports, "CallExpression", {
      enumerable: true,
      get: function () {
        return _index.callExpression;
      },
    });
    Object.defineProperty(exports, "CatchClause", {
      enumerable: true,
      get: function () {
        return _index.catchClause;
      },
    });
    Object.defineProperty(exports, "ClassAccessorProperty", {
      enumerable: true,
      get: function () {
        return _index.classAccessorProperty;
      },
    });
    Object.defineProperty(exports, "ClassBody", {
      enumerable: true,
      get: function () {
        return _index.classBody;
      },
    });
    Object.defineProperty(exports, "ClassDeclaration", {
      enumerable: true,
      get: function () {
        return _index.classDeclaration;
      },
    });
    Object.defineProperty(exports, "ClassExpression", {
      enumerable: true,
      get: function () {
        return _index.classExpression;
      },
    });
    Object.defineProperty(exports, "ClassImplements", {
      enumerable: true,
      get: function () {
        return _index.classImplements;
      },
    });
    Object.defineProperty(exports, "ClassMethod", {
      enumerable: true,
      get: function () {
        return _index.classMethod;
      },
    });
    Object.defineProperty(exports, "ClassPrivateMethod", {
      enumerable: true,
      get: function () {
        return _index.classPrivateMethod;
      },
    });
    Object.defineProperty(exports, "ClassPrivateProperty", {
      enumerable: true,
      get: function () {
        return _index.classPrivateProperty;
      },
    });
    Object.defineProperty(exports, "ClassProperty", {
      enumerable: true,
      get: function () {
        return _index.classProperty;
      },
    });
    Object.defineProperty(exports, "ConditionalExpression", {
      enumerable: true,
      get: function () {
        return _index.conditionalExpression;
      },
    });
    Object.defineProperty(exports, "ContinueStatement", {
      enumerable: true,
      get: function () {
        return _index.continueStatement;
      },
    });
    Object.defineProperty(exports, "DebuggerStatement", {
      enumerable: true,
      get: function () {
        return _index.debuggerStatement;
      },
    });
    Object.defineProperty(exports, "DecimalLiteral", {
      enumerable: true,
      get: function () {
        return _index.decimalLiteral;
      },
    });
    Object.defineProperty(exports, "DeclareClass", {
      enumerable: true,
      get: function () {
        return _index.declareClass;
      },
    });
    Object.defineProperty(exports, "DeclareExportAllDeclaration", {
      enumerable: true,
      get: function () {
        return _index.declareExportAllDeclaration;
      },
    });
    Object.defineProperty(exports, "DeclareExportDeclaration", {
      enumerable: true,
      get: function () {
        return _index.declareExportDeclaration;
      },
    });
    Object.defineProperty(exports, "DeclareFunction", {
      enumerable: true,
      get: function () {
        return _index.declareFunction;
      },
    });
    Object.defineProperty(exports, "DeclareInterface", {
      enumerable: true,
      get: function () {
        return _index.declareInterface;
      },
    });
    Object.defineProperty(exports, "DeclareModule", {
      enumerable: true,
      get: function () {
        return _index.declareModule;
      },
    });
    Object.defineProperty(exports, "DeclareModuleExports", {
      enumerable: true,
      get: function () {
        return _index.declareModuleExports;
      },
    });
    Object.defineProperty(exports, "DeclareOpaqueType", {
      enumerable: true,
      get: function () {
        return _index.declareOpaqueType;
      },
    });
    Object.defineProperty(exports, "DeclareTypeAlias", {
      enumerable: true,
      get: function () {
        return _index.declareTypeAlias;
      },
    });
    Object.defineProperty(exports, "DeclareVariable", {
      enumerable: true,
      get: function () {
        return _index.declareVariable;
      },
    });
    Object.defineProperty(exports, "DeclaredPredicate", {
      enumerable: true,
      get: function () {
        return _index.declaredPredicate;
      },
    });
    Object.defineProperty(exports, "Decorator", {
      enumerable: true,
      get: function () {
        return _index.decorator;
      },
    });
    Object.defineProperty(exports, "Directive", {
      enumerable: true,
      get: function () {
        return _index.directive;
      },
    });
    Object.defineProperty(exports, "DirectiveLiteral", {
      enumerable: true,
      get: function () {
        return _index.directiveLiteral;
      },
    });
    Object.defineProperty(exports, "DoExpression", {
      enumerable: true,
      get: function () {
        return _index.doExpression;
      },
    });
    Object.defineProperty(exports, "DoWhileStatement", {
      enumerable: true,
      get: function () {
        return _index.doWhileStatement;
      },
    });
    Object.defineProperty(exports, "EmptyStatement", {
      enumerable: true,
      get: function () {
        return _index.emptyStatement;
      },
    });
    Object.defineProperty(exports, "EmptyTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.emptyTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "EnumBooleanBody", {
      enumerable: true,
      get: function () {
        return _index.enumBooleanBody;
      },
    });
    Object.defineProperty(exports, "EnumBooleanMember", {
      enumerable: true,
      get: function () {
        return _index.enumBooleanMember;
      },
    });
    Object.defineProperty(exports, "EnumDeclaration", {
      enumerable: true,
      get: function () {
        return _index.enumDeclaration;
      },
    });
    Object.defineProperty(exports, "EnumDefaultedMember", {
      enumerable: true,
      get: function () {
        return _index.enumDefaultedMember;
      },
    });
    Object.defineProperty(exports, "EnumNumberBody", {
      enumerable: true,
      get: function () {
        return _index.enumNumberBody;
      },
    });
    Object.defineProperty(exports, "EnumNumberMember", {
      enumerable: true,
      get: function () {
        return _index.enumNumberMember;
      },
    });
    Object.defineProperty(exports, "EnumStringBody", {
      enumerable: true,
      get: function () {
        return _index.enumStringBody;
      },
    });
    Object.defineProperty(exports, "EnumStringMember", {
      enumerable: true,
      get: function () {
        return _index.enumStringMember;
      },
    });
    Object.defineProperty(exports, "EnumSymbolBody", {
      enumerable: true,
      get: function () {
        return _index.enumSymbolBody;
      },
    });
    Object.defineProperty(exports, "ExistsTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.existsTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "ExportAllDeclaration", {
      enumerable: true,
      get: function () {
        return _index.exportAllDeclaration;
      },
    });
    Object.defineProperty(exports, "ExportDefaultDeclaration", {
      enumerable: true,
      get: function () {
        return _index.exportDefaultDeclaration;
      },
    });
    Object.defineProperty(exports, "ExportDefaultSpecifier", {
      enumerable: true,
      get: function () {
        return _index.exportDefaultSpecifier;
      },
    });
    Object.defineProperty(exports, "ExportNamedDeclaration", {
      enumerable: true,
      get: function () {
        return _index.exportNamedDeclaration;
      },
    });
    Object.defineProperty(exports, "ExportNamespaceSpecifier", {
      enumerable: true,
      get: function () {
        return _index.exportNamespaceSpecifier;
      },
    });
    Object.defineProperty(exports, "ExportSpecifier", {
      enumerable: true,
      get: function () {
        return _index.exportSpecifier;
      },
    });
    Object.defineProperty(exports, "ExpressionStatement", {
      enumerable: true,
      get: function () {
        return _index.expressionStatement;
      },
    });
    Object.defineProperty(exports, "File", {
      enumerable: true,
      get: function () {
        return _index.file;
      },
    });
    Object.defineProperty(exports, "ForInStatement", {
      enumerable: true,
      get: function () {
        return _index.forInStatement;
      },
    });
    Object.defineProperty(exports, "ForOfStatement", {
      enumerable: true,
      get: function () {
        return _index.forOfStatement;
      },
    });
    Object.defineProperty(exports, "ForStatement", {
      enumerable: true,
      get: function () {
        return _index.forStatement;
      },
    });
    Object.defineProperty(exports, "FunctionDeclaration", {
      enumerable: true,
      get: function () {
        return _index.functionDeclaration;
      },
    });
    Object.defineProperty(exports, "FunctionExpression", {
      enumerable: true,
      get: function () {
        return _index.functionExpression;
      },
    });
    Object.defineProperty(exports, "FunctionTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.functionTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "FunctionTypeParam", {
      enumerable: true,
      get: function () {
        return _index.functionTypeParam;
      },
    });
    Object.defineProperty(exports, "GenericTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.genericTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "Identifier", {
      enumerable: true,
      get: function () {
        return _index.identifier;
      },
    });
    Object.defineProperty(exports, "IfStatement", {
      enumerable: true,
      get: function () {
        return _index.ifStatement;
      },
    });
    Object.defineProperty(exports, "Import", {
      enumerable: true,
      get: function () {
        return _index.import;
      },
    });
    Object.defineProperty(exports, "ImportAttribute", {
      enumerable: true,
      get: function () {
        return _index.importAttribute;
      },
    });
    Object.defineProperty(exports, "ImportDeclaration", {
      enumerable: true,
      get: function () {
        return _index.importDeclaration;
      },
    });
    Object.defineProperty(exports, "ImportDefaultSpecifier", {
      enumerable: true,
      get: function () {
        return _index.importDefaultSpecifier;
      },
    });
    Object.defineProperty(exports, "ImportNamespaceSpecifier", {
      enumerable: true,
      get: function () {
        return _index.importNamespaceSpecifier;
      },
    });
    Object.defineProperty(exports, "ImportSpecifier", {
      enumerable: true,
      get: function () {
        return _index.importSpecifier;
      },
    });
    Object.defineProperty(exports, "IndexedAccessType", {
      enumerable: true,
      get: function () {
        return _index.indexedAccessType;
      },
    });
    Object.defineProperty(exports, "InferredPredicate", {
      enumerable: true,
      get: function () {
        return _index.inferredPredicate;
      },
    });
    Object.defineProperty(exports, "InterfaceDeclaration", {
      enumerable: true,
      get: function () {
        return _index.interfaceDeclaration;
      },
    });
    Object.defineProperty(exports, "InterfaceExtends", {
      enumerable: true,
      get: function () {
        return _index.interfaceExtends;
      },
    });
    Object.defineProperty(exports, "InterfaceTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.interfaceTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "InterpreterDirective", {
      enumerable: true,
      get: function () {
        return _index.interpreterDirective;
      },
    });
    Object.defineProperty(exports, "IntersectionTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.intersectionTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "JSXAttribute", {
      enumerable: true,
      get: function () {
        return _index.jsxAttribute;
      },
    });
    Object.defineProperty(exports, "JSXClosingElement", {
      enumerable: true,
      get: function () {
        return _index.jsxClosingElement;
      },
    });
    Object.defineProperty(exports, "JSXClosingFragment", {
      enumerable: true,
      get: function () {
        return _index.jsxClosingFragment;
      },
    });
    Object.defineProperty(exports, "JSXElement", {
      enumerable: true,
      get: function () {
        return _index.jsxElement;
      },
    });
    Object.defineProperty(exports, "JSXEmptyExpression", {
      enumerable: true,
      get: function () {
        return _index.jsxEmptyExpression;
      },
    });
    Object.defineProperty(exports, "JSXExpressionContainer", {
      enumerable: true,
      get: function () {
        return _index.jsxExpressionContainer;
      },
    });
    Object.defineProperty(exports, "JSXFragment", {
      enumerable: true,
      get: function () {
        return _index.jsxFragment;
      },
    });
    Object.defineProperty(exports, "JSXIdentifier", {
      enumerable: true,
      get: function () {
        return _index.jsxIdentifier;
      },
    });
    Object.defineProperty(exports, "JSXMemberExpression", {
      enumerable: true,
      get: function () {
        return _index.jsxMemberExpression;
      },
    });
    Object.defineProperty(exports, "JSXNamespacedName", {
      enumerable: true,
      get: function () {
        return _index.jsxNamespacedName;
      },
    });
    Object.defineProperty(exports, "JSXOpeningElement", {
      enumerable: true,
      get: function () {
        return _index.jsxOpeningElement;
      },
    });
    Object.defineProperty(exports, "JSXOpeningFragment", {
      enumerable: true,
      get: function () {
        return _index.jsxOpeningFragment;
      },
    });
    Object.defineProperty(exports, "JSXSpreadAttribute", {
      enumerable: true,
      get: function () {
        return _index.jsxSpreadAttribute;
      },
    });
    Object.defineProperty(exports, "JSXSpreadChild", {
      enumerable: true,
      get: function () {
        return _index.jsxSpreadChild;
      },
    });
    Object.defineProperty(exports, "JSXText", {
      enumerable: true,
      get: function () {
        return _index.jsxText;
      },
    });
    Object.defineProperty(exports, "LabeledStatement", {
      enumerable: true,
      get: function () {
        return _index.labeledStatement;
      },
    });
    Object.defineProperty(exports, "LogicalExpression", {
      enumerable: true,
      get: function () {
        return _index.logicalExpression;
      },
    });
    Object.defineProperty(exports, "MemberExpression", {
      enumerable: true,
      get: function () {
        return _index.memberExpression;
      },
    });
    Object.defineProperty(exports, "MetaProperty", {
      enumerable: true,
      get: function () {
        return _index.metaProperty;
      },
    });
    Object.defineProperty(exports, "MixedTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.mixedTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "ModuleExpression", {
      enumerable: true,
      get: function () {
        return _index.moduleExpression;
      },
    });
    Object.defineProperty(exports, "NewExpression", {
      enumerable: true,
      get: function () {
        return _index.newExpression;
      },
    });
    Object.defineProperty(exports, "Noop", {
      enumerable: true,
      get: function () {
        return _index.noop;
      },
    });
    Object.defineProperty(exports, "NullLiteral", {
      enumerable: true,
      get: function () {
        return _index.nullLiteral;
      },
    });
    Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.nullLiteralTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "NullableTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.nullableTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "NumberLiteral", {
      enumerable: true,
      get: function () {
        return _index.numberLiteral;
      },
    });
    Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.numberLiteralTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "NumberTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.numberTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "NumericLiteral", {
      enumerable: true,
      get: function () {
        return _index.numericLiteral;
      },
    });
    Object.defineProperty(exports, "ObjectExpression", {
      enumerable: true,
      get: function () {
        return _index.objectExpression;
      },
    });
    Object.defineProperty(exports, "ObjectMethod", {
      enumerable: true,
      get: function () {
        return _index.objectMethod;
      },
    });
    Object.defineProperty(exports, "ObjectPattern", {
      enumerable: true,
      get: function () {
        return _index.objectPattern;
      },
    });
    Object.defineProperty(exports, "ObjectProperty", {
      enumerable: true,
      get: function () {
        return _index.objectProperty;
      },
    });
    Object.defineProperty(exports, "ObjectTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.objectTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "ObjectTypeCallProperty", {
      enumerable: true,
      get: function () {
        return _index.objectTypeCallProperty;
      },
    });
    Object.defineProperty(exports, "ObjectTypeIndexer", {
      enumerable: true,
      get: function () {
        return _index.objectTypeIndexer;
      },
    });
    Object.defineProperty(exports, "ObjectTypeInternalSlot", {
      enumerable: true,
      get: function () {
        return _index.objectTypeInternalSlot;
      },
    });
    Object.defineProperty(exports, "ObjectTypeProperty", {
      enumerable: true,
      get: function () {
        return _index.objectTypeProperty;
      },
    });
    Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
      enumerable: true,
      get: function () {
        return _index.objectTypeSpreadProperty;
      },
    });
    Object.defineProperty(exports, "OpaqueType", {
      enumerable: true,
      get: function () {
        return _index.opaqueType;
      },
    });
    Object.defineProperty(exports, "OptionalCallExpression", {
      enumerable: true,
      get: function () {
        return _index.optionalCallExpression;
      },
    });
    Object.defineProperty(exports, "OptionalIndexedAccessType", {
      enumerable: true,
      get: function () {
        return _index.optionalIndexedAccessType;
      },
    });
    Object.defineProperty(exports, "OptionalMemberExpression", {
      enumerable: true,
      get: function () {
        return _index.optionalMemberExpression;
      },
    });
    Object.defineProperty(exports, "ParenthesizedExpression", {
      enumerable: true,
      get: function () {
        return _index.parenthesizedExpression;
      },
    });
    Object.defineProperty(exports, "PipelineBareFunction", {
      enumerable: true,
      get: function () {
        return _index.pipelineBareFunction;
      },
    });
    Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
      enumerable: true,
      get: function () {
        return _index.pipelinePrimaryTopicReference;
      },
    });
    Object.defineProperty(exports, "PipelineTopicExpression", {
      enumerable: true,
      get: function () {
        return _index.pipelineTopicExpression;
      },
    });
    Object.defineProperty(exports, "Placeholder", {
      enumerable: true,
      get: function () {
        return _index.placeholder;
      },
    });
    Object.defineProperty(exports, "PrivateName", {
      enumerable: true,
      get: function () {
        return _index.privateName;
      },
    });
    Object.defineProperty(exports, "Program", {
      enumerable: true,
      get: function () {
        return _index.program;
      },
    });
    Object.defineProperty(exports, "QualifiedTypeIdentifier", {
      enumerable: true,
      get: function () {
        return _index.qualifiedTypeIdentifier;
      },
    });
    Object.defineProperty(exports, "RecordExpression", {
      enumerable: true,
      get: function () {
        return _index.recordExpression;
      },
    });
    Object.defineProperty(exports, "RegExpLiteral", {
      enumerable: true,
      get: function () {
        return _index.regExpLiteral;
      },
    });
    Object.defineProperty(exports, "RegexLiteral", {
      enumerable: true,
      get: function () {
        return _index.regexLiteral;
      },
    });
    Object.defineProperty(exports, "RestElement", {
      enumerable: true,
      get: function () {
        return _index.restElement;
      },
    });
    Object.defineProperty(exports, "RestProperty", {
      enumerable: true,
      get: function () {
        return _index.restProperty;
      },
    });
    Object.defineProperty(exports, "ReturnStatement", {
      enumerable: true,
      get: function () {
        return _index.returnStatement;
      },
    });
    Object.defineProperty(exports, "SequenceExpression", {
      enumerable: true,
      get: function () {
        return _index.sequenceExpression;
      },
    });
    Object.defineProperty(exports, "SpreadElement", {
      enumerable: true,
      get: function () {
        return _index.spreadElement;
      },
    });
    Object.defineProperty(exports, "SpreadProperty", {
      enumerable: true,
      get: function () {
        return _index.spreadProperty;
      },
    });
    Object.defineProperty(exports, "StaticBlock", {
      enumerable: true,
      get: function () {
        return _index.staticBlock;
      },
    });
    Object.defineProperty(exports, "StringLiteral", {
      enumerable: true,
      get: function () {
        return _index.stringLiteral;
      },
    });
    Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.stringLiteralTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "StringTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.stringTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "Super", {
      enumerable: true,
      get: function () {
        return _index.super;
      },
    });
    Object.defineProperty(exports, "SwitchCase", {
      enumerable: true,
      get: function () {
        return _index.switchCase;
      },
    });
    Object.defineProperty(exports, "SwitchStatement", {
      enumerable: true,
      get: function () {
        return _index.switchStatement;
      },
    });
    Object.defineProperty(exports, "SymbolTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.symbolTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "TSAnyKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsAnyKeyword;
      },
    });
    Object.defineProperty(exports, "TSArrayType", {
      enumerable: true,
      get: function () {
        return _index.tsArrayType;
      },
    });
    Object.defineProperty(exports, "TSAsExpression", {
      enumerable: true,
      get: function () {
        return _index.tsAsExpression;
      },
    });
    Object.defineProperty(exports, "TSBigIntKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsBigIntKeyword;
      },
    });
    Object.defineProperty(exports, "TSBooleanKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsBooleanKeyword;
      },
    });
    Object.defineProperty(exports, "TSCallSignatureDeclaration", {
      enumerable: true,
      get: function () {
        return _index.tsCallSignatureDeclaration;
      },
    });
    Object.defineProperty(exports, "TSConditionalType", {
      enumerable: true,
      get: function () {
        return _index.tsConditionalType;
      },
    });
    Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
      enumerable: true,
      get: function () {
        return _index.tsConstructSignatureDeclaration;
      },
    });
    Object.defineProperty(exports, "TSConstructorType", {
      enumerable: true,
      get: function () {
        return _index.tsConstructorType;
      },
    });
    Object.defineProperty(exports, "TSDeclareFunction", {
      enumerable: true,
      get: function () {
        return _index.tsDeclareFunction;
      },
    });
    Object.defineProperty(exports, "TSDeclareMethod", {
      enumerable: true,
      get: function () {
        return _index.tsDeclareMethod;
      },
    });
    Object.defineProperty(exports, "TSEnumDeclaration", {
      enumerable: true,
      get: function () {
        return _index.tsEnumDeclaration;
      },
    });
    Object.defineProperty(exports, "TSEnumMember", {
      enumerable: true,
      get: function () {
        return _index.tsEnumMember;
      },
    });
    Object.defineProperty(exports, "TSExportAssignment", {
      enumerable: true,
      get: function () {
        return _index.tsExportAssignment;
      },
    });
    Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
      enumerable: true,
      get: function () {
        return _index.tsExpressionWithTypeArguments;
      },
    });
    Object.defineProperty(exports, "TSExternalModuleReference", {
      enumerable: true,
      get: function () {
        return _index.tsExternalModuleReference;
      },
    });
    Object.defineProperty(exports, "TSFunctionType", {
      enumerable: true,
      get: function () {
        return _index.tsFunctionType;
      },
    });
    Object.defineProperty(exports, "TSImportEqualsDeclaration", {
      enumerable: true,
      get: function () {
        return _index.tsImportEqualsDeclaration;
      },
    });
    Object.defineProperty(exports, "TSImportType", {
      enumerable: true,
      get: function () {
        return _index.tsImportType;
      },
    });
    Object.defineProperty(exports, "TSIndexSignature", {
      enumerable: true,
      get: function () {
        return _index.tsIndexSignature;
      },
    });
    Object.defineProperty(exports, "TSIndexedAccessType", {
      enumerable: true,
      get: function () {
        return _index.tsIndexedAccessType;
      },
    });
    Object.defineProperty(exports, "TSInferType", {
      enumerable: true,
      get: function () {
        return _index.tsInferType;
      },
    });
    Object.defineProperty(exports, "TSInstantiationExpression", {
      enumerable: true,
      get: function () {
        return _index.tsInstantiationExpression;
      },
    });
    Object.defineProperty(exports, "TSInterfaceBody", {
      enumerable: true,
      get: function () {
        return _index.tsInterfaceBody;
      },
    });
    Object.defineProperty(exports, "TSInterfaceDeclaration", {
      enumerable: true,
      get: function () {
        return _index.tsInterfaceDeclaration;
      },
    });
    Object.defineProperty(exports, "TSIntersectionType", {
      enumerable: true,
      get: function () {
        return _index.tsIntersectionType;
      },
    });
    Object.defineProperty(exports, "TSIntrinsicKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsIntrinsicKeyword;
      },
    });
    Object.defineProperty(exports, "TSLiteralType", {
      enumerable: true,
      get: function () {
        return _index.tsLiteralType;
      },
    });
    Object.defineProperty(exports, "TSMappedType", {
      enumerable: true,
      get: function () {
        return _index.tsMappedType;
      },
    });
    Object.defineProperty(exports, "TSMethodSignature", {
      enumerable: true,
      get: function () {
        return _index.tsMethodSignature;
      },
    });
    Object.defineProperty(exports, "TSModuleBlock", {
      enumerable: true,
      get: function () {
        return _index.tsModuleBlock;
      },
    });
    Object.defineProperty(exports, "TSModuleDeclaration", {
      enumerable: true,
      get: function () {
        return _index.tsModuleDeclaration;
      },
    });
    Object.defineProperty(exports, "TSNamedTupleMember", {
      enumerable: true,
      get: function () {
        return _index.tsNamedTupleMember;
      },
    });
    Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
      enumerable: true,
      get: function () {
        return _index.tsNamespaceExportDeclaration;
      },
    });
    Object.defineProperty(exports, "TSNeverKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsNeverKeyword;
      },
    });
    Object.defineProperty(exports, "TSNonNullExpression", {
      enumerable: true,
      get: function () {
        return _index.tsNonNullExpression;
      },
    });
    Object.defineProperty(exports, "TSNullKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsNullKeyword;
      },
    });
    Object.defineProperty(exports, "TSNumberKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsNumberKeyword;
      },
    });
    Object.defineProperty(exports, "TSObjectKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsObjectKeyword;
      },
    });
    Object.defineProperty(exports, "TSOptionalType", {
      enumerable: true,
      get: function () {
        return _index.tsOptionalType;
      },
    });
    Object.defineProperty(exports, "TSParameterProperty", {
      enumerable: true,
      get: function () {
        return _index.tsParameterProperty;
      },
    });
    Object.defineProperty(exports, "TSParenthesizedType", {
      enumerable: true,
      get: function () {
        return _index.tsParenthesizedType;
      },
    });
    Object.defineProperty(exports, "TSPropertySignature", {
      enumerable: true,
      get: function () {
        return _index.tsPropertySignature;
      },
    });
    Object.defineProperty(exports, "TSQualifiedName", {
      enumerable: true,
      get: function () {
        return _index.tsQualifiedName;
      },
    });
    Object.defineProperty(exports, "TSRestType", {
      enumerable: true,
      get: function () {
        return _index.tsRestType;
      },
    });
    Object.defineProperty(exports, "TSStringKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsStringKeyword;
      },
    });
    Object.defineProperty(exports, "TSSymbolKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsSymbolKeyword;
      },
    });
    Object.defineProperty(exports, "TSThisType", {
      enumerable: true,
      get: function () {
        return _index.tsThisType;
      },
    });
    Object.defineProperty(exports, "TSTupleType", {
      enumerable: true,
      get: function () {
        return _index.tsTupleType;
      },
    });
    Object.defineProperty(exports, "TSTypeAliasDeclaration", {
      enumerable: true,
      get: function () {
        return _index.tsTypeAliasDeclaration;
      },
    });
    Object.defineProperty(exports, "TSTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.tsTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "TSTypeAssertion", {
      enumerable: true,
      get: function () {
        return _index.tsTypeAssertion;
      },
    });
    Object.defineProperty(exports, "TSTypeLiteral", {
      enumerable: true,
      get: function () {
        return _index.tsTypeLiteral;
      },
    });
    Object.defineProperty(exports, "TSTypeOperator", {
      enumerable: true,
      get: function () {
        return _index.tsTypeOperator;
      },
    });
    Object.defineProperty(exports, "TSTypeParameter", {
      enumerable: true,
      get: function () {
        return _index.tsTypeParameter;
      },
    });
    Object.defineProperty(exports, "TSTypeParameterDeclaration", {
      enumerable: true,
      get: function () {
        return _index.tsTypeParameterDeclaration;
      },
    });
    Object.defineProperty(exports, "TSTypeParameterInstantiation", {
      enumerable: true,
      get: function () {
        return _index.tsTypeParameterInstantiation;
      },
    });
    Object.defineProperty(exports, "TSTypePredicate", {
      enumerable: true,
      get: function () {
        return _index.tsTypePredicate;
      },
    });
    Object.defineProperty(exports, "TSTypeQuery", {
      enumerable: true,
      get: function () {
        return _index.tsTypeQuery;
      },
    });
    Object.defineProperty(exports, "TSTypeReference", {
      enumerable: true,
      get: function () {
        return _index.tsTypeReference;
      },
    });
    Object.defineProperty(exports, "TSUndefinedKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsUndefinedKeyword;
      },
    });
    Object.defineProperty(exports, "TSUnionType", {
      enumerable: true,
      get: function () {
        return _index.tsUnionType;
      },
    });
    Object.defineProperty(exports, "TSUnknownKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsUnknownKeyword;
      },
    });
    Object.defineProperty(exports, "TSVoidKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsVoidKeyword;
      },
    });
    Object.defineProperty(exports, "TaggedTemplateExpression", {
      enumerable: true,
      get: function () {
        return _index.taggedTemplateExpression;
      },
    });
    Object.defineProperty(exports, "TemplateElement", {
      enumerable: true,
      get: function () {
        return _index.templateElement;
      },
    });
    Object.defineProperty(exports, "TemplateLiteral", {
      enumerable: true,
      get: function () {
        return _index.templateLiteral;
      },
    });
    Object.defineProperty(exports, "ThisExpression", {
      enumerable: true,
      get: function () {
        return _index.thisExpression;
      },
    });
    Object.defineProperty(exports, "ThisTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.thisTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "ThrowStatement", {
      enumerable: true,
      get: function () {
        return _index.throwStatement;
      },
    });
    Object.defineProperty(exports, "TopicReference", {
      enumerable: true,
      get: function () {
        return _index.topicReference;
      },
    });
    Object.defineProperty(exports, "TryStatement", {
      enumerable: true,
      get: function () {
        return _index.tryStatement;
      },
    });
    Object.defineProperty(exports, "TupleExpression", {
      enumerable: true,
      get: function () {
        return _index.tupleExpression;
      },
    });
    Object.defineProperty(exports, "TupleTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.tupleTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "TypeAlias", {
      enumerable: true,
      get: function () {
        return _index.typeAlias;
      },
    });
    Object.defineProperty(exports, "TypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.typeAnnotation;
      },
    });
    Object.defineProperty(exports, "TypeCastExpression", {
      enumerable: true,
      get: function () {
        return _index.typeCastExpression;
      },
    });
    Object.defineProperty(exports, "TypeParameter", {
      enumerable: true,
      get: function () {
        return _index.typeParameter;
      },
    });
    Object.defineProperty(exports, "TypeParameterDeclaration", {
      enumerable: true,
      get: function () {
        return _index.typeParameterDeclaration;
      },
    });
    Object.defineProperty(exports, "TypeParameterInstantiation", {
      enumerable: true,
      get: function () {
        return _index.typeParameterInstantiation;
      },
    });
    Object.defineProperty(exports, "TypeofTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.typeofTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "UnaryExpression", {
      enumerable: true,
      get: function () {
        return _index.unaryExpression;
      },
    });
    Object.defineProperty(exports, "UnionTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.unionTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "UpdateExpression", {
      enumerable: true,
      get: function () {
        return _index.updateExpression;
      },
    });
    Object.defineProperty(exports, "V8IntrinsicIdentifier", {
      enumerable: true,
      get: function () {
        return _index.v8IntrinsicIdentifier;
      },
    });
    Object.defineProperty(exports, "VariableDeclaration", {
      enumerable: true,
      get: function () {
        return _index.variableDeclaration;
      },
    });
    Object.defineProperty(exports, "VariableDeclarator", {
      enumerable: true,
      get: function () {
        return _index.variableDeclarator;
      },
    });
    Object.defineProperty(exports, "Variance", {
      enumerable: true,
      get: function () {
        return _index.variance;
      },
    });
    Object.defineProperty(exports, "VoidTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.voidTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "WhileStatement", {
      enumerable: true,
      get: function () {
        return _index.whileStatement;
      },
    });
    Object.defineProperty(exports, "WithStatement", {
      enumerable: true,
      get: function () {
        return _index.withStatement;
      },
    });
    Object.defineProperty(exports, "YieldExpression", {
      enumerable: true,
      get: function () {
        return _index.yieldExpression;
      },
    });
    var _index = requireGenerated$5();
  })(uppercase$1);
  return uppercase$1;
}
var cloneNode$2 = {};
Object.defineProperty(cloneNode$2, "__esModule", { value: true });
cloneNode$2.default = cloneNode$1;
var _definitions$4 = requireDefinitions$1();
var _generated$9 = generated$9;
const has = Function.call.bind(Object.prototype.hasOwnProperty);
function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
  if (obj && typeof obj.type === "string") {
    return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
  }
  return obj;
}
function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
  if (Array.isArray(obj)) {
    return obj.map((node) =>
      cloneIfNode(node, deep, withoutLoc, commentsCache)
    );
  }
  return cloneIfNode(obj, deep, withoutLoc, commentsCache);
}
function cloneNode$1(node, deep = true, withoutLoc = false) {
  return cloneNodeInternal(node, deep, withoutLoc, new Map());
}
function cloneNodeInternal(
  node,
  deep = true,
  withoutLoc = false,
  commentsCache
) {
  if (!node) return node;
  const { type: type } = node;
  const newNode = { type: node.type };
  if ((0, _generated$9.isIdentifier)(node)) {
    newNode.name = node.name;
    if (has(node, "optional") && typeof node.optional === "boolean") {
      newNode.optional = node.optional;
    }
    if (has(node, "typeAnnotation")) {
      newNode.typeAnnotation = deep
        ? cloneIfNodeOrArray(
            node.typeAnnotation,
            true,
            withoutLoc,
            commentsCache
          )
        : node.typeAnnotation;
    }
  } else if (!has(_definitions$4.NODE_FIELDS, type)) {
    throw new Error(`Unknown node type: "${type}"`);
  } else {
    for (const field of Object.keys(_definitions$4.NODE_FIELDS[type])) {
      if (has(node, field)) {
        if (deep) {
          newNode[field] =
            (0, _generated$9.isFile)(node) && field === "comments"
              ? maybeCloneComments(
                  node.comments,
                  deep,
                  withoutLoc,
                  commentsCache
                )
              : cloneIfNodeOrArray(
                  node[field],
                  true,
                  withoutLoc,
                  commentsCache
                );
        } else {
          newNode[field] = node[field];
        }
      }
    }
  }
  if (has(node, "loc")) {
    if (withoutLoc) {
      newNode.loc = null;
    } else {
      newNode.loc = node.loc;
    }
  }
  if (has(node, "leadingComments")) {
    newNode.leadingComments = maybeCloneComments(
      node.leadingComments,
      deep,
      withoutLoc,
      commentsCache
    );
  }
  if (has(node, "innerComments")) {
    newNode.innerComments = maybeCloneComments(
      node.innerComments,
      deep,
      withoutLoc,
      commentsCache
    );
  }
  if (has(node, "trailingComments")) {
    newNode.trailingComments = maybeCloneComments(
      node.trailingComments,
      deep,
      withoutLoc,
      commentsCache
    );
  }
  if (has(node, "extra")) {
    newNode.extra = Object.assign({}, node.extra);
  }
  return newNode;
}
function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
  if (!comments || !deep) {
    return comments;
  }
  return comments.map((comment) => {
    const cache = commentsCache.get(comment);
    if (cache) return cache;
    const { type: type, value: value, loc: loc } = comment;
    const ret = { type: type, value: value, loc: loc };
    if (withoutLoc) {
      ret.loc = null;
    }
    commentsCache.set(comment, ret);
    return ret;
  });
}
var clone$2 = {};
Object.defineProperty(clone$2, "__esModule", { value: true });
clone$2.default = clone$1;
var _cloneNode$4 = cloneNode$2;
function clone$1(node) {
  return (0, _cloneNode$4.default)(node, false);
}
var cloneDeep$2 = {};
Object.defineProperty(cloneDeep$2, "__esModule", { value: true });
cloneDeep$2.default = cloneDeep$1;
var _cloneNode$3 = cloneNode$2;
function cloneDeep$1(node) {
  return (0, _cloneNode$3.default)(node);
}
var cloneDeepWithoutLoc$2 = {};
Object.defineProperty(cloneDeepWithoutLoc$2, "__esModule", { value: true });
cloneDeepWithoutLoc$2.default = cloneDeepWithoutLoc$1;
var _cloneNode$2 = cloneNode$2;
function cloneDeepWithoutLoc$1(node) {
  return (0, _cloneNode$2.default)(node, true, true);
}
var cloneWithoutLoc$2 = {};
Object.defineProperty(cloneWithoutLoc$2, "__esModule", { value: true });
cloneWithoutLoc$2.default = cloneWithoutLoc$1;
var _cloneNode$1 = cloneNode$2;
function cloneWithoutLoc$1(node) {
  return (0, _cloneNode$1.default)(node, false, true);
}
var addComment$2 = {};
var addComments$2 = {};
Object.defineProperty(addComments$2, "__esModule", { value: true });
addComments$2.default = addComments$1;
function addComments$1(node, type, comments) {
  if (!comments || !node) return node;
  const key = `${type}Comments`;
  if (node[key]) {
    if (type === "leading") {
      node[key] = comments.concat(node[key]);
    } else {
      node[key].push(...comments);
    }
  } else {
    node[key] = comments;
  }
  return node;
}
Object.defineProperty(addComment$2, "__esModule", { value: true });
addComment$2.default = addComment$1;
var _addComments = addComments$2;
function addComment$1(node, type, content, line) {
  return (0, _addComments.default)(node, type, [
    { type: line ? "CommentLine" : "CommentBlock", value: content },
  ]);
}
var inheritInnerComments$2 = {};
var inherit$2 = {};
Object.defineProperty(inherit$2, "__esModule", { value: true });
inherit$2.default = inherit$1;
function inherit$1(key, child, parent) {
  if (child && parent) {
    child[key] = Array.from(
      new Set([].concat(child[key], parent[key]).filter(Boolean))
    );
  }
}
Object.defineProperty(inheritInnerComments$2, "__esModule", { value: true });
inheritInnerComments$2.default = inheritInnerComments$1;
var _inherit$2 = inherit$2;
function inheritInnerComments$1(child, parent) {
  (0, _inherit$2.default)("innerComments", child, parent);
}
var inheritLeadingComments$2 = {};
Object.defineProperty(inheritLeadingComments$2, "__esModule", { value: true });
inheritLeadingComments$2.default = inheritLeadingComments$1;
var _inherit$1 = inherit$2;
function inheritLeadingComments$1(child, parent) {
  (0, _inherit$1.default)("leadingComments", child, parent);
}
var inheritsComments$2 = {};
var inheritTrailingComments$2 = {};
Object.defineProperty(inheritTrailingComments$2, "__esModule", { value: true });
inheritTrailingComments$2.default = inheritTrailingComments$1;
var _inherit = inherit$2;
function inheritTrailingComments$1(child, parent) {
  (0, _inherit.default)("trailingComments", child, parent);
}
Object.defineProperty(inheritsComments$2, "__esModule", { value: true });
inheritsComments$2.default = inheritsComments$1;
var _inheritTrailingComments = inheritTrailingComments$2;
var _inheritLeadingComments = inheritLeadingComments$2;
var _inheritInnerComments = inheritInnerComments$2;
function inheritsComments$1(child, parent) {
  (0, _inheritTrailingComments.default)(child, parent);
  (0, _inheritLeadingComments.default)(child, parent);
  (0, _inheritInnerComments.default)(child, parent);
  return child;
}
var removeComments$2 = {};
Object.defineProperty(removeComments$2, "__esModule", { value: true });
removeComments$2.default = removeComments$1;
var _constants$4 = constants$1;
function removeComments$1(node) {
  _constants$4.COMMENT_KEYS.forEach((key) => {
    node[key] = null;
  });
  return node;
}
var generated$6 = {};
Object.defineProperty(generated$6, "__esModule", { value: true });
generated$6.WHILE_TYPES =
  generated$6.USERWHITESPACABLE_TYPES =
  generated$6.UNARYLIKE_TYPES =
  generated$6.TYPESCRIPT_TYPES =
  generated$6.TSTYPE_TYPES =
  generated$6.TSTYPEELEMENT_TYPES =
  generated$6.TSENTITYNAME_TYPES =
  generated$6.TSBASETYPE_TYPES =
  generated$6.TERMINATORLESS_TYPES =
  generated$6.STATEMENT_TYPES =
  generated$6.STANDARDIZED_TYPES =
  generated$6.SCOPABLE_TYPES =
  generated$6.PUREISH_TYPES =
  generated$6.PROPERTY_TYPES =
  generated$6.PRIVATE_TYPES =
  generated$6.PATTERN_TYPES =
  generated$6.PATTERNLIKE_TYPES =
  generated$6.OBJECTMEMBER_TYPES =
  generated$6.MODULESPECIFIER_TYPES =
  generated$6.MODULEDECLARATION_TYPES =
  generated$6.MISCELLANEOUS_TYPES =
  generated$6.METHOD_TYPES =
  generated$6.LVAL_TYPES =
  generated$6.LOOP_TYPES =
  generated$6.LITERAL_TYPES =
  generated$6.JSX_TYPES =
  generated$6.IMMUTABLE_TYPES =
  generated$6.FUNCTION_TYPES =
  generated$6.FUNCTIONPARENT_TYPES =
  generated$6.FOR_TYPES =
  generated$6.FORXSTATEMENT_TYPES =
  generated$6.FLOW_TYPES =
  generated$6.FLOWTYPE_TYPES =
  generated$6.FLOWPREDICATE_TYPES =
  generated$6.FLOWDECLARATION_TYPES =
  generated$6.FLOWBASEANNOTATION_TYPES =
  generated$6.EXPRESSION_TYPES =
  generated$6.EXPRESSIONWRAPPER_TYPES =
  generated$6.EXPORTDECLARATION_TYPES =
  generated$6.ENUMMEMBER_TYPES =
  generated$6.ENUMBODY_TYPES =
  generated$6.DECLARATION_TYPES =
  generated$6.CONDITIONAL_TYPES =
  generated$6.COMPLETIONSTATEMENT_TYPES =
  generated$6.CLASS_TYPES =
  generated$6.BLOCK_TYPES =
  generated$6.BLOCKPARENT_TYPES =
  generated$6.BINARY_TYPES =
  generated$6.ACCESSOR_TYPES =
    void 0;
var _definitions$3 = requireDefinitions$1();
const STANDARDIZED_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Standardized"];
generated$6.STANDARDIZED_TYPES = STANDARDIZED_TYPES;
const EXPRESSION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Expression"];
generated$6.EXPRESSION_TYPES = EXPRESSION_TYPES;
const BINARY_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Binary"];
generated$6.BINARY_TYPES = BINARY_TYPES;
const SCOPABLE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Scopable"];
generated$6.SCOPABLE_TYPES = SCOPABLE_TYPES;
const BLOCKPARENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["BlockParent"];
generated$6.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
const BLOCK_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Block"];
generated$6.BLOCK_TYPES = BLOCK_TYPES;
const STATEMENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Statement"];
generated$6.STATEMENT_TYPES = STATEMENT_TYPES;
const TERMINATORLESS_TYPES =
  _definitions$3.FLIPPED_ALIAS_KEYS["Terminatorless"];
generated$6.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
const COMPLETIONSTATEMENT_TYPES =
  _definitions$3.FLIPPED_ALIAS_KEYS["CompletionStatement"];
generated$6.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
const CONDITIONAL_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Conditional"];
generated$6.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
const LOOP_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Loop"];
generated$6.LOOP_TYPES = LOOP_TYPES;
const WHILE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["While"];
generated$6.WHILE_TYPES = WHILE_TYPES;
const EXPRESSIONWRAPPER_TYPES =
  _definitions$3.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
generated$6.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
const FOR_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["For"];
generated$6.FOR_TYPES = FOR_TYPES;
const FORXSTATEMENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["ForXStatement"];
generated$6.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
const FUNCTION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Function"];
generated$6.FUNCTION_TYPES = FUNCTION_TYPES;
const FUNCTIONPARENT_TYPES =
  _definitions$3.FLIPPED_ALIAS_KEYS["FunctionParent"];
generated$6.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
const PUREISH_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Pureish"];
generated$6.PUREISH_TYPES = PUREISH_TYPES;
const DECLARATION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Declaration"];
generated$6.DECLARATION_TYPES = DECLARATION_TYPES;
const PATTERNLIKE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["PatternLike"];
generated$6.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
const LVAL_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["LVal"];
generated$6.LVAL_TYPES = LVAL_TYPES;
const TSENTITYNAME_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["TSEntityName"];
generated$6.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
const LITERAL_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Literal"];
generated$6.LITERAL_TYPES = LITERAL_TYPES;
const IMMUTABLE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Immutable"];
generated$6.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
const USERWHITESPACABLE_TYPES =
  _definitions$3.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
generated$6.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
const METHOD_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Method"];
generated$6.METHOD_TYPES = METHOD_TYPES;
const OBJECTMEMBER_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["ObjectMember"];
generated$6.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
const PROPERTY_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Property"];
generated$6.PROPERTY_TYPES = PROPERTY_TYPES;
const UNARYLIKE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["UnaryLike"];
generated$6.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
const PATTERN_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Pattern"];
generated$6.PATTERN_TYPES = PATTERN_TYPES;
const CLASS_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Class"];
generated$6.CLASS_TYPES = CLASS_TYPES;
const MODULEDECLARATION_TYPES =
  _definitions$3.FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
generated$6.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
const EXPORTDECLARATION_TYPES =
  _definitions$3.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
generated$6.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
const MODULESPECIFIER_TYPES =
  _definitions$3.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
generated$6.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
const ACCESSOR_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Accessor"];
generated$6.ACCESSOR_TYPES = ACCESSOR_TYPES;
const PRIVATE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Private"];
generated$6.PRIVATE_TYPES = PRIVATE_TYPES;
const FLOW_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Flow"];
generated$6.FLOW_TYPES = FLOW_TYPES;
const FLOWTYPE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["FlowType"];
generated$6.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
const FLOWBASEANNOTATION_TYPES =
  _definitions$3.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
generated$6.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
const FLOWDECLARATION_TYPES =
  _definitions$3.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
generated$6.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
const FLOWPREDICATE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["FlowPredicate"];
generated$6.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
const ENUMBODY_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["EnumBody"];
generated$6.ENUMBODY_TYPES = ENUMBODY_TYPES;
const ENUMMEMBER_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["EnumMember"];
generated$6.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
const JSX_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["JSX"];
generated$6.JSX_TYPES = JSX_TYPES;
const MISCELLANEOUS_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Miscellaneous"];
generated$6.MISCELLANEOUS_TYPES = MISCELLANEOUS_TYPES;
const TYPESCRIPT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["TypeScript"];
generated$6.TYPESCRIPT_TYPES = TYPESCRIPT_TYPES;
const TSTYPEELEMENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["TSTypeElement"];
generated$6.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
const TSTYPE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["TSType"];
generated$6.TSTYPE_TYPES = TSTYPE_TYPES;
const TSBASETYPE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["TSBaseType"];
generated$6.TSBASETYPE_TYPES = TSBASETYPE_TYPES;
var ensureBlock$1 = {};
var toBlock$1 = {};
var hasRequiredToBlock$1;
function requireToBlock$1() {
  if (hasRequiredToBlock$1) return toBlock$1;
  hasRequiredToBlock$1 = 1;
  Object.defineProperty(toBlock$1, "__esModule", { value: true });
  toBlock$1.default = toBlock;
  var _generated = generated$9;
  var _generated2 = requireGenerated$5();
  function toBlock(node, parent) {
    if ((0, _generated.isBlockStatement)(node)) {
      return node;
    }
    let blockNodes = [];
    if ((0, _generated.isEmptyStatement)(node)) {
      blockNodes = [];
    } else {
      if (!(0, _generated.isStatement)(node)) {
        if ((0, _generated.isFunction)(parent)) {
          node = (0, _generated2.returnStatement)(node);
        } else {
          node = (0, _generated2.expressionStatement)(node);
        }
      }
      blockNodes = [node];
    }
    return (0, _generated2.blockStatement)(blockNodes);
  }
  return toBlock$1;
}
var hasRequiredEnsureBlock$1;
function requireEnsureBlock$1() {
  if (hasRequiredEnsureBlock$1) return ensureBlock$1;
  hasRequiredEnsureBlock$1 = 1;
  Object.defineProperty(ensureBlock$1, "__esModule", { value: true });
  ensureBlock$1.default = ensureBlock;
  var _toBlock = requireToBlock$1();
  function ensureBlock(node, key = "body") {
    const result = (0, _toBlock.default)(node[key], node);
    node[key] = result;
    return result;
  }
  return ensureBlock$1;
}
var toBindingIdentifierName$2 = {};
var toIdentifier$2 = {};
Object.defineProperty(toIdentifier$2, "__esModule", { value: true });
toIdentifier$2.default = toIdentifier$1;
var _isValidIdentifier$1 = isValidIdentifier$2;
var _helperValidatorIdentifier = lib$4;
function toIdentifier$1(input) {
  input = input + "";
  let name = "";
  for (const c of input) {
    name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0))
      ? c
      : "-";
  }
  name = name.replace(/^[-0-9]+/, "");
  name = name.replace(/[-\s]+(.)?/g, function (match, c) {
    return c ? c.toUpperCase() : "";
  });
  if (!(0, _isValidIdentifier$1.default)(name)) {
    name = `_${name}`;
  }
  return name || "_";
}
Object.defineProperty(toBindingIdentifierName$2, "__esModule", { value: true });
toBindingIdentifierName$2.default = toBindingIdentifierName$1;
var _toIdentifier = toIdentifier$2;
function toBindingIdentifierName$1(name) {
  name = (0, _toIdentifier.default)(name);
  if (name === "eval" || name === "arguments") name = "_" + name;
  return name;
}
var toComputedKey$1 = {};
var hasRequiredToComputedKey$1;
function requireToComputedKey$1() {
  if (hasRequiredToComputedKey$1) return toComputedKey$1;
  hasRequiredToComputedKey$1 = 1;
  Object.defineProperty(toComputedKey$1, "__esModule", { value: true });
  toComputedKey$1.default = toComputedKey;
  var _generated = generated$9;
  var _generated2 = requireGenerated$5();
  function toComputedKey(node, key = node.key || node.property) {
    if (!node.computed && (0, _generated.isIdentifier)(key))
      key = (0, _generated2.stringLiteral)(key.name);
    return key;
  }
  return toComputedKey$1;
}
var toExpression$2 = {};
Object.defineProperty(toExpression$2, "__esModule", { value: true });
toExpression$2.default = void 0;
var _generated$8 = generated$9;
var _default$9 = toExpression$1;
toExpression$2.default = _default$9;
function toExpression$1(node) {
  if ((0, _generated$8.isExpressionStatement)(node)) {
    node = node.expression;
  }
  if ((0, _generated$8.isExpression)(node)) {
    return node;
  }
  if ((0, _generated$8.isClass)(node)) {
    node.type = "ClassExpression";
  } else if ((0, _generated$8.isFunction)(node)) {
    node.type = "FunctionExpression";
  }
  if (!(0, _generated$8.isExpression)(node)) {
    throw new Error(`cannot turn ${node.type} to an expression`);
  }
  return node;
}
var toKeyAlias$2 = {};
var removePropertiesDeep$2 = {};
var traverseFast$2 = {};
Object.defineProperty(traverseFast$2, "__esModule", { value: true });
traverseFast$2.default = traverseFast$1;
var _definitions$2 = requireDefinitions$1();
function traverseFast$1(node, enter, opts) {
  if (!node) return;
  const keys = _definitions$2.VISITOR_KEYS[node.type];
  if (!keys) return;
  opts = opts || {};
  enter(node, opts);
  for (const key of keys) {
    const subNode = node[key];
    if (Array.isArray(subNode)) {
      for (const node of subNode) {
        traverseFast$1(node, enter, opts);
      }
    } else {
      traverseFast$1(subNode, enter, opts);
    }
  }
}
var removeProperties$2 = {};
Object.defineProperty(removeProperties$2, "__esModule", { value: true });
removeProperties$2.default = removeProperties$1;
var _constants$3 = constants$1;
const CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
const CLEAR_KEYS_PLUS_COMMENTS = [
  ..._constants$3.COMMENT_KEYS,
  "comments",
  ...CLEAR_KEYS,
];
function removeProperties$1(node, opts = {}) {
  const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
  for (const key of map) {
    if (node[key] != null) node[key] = undefined;
  }
  for (const key of Object.keys(node)) {
    if (key[0] === "_" && node[key] != null) node[key] = undefined;
  }
  const symbols = Object.getOwnPropertySymbols(node);
  for (const sym of symbols) {
    node[sym] = null;
  }
}
Object.defineProperty(removePropertiesDeep$2, "__esModule", { value: true });
removePropertiesDeep$2.default = removePropertiesDeep$1;
var _traverseFast = traverseFast$2;
var _removeProperties = removeProperties$2;
function removePropertiesDeep$1(tree, opts) {
  (0, _traverseFast.default)(tree, _removeProperties.default, opts);
  return tree;
}
Object.defineProperty(toKeyAlias$2, "__esModule", { value: true });
toKeyAlias$2.default = toKeyAlias$1;
var _generated$7 = generated$9;
var _cloneNode = cloneNode$2;
var _removePropertiesDeep = removePropertiesDeep$2;
function toKeyAlias$1(node, key = node.key) {
  let alias;
  if (node.kind === "method") {
    return toKeyAlias$1.increment() + "";
  } else if ((0, _generated$7.isIdentifier)(key)) {
    alias = key.name;
  } else if ((0, _generated$7.isStringLiteral)(key)) {
    alias = JSON.stringify(key.value);
  } else {
    alias = JSON.stringify(
      (0, _removePropertiesDeep.default)((0, _cloneNode.default)(key))
    );
  }
  if (node.computed) {
    alias = `[${alias}]`;
  }
  if (node.static) {
    alias = `static:${alias}`;
  }
  return alias;
}
toKeyAlias$1.uid = 0;
toKeyAlias$1.increment = function () {
  if (toKeyAlias$1.uid >= Number.MAX_SAFE_INTEGER) {
    return (toKeyAlias$1.uid = 0);
  } else {
    return toKeyAlias$1.uid++;
  }
};
var toSequenceExpression$1 = {};
var gatherSequenceExpressions$1 = {};
var getBindingIdentifiers$2 = {};
Object.defineProperty(getBindingIdentifiers$2, "__esModule", { value: true });
getBindingIdentifiers$2.default = getBindingIdentifiers$1;
var _generated$6 = generated$9;
function getBindingIdentifiers$1(node, duplicates, outerOnly) {
  const search = [].concat(node);
  const ids = Object.create(null);
  while (search.length) {
    const id = search.shift();
    if (!id) continue;
    const keys = getBindingIdentifiers$1.keys[id.type];
    if ((0, _generated$6.isIdentifier)(id)) {
      if (duplicates) {
        const _ids = (ids[id.name] = ids[id.name] || []);
        _ids.push(id);
      } else {
        ids[id.name] = id;
      }
      continue;
    }
    if (
      (0, _generated$6.isExportDeclaration)(id) &&
      !(0, _generated$6.isExportAllDeclaration)(id)
    ) {
      if ((0, _generated$6.isDeclaration)(id.declaration)) {
        search.push(id.declaration);
      }
      continue;
    }
    if (outerOnly) {
      if ((0, _generated$6.isFunctionDeclaration)(id)) {
        search.push(id.id);
        continue;
      }
      if ((0, _generated$6.isFunctionExpression)(id)) {
        continue;
      }
    }
    if (keys) {
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const nodes = id[key];
        if (nodes) {
          Array.isArray(nodes) ? search.push(...nodes) : search.push(nodes);
        }
      }
    }
  }
  return ids;
}
getBindingIdentifiers$1.keys = {
  DeclareClass: ["id"],
  DeclareFunction: ["id"],
  DeclareModule: ["id"],
  DeclareVariable: ["id"],
  DeclareInterface: ["id"],
  DeclareTypeAlias: ["id"],
  DeclareOpaqueType: ["id"],
  InterfaceDeclaration: ["id"],
  TypeAlias: ["id"],
  OpaqueType: ["id"],
  CatchClause: ["param"],
  LabeledStatement: ["label"],
  UnaryExpression: ["argument"],
  AssignmentExpression: ["left"],
  ImportSpecifier: ["local"],
  ImportNamespaceSpecifier: ["local"],
  ImportDefaultSpecifier: ["local"],
  ImportDeclaration: ["specifiers"],
  ExportSpecifier: ["exported"],
  ExportNamespaceSpecifier: ["exported"],
  ExportDefaultSpecifier: ["exported"],
  FunctionDeclaration: ["id", "params"],
  FunctionExpression: ["id", "params"],
  ArrowFunctionExpression: ["params"],
  ObjectMethod: ["params"],
  ClassMethod: ["params"],
  ClassPrivateMethod: ["params"],
  ForInStatement: ["left"],
  ForOfStatement: ["left"],
  ClassDeclaration: ["id"],
  ClassExpression: ["id"],
  RestElement: ["argument"],
  UpdateExpression: ["argument"],
  ObjectProperty: ["value"],
  AssignmentPattern: ["left"],
  ArrayPattern: ["elements"],
  ObjectPattern: ["properties"],
  VariableDeclaration: ["declarations"],
  VariableDeclarator: ["id"],
};
var hasRequiredGatherSequenceExpressions$1;
function requireGatherSequenceExpressions$1() {
  if (hasRequiredGatherSequenceExpressions$1)
    return gatherSequenceExpressions$1;
  hasRequiredGatherSequenceExpressions$1 = 1;
  Object.defineProperty(gatherSequenceExpressions$1, "__esModule", {
    value: true,
  });
  gatherSequenceExpressions$1.default = gatherSequenceExpressions;
  var _getBindingIdentifiers = getBindingIdentifiers$2;
  var _generated = generated$9;
  var _generated2 = requireGenerated$5();
  var _cloneNode = cloneNode$2;
  function gatherSequenceExpressions(nodes, scope, declars) {
    const exprs = [];
    let ensureLastUndefined = true;
    for (const node of nodes) {
      if (!(0, _generated.isEmptyStatement)(node)) {
        ensureLastUndefined = false;
      }
      if ((0, _generated.isExpression)(node)) {
        exprs.push(node);
      } else if ((0, _generated.isExpressionStatement)(node)) {
        exprs.push(node.expression);
      } else if ((0, _generated.isVariableDeclaration)(node)) {
        if (node.kind !== "var") return;
        for (const declar of node.declarations) {
          const bindings = (0, _getBindingIdentifiers.default)(declar);
          for (const key of Object.keys(bindings)) {
            declars.push({
              kind: node.kind,
              id: (0, _cloneNode.default)(bindings[key]),
            });
          }
          if (declar.init) {
            exprs.push(
              (0, _generated2.assignmentExpression)("=", declar.id, declar.init)
            );
          }
        }
        ensureLastUndefined = true;
      } else if ((0, _generated.isIfStatement)(node)) {
        const consequent = node.consequent
          ? gatherSequenceExpressions([node.consequent], scope, declars)
          : scope.buildUndefinedNode();
        const alternate = node.alternate
          ? gatherSequenceExpressions([node.alternate], scope, declars)
          : scope.buildUndefinedNode();
        if (!consequent || !alternate) return;
        exprs.push(
          (0, _generated2.conditionalExpression)(
            node.test,
            consequent,
            alternate
          )
        );
      } else if ((0, _generated.isBlockStatement)(node)) {
        const body = gatherSequenceExpressions(node.body, scope, declars);
        if (!body) return;
        exprs.push(body);
      } else if ((0, _generated.isEmptyStatement)(node)) {
        if (nodes.indexOf(node) === 0) {
          ensureLastUndefined = true;
        }
      } else {
        return;
      }
    }
    if (ensureLastUndefined) {
      exprs.push(scope.buildUndefinedNode());
    }
    if (exprs.length === 1) {
      return exprs[0];
    } else {
      return (0, _generated2.sequenceExpression)(exprs);
    }
  }
  return gatherSequenceExpressions$1;
}
var hasRequiredToSequenceExpression$1;
function requireToSequenceExpression$1() {
  if (hasRequiredToSequenceExpression$1) return toSequenceExpression$1;
  hasRequiredToSequenceExpression$1 = 1;
  Object.defineProperty(toSequenceExpression$1, "__esModule", { value: true });
  toSequenceExpression$1.default = toSequenceExpression;
  var _gatherSequenceExpressions = requireGatherSequenceExpressions$1();
  function toSequenceExpression(nodes, scope) {
    if (!(nodes != null && nodes.length)) return;
    const declars = [];
    const result = (0, _gatherSequenceExpressions.default)(
      nodes,
      scope,
      declars
    );
    if (!result) return;
    for (const declar of declars) {
      scope.push(declar);
    }
    return result;
  }
  return toSequenceExpression$1;
}
var toStatement$1 = {};
var hasRequiredToStatement$1;
function requireToStatement$1() {
  if (hasRequiredToStatement$1) return toStatement$1;
  hasRequiredToStatement$1 = 1;
  Object.defineProperty(toStatement$1, "__esModule", { value: true });
  toStatement$1.default = void 0;
  var _generated = generated$9;
  var _generated2 = requireGenerated$5();
  var _default = toStatement;
  toStatement$1.default = _default;
  function toStatement(node, ignore) {
    if ((0, _generated.isStatement)(node)) {
      return node;
    }
    let mustHaveId = false;
    let newType;
    if ((0, _generated.isClass)(node)) {
      mustHaveId = true;
      newType = "ClassDeclaration";
    } else if ((0, _generated.isFunction)(node)) {
      mustHaveId = true;
      newType = "FunctionDeclaration";
    } else if ((0, _generated.isAssignmentExpression)(node)) {
      return (0, _generated2.expressionStatement)(node);
    }
    if (mustHaveId && !node.id) {
      newType = false;
    }
    if (!newType) {
      if (ignore) {
        return false;
      } else {
        throw new Error(`cannot turn ${node.type} to a statement`);
      }
    }
    node.type = newType;
    return node;
  }
  return toStatement$1;
}
var valueToNode$1 = {};
var hasRequiredValueToNode$1;
function requireValueToNode$1() {
  if (hasRequiredValueToNode$1) return valueToNode$1;
  hasRequiredValueToNode$1 = 1;
  Object.defineProperty(valueToNode$1, "__esModule", { value: true });
  valueToNode$1.default = void 0;
  var _isValidIdentifier = isValidIdentifier$2;
  var _generated = requireGenerated$5();
  var _default = valueToNode;
  valueToNode$1.default = _default;
  const objectToString = Function.call.bind(Object.prototype.toString);
  function isRegExp(value) {
    return objectToString(value) === "[object RegExp]";
  }
  function isPlainObject(value) {
    if (
      typeof value !== "object" ||
      value === null ||
      Object.prototype.toString.call(value) !== "[object Object]"
    ) {
      return false;
    }
    const proto = Object.getPrototypeOf(value);
    return proto === null || Object.getPrototypeOf(proto) === null;
  }
  function valueToNode(value) {
    if (value === undefined) {
      return (0, _generated.identifier)("undefined");
    }
    if (value === true || value === false) {
      return (0, _generated.booleanLiteral)(value);
    }
    if (value === null) {
      return (0, _generated.nullLiteral)();
    }
    if (typeof value === "string") {
      return (0, _generated.stringLiteral)(value);
    }
    if (typeof value === "number") {
      let result;
      if (Number.isFinite(value)) {
        result = (0, _generated.numericLiteral)(Math.abs(value));
      } else {
        let numerator;
        if (Number.isNaN(value)) {
          numerator = (0, _generated.numericLiteral)(0);
        } else {
          numerator = (0, _generated.numericLiteral)(1);
        }
        result = (0, _generated.binaryExpression)(
          "/",
          numerator,
          (0, _generated.numericLiteral)(0)
        );
      }
      if (value < 0 || Object.is(value, -0)) {
        result = (0, _generated.unaryExpression)("-", result);
      }
      return result;
    }
    if (isRegExp(value)) {
      const pattern = value.source;
      const flags = value.toString().match(/\/([a-z]+|)$/)[1];
      return (0, _generated.regExpLiteral)(pattern, flags);
    }
    if (Array.isArray(value)) {
      return (0, _generated.arrayExpression)(value.map(valueToNode));
    }
    if (isPlainObject(value)) {
      const props = [];
      for (const key of Object.keys(value)) {
        let nodeKey;
        if ((0, _isValidIdentifier.default)(key)) {
          nodeKey = (0, _generated.identifier)(key);
        } else {
          nodeKey = (0, _generated.stringLiteral)(key);
        }
        props.push(
          (0, _generated.objectProperty)(nodeKey, valueToNode(value[key]))
        );
      }
      return (0, _generated.objectExpression)(props);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  return valueToNode$1;
}
var appendToMemberExpression$1 = {};
var hasRequiredAppendToMemberExpression$1;
function requireAppendToMemberExpression$1() {
  if (hasRequiredAppendToMemberExpression$1) return appendToMemberExpression$1;
  hasRequiredAppendToMemberExpression$1 = 1;
  Object.defineProperty(appendToMemberExpression$1, "__esModule", {
    value: true,
  });
  appendToMemberExpression$1.default = appendToMemberExpression;
  var _generated = requireGenerated$5();
  function appendToMemberExpression(member, append, computed = false) {
    member.object = (0, _generated.memberExpression)(
      member.object,
      member.property,
      member.computed
    );
    member.property = append;
    member.computed = !!computed;
    return member;
  }
  return appendToMemberExpression$1;
}
var inherits$2 = {};
Object.defineProperty(inherits$2, "__esModule", { value: true });
inherits$2.default = inherits$1;
var _constants$2 = constants$1;
var _inheritsComments = inheritsComments$2;
function inherits$1(child, parent) {
  if (!child || !parent) return child;
  for (const key of _constants$2.INHERIT_KEYS.optional) {
    if (child[key] == null) {
      child[key] = parent[key];
    }
  }
  for (const key of Object.keys(parent)) {
    if (key[0] === "_" && key !== "__clone") {
      child[key] = parent[key];
    }
  }
  for (const key of _constants$2.INHERIT_KEYS.force) {
    child[key] = parent[key];
  }
  (0, _inheritsComments.default)(child, parent);
  return child;
}
var prependToMemberExpression$1 = {};
var hasRequiredPrependToMemberExpression$1;
function requirePrependToMemberExpression$1() {
  if (hasRequiredPrependToMemberExpression$1)
    return prependToMemberExpression$1;
  hasRequiredPrependToMemberExpression$1 = 1;
  Object.defineProperty(prependToMemberExpression$1, "__esModule", {
    value: true,
  });
  prependToMemberExpression$1.default = prependToMemberExpression;
  var _generated = requireGenerated$5();
  var _ = requireLib$2();
  function prependToMemberExpression(member, prepend) {
    if ((0, _.isSuper)(member.object)) {
      throw new Error(
        "Cannot prepend node to super property access (`super.foo`)."
      );
    }
    member.object = (0, _generated.memberExpression)(prepend, member.object);
    return member;
  }
  return prependToMemberExpression$1;
}
var getOuterBindingIdentifiers$2 = {};
Object.defineProperty(getOuterBindingIdentifiers$2, "__esModule", {
  value: true,
});
getOuterBindingIdentifiers$2.default = void 0;
var _getBindingIdentifiers$1 = getBindingIdentifiers$2;
var _default$8 = getOuterBindingIdentifiers$1;
getOuterBindingIdentifiers$2.default = _default$8;
function getOuterBindingIdentifiers$1(node, duplicates) {
  return (0, _getBindingIdentifiers$1.default)(node, duplicates, true);
}
var traverse$2 = {};
Object.defineProperty(traverse$2, "__esModule", { value: true });
traverse$2.default = traverse$1;
var _definitions$1 = requireDefinitions$1();
function traverse$1(node, handlers, state) {
  if (typeof handlers === "function") {
    handlers = { enter: handlers };
  }
  const { enter: enter, exit: exit } = handlers;
  traverseSimpleImpl(node, enter, exit, state, []);
}
function traverseSimpleImpl(node, enter, exit, state, ancestors) {
  const keys = _definitions$1.VISITOR_KEYS[node.type];
  if (!keys) return;
  if (enter) enter(node, ancestors, state);
  for (const key of keys) {
    const subNode = node[key];
    if (Array.isArray(subNode)) {
      for (let i = 0; i < subNode.length; i++) {
        const child = subNode[i];
        if (!child) continue;
        ancestors.push({ node: node, key: key, index: i });
        traverseSimpleImpl(child, enter, exit, state, ancestors);
        ancestors.pop();
      }
    } else if (subNode) {
      ancestors.push({ node: node, key: key });
      traverseSimpleImpl(subNode, enter, exit, state, ancestors);
      ancestors.pop();
    }
  }
  if (exit) exit(node, ancestors, state);
}
var isBinding$2 = {};
Object.defineProperty(isBinding$2, "__esModule", { value: true });
isBinding$2.default = isBinding$1;
var _getBindingIdentifiers = getBindingIdentifiers$2;
function isBinding$1(node, parent, grandparent) {
  if (
    grandparent &&
    node.type === "Identifier" &&
    parent.type === "ObjectProperty" &&
    grandparent.type === "ObjectExpression"
  ) {
    return false;
  }
  const keys = _getBindingIdentifiers.default.keys[parent.type];
  if (keys) {
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const val = parent[key];
      if (Array.isArray(val)) {
        if (val.indexOf(node) >= 0) return true;
      } else {
        if (val === node) return true;
      }
    }
  }
  return false;
}
var isBlockScoped$2 = {};
var isLet$2 = {};
Object.defineProperty(isLet$2, "__esModule", { value: true });
isLet$2.default = isLet$1;
var _generated$5 = generated$9;
var _constants$1 = constants$1;
function isLet$1(node) {
  return (
    (0, _generated$5.isVariableDeclaration)(node) &&
    (node.kind !== "var" || node[_constants$1.BLOCK_SCOPED_SYMBOL])
  );
}
Object.defineProperty(isBlockScoped$2, "__esModule", { value: true });
isBlockScoped$2.default = isBlockScoped$1;
var _generated$4 = generated$9;
var _isLet = isLet$2;
function isBlockScoped$1(node) {
  return (
    (0, _generated$4.isFunctionDeclaration)(node) ||
    (0, _generated$4.isClassDeclaration)(node) ||
    (0, _isLet.default)(node)
  );
}
var isImmutable$2 = {};
Object.defineProperty(isImmutable$2, "__esModule", { value: true });
isImmutable$2.default = isImmutable$1;
var _isType = requireIsType$1();
var _generated$3 = generated$9;
function isImmutable$1(node) {
  if ((0, _isType.default)(node.type, "Immutable")) return true;
  if ((0, _generated$3.isIdentifier)(node)) {
    if (node.name === "undefined") {
      return true;
    } else {
      return false;
    }
  }
  return false;
}
var isNodesEquivalent$2 = {};
Object.defineProperty(isNodesEquivalent$2, "__esModule", { value: true });
isNodesEquivalent$2.default = isNodesEquivalent$1;
var _definitions = requireDefinitions$1();
function isNodesEquivalent$1(a, b) {
  if (
    typeof a !== "object" ||
    typeof b !== "object" ||
    a == null ||
    b == null
  ) {
    return a === b;
  }
  if (a.type !== b.type) {
    return false;
  }
  const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);
  const visitorKeys = _definitions.VISITOR_KEYS[a.type];
  for (const field of fields) {
    const val_a = a[field];
    const val_b = b[field];
    if (typeof val_a !== typeof val_b) {
      return false;
    }
    if (val_a == null && val_b == null) {
      continue;
    } else if (val_a == null || val_b == null) {
      return false;
    }
    if (Array.isArray(val_a)) {
      if (!Array.isArray(val_b)) {
        return false;
      }
      if (val_a.length !== val_b.length) {
        return false;
      }
      for (let i = 0; i < val_a.length; i++) {
        if (!isNodesEquivalent$1(val_a[i], val_b[i])) {
          return false;
        }
      }
      continue;
    }
    if (
      typeof val_a === "object" &&
      !(visitorKeys != null && visitorKeys.includes(field))
    ) {
      for (const key of Object.keys(val_a)) {
        if (val_a[key] !== val_b[key]) {
          return false;
        }
      }
      continue;
    }
    if (!isNodesEquivalent$1(val_a, val_b)) {
      return false;
    }
  }
  return true;
}
var isReferenced$2 = {};
Object.defineProperty(isReferenced$2, "__esModule", { value: true });
isReferenced$2.default = isReferenced$1;
function isReferenced$1(node, parent, grandparent) {
  switch (parent.type) {
    case "MemberExpression":
    case "OptionalMemberExpression":
      if (parent.property === node) {
        return !!parent.computed;
      }
      return parent.object === node;
    case "JSXMemberExpression":
      return parent.object === node;
    case "VariableDeclarator":
      return parent.init === node;
    case "ArrowFunctionExpression":
      return parent.body === node;
    case "PrivateName":
      return false;
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "ObjectMethod":
      if (parent.key === node) {
        return !!parent.computed;
      }
      return false;
    case "ObjectProperty":
      if (parent.key === node) {
        return !!parent.computed;
      }
      return !grandparent || grandparent.type !== "ObjectPattern";
    case "ClassProperty":
    case "ClassAccessorProperty":
      if (parent.key === node) {
        return !!parent.computed;
      }
      return true;
    case "ClassPrivateProperty":
      return parent.key !== node;
    case "ClassDeclaration":
    case "ClassExpression":
      return parent.superClass === node;
    case "AssignmentExpression":
      return parent.right === node;
    case "AssignmentPattern":
      return parent.right === node;
    case "LabeledStatement":
      return false;
    case "CatchClause":
      return false;
    case "RestElement":
      return false;
    case "BreakStatement":
    case "ContinueStatement":
      return false;
    case "FunctionDeclaration":
    case "FunctionExpression":
      return false;
    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return false;
    case "ExportSpecifier":
      if (grandparent != null && grandparent.source) {
        return false;
      }
      return parent.local === node;
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
      return false;
    case "ImportAttribute":
      return false;
    case "JSXAttribute":
      return false;
    case "ObjectPattern":
    case "ArrayPattern":
      return false;
    case "MetaProperty":
      return false;
    case "ObjectTypeProperty":
      return parent.key !== node;
    case "TSEnumMember":
      return parent.id !== node;
    case "TSPropertySignature":
      if (parent.key === node) {
        return !!parent.computed;
      }
      return true;
  }
  return true;
}
var isScope$2 = {};
Object.defineProperty(isScope$2, "__esModule", { value: true });
isScope$2.default = isScope$1;
var _generated$2 = generated$9;
function isScope$1(node, parent) {
  if (
    (0, _generated$2.isBlockStatement)(node) &&
    ((0, _generated$2.isFunction)(parent) ||
      (0, _generated$2.isCatchClause)(parent))
  ) {
    return false;
  }
  if (
    (0, _generated$2.isPattern)(node) &&
    ((0, _generated$2.isFunction)(parent) ||
      (0, _generated$2.isCatchClause)(parent))
  ) {
    return true;
  }
  return (0, _generated$2.isScopable)(node);
}
var isSpecifierDefault$2 = {};
Object.defineProperty(isSpecifierDefault$2, "__esModule", { value: true });
isSpecifierDefault$2.default = isSpecifierDefault$1;
var _generated$1 = generated$9;
function isSpecifierDefault$1(specifier) {
  return (
    (0, _generated$1.isImportDefaultSpecifier)(specifier) ||
    (0, _generated$1.isIdentifier)(specifier.imported || specifier.exported, {
      name: "default",
    })
  );
}
var isValidES3Identifier$2 = {};
Object.defineProperty(isValidES3Identifier$2, "__esModule", { value: true });
isValidES3Identifier$2.default = isValidES3Identifier$1;
var _isValidIdentifier = isValidIdentifier$2;
const RESERVED_WORDS_ES3_ONLY = new Set([
  "abstract",
  "boolean",
  "byte",
  "char",
  "double",
  "enum",
  "final",
  "float",
  "goto",
  "implements",
  "int",
  "interface",
  "long",
  "native",
  "package",
  "private",
  "protected",
  "public",
  "short",
  "static",
  "synchronized",
  "throws",
  "transient",
  "volatile",
]);
function isValidES3Identifier$1(name) {
  return (
    (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name)
  );
}
var isVar$2 = {};
Object.defineProperty(isVar$2, "__esModule", { value: true });
isVar$2.default = isVar$1;
var _generated = generated$9;
var _constants = constants$1;
function isVar$1(node) {
  return (
    (0, _generated.isVariableDeclaration)(node, { kind: "var" }) &&
    !node[_constants.BLOCK_SCOPED_SYMBOL]
  );
}
var generated$5 = {};
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$5;
  hasRequiredLib$2 = 1;
  (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var _exportNames = {
      react: true,
      assertNode: true,
      createTypeAnnotationBasedOnTypeof: true,
      createUnionTypeAnnotation: true,
      createFlowUnionType: true,
      createTSUnionType: true,
      cloneNode: true,
      clone: true,
      cloneDeep: true,
      cloneDeepWithoutLoc: true,
      cloneWithoutLoc: true,
      addComment: true,
      addComments: true,
      inheritInnerComments: true,
      inheritLeadingComments: true,
      inheritsComments: true,
      inheritTrailingComments: true,
      removeComments: true,
      ensureBlock: true,
      toBindingIdentifierName: true,
      toBlock: true,
      toComputedKey: true,
      toExpression: true,
      toIdentifier: true,
      toKeyAlias: true,
      toSequenceExpression: true,
      toStatement: true,
      valueToNode: true,
      appendToMemberExpression: true,
      inherits: true,
      prependToMemberExpression: true,
      removeProperties: true,
      removePropertiesDeep: true,
      removeTypeDuplicates: true,
      getBindingIdentifiers: true,
      getOuterBindingIdentifiers: true,
      traverse: true,
      traverseFast: true,
      shallowEqual: true,
      is: true,
      isBinding: true,
      isBlockScoped: true,
      isImmutable: true,
      isLet: true,
      isNode: true,
      isNodesEquivalent: true,
      isPlaceholderType: true,
      isReferenced: true,
      isScope: true,
      isSpecifierDefault: true,
      isType: true,
      isValidES3Identifier: true,
      isValidIdentifier: true,
      isVar: true,
      matchesPattern: true,
      validate: true,
      buildMatchMemberExpression: true,
    };
    Object.defineProperty(exports, "addComment", {
      enumerable: true,
      get: function () {
        return _addComment.default;
      },
    });
    Object.defineProperty(exports, "addComments", {
      enumerable: true,
      get: function () {
        return _addComments.default;
      },
    });
    Object.defineProperty(exports, "appendToMemberExpression", {
      enumerable: true,
      get: function () {
        return _appendToMemberExpression.default;
      },
    });
    Object.defineProperty(exports, "assertNode", {
      enumerable: true,
      get: function () {
        return _assertNode.default;
      },
    });
    Object.defineProperty(exports, "buildMatchMemberExpression", {
      enumerable: true,
      get: function () {
        return _buildMatchMemberExpression.default;
      },
    });
    Object.defineProperty(exports, "clone", {
      enumerable: true,
      get: function () {
        return _clone.default;
      },
    });
    Object.defineProperty(exports, "cloneDeep", {
      enumerable: true,
      get: function () {
        return _cloneDeep.default;
      },
    });
    Object.defineProperty(exports, "cloneDeepWithoutLoc", {
      enumerable: true,
      get: function () {
        return _cloneDeepWithoutLoc.default;
      },
    });
    Object.defineProperty(exports, "cloneNode", {
      enumerable: true,
      get: function () {
        return _cloneNode.default;
      },
    });
    Object.defineProperty(exports, "cloneWithoutLoc", {
      enumerable: true,
      get: function () {
        return _cloneWithoutLoc.default;
      },
    });
    Object.defineProperty(exports, "createFlowUnionType", {
      enumerable: true,
      get: function () {
        return _createFlowUnionType.default;
      },
    });
    Object.defineProperty(exports, "createTSUnionType", {
      enumerable: true,
      get: function () {
        return _createTSUnionType.default;
      },
    });
    Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
      enumerable: true,
      get: function () {
        return _createTypeAnnotationBasedOnTypeof.default;
      },
    });
    Object.defineProperty(exports, "createUnionTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _createFlowUnionType.default;
      },
    });
    Object.defineProperty(exports, "ensureBlock", {
      enumerable: true,
      get: function () {
        return _ensureBlock.default;
      },
    });
    Object.defineProperty(exports, "getBindingIdentifiers", {
      enumerable: true,
      get: function () {
        return _getBindingIdentifiers.default;
      },
    });
    Object.defineProperty(exports, "getOuterBindingIdentifiers", {
      enumerable: true,
      get: function () {
        return _getOuterBindingIdentifiers.default;
      },
    });
    Object.defineProperty(exports, "inheritInnerComments", {
      enumerable: true,
      get: function () {
        return _inheritInnerComments.default;
      },
    });
    Object.defineProperty(exports, "inheritLeadingComments", {
      enumerable: true,
      get: function () {
        return _inheritLeadingComments.default;
      },
    });
    Object.defineProperty(exports, "inheritTrailingComments", {
      enumerable: true,
      get: function () {
        return _inheritTrailingComments.default;
      },
    });
    Object.defineProperty(exports, "inherits", {
      enumerable: true,
      get: function () {
        return _inherits.default;
      },
    });
    Object.defineProperty(exports, "inheritsComments", {
      enumerable: true,
      get: function () {
        return _inheritsComments.default;
      },
    });
    Object.defineProperty(exports, "is", {
      enumerable: true,
      get: function () {
        return _is.default;
      },
    });
    Object.defineProperty(exports, "isBinding", {
      enumerable: true,
      get: function () {
        return _isBinding.default;
      },
    });
    Object.defineProperty(exports, "isBlockScoped", {
      enumerable: true,
      get: function () {
        return _isBlockScoped.default;
      },
    });
    Object.defineProperty(exports, "isImmutable", {
      enumerable: true,
      get: function () {
        return _isImmutable.default;
      },
    });
    Object.defineProperty(exports, "isLet", {
      enumerable: true,
      get: function () {
        return _isLet.default;
      },
    });
    Object.defineProperty(exports, "isNode", {
      enumerable: true,
      get: function () {
        return _isNode.default;
      },
    });
    Object.defineProperty(exports, "isNodesEquivalent", {
      enumerable: true,
      get: function () {
        return _isNodesEquivalent.default;
      },
    });
    Object.defineProperty(exports, "isPlaceholderType", {
      enumerable: true,
      get: function () {
        return _isPlaceholderType.default;
      },
    });
    Object.defineProperty(exports, "isReferenced", {
      enumerable: true,
      get: function () {
        return _isReferenced.default;
      },
    });
    Object.defineProperty(exports, "isScope", {
      enumerable: true,
      get: function () {
        return _isScope.default;
      },
    });
    Object.defineProperty(exports, "isSpecifierDefault", {
      enumerable: true,
      get: function () {
        return _isSpecifierDefault.default;
      },
    });
    Object.defineProperty(exports, "isType", {
      enumerable: true,
      get: function () {
        return _isType.default;
      },
    });
    Object.defineProperty(exports, "isValidES3Identifier", {
      enumerable: true,
      get: function () {
        return _isValidES3Identifier.default;
      },
    });
    Object.defineProperty(exports, "isValidIdentifier", {
      enumerable: true,
      get: function () {
        return _isValidIdentifier.default;
      },
    });
    Object.defineProperty(exports, "isVar", {
      enumerable: true,
      get: function () {
        return _isVar.default;
      },
    });
    Object.defineProperty(exports, "matchesPattern", {
      enumerable: true,
      get: function () {
        return _matchesPattern.default;
      },
    });
    Object.defineProperty(exports, "prependToMemberExpression", {
      enumerable: true,
      get: function () {
        return _prependToMemberExpression.default;
      },
    });
    exports.react = void 0;
    Object.defineProperty(exports, "removeComments", {
      enumerable: true,
      get: function () {
        return _removeComments.default;
      },
    });
    Object.defineProperty(exports, "removeProperties", {
      enumerable: true,
      get: function () {
        return _removeProperties.default;
      },
    });
    Object.defineProperty(exports, "removePropertiesDeep", {
      enumerable: true,
      get: function () {
        return _removePropertiesDeep.default;
      },
    });
    Object.defineProperty(exports, "removeTypeDuplicates", {
      enumerable: true,
      get: function () {
        return _removeTypeDuplicates.default;
      },
    });
    Object.defineProperty(exports, "shallowEqual", {
      enumerable: true,
      get: function () {
        return _shallowEqual.default;
      },
    });
    Object.defineProperty(exports, "toBindingIdentifierName", {
      enumerable: true,
      get: function () {
        return _toBindingIdentifierName.default;
      },
    });
    Object.defineProperty(exports, "toBlock", {
      enumerable: true,
      get: function () {
        return _toBlock.default;
      },
    });
    Object.defineProperty(exports, "toComputedKey", {
      enumerable: true,
      get: function () {
        return _toComputedKey.default;
      },
    });
    Object.defineProperty(exports, "toExpression", {
      enumerable: true,
      get: function () {
        return _toExpression.default;
      },
    });
    Object.defineProperty(exports, "toIdentifier", {
      enumerable: true,
      get: function () {
        return _toIdentifier.default;
      },
    });
    Object.defineProperty(exports, "toKeyAlias", {
      enumerable: true,
      get: function () {
        return _toKeyAlias.default;
      },
    });
    Object.defineProperty(exports, "toSequenceExpression", {
      enumerable: true,
      get: function () {
        return _toSequenceExpression.default;
      },
    });
    Object.defineProperty(exports, "toStatement", {
      enumerable: true,
      get: function () {
        return _toStatement.default;
      },
    });
    Object.defineProperty(exports, "traverse", {
      enumerable: true,
      get: function () {
        return _traverse.default;
      },
    });
    Object.defineProperty(exports, "traverseFast", {
      enumerable: true,
      get: function () {
        return _traverseFast.default;
      },
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function () {
        return _validate.default;
      },
    });
    Object.defineProperty(exports, "valueToNode", {
      enumerable: true,
      get: function () {
        return _valueToNode.default;
      },
    });
    var _isReactComponent = isReactComponent$2;
    var _isCompatTag = isCompatTag$2;
    var _buildChildren = requireBuildChildren$1();
    var _assertNode = assertNode$2;
    var _generated = generated$7;
    Object.keys(_generated).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _generated[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _generated[key];
        },
      });
    });
    var _createTypeAnnotationBasedOnTypeof =
      requireCreateTypeAnnotationBasedOnTypeof$1();
    var _createFlowUnionType = requireCreateFlowUnionType$1();
    var _createTSUnionType = requireCreateTSUnionType$1();
    var _generated2 = requireGenerated$5();
    Object.keys(_generated2).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _generated2[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _generated2[key];
        },
      });
    });
    var _uppercase = requireUppercase$1();
    Object.keys(_uppercase).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _uppercase[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _uppercase[key];
        },
      });
    });
    var _cloneNode = cloneNode$2;
    var _clone = clone$2;
    var _cloneDeep = cloneDeep$2;
    var _cloneDeepWithoutLoc = cloneDeepWithoutLoc$2;
    var _cloneWithoutLoc = cloneWithoutLoc$2;
    var _addComment = addComment$2;
    var _addComments = addComments$2;
    var _inheritInnerComments = inheritInnerComments$2;
    var _inheritLeadingComments = inheritLeadingComments$2;
    var _inheritsComments = inheritsComments$2;
    var _inheritTrailingComments = inheritTrailingComments$2;
    var _removeComments = removeComments$2;
    var _generated3 = generated$6;
    Object.keys(_generated3).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _generated3[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _generated3[key];
        },
      });
    });
    var _constants = constants$1;
    Object.keys(_constants).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _constants[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _constants[key];
        },
      });
    });
    var _ensureBlock = requireEnsureBlock$1();
    var _toBindingIdentifierName = toBindingIdentifierName$2;
    var _toBlock = requireToBlock$1();
    var _toComputedKey = requireToComputedKey$1();
    var _toExpression = toExpression$2;
    var _toIdentifier = toIdentifier$2;
    var _toKeyAlias = toKeyAlias$2;
    var _toSequenceExpression = requireToSequenceExpression$1();
    var _toStatement = requireToStatement$1();
    var _valueToNode = requireValueToNode$1();
    var _definitions = requireDefinitions$1();
    Object.keys(_definitions).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _definitions[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _definitions[key];
        },
      });
    });
    var _appendToMemberExpression = requireAppendToMemberExpression$1();
    var _inherits = inherits$2;
    var _prependToMemberExpression = requirePrependToMemberExpression$1();
    var _removeProperties = removeProperties$2;
    var _removePropertiesDeep = removePropertiesDeep$2;
    var _removeTypeDuplicates = removeTypeDuplicates$5;
    var _getBindingIdentifiers = getBindingIdentifiers$2;
    var _getOuterBindingIdentifiers = getOuterBindingIdentifiers$2;
    var _traverse = traverse$2;
    Object.keys(_traverse).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _traverse[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _traverse[key];
        },
      });
    });
    var _traverseFast = traverseFast$2;
    var _shallowEqual = shallowEqual$2;
    var _is = requireIs$1();
    var _isBinding = isBinding$2;
    var _isBlockScoped = isBlockScoped$2;
    var _isImmutable = isImmutable$2;
    var _isLet = isLet$2;
    var _isNode = isNode$2;
    var _isNodesEquivalent = isNodesEquivalent$2;
    var _isPlaceholderType = requireIsPlaceholderType$1();
    var _isReferenced = isReferenced$2;
    var _isScope = isScope$2;
    var _isSpecifierDefault = isSpecifierDefault$2;
    var _isType = requireIsType$1();
    var _isValidES3Identifier = isValidES3Identifier$2;
    var _isValidIdentifier = isValidIdentifier$2;
    var _isVar = isVar$2;
    var _matchesPattern = matchesPattern$2;
    var _validate = requireValidate$1();
    var _buildMatchMemberExpression = buildMatchMemberExpression$2;
    var _generated4 = generated$9;
    Object.keys(_generated4).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _generated4[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _generated4[key];
        },
      });
    });
    var _generated5 = generated$5;
    Object.keys(_generated5).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _generated5[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _generated5[key];
        },
      });
    });
    const react = {
      isReactComponent: _isReactComponent.default,
      isCompatTag: _isCompatTag.default,
      buildChildren: _buildChildren.default,
    };
    exports.react = react;
  })(lib$5);
  return lib$5;
}
var libExports = requireLib$2();
function insertGatedFunctionDeclaration(fnPath, compiled, gating) {
  const gatingExpression = libExports.conditionalExpression(
    libExports.callExpression(
      libExports.identifier(gating.importSpecifierName),
      []
    ),
    buildFunctionExpression(compiled),
    buildFunctionExpression(fnPath.node)
  );
  if (
    fnPath.parentPath.node.type !== "ExportDefaultDeclaration" &&
    fnPath.node.type === "FunctionDeclaration" &&
    fnPath.node.id != null
  ) {
    fnPath.replaceWith(
      libExports.variableDeclaration("const", [
        libExports.variableDeclarator(fnPath.node.id, gatingExpression),
      ])
    );
  } else if (
    fnPath.parentPath.node.type === "ExportDefaultDeclaration" &&
    fnPath.node.type !== "ArrowFunctionExpression" &&
    fnPath.node.id != null
  ) {
    fnPath.insertAfter(
      libExports.exportDefaultDeclaration(
        libExports.identifier(fnPath.node.id.name)
      )
    );
    fnPath.parentPath.replaceWith(
      libExports.variableDeclaration("const", [
        libExports.variableDeclarator(
          libExports.identifier(fnPath.node.id.name),
          gatingExpression
        ),
      ])
    );
  } else {
    fnPath.replaceWith(gatingExpression);
  }
}
function buildFunctionExpression(node) {
  var _a, _b;
  if (
    node.type === "ArrowFunctionExpression" ||
    node.type === "FunctionExpression"
  ) {
    return node;
  } else {
    const fn = {
      type: "FunctionExpression",
      async: node.async,
      generator: node.generator,
      loc: (_a = node.loc) !== null && _a !== void 0 ? _a : null,
      id: (_b = node.id) !== null && _b !== void 0 ? _b : null,
      params: node.params,
      body: node.body,
    };
    return fn;
  }
}
function assertExhaustive$1(_, errorMsg) {
  throw new Error(errorMsg);
}
function retainWhere(array, predicate) {
  let writeIndex = 0;
  for (let readIndex = 0; readIndex < array.length; readIndex++) {
    const item = array[readIndex];
    if (predicate(item) === true) {
      array[writeIndex++] = item;
    }
  }
  array.length = writeIndex;
}
function getOrInsertWith(m, key, makeDefault) {
  if (m.has(key)) {
    return m.get(key);
  } else {
    const defaultValue = makeDefault();
    m.set(key, defaultValue);
    return defaultValue;
  }
}
function getOrInsertDefault(m, key, defaultValue) {
  if (m.has(key)) {
    return m.get(key);
  } else {
    m.set(key, defaultValue);
    return defaultValue;
  }
}
function hasNode(input) {
  return input.node != null;
}
function hasOwnProperty(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
var ErrorSeverity;
(function (ErrorSeverity) {
  ErrorSeverity["InvalidJS"] = "InvalidJS";
  ErrorSeverity["InvalidReact"] = "InvalidReact";
  ErrorSeverity["InvalidConfig"] = "InvalidConfig";
  ErrorSeverity["CannotPreserveMemoization"] = "CannotPreserveMemoization";
  ErrorSeverity["Todo"] = "Todo";
  ErrorSeverity["Invariant"] = "Invariant";
})(ErrorSeverity || (ErrorSeverity = {}));
var CompilerSuggestionOperation;
(function (CompilerSuggestionOperation) {
  CompilerSuggestionOperation[
    (CompilerSuggestionOperation["InsertBefore"] = 0)
  ] = "InsertBefore";
  CompilerSuggestionOperation[
    (CompilerSuggestionOperation["InsertAfter"] = 1)
  ] = "InsertAfter";
  CompilerSuggestionOperation[(CompilerSuggestionOperation["Remove"] = 2)] =
    "Remove";
  CompilerSuggestionOperation[(CompilerSuggestionOperation["Replace"] = 3)] =
    "Replace";
})(CompilerSuggestionOperation || (CompilerSuggestionOperation = {}));
class CompilerErrorDetail {
  constructor(options) {
    this.options = options;
  }
  get reason() {
    return this.options.reason;
  }
  get description() {
    return this.options.description;
  }
  get severity() {
    return this.options.severity;
  }
  get loc() {
    return this.options.loc;
  }
  get suggestions() {
    return this.options.suggestions;
  }
  printErrorMessage() {
    const buffer = [`${this.severity}: ${this.reason}`];
    if (this.description != null) {
      buffer.push(`. ${this.description}`);
    }
    if (this.loc != null && typeof this.loc !== "symbol") {
      buffer.push(` (${this.loc.start.line}:${this.loc.end.line})`);
    }
    return buffer.join("");
  }
  toString() {
    return this.printErrorMessage();
  }
}
class CompilerError extends Error {
  static invariant(condition, options) {
    if (!condition) {
      const errors = new CompilerError();
      errors.pushErrorDetail(
        new CompilerErrorDetail(
          Object.assign(Object.assign({}, options), {
            severity: ErrorSeverity.Invariant,
          })
        )
      );
      throw errors;
    }
  }
  static throwTodo(options) {
    const errors = new CompilerError();
    errors.pushErrorDetail(
      new CompilerErrorDetail(
        Object.assign(Object.assign({}, options), {
          severity: ErrorSeverity.Todo,
        })
      )
    );
    throw errors;
  }
  static throwInvalidJS(options) {
    const errors = new CompilerError();
    errors.pushErrorDetail(
      new CompilerErrorDetail(
        Object.assign(Object.assign({}, options), {
          severity: ErrorSeverity.InvalidJS,
        })
      )
    );
    throw errors;
  }
  static throwInvalidReact(options) {
    const errors = new CompilerError();
    errors.pushErrorDetail(
      new CompilerErrorDetail(
        Object.assign(Object.assign({}, options), {
          severity: ErrorSeverity.InvalidReact,
        })
      )
    );
    throw errors;
  }
  static throwInvalidConfig(options) {
    const errors = new CompilerError();
    errors.pushErrorDetail(
      new CompilerErrorDetail(
        Object.assign(Object.assign({}, options), {
          severity: ErrorSeverity.InvalidConfig,
        })
      )
    );
    throw errors;
  }
  static throw(options) {
    const errors = new CompilerError();
    errors.pushErrorDetail(new CompilerErrorDetail(options));
    throw errors;
  }
  constructor(...args) {
    super(...args);
    this.details = [];
    this.name = "ReactCompilerError";
  }
  get message() {
    return this.toString();
  }
  set message(_message) {}
  toString() {
    return this.details.map((detail) => detail.toString()).join("\n\n");
  }
  push(options) {
    var _a;
    const detail = new CompilerErrorDetail({
      reason: options.reason,
      description:
        (_a = options.description) !== null && _a !== void 0 ? _a : null,
      severity: options.severity,
      suggestions: options.suggestions,
      loc: typeof options.loc === "symbol" ? null : options.loc,
    });
    return this.pushErrorDetail(detail);
  }
  pushErrorDetail(detail) {
    this.details.push(detail);
    return detail;
  }
  hasErrors() {
    return this.details.length > 0;
  }
  isCritical() {
    return this.details.some((detail) => {
      switch (detail.severity) {
        case ErrorSeverity.Invariant:
        case ErrorSeverity.InvalidJS:
        case ErrorSeverity.InvalidReact:
        case ErrorSeverity.InvalidConfig:
          return true;
        case ErrorSeverity.CannotPreserveMemoization:
        case ErrorSeverity.Todo:
          return false;
        default:
          assertExhaustive$1(detail.severity, "Unhandled error severity");
      }
    });
  }
}
function makeTypeId(id) {
  CompilerError.invariant(id >= 0 && Number.isInteger(id), {
    reason: "Expected instruction id to be a non-negative integer",
    description: null,
    loc: null,
    suggestions: null,
  });
  return id;
}
let typeCounter = 0;
function makeType() {
  return { kind: "Type", id: makeTypeId(typeCounter++) };
}
function typeEquals(tA, tB) {
  if (tA.kind !== tB.kind) return false;
  return (
    typeVarEquals(tA, tB) ||
    funcTypeEquals(tA, tB) ||
    objectTypeEquals(tA, tB) ||
    primitiveTypeEquals(tA, tB) ||
    polyTypeEquals(tA, tB) ||
    phiTypeEquals(tA, tB) ||
    propTypeEquals(tA, tB) ||
    objectMethodTypeEquals(tA, tB)
  );
}
function typeVarEquals(tA, tB) {
  if (tA.kind === "Type" && tB.kind === "Type") {
    return tA.id === tB.id;
  }
  return false;
}
function typeKindCheck(tA, tb, type) {
  return tA.kind === type && tb.kind === type;
}
function objectMethodTypeEquals(tA, tB) {
  return typeKindCheck(tA, tB, "ObjectMethod");
}
function propTypeEquals(tA, tB) {
  if (tA.kind === "Property" && tB.kind === "Property") {
    if (!typeEquals(tA.objectType, tB.objectType)) {
      return false;
    }
    return (
      tA.propertyName === tB.propertyName && tA.objectName === tB.objectName
    );
  }
  return false;
}
function primitiveTypeEquals(tA, tB) {
  return typeKindCheck(tA, tB, "Primitive");
}
function polyTypeEquals(tA, tB) {
  return typeKindCheck(tA, tB, "Poly");
}
function objectTypeEquals(tA, tB) {
  if (tA.kind === "Object" && tB.kind == "Object") {
    return tA.shapeId === tB.shapeId;
  }
  return false;
}
function funcTypeEquals(tA, tB) {
  if (tA.kind !== "Function" || tB.kind !== "Function") {
    return false;
  }
  return typeEquals(tA.return, tB.return);
}
function phiTypeEquals(tA, tB) {
  if (tA.kind === "Phi" && tB.kind === "Phi") {
    if (tA.operands.length !== tB.operands.length) {
      return false;
    }
    let operands = new Set(tA.operands);
    for (let i = 0; i < tB.operands.length; i++) {
      if (!operands.has(tB.operands[i])) {
        return false;
      }
    }
  }
  return false;
}
const GeneratedSource = Symbol();
function isStatementBlockKind(kind) {
  return kind === "block" || kind === "catch";
}
function isExpressionBlockKind(kind) {
  return !isStatementBlockKind(kind);
}
var GotoVariant;
(function (GotoVariant) {
  GotoVariant["Break"] = "Break";
  GotoVariant["Continue"] = "Continue";
  GotoVariant["Try"] = "Try";
})(GotoVariant || (GotoVariant = {}));
var InstructionKind;
(function (InstructionKind) {
  InstructionKind["Const"] = "Const";
  InstructionKind["Let"] = "Let";
  InstructionKind["Reassign"] = "Reassign";
  InstructionKind["Catch"] = "Catch";
  InstructionKind["HoistedConst"] = "HoistedConst";
})(InstructionKind || (InstructionKind = {}));
function makeIdentifierName(name) {
  CompilerError.invariant(libExports.isValidIdentifier(name), {
    reason: `Expected a valid identifier name`,
    loc: GeneratedSource,
    description: `\`${name}\` is not a valid JavaScript identifier`,
    suggestions: null,
  });
  return { kind: "named", value: name };
}
function promoteTemporary(identifier) {
  CompilerError.invariant(identifier.name === null, {
    reason: `Expected a temporary (unnamed) identifier`,
    loc: GeneratedSource,
    description: `Identifier already has a name, \`${identifier.name}\``,
    suggestions: null,
  });
  identifier.name = { kind: "promoted", value: `#t${identifier.id}` };
}
function isPromotedTemporary(name) {
  return name.startsWith("#t");
}
function promoteTemporaryJsxTag(identifier) {
  CompilerError.invariant(identifier.name === null, {
    reason: `Expected a temporary (unnamed) identifier`,
    loc: GeneratedSource,
    description: `Identifier already has a name, \`${identifier.name}\``,
    suggestions: null,
  });
  identifier.name = { kind: "promoted", value: `#T${identifier.id}` };
}
function isPromotedJsxTemporary(name) {
  return name.startsWith("#T");
}
var ValueReason;
(function (ValueReason) {
  ValueReason["Global"] = "global";
  ValueReason["JsxCaptured"] = "jsx-captured";
  ValueReason["KnownReturnSignature"] = "known-return-signature";
  ValueReason["Context"] = "context";
  ValueReason["State"] = "state";
  ValueReason["ReducerState"] = "reducer-state";
  ValueReason["ReactiveFunctionArgument"] = "reactive-function-argument";
  ValueReason["Other"] = "other";
})(ValueReason || (ValueReason = {}));
var ValueKind;
(function (ValueKind) {
  ValueKind["MaybeFrozen"] = "maybefrozen";
  ValueKind["Frozen"] = "frozen";
  ValueKind["Primitive"] = "primitive";
  ValueKind["Global"] = "global";
  ValueKind["Mutable"] = "mutable";
  ValueKind["Context"] = "context";
})(ValueKind || (ValueKind = {}));
var Effect;
(function (Effect) {
  Effect["Unknown"] = "<unknown>";
  Effect["Freeze"] = "freeze";
  Effect["Read"] = "read";
  Effect["Capture"] = "capture";
  Effect["ConditionallyMutate"] = "mutate?";
  Effect["Mutate"] = "mutate";
  Effect["Store"] = "store";
})(Effect || (Effect = {}));
function isMutableEffect(effect, location) {
  switch (effect) {
    case Effect.Capture:
    case Effect.Store:
    case Effect.ConditionallyMutate:
    case Effect.Mutate: {
      return true;
    }
    case Effect.Unknown: {
      CompilerError.invariant(false, {
        reason: "Unexpected unknown effect",
        description: null,
        loc: location,
        suggestions: null,
      });
    }
    case Effect.Read:
    case Effect.Freeze: {
      return false;
    }
    default: {
      assertExhaustive$1(effect, `Unexpected effect \`${effect}\``);
    }
  }
}
function makeBlockId(id) {
  CompilerError.invariant(id >= 0 && Number.isInteger(id), {
    reason: "Expected block id to be a non-negative integer",
    description: null,
    loc: null,
    suggestions: null,
  });
  return id;
}
function makeScopeId(id) {
  CompilerError.invariant(id >= 0 && Number.isInteger(id), {
    reason: "Expected block id to be a non-negative integer",
    description: null,
    loc: null,
    suggestions: null,
  });
  return id;
}
function makeIdentifierId(id) {
  CompilerError.invariant(id >= 0 && Number.isInteger(id), {
    reason: "Expected identifier id to be a non-negative integer",
    description: null,
    loc: null,
    suggestions: null,
  });
  return id;
}
function makeInstructionId(id) {
  CompilerError.invariant(id >= 0 && Number.isInteger(id), {
    reason: "Expected instruction id to be a non-negative integer",
    description: null,
    loc: null,
    suggestions: null,
  });
  return id;
}
function isObjectMethodType(id) {
  return id.type.kind == "ObjectMethod";
}
function isObjectType(id) {
  return id.type.kind === "Object";
}
function isPrimitiveType(id) {
  return id.type.kind === "Primitive";
}
function isArrayType(id) {
  return id.type.kind === "Object" && id.type.shapeId === "BuiltInArray";
}
function isRefValueType(id) {
  return id.type.kind === "Object" && id.type.shapeId === "BuiltInRefValue";
}
function isUseRefType(id) {
  return id.type.kind === "Object" && id.type.shapeId === "BuiltInUseRefId";
}
function isUseStateType(id) {
  return id.type.kind === "Object" && id.type.shapeId === "BuiltInUseState";
}
function isSetStateType(id) {
  return id.type.kind === "Function" && id.type.shapeId === "BuiltInSetState";
}
function isSetActionStateType(id) {
  return (
    id.type.kind === "Function" && id.type.shapeId === "BuiltInSetActionState"
  );
}
function isDispatcherType(id) {
  return id.type.kind === "Function" && id.type.shapeId === "BuiltInDispatch";
}
function isStableType(id) {
  return isSetStateType(id) || isSetActionStateType(id) || isDispatcherType(id);
}
function isUseEffectHookType(id) {
  return (
    id.type.kind === "Function" && id.type.shapeId === "BuiltInUseEffectHook"
  );
}
function isUseLayoutEffectHookType(id) {
  return (
    id.type.kind === "Function" &&
    id.type.shapeId === "BuiltInUseLayoutEffectHook"
  );
}
function isUseInsertionEffectHookType(id) {
  return (
    id.type.kind === "Function" &&
    id.type.shapeId === "BuiltInUseInsertionEffectHook"
  );
}
function getHookKind(env, id) {
  return getHookKindForType(env, id.type);
}
function isUseOperator(id) {
  return (
    id.type.kind === "Function" && id.type.shapeId === "BuiltInUseOperator"
  );
}
function getHookKindForType(env, type) {
  var _a;
  if (type.kind === "Function") {
    const signature = env.getFunctionSignature(type);
    return (_a =
      signature === null || signature === void 0
        ? void 0
        : signature.hookKind) !== null && _a !== void 0
      ? _a
      : null;
  }
  return null;
}
var lib$2 = {};
var sourceMap$1 = {};
var sourceMap = {};
var sourceMapGenerator = {};
var base64Vlq = {};
var base64 = {};
var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64) return base64;
  hasRequiredBase64 = 1;
  var intToCharMap =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(
      ""
    );
  base64.encode = function (number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };
  base64.decode = function (charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }
    if (charCode == plus) {
      return 62;
    }
    if (charCode == slash) {
      return 63;
    }
    return -1;
  };
  return base64;
}
var hasRequiredBase64Vlq;
function requireBase64Vlq() {
  if (hasRequiredBase64Vlq) return base64Vlq;
  hasRequiredBase64Vlq = 1;
  var base64 = requireBase64();
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  base64Vlq.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
  return base64Vlq;
}
var util = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  (function (exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp =
      /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5],
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined =
        aPath.charAt(0) === "/"
          ? aPath
          : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function (aPath) {
      return aPath.charAt(0) === "/" || !!aPath.match(urlRegexp);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = (function () {
      var obj = Object.create(null);
      return !("__proto__" in obj);
    })();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (
        s.charCodeAt(length - 1) !== 95 ||
        s.charCodeAt(length - 2) !== 95 ||
        s.charCodeAt(length - 3) !== 111 ||
        s.charCodeAt(length - 4) !== 116 ||
        s.charCodeAt(length - 5) !== 111 ||
        s.charCodeAt(length - 6) !== 114 ||
        s.charCodeAt(length - 7) !== 112 ||
        s.charCodeAt(length - 8) !== 95 ||
        s.charCodeAt(length - 9) !== 95
      ) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(
      mappingA,
      mappingB,
      onlyCompareOriginal
    ) {
      var cmp = mappingA.source - mappingB.source;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return mappingA.name - mappingB.name;
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(
      mappingA,
      mappingB,
      onlyCompareGenerated
    ) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = mappingA.source - mappingB.source;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return mappingA.name - mappingB.name;
    }
    exports.compareByGeneratedPositionsDeflated =
      compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated =
      compareByGeneratedPositionsInflated;
  })(util);
  return util;
}
var arraySet = {};
var hasRequiredArraySet;
function requireArraySet() {
  if (hasRequiredArraySet) return arraySet;
  hasRequiredArraySet = 1;
  var util = requireUtil();
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
  }
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap
      ? this._set.size
      : Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  arraySet.ArraySet = ArraySet;
  return arraySet;
}
var mappingList = {};
var hasRequiredMappingList;
function requireMappingList() {
  if (hasRequiredMappingList) return mappingList;
  hasRequiredMappingList = 1;
  var util = requireUtil();
  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return (
      lineB > lineA ||
      (lineB == lineA && columnB >= columnA) ||
      util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0
    );
  }
  function MappingList() {
    this._array = [];
    this._sorted = true;
    this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  MappingList.prototype.unsortedForEach = function MappingList_forEach(
    aCallback,
    aThisArg
  ) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  mappingList.MappingList = MappingList;
  return mappingList;
}
var hasRequiredSourceMapGenerator;
function requireSourceMapGenerator() {
  if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
  hasRequiredSourceMapGenerator = 1;
  var base64VLQ = requireBase64Vlq();
  var util = requireUtil();
  var ArraySet = requireArraySet().ArraySet;
  var MappingList = requireMappingList().MappingList;
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, "file", null);
    this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util.getArg(aArgs, "skipValidation", false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(
    aSourceMapConsumer
  ) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot,
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn,
        },
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn,
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name,
      });
    };
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(
      aSourceMapConsumer,
      aSourceFile,
      aSourceMapPath
    ) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            "SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, " +
              'or the source map\'s "file" property. Both were omitted.'
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function (mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn,
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile = util.join(aSourceMapPath, sourceFile);
          }
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(
      aGenerated,
      aOriginal,
      aSource,
      aName
    ) {
      if (
        aOriginal &&
        typeof aOriginal.line !== "number" &&
        typeof aOriginal.column !== "number"
      ) {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit " +
            "the original mapping entirely and only map the generated position. If so, pass " +
            "null for the original mapping instead of an object with empty or null values."
        );
      }
      if (
        aGenerated &&
        "line" in aGenerated &&
        "column" in aGenerated &&
        aGenerated.line > 0 &&
        aGenerated.column >= 0 &&
        !aOriginal &&
        !aSource &&
        !aName
      ) {
        return;
      } else if (
        aGenerated &&
        "line" in aGenerated &&
        "column" in aGenerated &&
        aOriginal &&
        "line" in aOriginal &&
        "column" in aOriginal &&
        aGenerated.line > 0 &&
        aGenerated.column >= 0 &&
        aOriginal.line > 0 &&
        aOriginal.column >= 0 &&
        aSource
      ) {
        return;
      } else {
        throw new Error(
          "Invalid mapping: " +
            JSON.stringify({
              generated: aGenerated,
              source: aSource,
              original: aOriginal,
              name: aName,
            })
        );
      }
    };
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (
              !util.compareByGeneratedPositionsInflated(
                mapping,
                mappings[i - 1]
              )
            ) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(
          mapping.generatedColumn - previousGeneratedColumn
        );
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(
            mapping.originalLine - 1 - previousOriginalLine
          );
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(
            mapping.originalColumn - previousOriginalColumn
          );
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings(),
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(
        map.sources,
        map.sourceRoot
      );
    }
    return map;
  };
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
  sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
  return sourceMapGenerator;
}
var sourceMapConsumer = {};
var binarySearch = {};
var hasRequiredBinarySearch;
function requireBinarySearch() {
  if (hasRequiredBinarySearch) return binarySearch;
  hasRequiredBinarySearch = 1;
  (function (exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(
            mid,
            aHigh,
            aNeedle,
            aHaystack,
            aCompare,
            aBias
          );
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(
            aLow,
            mid,
            aNeedle,
            aHaystack,
            aCompare,
            aBias
          );
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND
      );
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  })(binarySearch);
  return binarySearch;
}
var quickSort = {};
var hasRequiredQuickSort;
function requireQuickSort() {
  if (hasRequiredQuickSort) return quickSort;
  hasRequiredQuickSort = 1;
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }
  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }
  function doQuickSort(ary, comparator, p, r) {
    if (p < r) {
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;
      swap(ary, pivotIndex, r);
      var pivot = ary[r];
      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }
      swap(ary, i + 1, j);
      var q = i + 1;
      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }
  quickSort.quickSort = function (ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };
  return quickSort;
}
var hasRequiredSourceMapConsumer;
function requireSourceMapConsumer() {
  if (hasRequiredSourceMapConsumer) return sourceMapConsumer;
  hasRequiredSourceMapConsumer = 1;
  var util = requireUtil();
  var binarySearch = requireBinarySearch();
  var ArraySet = requireArraySet().ArraySet;
  var base64VLQ = requireBase64Vlq();
  var quickSort = requireQuickSort().quickSort;
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
    }
    return sourceMap.sections != null
      ? new IndexedSourceMapConsumer(sourceMap)
      : new BasicSourceMapConsumer(sourceMap);
  }
  SourceMapConsumer.fromSourceMap = function (aSourceMap) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
  };
  SourceMapConsumer.prototype._version = 3;
  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
    get: function () {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__generatedMappings;
    },
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
    get: function () {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__originalMappings;
    },
  });
  SourceMapConsumer.prototype._charIsMappingSeparator =
    function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings
        .map(function (mapping) {
          var source =
            mapping.source === null ? null : this._sources.at(mapping.source);
          if (source != null && sourceRoot != null) {
            source = util.join(sourceRoot, source);
          }
          return {
            source: source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : this._names.at(mapping.name),
          };
        }, this)
        .forEach(aCallback, context);
    };
  SourceMapConsumer.prototype.allGeneratedPositionsFor =
    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0),
      };
      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }
      if (!this._sources.has(needle.source)) {
        return [];
      }
      needle.source = this._sources.indexOf(needle.source);
      var mappings = [];
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === undefined) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null),
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (
            mapping &&
            mapping.originalLine === line &&
            mapping.originalColumn == originalColumn
          ) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null),
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
  sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;
  function BasicSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
    }
    var version = util.getArg(sourceMap, "version");
    var sources = util.getArg(sourceMap, "sources");
    var names = util.getArg(sourceMap, "names", []);
    var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
    var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
    var mappings = util.getArg(sourceMap, "mappings");
    var file = util.getArg(sourceMap, "file", null);
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    sources = sources
      .map(String)
      .map(util.normalize)
      .map(function (source) {
        return sourceRoot &&
          util.isAbsolute(sourceRoot) &&
          util.isAbsolute(source)
          ? util.relative(sourceRoot, source)
          : source;
      });
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
  BasicSourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = (smc._names = ArraySet.fromArray(
        aSourceMap._names.toArray(),
        true
      ));
      var sources = (smc._sources = ArraySet.fromArray(
        aSourceMap._sources.toArray(),
        true
      ));
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      );
      smc.file = aSourceMap._file;
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = (smc.__generatedMappings = []);
      var destOriginalMappings = (smc.__originalMappings = []);
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
  BasicSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
      }, this);
    },
  });
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }
  BasicSourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
  BasicSourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(
      aNeedle,
      aMappings,
      aLineName,
      aColumnName,
      aComparator,
      aBias
    ) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError(
          "Line must be greater than or equal to 1, got " + aNeedle[aLineName]
        );
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError(
          "Column must be greater than or equal to 0, got " +
            aNeedle[aColumnName]
        );
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
  BasicSourceMapConsumer.prototype.computeColumnSpans =
    function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
  BasicSourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column"),
      };
      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            if (this.sourceRoot != null) {
              source = util.join(this.sourceRoot, source);
            }
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source: source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name: name,
          };
        }
      }
      return { source: null, line: null, column: null, name: null };
    };
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
    function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return (
        this.sourcesContent.length >= this._sources.size() &&
        !this.sourcesContent.some(function (sc) {
          return sc == null;
        })
      );
    };
  BasicSourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      if (this.sourceRoot != null) {
        aSource = util.relative(this.sourceRoot, aSource);
      }
      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if (
          (!url.path || url.path == "/") &&
          this._sources.has("/" + aSource)
        ) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
  BasicSourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      if (this.sourceRoot != null) {
        source = util.relative(this.sourceRoot, source);
      }
      if (!this._sources.has(source)) {
        return { line: null, column: null, lastColumn: null };
      }
      source = this._sources.indexOf(source);
      var needle = {
        source: source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column"),
      };
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null),
          };
        }
      }
      return { line: null, column: null, lastColumn: null };
    };
  sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;
  function IndexedSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
    }
    var version = util.getArg(sourceMap, "version");
    var sections = util.getArg(sourceMap, "sections");
    if (version != this._version) {
      throw new Error("Unsupported version: " + version);
    }
    this._sources = new ArraySet();
    this._names = new ArraySet();
    var lastOffset = { line: -1, column: 0 };
    this._sections = sections.map(function (s) {
      if (s.url) {
        throw new Error("Support for url field in sections not implemented.");
      }
      var offset = util.getArg(s, "offset");
      var offsetLine = util.getArg(offset, "line");
      var offsetColumn = util.getArg(offset, "column");
      if (
        offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)
      ) {
        throw new Error("Section offsets must be ordered and non-overlapping.");
      }
      lastOffset = offset;
      return {
        generatedOffset: {
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1,
        },
        consumer: new SourceMapConsumer(util.getArg(s, "map")),
      };
    });
  }
  IndexedSourceMapConsumer.prototype = Object.create(
    SourceMapConsumer.prototype
  );
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  IndexedSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
    get: function () {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }
      return sources;
    },
  });
  IndexedSourceMapConsumer.prototype.originalPositionFor =
    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column"),
      };
      var sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function (needle, section) {
          var cmp =
            needle.generatedLine - section.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return (
            needle.generatedColumn - section.generatedOffset.generatedColumn
          );
        }
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return { source: null, line: null, column: null, name: null };
      }
      return section.consumer.originalPositionFor({
        line:
          needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column:
          needle.generatedColumn -
          (section.generatedOffset.generatedLine === needle.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
        bias: aArgs.bias,
      });
    };
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
    function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function (s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
  IndexedSourceMapConsumer.prototype.sourceContentFor =
    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
  IndexedSourceMapConsumer.prototype.generatedPositionFor =
    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (
          section.consumer.sources.indexOf(util.getArg(aArgs, "source")) === -1
        ) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line:
              generatedPosition.line +
              (section.generatedOffset.generatedLine - 1),
            column:
              generatedPosition.column +
              (section.generatedOffset.generatedLine === generatedPosition.line
                ? section.generatedOffset.generatedColumn - 1
                : 0),
          };
          return ret;
        }
      }
      return { line: null, column: null };
    };
  IndexedSourceMapConsumer.prototype._parseMappings =
    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          if (section.consumer.sourceRoot !== null) {
            source = util.join(section.consumer.sourceRoot, source);
          }
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
          var adjustedMapping = {
            source: source,
            generatedLine:
              mapping.generatedLine +
              (section.generatedOffset.generatedLine - 1),
            generatedColumn:
              mapping.generatedColumn +
              (section.generatedOffset.generatedLine === mapping.generatedLine
                ? section.generatedOffset.generatedColumn - 1
                : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: name,
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(
        this.__generatedMappings,
        util.compareByGeneratedPositionsDeflated
      );
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
  sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  return sourceMapConsumer;
}
var sourceNode = {};
var hasRequiredSourceNode;
function requireSourceNode() {
  if (hasRequiredSourceNode) return sourceNode;
  hasRequiredSourceNode = 1;
  var SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
  var util = requireUtil();
  var REGEX_NEWLINE = /(\r?\n)/;
  var NEWLINE_CODE = 10;
  var isSourceNode = "$$$isSourceNode$$$";
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(
      aGeneratedCode,
      aSourceMapConsumer,
      aRelativePath
    ) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function () {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length
            ? remainingLines[remainingLinesIndex++]
            : undefined;
        }
      };
      var lastGeneratedLine = 1,
        lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex];
            var code = nextLine.substr(
              0,
              mapping.generatedColumn - lastGeneratedColumn
            );
            remainingLines[remainingLinesIndex] = nextLine.substr(
              mapping.generatedColumn - lastGeneratedColumn
            );
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(
            mapping.generatedColumn
          );
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          var source = aRelativePath
            ? util.join(aRelativePath, mapping.source)
            : mapping.source;
          node.add(
            new SourceNode(
              mapping.originalLine,
              mapping.originalColumn,
              source,
              code,
              mapping.name
            )
          );
        }
      }
    };
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " +
          aChunk
      );
    }
    return this;
  };
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " +
          aChunk
      );
    }
    return this;
  };
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== "") {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name,
          });
        }
      }
    }
  };
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(
    aPattern,
    aReplacement
  ) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === "string") {
      this.children[this.children.length - 1] = lastChild.replace(
        aPattern,
        aReplacement
      );
    } else {
      this.children.push("".replace(aPattern, aReplacement));
    }
    return this;
  };
  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(
    aSourceFile,
    aSourceContent
  ) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };
  SourceNode.prototype.toStringWithSourceMap =
    function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = { code: "", line: 1, column: 0 };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function (chunk, original) {
        generated.code += chunk;
        if (
          original.source !== null &&
          original.line !== null &&
          original.column !== null
        ) {
          if (
            lastOriginalSource !== original.source ||
            lastOriginalLine !== original.line ||
            lastOriginalColumn !== original.column ||
            lastOriginalName !== original.name
          ) {
            map.addMapping({
              source: original.source,
              original: { line: original.line, column: original.column },
              generated: { line: generated.line, column: generated.column },
              name: original.name,
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: { line: generated.line, column: generated.column },
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: { line: original.line, column: original.column },
                generated: { line: generated.line, column: generated.column },
                name: original.name,
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function (sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map: map };
    };
  sourceNode.SourceNode = SourceNode;
  return sourceNode;
}
var hasRequiredSourceMap;
function requireSourceMap() {
  if (hasRequiredSourceMap) return sourceMap;
  hasRequiredSourceMap = 1;
  sourceMap.SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
  sourceMap.SourceMapConsumer = requireSourceMapConsumer().SourceMapConsumer;
  sourceMap.SourceNode = requireSourceNode().SourceNode;
  return sourceMap;
}
Object.defineProperty(sourceMap$1, "__esModule", { value: true });
sourceMap$1.default = void 0;
function _sourceMap$1() {
  const data = _interopRequireDefault$7(requireSourceMap());
  _sourceMap$1 = function () {
    return data;
  };
  return data;
}
function _interopRequireDefault$7(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
class SourceMap {
  constructor(opts, code) {
    this._cachedMap = null;
    this._code = code;
    this._opts = opts;
    this._rawMappings = [];
  }
  get() {
    if (!this._cachedMap) {
      const map = (this._cachedMap =
        new (_sourceMap$1().default.SourceMapGenerator)({
          sourceRoot: this._opts.sourceRoot,
        }));
      const code = this._code;
      if (typeof code === "string") {
        map.setSourceContent(this._opts.sourceFileName, code);
      } else if (typeof code === "object") {
        Object.keys(code).forEach((sourceFileName) => {
          map.setSourceContent(sourceFileName, code[sourceFileName]);
        });
      }
      this._rawMappings.forEach(map.addMapping, map);
    }
    return this._cachedMap.toJSON();
  }
  getRawMappings() {
    return this._rawMappings.slice();
  }
  mark(
    generatedLine,
    generatedColumn,
    line,
    column,
    identifierName,
    filename,
    force
  ) {
    if (this._lastGenLine !== generatedLine && line === null) return;
    if (
      !force &&
      this._lastGenLine === generatedLine &&
      this._lastSourceLine === line &&
      this._lastSourceColumn === column
    ) {
      return;
    }
    this._cachedMap = null;
    this._lastGenLine = generatedLine;
    this._lastSourceLine = line;
    this._lastSourceColumn = column;
    this._rawMappings.push({
      name: identifierName || undefined,
      generated: { line: generatedLine, column: generatedColumn },
      source: line == null ? undefined : filename || this._opts.sourceFileName,
      original: line == null ? undefined : { line: line, column: column },
    });
  }
}
sourceMap$1.default = SourceMap;
var printer$1 = {};
var _trimmedEndIndex;
var hasRequired_trimmedEndIndex;
function require_trimmedEndIndex() {
  if (hasRequired_trimmedEndIndex) return _trimmedEndIndex;
  hasRequired_trimmedEndIndex = 1;
  var reWhitespace = /\s/;
  function trimmedEndIndex(string) {
    var index = string.length;
    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }
  _trimmedEndIndex = trimmedEndIndex;
  return _trimmedEndIndex;
}
var _baseTrim;
var hasRequired_baseTrim;
function require_baseTrim() {
  if (hasRequired_baseTrim) return _baseTrim;
  hasRequired_baseTrim = 1;
  var trimmedEndIndex = require_trimmedEndIndex();
  var reTrimStart = /^\s+/;
  function baseTrim(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "")
      : string;
  }
  _baseTrim = baseTrim;
  return _baseTrim;
}
var isObject_1;
var hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject) return isObject_1;
  hasRequiredIsObject = 1;
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  isObject_1 = isObject;
  return isObject_1;
}
var _freeGlobal;
var hasRequired_freeGlobal;
function require_freeGlobal() {
  if (hasRequired_freeGlobal) return _freeGlobal;
  hasRequired_freeGlobal = 1;
  var freeGlobal =
    typeof commonjsGlobal == "object" &&
    commonjsGlobal &&
    commonjsGlobal.Object === Object &&
    commonjsGlobal;
  _freeGlobal = freeGlobal;
  return _freeGlobal;
}
var _root;
var hasRequired_root;
function require_root() {
  if (hasRequired_root) return _root;
  hasRequired_root = 1;
  var freeGlobal = require_freeGlobal();
  var freeSelf =
    typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  _root = root;
  return _root;
}
var _Symbol;
var hasRequired_Symbol;
function require_Symbol() {
  if (hasRequired_Symbol) return _Symbol;
  hasRequired_Symbol = 1;
  var root = require_root();
  var Symbol = root.Symbol;
  _Symbol = Symbol;
  return _Symbol;
}
var _getRawTag;
var hasRequired_getRawTag;
function require_getRawTag() {
  if (hasRequired_getRawTag) return _getRawTag;
  hasRequired_getRawTag = 1;
  var Symbol = require_Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];
    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  _getRawTag = getRawTag;
  return _getRawTag;
}
var _objectToString;
var hasRequired_objectToString;
function require_objectToString() {
  if (hasRequired_objectToString) return _objectToString;
  hasRequired_objectToString = 1;
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  _objectToString = objectToString;
  return _objectToString;
}
var _baseGetTag;
var hasRequired_baseGetTag;
function require_baseGetTag() {
  if (hasRequired_baseGetTag) return _baseGetTag;
  hasRequired_baseGetTag = 1;
  var Symbol = require_Symbol(),
    getRawTag = require_getRawTag(),
    objectToString = require_objectToString();
  var nullTag = "[object Null]",
    undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value)
      ? getRawTag(value)
      : objectToString(value);
  }
  _baseGetTag = baseGetTag;
  return _baseGetTag;
}
var isObjectLike_1;
var hasRequiredIsObjectLike;
function requireIsObjectLike() {
  if (hasRequiredIsObjectLike) return isObjectLike_1;
  hasRequiredIsObjectLike = 1;
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  isObjectLike_1 = isObjectLike;
  return isObjectLike_1;
}
var isSymbol_1;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol) return isSymbol_1;
  hasRequiredIsSymbol = 1;
  var baseGetTag = require_baseGetTag(),
    isObjectLike = requireIsObjectLike();
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return (
      typeof value == "symbol" ||
      (isObjectLike(value) && baseGetTag(value) == symbolTag)
    );
  }
  isSymbol_1 = isSymbol;
  return isSymbol_1;
}
var toNumber_1;
var hasRequiredToNumber;
function requireToNumber() {
  if (hasRequiredToNumber) return toNumber_1;
  hasRequiredToNumber = 1;
  var baseTrim = require_baseTrim(),
    isObject = requireIsObject(),
    isSymbol = requireIsSymbol();
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value)
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : reIsBadHex.test(value)
        ? NAN
        : +value;
  }
  toNumber_1 = toNumber;
  return toNumber_1;
}
var toFinite_1;
var hasRequiredToFinite;
function requireToFinite() {
  if (hasRequiredToFinite) return toFinite_1;
  hasRequiredToFinite = 1;
  var toNumber = requireToNumber();
  var INFINITY = 1 / 0,
    MAX_INTEGER = 17976931348623157e292;
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  toFinite_1 = toFinite;
  return toFinite_1;
}
var toInteger_1;
var hasRequiredToInteger;
function requireToInteger() {
  if (hasRequiredToInteger) return toInteger_1;
  hasRequiredToInteger = 1;
  var toFinite = requireToFinite();
  function toInteger(value) {
    var result = toFinite(value),
      remainder = result % 1;
    return result === result ? (remainder ? result - remainder : result) : 0;
  }
  toInteger_1 = toInteger;
  return toInteger_1;
}
var isInteger_1;
var hasRequiredIsInteger;
function requireIsInteger() {
  if (hasRequiredIsInteger) return isInteger_1;
  hasRequiredIsInteger = 1;
  var toInteger = requireToInteger();
  function isInteger(value) {
    return typeof value == "number" && value == toInteger(value);
  }
  isInteger_1 = isInteger;
  return isInteger_1;
}
var _baseRepeat;
var hasRequired_baseRepeat;
function require_baseRepeat() {
  if (hasRequired_baseRepeat) return _baseRepeat;
  hasRequired_baseRepeat = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var nativeFloor = Math.floor;
  function baseRepeat(string, n) {
    var result = "";
    if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
      return result;
    }
    do {
      if (n % 2) {
        result += string;
      }
      n = nativeFloor(n / 2);
      if (n) {
        string += string;
      }
    } while (n);
    return result;
  }
  _baseRepeat = baseRepeat;
  return _baseRepeat;
}
var eq_1;
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq) return eq_1;
  hasRequiredEq = 1;
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }
  eq_1 = eq;
  return eq_1;
}
var isFunction_1;
var hasRequiredIsFunction;
function requireIsFunction() {
  if (hasRequiredIsFunction) return isFunction_1;
  hasRequiredIsFunction = 1;
  var baseGetTag = require_baseGetTag(),
    isObject = requireIsObject();
  var asyncTag = "[object AsyncFunction]",
    funcTag = "[object Function]",
    genTag = "[object GeneratorFunction]",
    proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return (
      tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag
    );
  }
  isFunction_1 = isFunction;
  return isFunction_1;
}
var isLength_1;
var hasRequiredIsLength;
function requireIsLength() {
  if (hasRequiredIsLength) return isLength_1;
  hasRequiredIsLength = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return (
      typeof value == "number" &&
      value > -1 &&
      value % 1 == 0 &&
      value <= MAX_SAFE_INTEGER
    );
  }
  isLength_1 = isLength;
  return isLength_1;
}
var isArrayLike_1;
var hasRequiredIsArrayLike;
function requireIsArrayLike() {
  if (hasRequiredIsArrayLike) return isArrayLike_1;
  hasRequiredIsArrayLike = 1;
  var isFunction = requireIsFunction(),
    isLength = requireIsLength();
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  isArrayLike_1 = isArrayLike;
  return isArrayLike_1;
}
var _isIndex;
var hasRequired_isIndex;
function require_isIndex() {
  if (hasRequired_isIndex) return _isIndex;
  hasRequired_isIndex = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return (
      !!length &&
      (type == "number" || (type != "symbol" && reIsUint.test(value))) &&
      value > -1 &&
      value % 1 == 0 &&
      value < length
    );
  }
  _isIndex = isIndex;
  return _isIndex;
}
var _isIterateeCall;
var hasRequired_isIterateeCall;
function require_isIterateeCall() {
  if (hasRequired_isIterateeCall) return _isIterateeCall;
  hasRequired_isIterateeCall = 1;
  var eq = requireEq(),
    isArrayLike = requireIsArrayLike(),
    isIndex = require_isIndex(),
    isObject = requireIsObject();
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (
      type == "number"
        ? isArrayLike(object) && isIndex(index, object.length)
        : type == "string" && index in object
    ) {
      return eq(object[index], value);
    }
    return false;
  }
  _isIterateeCall = isIterateeCall;
  return _isIterateeCall;
}
var _arrayMap;
var hasRequired_arrayMap;
function require_arrayMap() {
  if (hasRequired_arrayMap) return _arrayMap;
  hasRequired_arrayMap = 1;
  function arrayMap(array, iteratee) {
    var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  _arrayMap = arrayMap;
  return _arrayMap;
}
var isArray_1;
var hasRequiredIsArray;
function requireIsArray() {
  if (hasRequiredIsArray) return isArray_1;
  hasRequiredIsArray = 1;
  var isArray = Array.isArray;
  isArray_1 = isArray;
  return isArray_1;
}
var _baseToString;
var hasRequired_baseToString;
function require_baseToString() {
  if (hasRequired_baseToString) return _baseToString;
  hasRequired_baseToString = 1;
  var Symbol = require_Symbol(),
    arrayMap = require_arrayMap(),
    isArray = requireIsArray(),
    isSymbol = requireIsSymbol();
  var INFINITY = 1 / 0;
  var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  _baseToString = baseToString;
  return _baseToString;
}
var toString_1;
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString) return toString_1;
  hasRequiredToString = 1;
  var baseToString = require_baseToString();
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  toString_1 = toString;
  return toString_1;
}
var repeat_1;
var hasRequiredRepeat;
function requireRepeat() {
  if (hasRequiredRepeat) return repeat_1;
  hasRequiredRepeat = 1;
  var baseRepeat = require_baseRepeat(),
    isIterateeCall = require_isIterateeCall(),
    toInteger = requireToInteger(),
    toString = requireToString();
  function repeat(string, n, guard) {
    if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
      n = 1;
    } else {
      n = toInteger(n);
    }
    return baseRepeat(toString(string), n);
  }
  repeat_1 = repeat;
  return repeat_1;
}
var buffer = {};
var trimRight;
var hasRequiredTrimRight;
function requireTrimRight() {
  if (hasRequiredTrimRight) return trimRight;
  hasRequiredTrimRight = 1;
  trimRight = function (str) {
    var tail = str.length;
    while (/[\s\uFEFF\u00A0]/.test(str[tail - 1])) {
      tail--;
    }
    return str.slice(0, tail);
  };
  return trimRight;
}
Object.defineProperty(buffer, "__esModule", { value: true });
buffer.default = void 0;
function _trimRight() {
  const data = _interopRequireDefault$6(requireTrimRight());
  _trimRight = function () {
    return data;
  };
  return data;
}
function _interopRequireDefault$6(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const SPACES_RE = /^[ \t]+$/;
let Buffer$1 = class Buffer {
  constructor(map) {
    this._map = null;
    this._buf = [];
    this._last = "";
    this._queue = [];
    this._position = { line: 1, column: 0 };
    this._sourcePosition = {
      identifierName: null,
      line: null,
      column: null,
      filename: null,
    };
    this._disallowedPop = null;
    this._map = map;
  }
  get() {
    this._flush();
    const map = this._map;
    const result = {
      code: (0, _trimRight().default)(this._buf.join("")),
      map: null,
      rawMappings: map && map.getRawMappings(),
    };
    if (map) {
      Object.defineProperty(result, "map", {
        configurable: true,
        enumerable: true,
        get() {
          return (this.map = map.get());
        },
        set(value) {
          Object.defineProperty(this, "map", { value: value, writable: true });
        },
      });
    }
    return result;
  }
  append(str) {
    this._flush();
    const {
      line: line,
      column: column,
      filename: filename,
      identifierName: identifierName,
      force: force,
    } = this._sourcePosition;
    this._append(str, line, column, identifierName, filename, force);
  }
  queue(str) {
    if (str === "\n") {
      while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {
        this._queue.shift();
      }
    }
    const {
      line: line,
      column: column,
      filename: filename,
      identifierName: identifierName,
      force: force,
    } = this._sourcePosition;
    this._queue.unshift([str, line, column, identifierName, filename, force]);
  }
  _flush() {
    let item;
    while ((item = this._queue.pop())) this._append(...item);
  }
  _append(str, line, column, identifierName, filename, force) {
    if (this._map && str[0] !== "\n") {
      this._map.mark(
        this._position.line,
        this._position.column,
        line,
        column,
        identifierName,
        filename,
        force
      );
    }
    this._buf.push(str);
    this._last = str[str.length - 1];
    for (let i = 0; i < str.length; i++) {
      if (str[i] === "\n") {
        this._position.line++;
        this._position.column = 0;
      } else {
        this._position.column++;
      }
    }
  }
  removeTrailingNewline() {
    if (this._queue.length > 0 && this._queue[0][0] === "\n") {
      this._queue.shift();
    }
  }
  removeLastSemicolon() {
    if (this._queue.length > 0 && this._queue[0][0] === ";") {
      this._queue.shift();
    }
  }
  endsWith(suffix) {
    if (suffix.length === 1) {
      let last;
      if (this._queue.length > 0) {
        const str = this._queue[0][0];
        last = str[str.length - 1];
      } else {
        last = this._last;
      }
      return last === suffix;
    }
    const end =
      this._last + this._queue.reduce((acc, item) => item[0] + acc, "");
    if (suffix.length <= end.length) {
      return end.slice(-suffix.length) === suffix;
    }
    return false;
  }
  hasContent() {
    return this._queue.length > 0 || !!this._last;
  }
  exactSource(loc, cb) {
    this.source("start", loc, true);
    cb();
    this.source("end", loc);
    this._disallowPop("start", loc);
  }
  source(prop, loc, force) {
    if (prop && !loc) return;
    this._normalizePosition(prop, loc, this._sourcePosition, force);
  }
  withSource(prop, loc, cb) {
    if (!this._map) return cb();
    const originalLine = this._sourcePosition.line;
    const originalColumn = this._sourcePosition.column;
    const originalFilename = this._sourcePosition.filename;
    const originalIdentifierName = this._sourcePosition.identifierName;
    this.source(prop, loc);
    cb();
    if (
      (!this._sourcePosition.force ||
        this._sourcePosition.line !== originalLine ||
        this._sourcePosition.column !== originalColumn ||
        this._sourcePosition.filename !== originalFilename) &&
      (!this._disallowedPop ||
        this._disallowedPop.line !== originalLine ||
        this._disallowedPop.column !== originalColumn ||
        this._disallowedPop.filename !== originalFilename)
    ) {
      this._sourcePosition.line = originalLine;
      this._sourcePosition.column = originalColumn;
      this._sourcePosition.filename = originalFilename;
      this._sourcePosition.identifierName = originalIdentifierName;
      this._sourcePosition.force = false;
      this._disallowedPop = null;
    }
  }
  _disallowPop(prop, loc) {
    if (prop && !loc) return;
    this._disallowedPop = this._normalizePosition(prop, loc);
  }
  _normalizePosition(prop, loc, targetObj, force) {
    const pos = loc ? loc[prop] : null;
    if (targetObj === undefined) {
      targetObj = {
        identifierName: null,
        line: null,
        column: null,
        filename: null,
        force: false,
      };
    }
    const origLine = targetObj.line;
    const origColumn = targetObj.column;
    const origFilename = targetObj.filename;
    targetObj.identifierName =
      (prop === "start" && loc && loc.identifierName) || null;
    targetObj.line = pos ? pos.line : null;
    targetObj.column = pos ? pos.column : null;
    targetObj.filename = (loc && loc.filename) || null;
    if (
      force ||
      targetObj.line !== origLine ||
      targetObj.column !== origColumn ||
      targetObj.filename !== origFilename
    ) {
      targetObj.force = force;
    }
    return targetObj;
  }
  getCurrentColumn() {
    const extra = this._queue.reduce((acc, item) => item[0] + acc, "");
    const lastIndex = extra.lastIndexOf("\n");
    return lastIndex === -1
      ? this._position.column + extra.length
      : extra.length - 1 - lastIndex;
  }
  getCurrentLine() {
    const extra = this._queue.reduce((acc, item) => item[0] + acc, "");
    let count = 0;
    for (let i = 0; i < extra.length; i++) {
      if (extra[i] === "\n") count++;
    }
    return this._position.line + count;
  }
};
buffer.default = Buffer$1;
var node = {};
var whitespace$1 = {};
var lib$1 = {};
var isReactComponent = {};
var buildMatchMemberExpression = {};
var matchesPattern = {};
var generated$4 = {};
var shallowEqual = {};
var hasRequiredShallowEqual;
function requireShallowEqual() {
  if (hasRequiredShallowEqual) return shallowEqual;
  hasRequiredShallowEqual = 1;
  Object.defineProperty(shallowEqual, "__esModule", { value: true });
  shallowEqual.default = shallowEqual$1;
  function shallowEqual$1(actual, expected) {
    const keys = Object.keys(expected);
    for (const key of keys) {
      if (actual[key] !== expected[key]) {
        return false;
      }
    }
    return true;
  }
  return shallowEqual;
}
var hasRequiredGenerated$4;
function requireGenerated$4() {
  if (hasRequiredGenerated$4) return generated$4;
  hasRequiredGenerated$4 = 1;
  Object.defineProperty(generated$4, "__esModule", { value: true });
  generated$4.isAccessor = isAccessor;
  generated$4.isAnyTypeAnnotation = isAnyTypeAnnotation;
  generated$4.isArgumentPlaceholder = isArgumentPlaceholder;
  generated$4.isArrayExpression = isArrayExpression;
  generated$4.isArrayPattern = isArrayPattern;
  generated$4.isArrayTypeAnnotation = isArrayTypeAnnotation;
  generated$4.isArrowFunctionExpression = isArrowFunctionExpression;
  generated$4.isAssignmentExpression = isAssignmentExpression;
  generated$4.isAssignmentPattern = isAssignmentPattern;
  generated$4.isAwaitExpression = isAwaitExpression;
  generated$4.isBigIntLiteral = isBigIntLiteral;
  generated$4.isBinary = isBinary;
  generated$4.isBinaryExpression = isBinaryExpression;
  generated$4.isBindExpression = isBindExpression;
  generated$4.isBlock = isBlock;
  generated$4.isBlockParent = isBlockParent;
  generated$4.isBlockStatement = isBlockStatement;
  generated$4.isBooleanLiteral = isBooleanLiteral;
  generated$4.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
  generated$4.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
  generated$4.isBreakStatement = isBreakStatement;
  generated$4.isCallExpression = isCallExpression;
  generated$4.isCatchClause = isCatchClause;
  generated$4.isClass = isClass;
  generated$4.isClassAccessorProperty = isClassAccessorProperty;
  generated$4.isClassBody = isClassBody;
  generated$4.isClassDeclaration = isClassDeclaration;
  generated$4.isClassExpression = isClassExpression;
  generated$4.isClassImplements = isClassImplements;
  generated$4.isClassMethod = isClassMethod;
  generated$4.isClassPrivateMethod = isClassPrivateMethod;
  generated$4.isClassPrivateProperty = isClassPrivateProperty;
  generated$4.isClassProperty = isClassProperty;
  generated$4.isCompletionStatement = isCompletionStatement;
  generated$4.isConditional = isConditional;
  generated$4.isConditionalExpression = isConditionalExpression;
  generated$4.isContinueStatement = isContinueStatement;
  generated$4.isDebuggerStatement = isDebuggerStatement;
  generated$4.isDecimalLiteral = isDecimalLiteral;
  generated$4.isDeclaration = isDeclaration;
  generated$4.isDeclareClass = isDeclareClass;
  generated$4.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
  generated$4.isDeclareExportDeclaration = isDeclareExportDeclaration;
  generated$4.isDeclareFunction = isDeclareFunction;
  generated$4.isDeclareInterface = isDeclareInterface;
  generated$4.isDeclareModule = isDeclareModule;
  generated$4.isDeclareModuleExports = isDeclareModuleExports;
  generated$4.isDeclareOpaqueType = isDeclareOpaqueType;
  generated$4.isDeclareTypeAlias = isDeclareTypeAlias;
  generated$4.isDeclareVariable = isDeclareVariable;
  generated$4.isDeclaredPredicate = isDeclaredPredicate;
  generated$4.isDecorator = isDecorator;
  generated$4.isDirective = isDirective;
  generated$4.isDirectiveLiteral = isDirectiveLiteral;
  generated$4.isDoExpression = isDoExpression;
  generated$4.isDoWhileStatement = isDoWhileStatement;
  generated$4.isEmptyStatement = isEmptyStatement;
  generated$4.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
  generated$4.isEnumBody = isEnumBody;
  generated$4.isEnumBooleanBody = isEnumBooleanBody;
  generated$4.isEnumBooleanMember = isEnumBooleanMember;
  generated$4.isEnumDeclaration = isEnumDeclaration;
  generated$4.isEnumDefaultedMember = isEnumDefaultedMember;
  generated$4.isEnumMember = isEnumMember;
  generated$4.isEnumNumberBody = isEnumNumberBody;
  generated$4.isEnumNumberMember = isEnumNumberMember;
  generated$4.isEnumStringBody = isEnumStringBody;
  generated$4.isEnumStringMember = isEnumStringMember;
  generated$4.isEnumSymbolBody = isEnumSymbolBody;
  generated$4.isExistsTypeAnnotation = isExistsTypeAnnotation;
  generated$4.isExportAllDeclaration = isExportAllDeclaration;
  generated$4.isExportDeclaration = isExportDeclaration;
  generated$4.isExportDefaultDeclaration = isExportDefaultDeclaration;
  generated$4.isExportDefaultSpecifier = isExportDefaultSpecifier;
  generated$4.isExportNamedDeclaration = isExportNamedDeclaration;
  generated$4.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
  generated$4.isExportSpecifier = isExportSpecifier;
  generated$4.isExpression = isExpression;
  generated$4.isExpressionStatement = isExpressionStatement;
  generated$4.isExpressionWrapper = isExpressionWrapper;
  generated$4.isFile = isFile;
  generated$4.isFlow = isFlow;
  generated$4.isFlowBaseAnnotation = isFlowBaseAnnotation;
  generated$4.isFlowDeclaration = isFlowDeclaration;
  generated$4.isFlowPredicate = isFlowPredicate;
  generated$4.isFlowType = isFlowType;
  generated$4.isFor = isFor;
  generated$4.isForInStatement = isForInStatement;
  generated$4.isForOfStatement = isForOfStatement;
  generated$4.isForStatement = isForStatement;
  generated$4.isForXStatement = isForXStatement;
  generated$4.isFunction = isFunction;
  generated$4.isFunctionDeclaration = isFunctionDeclaration;
  generated$4.isFunctionExpression = isFunctionExpression;
  generated$4.isFunctionParent = isFunctionParent;
  generated$4.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
  generated$4.isFunctionTypeParam = isFunctionTypeParam;
  generated$4.isGenericTypeAnnotation = isGenericTypeAnnotation;
  generated$4.isIdentifier = isIdentifier;
  generated$4.isIfStatement = isIfStatement;
  generated$4.isImmutable = isImmutable;
  generated$4.isImport = isImport;
  generated$4.isImportAttribute = isImportAttribute;
  generated$4.isImportDeclaration = isImportDeclaration;
  generated$4.isImportDefaultSpecifier = isImportDefaultSpecifier;
  generated$4.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
  generated$4.isImportSpecifier = isImportSpecifier;
  generated$4.isIndexedAccessType = isIndexedAccessType;
  generated$4.isInferredPredicate = isInferredPredicate;
  generated$4.isInterfaceDeclaration = isInterfaceDeclaration;
  generated$4.isInterfaceExtends = isInterfaceExtends;
  generated$4.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
  generated$4.isInterpreterDirective = isInterpreterDirective;
  generated$4.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
  generated$4.isJSX = isJSX;
  generated$4.isJSXAttribute = isJSXAttribute;
  generated$4.isJSXClosingElement = isJSXClosingElement;
  generated$4.isJSXClosingFragment = isJSXClosingFragment;
  generated$4.isJSXElement = isJSXElement;
  generated$4.isJSXEmptyExpression = isJSXEmptyExpression;
  generated$4.isJSXExpressionContainer = isJSXExpressionContainer;
  generated$4.isJSXFragment = isJSXFragment;
  generated$4.isJSXIdentifier = isJSXIdentifier;
  generated$4.isJSXMemberExpression = isJSXMemberExpression;
  generated$4.isJSXNamespacedName = isJSXNamespacedName;
  generated$4.isJSXOpeningElement = isJSXOpeningElement;
  generated$4.isJSXOpeningFragment = isJSXOpeningFragment;
  generated$4.isJSXSpreadAttribute = isJSXSpreadAttribute;
  generated$4.isJSXSpreadChild = isJSXSpreadChild;
  generated$4.isJSXText = isJSXText;
  generated$4.isLVal = isLVal;
  generated$4.isLabeledStatement = isLabeledStatement;
  generated$4.isLiteral = isLiteral;
  generated$4.isLogicalExpression = isLogicalExpression;
  generated$4.isLoop = isLoop;
  generated$4.isMemberExpression = isMemberExpression;
  generated$4.isMetaProperty = isMetaProperty;
  generated$4.isMethod = isMethod;
  generated$4.isMiscellaneous = isMiscellaneous;
  generated$4.isMixedTypeAnnotation = isMixedTypeAnnotation;
  generated$4.isModuleDeclaration = isModuleDeclaration;
  generated$4.isModuleExpression = isModuleExpression;
  generated$4.isModuleSpecifier = isModuleSpecifier;
  generated$4.isNewExpression = isNewExpression;
  generated$4.isNoop = isNoop;
  generated$4.isNullLiteral = isNullLiteral;
  generated$4.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
  generated$4.isNullableTypeAnnotation = isNullableTypeAnnotation;
  generated$4.isNumberLiteral = isNumberLiteral;
  generated$4.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
  generated$4.isNumberTypeAnnotation = isNumberTypeAnnotation;
  generated$4.isNumericLiteral = isNumericLiteral;
  generated$4.isObjectExpression = isObjectExpression;
  generated$4.isObjectMember = isObjectMember;
  generated$4.isObjectMethod = isObjectMethod;
  generated$4.isObjectPattern = isObjectPattern;
  generated$4.isObjectProperty = isObjectProperty;
  generated$4.isObjectTypeAnnotation = isObjectTypeAnnotation;
  generated$4.isObjectTypeCallProperty = isObjectTypeCallProperty;
  generated$4.isObjectTypeIndexer = isObjectTypeIndexer;
  generated$4.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
  generated$4.isObjectTypeProperty = isObjectTypeProperty;
  generated$4.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
  generated$4.isOpaqueType = isOpaqueType;
  generated$4.isOptionalCallExpression = isOptionalCallExpression;
  generated$4.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
  generated$4.isOptionalMemberExpression = isOptionalMemberExpression;
  generated$4.isParenthesizedExpression = isParenthesizedExpression;
  generated$4.isPattern = isPattern;
  generated$4.isPatternLike = isPatternLike;
  generated$4.isPipelineBareFunction = isPipelineBareFunction;
  generated$4.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
  generated$4.isPipelineTopicExpression = isPipelineTopicExpression;
  generated$4.isPlaceholder = isPlaceholder;
  generated$4.isPrivate = isPrivate;
  generated$4.isPrivateName = isPrivateName;
  generated$4.isProgram = isProgram;
  generated$4.isProperty = isProperty;
  generated$4.isPureish = isPureish;
  generated$4.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
  generated$4.isRecordExpression = isRecordExpression;
  generated$4.isRegExpLiteral = isRegExpLiteral;
  generated$4.isRegexLiteral = isRegexLiteral;
  generated$4.isRestElement = isRestElement;
  generated$4.isRestProperty = isRestProperty;
  generated$4.isReturnStatement = isReturnStatement;
  generated$4.isScopable = isScopable;
  generated$4.isSequenceExpression = isSequenceExpression;
  generated$4.isSpreadElement = isSpreadElement;
  generated$4.isSpreadProperty = isSpreadProperty;
  generated$4.isStandardized = isStandardized;
  generated$4.isStatement = isStatement;
  generated$4.isStaticBlock = isStaticBlock;
  generated$4.isStringLiteral = isStringLiteral;
  generated$4.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
  generated$4.isStringTypeAnnotation = isStringTypeAnnotation;
  generated$4.isSuper = isSuper;
  generated$4.isSwitchCase = isSwitchCase;
  generated$4.isSwitchStatement = isSwitchStatement;
  generated$4.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
  generated$4.isTSAnyKeyword = isTSAnyKeyword;
  generated$4.isTSArrayType = isTSArrayType;
  generated$4.isTSAsExpression = isTSAsExpression;
  generated$4.isTSBaseType = isTSBaseType;
  generated$4.isTSBigIntKeyword = isTSBigIntKeyword;
  generated$4.isTSBooleanKeyword = isTSBooleanKeyword;
  generated$4.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
  generated$4.isTSConditionalType = isTSConditionalType;
  generated$4.isTSConstructSignatureDeclaration =
    isTSConstructSignatureDeclaration;
  generated$4.isTSConstructorType = isTSConstructorType;
  generated$4.isTSDeclareFunction = isTSDeclareFunction;
  generated$4.isTSDeclareMethod = isTSDeclareMethod;
  generated$4.isTSEntityName = isTSEntityName;
  generated$4.isTSEnumDeclaration = isTSEnumDeclaration;
  generated$4.isTSEnumMember = isTSEnumMember;
  generated$4.isTSExportAssignment = isTSExportAssignment;
  generated$4.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
  generated$4.isTSExternalModuleReference = isTSExternalModuleReference;
  generated$4.isTSFunctionType = isTSFunctionType;
  generated$4.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
  generated$4.isTSImportType = isTSImportType;
  generated$4.isTSIndexSignature = isTSIndexSignature;
  generated$4.isTSIndexedAccessType = isTSIndexedAccessType;
  generated$4.isTSInferType = isTSInferType;
  generated$4.isTSInstantiationExpression = isTSInstantiationExpression;
  generated$4.isTSInterfaceBody = isTSInterfaceBody;
  generated$4.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
  generated$4.isTSIntersectionType = isTSIntersectionType;
  generated$4.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
  generated$4.isTSLiteralType = isTSLiteralType;
  generated$4.isTSMappedType = isTSMappedType;
  generated$4.isTSMethodSignature = isTSMethodSignature;
  generated$4.isTSModuleBlock = isTSModuleBlock;
  generated$4.isTSModuleDeclaration = isTSModuleDeclaration;
  generated$4.isTSNamedTupleMember = isTSNamedTupleMember;
  generated$4.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
  generated$4.isTSNeverKeyword = isTSNeverKeyword;
  generated$4.isTSNonNullExpression = isTSNonNullExpression;
  generated$4.isTSNullKeyword = isTSNullKeyword;
  generated$4.isTSNumberKeyword = isTSNumberKeyword;
  generated$4.isTSObjectKeyword = isTSObjectKeyword;
  generated$4.isTSOptionalType = isTSOptionalType;
  generated$4.isTSParameterProperty = isTSParameterProperty;
  generated$4.isTSParenthesizedType = isTSParenthesizedType;
  generated$4.isTSPropertySignature = isTSPropertySignature;
  generated$4.isTSQualifiedName = isTSQualifiedName;
  generated$4.isTSRestType = isTSRestType;
  generated$4.isTSStringKeyword = isTSStringKeyword;
  generated$4.isTSSymbolKeyword = isTSSymbolKeyword;
  generated$4.isTSThisType = isTSThisType;
  generated$4.isTSTupleType = isTSTupleType;
  generated$4.isTSType = isTSType;
  generated$4.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
  generated$4.isTSTypeAnnotation = isTSTypeAnnotation;
  generated$4.isTSTypeAssertion = isTSTypeAssertion;
  generated$4.isTSTypeElement = isTSTypeElement;
  generated$4.isTSTypeLiteral = isTSTypeLiteral;
  generated$4.isTSTypeOperator = isTSTypeOperator;
  generated$4.isTSTypeParameter = isTSTypeParameter;
  generated$4.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
  generated$4.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
  generated$4.isTSTypePredicate = isTSTypePredicate;
  generated$4.isTSTypeQuery = isTSTypeQuery;
  generated$4.isTSTypeReference = isTSTypeReference;
  generated$4.isTSUndefinedKeyword = isTSUndefinedKeyword;
  generated$4.isTSUnionType = isTSUnionType;
  generated$4.isTSUnknownKeyword = isTSUnknownKeyword;
  generated$4.isTSVoidKeyword = isTSVoidKeyword;
  generated$4.isTaggedTemplateExpression = isTaggedTemplateExpression;
  generated$4.isTemplateElement = isTemplateElement;
  generated$4.isTemplateLiteral = isTemplateLiteral;
  generated$4.isTerminatorless = isTerminatorless;
  generated$4.isThisExpression = isThisExpression;
  generated$4.isThisTypeAnnotation = isThisTypeAnnotation;
  generated$4.isThrowStatement = isThrowStatement;
  generated$4.isTopicReference = isTopicReference;
  generated$4.isTryStatement = isTryStatement;
  generated$4.isTupleExpression = isTupleExpression;
  generated$4.isTupleTypeAnnotation = isTupleTypeAnnotation;
  generated$4.isTypeAlias = isTypeAlias;
  generated$4.isTypeAnnotation = isTypeAnnotation;
  generated$4.isTypeCastExpression = isTypeCastExpression;
  generated$4.isTypeParameter = isTypeParameter;
  generated$4.isTypeParameterDeclaration = isTypeParameterDeclaration;
  generated$4.isTypeParameterInstantiation = isTypeParameterInstantiation;
  generated$4.isTypeScript = isTypeScript;
  generated$4.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
  generated$4.isUnaryExpression = isUnaryExpression;
  generated$4.isUnaryLike = isUnaryLike;
  generated$4.isUnionTypeAnnotation = isUnionTypeAnnotation;
  generated$4.isUpdateExpression = isUpdateExpression;
  generated$4.isUserWhitespacable = isUserWhitespacable;
  generated$4.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
  generated$4.isVariableDeclaration = isVariableDeclaration;
  generated$4.isVariableDeclarator = isVariableDeclarator;
  generated$4.isVariance = isVariance;
  generated$4.isVoidTypeAnnotation = isVoidTypeAnnotation;
  generated$4.isWhile = isWhile;
  generated$4.isWhileStatement = isWhileStatement;
  generated$4.isWithStatement = isWithStatement;
  generated$4.isYieldExpression = isYieldExpression;
  var _shallowEqual = requireShallowEqual();
  function isArrayExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ArrayExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isAssignmentExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "AssignmentExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isBinaryExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BinaryExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isInterpreterDirective(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "InterpreterDirective") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isDirective(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Directive") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isDirectiveLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DirectiveLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isBlockStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BlockStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isBreakStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BreakStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isCallExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "CallExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isCatchClause(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "CatchClause") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isConditionalExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ConditionalExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isContinueStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ContinueStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isDebuggerStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DebuggerStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isDoWhileStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DoWhileStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isEmptyStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EmptyStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isExpressionStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExpressionStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isFile(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "File") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isForInStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ForInStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isForStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ForStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isFunctionDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "FunctionDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isFunctionExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "FunctionExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Identifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isIfStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "IfStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isLabeledStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "LabeledStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isStringLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "StringLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isNumericLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NumericLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isNullLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NullLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isBooleanLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BooleanLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isRegExpLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "RegExpLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isLogicalExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "LogicalExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isMemberExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "MemberExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isNewExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NewExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isProgram(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Program") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isObjectExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isObjectMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectMethod") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isObjectProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isRestElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "RestElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isReturnStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ReturnStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isSequenceExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SequenceExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isParenthesizedExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ParenthesizedExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isSwitchCase(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SwitchCase") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isSwitchStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SwitchStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isThisExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ThisExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isThrowStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ThrowStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTryStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TryStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isUnaryExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "UnaryExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isUpdateExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "UpdateExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isVariableDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "VariableDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isVariableDeclarator(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "VariableDeclarator") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isWhileStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "WhileStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isWithStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "WithStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isAssignmentPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "AssignmentPattern") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isArrayPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ArrayPattern") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isArrowFunctionExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ArrowFunctionExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isClassBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isClassExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isClassDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isExportAllDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportAllDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isExportDefaultDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportDefaultDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isExportNamedDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportNamedDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isExportSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isForOfStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ForOfStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isImportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ImportDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isImportDefaultSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ImportDefaultSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isImportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ImportNamespaceSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isImportSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ImportSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isMetaProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "MetaProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isClassMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassMethod") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isObjectPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectPattern") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isSpreadElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SpreadElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isSuper(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Super") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTaggedTemplateExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TaggedTemplateExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTemplateElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TemplateElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTemplateLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TemplateLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isYieldExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "YieldExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isAwaitExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "AwaitExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isImport(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Import") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isBigIntLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BigIntLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isExportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportNamespaceSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isOptionalMemberExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "OptionalMemberExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isOptionalCallExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "OptionalCallExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isClassProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isClassAccessorProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassAccessorProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isClassPrivateProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassPrivateProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isClassPrivateMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassPrivateMethod") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isPrivateName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "PrivateName") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isStaticBlock(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "StaticBlock") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isAnyTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "AnyTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isArrayTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ArrayTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isBooleanTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BooleanTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isBooleanLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BooleanLiteralTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isNullLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NullLiteralTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isClassImplements(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassImplements") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isDeclareClass(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareClass") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isDeclareFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareFunction") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isDeclareInterface(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareInterface") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isDeclareModule(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareModule") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isDeclareModuleExports(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareModuleExports") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isDeclareTypeAlias(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareTypeAlias") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isDeclareOpaqueType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareOpaqueType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isDeclareVariable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareVariable") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isDeclareExportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareExportDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isDeclareExportAllDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareExportAllDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isDeclaredPredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclaredPredicate") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isExistsTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExistsTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isFunctionTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "FunctionTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isFunctionTypeParam(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "FunctionTypeParam") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isGenericTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "GenericTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isInferredPredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "InferredPredicate") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isInterfaceExtends(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "InterfaceExtends") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isInterfaceDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "InterfaceDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isInterfaceTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "InterfaceTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isIntersectionTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "IntersectionTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isMixedTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "MixedTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isEmptyTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EmptyTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isNullableTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NullableTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isNumberLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NumberLiteralTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isNumberTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NumberTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isObjectTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isObjectTypeInternalSlot(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeInternalSlot") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isObjectTypeCallProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeCallProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isObjectTypeIndexer(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeIndexer") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isObjectTypeProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isObjectTypeSpreadProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeSpreadProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isOpaqueType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "OpaqueType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isQualifiedTypeIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "QualifiedTypeIdentifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isStringLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "StringLiteralTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isStringTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "StringTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isSymbolTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SymbolTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isThisTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ThisTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTupleTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TupleTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTypeofTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeofTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTypeAlias(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeAlias") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTypeCastExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeCastExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTypeParameter(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeParameter") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeParameterDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeParameterInstantiation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isUnionTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "UnionTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isVariance(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Variance") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isVoidTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "VoidTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isEnumDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isEnumBooleanBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumBooleanBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isEnumNumberBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumNumberBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isEnumStringBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumStringBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isEnumSymbolBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumSymbolBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isEnumBooleanMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumBooleanMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isEnumNumberMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumNumberMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isEnumStringMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumStringMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isEnumDefaultedMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumDefaultedMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isIndexedAccessType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "IndexedAccessType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isOptionalIndexedAccessType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "OptionalIndexedAccessType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isJSXAttribute(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXAttribute") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isJSXClosingElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXClosingElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isJSXElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isJSXEmptyExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXEmptyExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isJSXExpressionContainer(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXExpressionContainer") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isJSXSpreadChild(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXSpreadChild") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isJSXIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXIdentifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isJSXMemberExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXMemberExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isJSXNamespacedName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXNamespacedName") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isJSXOpeningElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXOpeningElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isJSXSpreadAttribute(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXSpreadAttribute") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isJSXText(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXText") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isJSXFragment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXFragment") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isJSXOpeningFragment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXOpeningFragment") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isJSXClosingFragment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXClosingFragment") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isNoop(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Noop") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isPlaceholder(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Placeholder") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isV8IntrinsicIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "V8IntrinsicIdentifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isArgumentPlaceholder(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ArgumentPlaceholder") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isBindExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BindExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isImportAttribute(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ImportAttribute") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isDecorator(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Decorator") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isDoExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DoExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isExportDefaultSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportDefaultSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isRecordExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "RecordExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTupleExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TupleExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isDecimalLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DecimalLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isModuleExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ModuleExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTopicReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TopicReference") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isPipelineTopicExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "PipelineTopicExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isPipelineBareFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "PipelineBareFunction") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isPipelinePrimaryTopicReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "PipelinePrimaryTopicReference") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSParameterProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSParameterProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSDeclareFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSDeclareFunction") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSDeclareMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSDeclareMethod") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSQualifiedName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSQualifiedName") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSCallSignatureDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSCallSignatureDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSConstructSignatureDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSConstructSignatureDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSPropertySignature(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSPropertySignature") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSMethodSignature(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSMethodSignature") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSIndexSignature(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSIndexSignature") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSAnyKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSAnyKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSBooleanKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSBooleanKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSBigIntKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSBigIntKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSIntrinsicKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSIntrinsicKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSNeverKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNeverKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSNullKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNullKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSNumberKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNumberKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSObjectKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSObjectKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSStringKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSStringKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSSymbolKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSSymbolKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSUndefinedKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSUndefinedKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSUnknownKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSUnknownKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSVoidKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSVoidKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSThisType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSThisType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSFunctionType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSFunctionType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSConstructorType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSConstructorType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSTypeReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeReference") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSTypePredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypePredicate") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSTypeQuery(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeQuery") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSTypeLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSArrayType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSArrayType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSTupleType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTupleType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSOptionalType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSOptionalType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSRestType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSRestType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSNamedTupleMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNamedTupleMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSUnionType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSUnionType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSIntersectionType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSIntersectionType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSConditionalType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSConditionalType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSInferType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSInferType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSParenthesizedType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSParenthesizedType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSTypeOperator(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeOperator") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSIndexedAccessType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSIndexedAccessType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSMappedType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSMappedType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSLiteralType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSLiteralType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSExpressionWithTypeArguments(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSExpressionWithTypeArguments") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSInterfaceDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSInterfaceDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSInterfaceBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSInterfaceBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSTypeAliasDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeAliasDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSInstantiationExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSInstantiationExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSAsExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSAsExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSTypeAssertion(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeAssertion") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSEnumDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSEnumDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSEnumMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSEnumMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSModuleDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSModuleDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSModuleBlock(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSModuleBlock") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSImportType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSImportType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSImportEqualsDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSImportEqualsDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSExternalModuleReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSExternalModuleReference") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSNonNullExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNonNullExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSExportAssignment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSExportAssignment") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSNamespaceExportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNamespaceExportDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeParameterInstantiation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeParameterDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSTypeParameter(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeParameter") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isStandardized(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "ArrayExpression" === nodeType ||
      "AssignmentExpression" === nodeType ||
      "BinaryExpression" === nodeType ||
      "InterpreterDirective" === nodeType ||
      "Directive" === nodeType ||
      "DirectiveLiteral" === nodeType ||
      "BlockStatement" === nodeType ||
      "BreakStatement" === nodeType ||
      "CallExpression" === nodeType ||
      "CatchClause" === nodeType ||
      "ConditionalExpression" === nodeType ||
      "ContinueStatement" === nodeType ||
      "DebuggerStatement" === nodeType ||
      "DoWhileStatement" === nodeType ||
      "EmptyStatement" === nodeType ||
      "ExpressionStatement" === nodeType ||
      "File" === nodeType ||
      "ForInStatement" === nodeType ||
      "ForStatement" === nodeType ||
      "FunctionDeclaration" === nodeType ||
      "FunctionExpression" === nodeType ||
      "Identifier" === nodeType ||
      "IfStatement" === nodeType ||
      "LabeledStatement" === nodeType ||
      "StringLiteral" === nodeType ||
      "NumericLiteral" === nodeType ||
      "NullLiteral" === nodeType ||
      "BooleanLiteral" === nodeType ||
      "RegExpLiteral" === nodeType ||
      "LogicalExpression" === nodeType ||
      "MemberExpression" === nodeType ||
      "NewExpression" === nodeType ||
      "Program" === nodeType ||
      "ObjectExpression" === nodeType ||
      "ObjectMethod" === nodeType ||
      "ObjectProperty" === nodeType ||
      "RestElement" === nodeType ||
      "ReturnStatement" === nodeType ||
      "SequenceExpression" === nodeType ||
      "ParenthesizedExpression" === nodeType ||
      "SwitchCase" === nodeType ||
      "SwitchStatement" === nodeType ||
      "ThisExpression" === nodeType ||
      "ThrowStatement" === nodeType ||
      "TryStatement" === nodeType ||
      "UnaryExpression" === nodeType ||
      "UpdateExpression" === nodeType ||
      "VariableDeclaration" === nodeType ||
      "VariableDeclarator" === nodeType ||
      "WhileStatement" === nodeType ||
      "WithStatement" === nodeType ||
      "AssignmentPattern" === nodeType ||
      "ArrayPattern" === nodeType ||
      "ArrowFunctionExpression" === nodeType ||
      "ClassBody" === nodeType ||
      "ClassExpression" === nodeType ||
      "ClassDeclaration" === nodeType ||
      "ExportAllDeclaration" === nodeType ||
      "ExportDefaultDeclaration" === nodeType ||
      "ExportNamedDeclaration" === nodeType ||
      "ExportSpecifier" === nodeType ||
      "ForOfStatement" === nodeType ||
      "ImportDeclaration" === nodeType ||
      "ImportDefaultSpecifier" === nodeType ||
      "ImportNamespaceSpecifier" === nodeType ||
      "ImportSpecifier" === nodeType ||
      "MetaProperty" === nodeType ||
      "ClassMethod" === nodeType ||
      "ObjectPattern" === nodeType ||
      "SpreadElement" === nodeType ||
      "Super" === nodeType ||
      "TaggedTemplateExpression" === nodeType ||
      "TemplateElement" === nodeType ||
      "TemplateLiteral" === nodeType ||
      "YieldExpression" === nodeType ||
      "AwaitExpression" === nodeType ||
      "Import" === nodeType ||
      "BigIntLiteral" === nodeType ||
      "ExportNamespaceSpecifier" === nodeType ||
      "OptionalMemberExpression" === nodeType ||
      "OptionalCallExpression" === nodeType ||
      "ClassProperty" === nodeType ||
      "ClassAccessorProperty" === nodeType ||
      "ClassPrivateProperty" === nodeType ||
      "ClassPrivateMethod" === nodeType ||
      "PrivateName" === nodeType ||
      "StaticBlock" === nodeType ||
      (nodeType === "Placeholder" &&
        ("Identifier" === node.expectedNode ||
          "StringLiteral" === node.expectedNode ||
          "BlockStatement" === node.expectedNode ||
          "ClassBody" === node.expectedNode))
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "ArrayExpression" === nodeType ||
      "AssignmentExpression" === nodeType ||
      "BinaryExpression" === nodeType ||
      "CallExpression" === nodeType ||
      "ConditionalExpression" === nodeType ||
      "FunctionExpression" === nodeType ||
      "Identifier" === nodeType ||
      "StringLiteral" === nodeType ||
      "NumericLiteral" === nodeType ||
      "NullLiteral" === nodeType ||
      "BooleanLiteral" === nodeType ||
      "RegExpLiteral" === nodeType ||
      "LogicalExpression" === nodeType ||
      "MemberExpression" === nodeType ||
      "NewExpression" === nodeType ||
      "ObjectExpression" === nodeType ||
      "SequenceExpression" === nodeType ||
      "ParenthesizedExpression" === nodeType ||
      "ThisExpression" === nodeType ||
      "UnaryExpression" === nodeType ||
      "UpdateExpression" === nodeType ||
      "ArrowFunctionExpression" === nodeType ||
      "ClassExpression" === nodeType ||
      "MetaProperty" === nodeType ||
      "Super" === nodeType ||
      "TaggedTemplateExpression" === nodeType ||
      "TemplateLiteral" === nodeType ||
      "YieldExpression" === nodeType ||
      "AwaitExpression" === nodeType ||
      "Import" === nodeType ||
      "BigIntLiteral" === nodeType ||
      "OptionalMemberExpression" === nodeType ||
      "OptionalCallExpression" === nodeType ||
      "TypeCastExpression" === nodeType ||
      "JSXElement" === nodeType ||
      "JSXFragment" === nodeType ||
      "BindExpression" === nodeType ||
      "DoExpression" === nodeType ||
      "RecordExpression" === nodeType ||
      "TupleExpression" === nodeType ||
      "DecimalLiteral" === nodeType ||
      "ModuleExpression" === nodeType ||
      "TopicReference" === nodeType ||
      "PipelineTopicExpression" === nodeType ||
      "PipelineBareFunction" === nodeType ||
      "PipelinePrimaryTopicReference" === nodeType ||
      "TSInstantiationExpression" === nodeType ||
      "TSAsExpression" === nodeType ||
      "TSTypeAssertion" === nodeType ||
      "TSNonNullExpression" === nodeType ||
      (nodeType === "Placeholder" &&
        ("Expression" === node.expectedNode ||
          "Identifier" === node.expectedNode ||
          "StringLiteral" === node.expectedNode))
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isBinary(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isScopable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "BlockStatement" === nodeType ||
      "CatchClause" === nodeType ||
      "DoWhileStatement" === nodeType ||
      "ForInStatement" === nodeType ||
      "ForStatement" === nodeType ||
      "FunctionDeclaration" === nodeType ||
      "FunctionExpression" === nodeType ||
      "Program" === nodeType ||
      "ObjectMethod" === nodeType ||
      "SwitchStatement" === nodeType ||
      "WhileStatement" === nodeType ||
      "ArrowFunctionExpression" === nodeType ||
      "ClassExpression" === nodeType ||
      "ClassDeclaration" === nodeType ||
      "ForOfStatement" === nodeType ||
      "ClassMethod" === nodeType ||
      "ClassPrivateMethod" === nodeType ||
      "StaticBlock" === nodeType ||
      "TSModuleBlock" === nodeType ||
      (nodeType === "Placeholder" && "BlockStatement" === node.expectedNode)
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isBlockParent(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "BlockStatement" === nodeType ||
      "CatchClause" === nodeType ||
      "DoWhileStatement" === nodeType ||
      "ForInStatement" === nodeType ||
      "ForStatement" === nodeType ||
      "FunctionDeclaration" === nodeType ||
      "FunctionExpression" === nodeType ||
      "Program" === nodeType ||
      "ObjectMethod" === nodeType ||
      "SwitchStatement" === nodeType ||
      "WhileStatement" === nodeType ||
      "ArrowFunctionExpression" === nodeType ||
      "ForOfStatement" === nodeType ||
      "ClassMethod" === nodeType ||
      "ClassPrivateMethod" === nodeType ||
      "StaticBlock" === nodeType ||
      "TSModuleBlock" === nodeType ||
      (nodeType === "Placeholder" && "BlockStatement" === node.expectedNode)
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isBlock(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "BlockStatement" === nodeType ||
      "Program" === nodeType ||
      "TSModuleBlock" === nodeType ||
      (nodeType === "Placeholder" && "BlockStatement" === node.expectedNode)
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "BlockStatement" === nodeType ||
      "BreakStatement" === nodeType ||
      "ContinueStatement" === nodeType ||
      "DebuggerStatement" === nodeType ||
      "DoWhileStatement" === nodeType ||
      "EmptyStatement" === nodeType ||
      "ExpressionStatement" === nodeType ||
      "ForInStatement" === nodeType ||
      "ForStatement" === nodeType ||
      "FunctionDeclaration" === nodeType ||
      "IfStatement" === nodeType ||
      "LabeledStatement" === nodeType ||
      "ReturnStatement" === nodeType ||
      "SwitchStatement" === nodeType ||
      "ThrowStatement" === nodeType ||
      "TryStatement" === nodeType ||
      "VariableDeclaration" === nodeType ||
      "WhileStatement" === nodeType ||
      "WithStatement" === nodeType ||
      "ClassDeclaration" === nodeType ||
      "ExportAllDeclaration" === nodeType ||
      "ExportDefaultDeclaration" === nodeType ||
      "ExportNamedDeclaration" === nodeType ||
      "ForOfStatement" === nodeType ||
      "ImportDeclaration" === nodeType ||
      "DeclareClass" === nodeType ||
      "DeclareFunction" === nodeType ||
      "DeclareInterface" === nodeType ||
      "DeclareModule" === nodeType ||
      "DeclareModuleExports" === nodeType ||
      "DeclareTypeAlias" === nodeType ||
      "DeclareOpaqueType" === nodeType ||
      "DeclareVariable" === nodeType ||
      "DeclareExportDeclaration" === nodeType ||
      "DeclareExportAllDeclaration" === nodeType ||
      "InterfaceDeclaration" === nodeType ||
      "OpaqueType" === nodeType ||
      "TypeAlias" === nodeType ||
      "EnumDeclaration" === nodeType ||
      "TSDeclareFunction" === nodeType ||
      "TSInterfaceDeclaration" === nodeType ||
      "TSTypeAliasDeclaration" === nodeType ||
      "TSEnumDeclaration" === nodeType ||
      "TSModuleDeclaration" === nodeType ||
      "TSImportEqualsDeclaration" === nodeType ||
      "TSExportAssignment" === nodeType ||
      "TSNamespaceExportDeclaration" === nodeType ||
      (nodeType === "Placeholder" &&
        ("Statement" === node.expectedNode ||
          "Declaration" === node.expectedNode ||
          "BlockStatement" === node.expectedNode))
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTerminatorless(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "BreakStatement" === nodeType ||
      "ContinueStatement" === nodeType ||
      "ReturnStatement" === nodeType ||
      "ThrowStatement" === nodeType ||
      "YieldExpression" === nodeType ||
      "AwaitExpression" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isCompletionStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "BreakStatement" === nodeType ||
      "ContinueStatement" === nodeType ||
      "ReturnStatement" === nodeType ||
      "ThrowStatement" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isConditional(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ConditionalExpression" === nodeType || "IfStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isLoop(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "DoWhileStatement" === nodeType ||
      "ForInStatement" === nodeType ||
      "ForStatement" === nodeType ||
      "WhileStatement" === nodeType ||
      "ForOfStatement" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isWhile(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isExpressionWrapper(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "ExpressionStatement" === nodeType ||
      "ParenthesizedExpression" === nodeType ||
      "TypeCastExpression" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isFor(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "ForInStatement" === nodeType ||
      "ForStatement" === nodeType ||
      "ForOfStatement" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isForXStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ForInStatement" === nodeType || "ForOfStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "FunctionDeclaration" === nodeType ||
      "FunctionExpression" === nodeType ||
      "ObjectMethod" === nodeType ||
      "ArrowFunctionExpression" === nodeType ||
      "ClassMethod" === nodeType ||
      "ClassPrivateMethod" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isFunctionParent(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "FunctionDeclaration" === nodeType ||
      "FunctionExpression" === nodeType ||
      "ObjectMethod" === nodeType ||
      "ArrowFunctionExpression" === nodeType ||
      "ClassMethod" === nodeType ||
      "ClassPrivateMethod" === nodeType ||
      "StaticBlock" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isPureish(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "FunctionDeclaration" === nodeType ||
      "FunctionExpression" === nodeType ||
      "StringLiteral" === nodeType ||
      "NumericLiteral" === nodeType ||
      "NullLiteral" === nodeType ||
      "BooleanLiteral" === nodeType ||
      "RegExpLiteral" === nodeType ||
      "ArrowFunctionExpression" === nodeType ||
      "BigIntLiteral" === nodeType ||
      "DecimalLiteral" === nodeType ||
      (nodeType === "Placeholder" && "StringLiteral" === node.expectedNode)
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "FunctionDeclaration" === nodeType ||
      "VariableDeclaration" === nodeType ||
      "ClassDeclaration" === nodeType ||
      "ExportAllDeclaration" === nodeType ||
      "ExportDefaultDeclaration" === nodeType ||
      "ExportNamedDeclaration" === nodeType ||
      "ImportDeclaration" === nodeType ||
      "DeclareClass" === nodeType ||
      "DeclareFunction" === nodeType ||
      "DeclareInterface" === nodeType ||
      "DeclareModule" === nodeType ||
      "DeclareModuleExports" === nodeType ||
      "DeclareTypeAlias" === nodeType ||
      "DeclareOpaqueType" === nodeType ||
      "DeclareVariable" === nodeType ||
      "DeclareExportDeclaration" === nodeType ||
      "DeclareExportAllDeclaration" === nodeType ||
      "InterfaceDeclaration" === nodeType ||
      "OpaqueType" === nodeType ||
      "TypeAlias" === nodeType ||
      "EnumDeclaration" === nodeType ||
      "TSDeclareFunction" === nodeType ||
      "TSInterfaceDeclaration" === nodeType ||
      "TSTypeAliasDeclaration" === nodeType ||
      "TSEnumDeclaration" === nodeType ||
      "TSModuleDeclaration" === nodeType ||
      (nodeType === "Placeholder" && "Declaration" === node.expectedNode)
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isPatternLike(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "Identifier" === nodeType ||
      "RestElement" === nodeType ||
      "AssignmentPattern" === nodeType ||
      "ArrayPattern" === nodeType ||
      "ObjectPattern" === nodeType ||
      "TSAsExpression" === nodeType ||
      "TSTypeAssertion" === nodeType ||
      "TSNonNullExpression" === nodeType ||
      (nodeType === "Placeholder" &&
        ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode))
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isLVal(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "Identifier" === nodeType ||
      "MemberExpression" === nodeType ||
      "RestElement" === nodeType ||
      "AssignmentPattern" === nodeType ||
      "ArrayPattern" === nodeType ||
      "ObjectPattern" === nodeType ||
      "TSParameterProperty" === nodeType ||
      "TSAsExpression" === nodeType ||
      "TSTypeAssertion" === nodeType ||
      "TSNonNullExpression" === nodeType ||
      (nodeType === "Placeholder" &&
        ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode))
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSEntityName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "Identifier" === nodeType ||
      "TSQualifiedName" === nodeType ||
      (nodeType === "Placeholder" && "Identifier" === node.expectedNode)
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "StringLiteral" === nodeType ||
      "NumericLiteral" === nodeType ||
      "NullLiteral" === nodeType ||
      "BooleanLiteral" === nodeType ||
      "RegExpLiteral" === nodeType ||
      "TemplateLiteral" === nodeType ||
      "BigIntLiteral" === nodeType ||
      "DecimalLiteral" === nodeType ||
      (nodeType === "Placeholder" && "StringLiteral" === node.expectedNode)
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isImmutable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "StringLiteral" === nodeType ||
      "NumericLiteral" === nodeType ||
      "NullLiteral" === nodeType ||
      "BooleanLiteral" === nodeType ||
      "BigIntLiteral" === nodeType ||
      "JSXAttribute" === nodeType ||
      "JSXClosingElement" === nodeType ||
      "JSXElement" === nodeType ||
      "JSXExpressionContainer" === nodeType ||
      "JSXSpreadChild" === nodeType ||
      "JSXOpeningElement" === nodeType ||
      "JSXText" === nodeType ||
      "JSXFragment" === nodeType ||
      "JSXOpeningFragment" === nodeType ||
      "JSXClosingFragment" === nodeType ||
      "DecimalLiteral" === nodeType ||
      (nodeType === "Placeholder" && "StringLiteral" === node.expectedNode)
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isUserWhitespacable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "ObjectMethod" === nodeType ||
      "ObjectProperty" === nodeType ||
      "ObjectTypeInternalSlot" === nodeType ||
      "ObjectTypeCallProperty" === nodeType ||
      "ObjectTypeIndexer" === nodeType ||
      "ObjectTypeProperty" === nodeType ||
      "ObjectTypeSpreadProperty" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "ObjectMethod" === nodeType ||
      "ClassMethod" === nodeType ||
      "ClassPrivateMethod" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isObjectMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "ObjectProperty" === nodeType ||
      "ClassProperty" === nodeType ||
      "ClassAccessorProperty" === nodeType ||
      "ClassPrivateProperty" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isUnaryLike(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("UnaryExpression" === nodeType || "SpreadElement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "AssignmentPattern" === nodeType ||
      "ArrayPattern" === nodeType ||
      "ObjectPattern" === nodeType ||
      (nodeType === "Placeholder" && "Pattern" === node.expectedNode)
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isClass(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ClassExpression" === nodeType || "ClassDeclaration" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isModuleDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "ExportAllDeclaration" === nodeType ||
      "ExportDefaultDeclaration" === nodeType ||
      "ExportNamedDeclaration" === nodeType ||
      "ImportDeclaration" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isExportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "ExportAllDeclaration" === nodeType ||
      "ExportDefaultDeclaration" === nodeType ||
      "ExportNamedDeclaration" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isModuleSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "ExportSpecifier" === nodeType ||
      "ImportDefaultSpecifier" === nodeType ||
      "ImportNamespaceSpecifier" === nodeType ||
      "ImportSpecifier" === nodeType ||
      "ExportNamespaceSpecifier" === nodeType ||
      "ExportDefaultSpecifier" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isAccessor(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ClassAccessorProperty" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isPrivate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "ClassPrivateProperty" === nodeType ||
      "ClassPrivateMethod" === nodeType ||
      "PrivateName" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isFlow(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "AnyTypeAnnotation" === nodeType ||
      "ArrayTypeAnnotation" === nodeType ||
      "BooleanTypeAnnotation" === nodeType ||
      "BooleanLiteralTypeAnnotation" === nodeType ||
      "NullLiteralTypeAnnotation" === nodeType ||
      "ClassImplements" === nodeType ||
      "DeclareClass" === nodeType ||
      "DeclareFunction" === nodeType ||
      "DeclareInterface" === nodeType ||
      "DeclareModule" === nodeType ||
      "DeclareModuleExports" === nodeType ||
      "DeclareTypeAlias" === nodeType ||
      "DeclareOpaqueType" === nodeType ||
      "DeclareVariable" === nodeType ||
      "DeclareExportDeclaration" === nodeType ||
      "DeclareExportAllDeclaration" === nodeType ||
      "DeclaredPredicate" === nodeType ||
      "ExistsTypeAnnotation" === nodeType ||
      "FunctionTypeAnnotation" === nodeType ||
      "FunctionTypeParam" === nodeType ||
      "GenericTypeAnnotation" === nodeType ||
      "InferredPredicate" === nodeType ||
      "InterfaceExtends" === nodeType ||
      "InterfaceDeclaration" === nodeType ||
      "InterfaceTypeAnnotation" === nodeType ||
      "IntersectionTypeAnnotation" === nodeType ||
      "MixedTypeAnnotation" === nodeType ||
      "EmptyTypeAnnotation" === nodeType ||
      "NullableTypeAnnotation" === nodeType ||
      "NumberLiteralTypeAnnotation" === nodeType ||
      "NumberTypeAnnotation" === nodeType ||
      "ObjectTypeAnnotation" === nodeType ||
      "ObjectTypeInternalSlot" === nodeType ||
      "ObjectTypeCallProperty" === nodeType ||
      "ObjectTypeIndexer" === nodeType ||
      "ObjectTypeProperty" === nodeType ||
      "ObjectTypeSpreadProperty" === nodeType ||
      "OpaqueType" === nodeType ||
      "QualifiedTypeIdentifier" === nodeType ||
      "StringLiteralTypeAnnotation" === nodeType ||
      "StringTypeAnnotation" === nodeType ||
      "SymbolTypeAnnotation" === nodeType ||
      "ThisTypeAnnotation" === nodeType ||
      "TupleTypeAnnotation" === nodeType ||
      "TypeofTypeAnnotation" === nodeType ||
      "TypeAlias" === nodeType ||
      "TypeAnnotation" === nodeType ||
      "TypeCastExpression" === nodeType ||
      "TypeParameter" === nodeType ||
      "TypeParameterDeclaration" === nodeType ||
      "TypeParameterInstantiation" === nodeType ||
      "UnionTypeAnnotation" === nodeType ||
      "Variance" === nodeType ||
      "VoidTypeAnnotation" === nodeType ||
      "EnumDeclaration" === nodeType ||
      "EnumBooleanBody" === nodeType ||
      "EnumNumberBody" === nodeType ||
      "EnumStringBody" === nodeType ||
      "EnumSymbolBody" === nodeType ||
      "EnumBooleanMember" === nodeType ||
      "EnumNumberMember" === nodeType ||
      "EnumStringMember" === nodeType ||
      "EnumDefaultedMember" === nodeType ||
      "IndexedAccessType" === nodeType ||
      "OptionalIndexedAccessType" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isFlowType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "AnyTypeAnnotation" === nodeType ||
      "ArrayTypeAnnotation" === nodeType ||
      "BooleanTypeAnnotation" === nodeType ||
      "BooleanLiteralTypeAnnotation" === nodeType ||
      "NullLiteralTypeAnnotation" === nodeType ||
      "ExistsTypeAnnotation" === nodeType ||
      "FunctionTypeAnnotation" === nodeType ||
      "GenericTypeAnnotation" === nodeType ||
      "InterfaceTypeAnnotation" === nodeType ||
      "IntersectionTypeAnnotation" === nodeType ||
      "MixedTypeAnnotation" === nodeType ||
      "EmptyTypeAnnotation" === nodeType ||
      "NullableTypeAnnotation" === nodeType ||
      "NumberLiteralTypeAnnotation" === nodeType ||
      "NumberTypeAnnotation" === nodeType ||
      "ObjectTypeAnnotation" === nodeType ||
      "StringLiteralTypeAnnotation" === nodeType ||
      "StringTypeAnnotation" === nodeType ||
      "SymbolTypeAnnotation" === nodeType ||
      "ThisTypeAnnotation" === nodeType ||
      "TupleTypeAnnotation" === nodeType ||
      "TypeofTypeAnnotation" === nodeType ||
      "UnionTypeAnnotation" === nodeType ||
      "VoidTypeAnnotation" === nodeType ||
      "IndexedAccessType" === nodeType ||
      "OptionalIndexedAccessType" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isFlowBaseAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "AnyTypeAnnotation" === nodeType ||
      "BooleanTypeAnnotation" === nodeType ||
      "NullLiteralTypeAnnotation" === nodeType ||
      "MixedTypeAnnotation" === nodeType ||
      "EmptyTypeAnnotation" === nodeType ||
      "NumberTypeAnnotation" === nodeType ||
      "StringTypeAnnotation" === nodeType ||
      "SymbolTypeAnnotation" === nodeType ||
      "ThisTypeAnnotation" === nodeType ||
      "VoidTypeAnnotation" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isFlowDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "DeclareClass" === nodeType ||
      "DeclareFunction" === nodeType ||
      "DeclareInterface" === nodeType ||
      "DeclareModule" === nodeType ||
      "DeclareModuleExports" === nodeType ||
      "DeclareTypeAlias" === nodeType ||
      "DeclareOpaqueType" === nodeType ||
      "DeclareVariable" === nodeType ||
      "DeclareExportDeclaration" === nodeType ||
      "DeclareExportAllDeclaration" === nodeType ||
      "InterfaceDeclaration" === nodeType ||
      "OpaqueType" === nodeType ||
      "TypeAlias" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isFlowPredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isEnumBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "EnumBooleanBody" === nodeType ||
      "EnumNumberBody" === nodeType ||
      "EnumStringBody" === nodeType ||
      "EnumSymbolBody" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isEnumMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "EnumBooleanMember" === nodeType ||
      "EnumNumberMember" === nodeType ||
      "EnumStringMember" === nodeType ||
      "EnumDefaultedMember" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isJSX(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "JSXAttribute" === nodeType ||
      "JSXClosingElement" === nodeType ||
      "JSXElement" === nodeType ||
      "JSXEmptyExpression" === nodeType ||
      "JSXExpressionContainer" === nodeType ||
      "JSXSpreadChild" === nodeType ||
      "JSXIdentifier" === nodeType ||
      "JSXMemberExpression" === nodeType ||
      "JSXNamespacedName" === nodeType ||
      "JSXOpeningElement" === nodeType ||
      "JSXSpreadAttribute" === nodeType ||
      "JSXText" === nodeType ||
      "JSXFragment" === nodeType ||
      "JSXOpeningFragment" === nodeType ||
      "JSXClosingFragment" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isMiscellaneous(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "Noop" === nodeType ||
      "Placeholder" === nodeType ||
      "V8IntrinsicIdentifier" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTypeScript(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "TSParameterProperty" === nodeType ||
      "TSDeclareFunction" === nodeType ||
      "TSDeclareMethod" === nodeType ||
      "TSQualifiedName" === nodeType ||
      "TSCallSignatureDeclaration" === nodeType ||
      "TSConstructSignatureDeclaration" === nodeType ||
      "TSPropertySignature" === nodeType ||
      "TSMethodSignature" === nodeType ||
      "TSIndexSignature" === nodeType ||
      "TSAnyKeyword" === nodeType ||
      "TSBooleanKeyword" === nodeType ||
      "TSBigIntKeyword" === nodeType ||
      "TSIntrinsicKeyword" === nodeType ||
      "TSNeverKeyword" === nodeType ||
      "TSNullKeyword" === nodeType ||
      "TSNumberKeyword" === nodeType ||
      "TSObjectKeyword" === nodeType ||
      "TSStringKeyword" === nodeType ||
      "TSSymbolKeyword" === nodeType ||
      "TSUndefinedKeyword" === nodeType ||
      "TSUnknownKeyword" === nodeType ||
      "TSVoidKeyword" === nodeType ||
      "TSThisType" === nodeType ||
      "TSFunctionType" === nodeType ||
      "TSConstructorType" === nodeType ||
      "TSTypeReference" === nodeType ||
      "TSTypePredicate" === nodeType ||
      "TSTypeQuery" === nodeType ||
      "TSTypeLiteral" === nodeType ||
      "TSArrayType" === nodeType ||
      "TSTupleType" === nodeType ||
      "TSOptionalType" === nodeType ||
      "TSRestType" === nodeType ||
      "TSNamedTupleMember" === nodeType ||
      "TSUnionType" === nodeType ||
      "TSIntersectionType" === nodeType ||
      "TSConditionalType" === nodeType ||
      "TSInferType" === nodeType ||
      "TSParenthesizedType" === nodeType ||
      "TSTypeOperator" === nodeType ||
      "TSIndexedAccessType" === nodeType ||
      "TSMappedType" === nodeType ||
      "TSLiteralType" === nodeType ||
      "TSExpressionWithTypeArguments" === nodeType ||
      "TSInterfaceDeclaration" === nodeType ||
      "TSInterfaceBody" === nodeType ||
      "TSTypeAliasDeclaration" === nodeType ||
      "TSInstantiationExpression" === nodeType ||
      "TSAsExpression" === nodeType ||
      "TSTypeAssertion" === nodeType ||
      "TSEnumDeclaration" === nodeType ||
      "TSEnumMember" === nodeType ||
      "TSModuleDeclaration" === nodeType ||
      "TSModuleBlock" === nodeType ||
      "TSImportType" === nodeType ||
      "TSImportEqualsDeclaration" === nodeType ||
      "TSExternalModuleReference" === nodeType ||
      "TSNonNullExpression" === nodeType ||
      "TSExportAssignment" === nodeType ||
      "TSNamespaceExportDeclaration" === nodeType ||
      "TSTypeAnnotation" === nodeType ||
      "TSTypeParameterInstantiation" === nodeType ||
      "TSTypeParameterDeclaration" === nodeType ||
      "TSTypeParameter" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSTypeElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "TSCallSignatureDeclaration" === nodeType ||
      "TSConstructSignatureDeclaration" === nodeType ||
      "TSPropertySignature" === nodeType ||
      "TSMethodSignature" === nodeType ||
      "TSIndexSignature" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "TSAnyKeyword" === nodeType ||
      "TSBooleanKeyword" === nodeType ||
      "TSBigIntKeyword" === nodeType ||
      "TSIntrinsicKeyword" === nodeType ||
      "TSNeverKeyword" === nodeType ||
      "TSNullKeyword" === nodeType ||
      "TSNumberKeyword" === nodeType ||
      "TSObjectKeyword" === nodeType ||
      "TSStringKeyword" === nodeType ||
      "TSSymbolKeyword" === nodeType ||
      "TSUndefinedKeyword" === nodeType ||
      "TSUnknownKeyword" === nodeType ||
      "TSVoidKeyword" === nodeType ||
      "TSThisType" === nodeType ||
      "TSFunctionType" === nodeType ||
      "TSConstructorType" === nodeType ||
      "TSTypeReference" === nodeType ||
      "TSTypePredicate" === nodeType ||
      "TSTypeQuery" === nodeType ||
      "TSTypeLiteral" === nodeType ||
      "TSArrayType" === nodeType ||
      "TSTupleType" === nodeType ||
      "TSOptionalType" === nodeType ||
      "TSRestType" === nodeType ||
      "TSUnionType" === nodeType ||
      "TSIntersectionType" === nodeType ||
      "TSConditionalType" === nodeType ||
      "TSInferType" === nodeType ||
      "TSParenthesizedType" === nodeType ||
      "TSTypeOperator" === nodeType ||
      "TSIndexedAccessType" === nodeType ||
      "TSMappedType" === nodeType ||
      "TSLiteralType" === nodeType ||
      "TSExpressionWithTypeArguments" === nodeType ||
      "TSImportType" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isTSBaseType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (
      "TSAnyKeyword" === nodeType ||
      "TSBooleanKeyword" === nodeType ||
      "TSBigIntKeyword" === nodeType ||
      "TSIntrinsicKeyword" === nodeType ||
      "TSNeverKeyword" === nodeType ||
      "TSNullKeyword" === nodeType ||
      "TSNumberKeyword" === nodeType ||
      "TSObjectKeyword" === nodeType ||
      "TSStringKeyword" === nodeType ||
      "TSSymbolKeyword" === nodeType ||
      "TSUndefinedKeyword" === nodeType ||
      "TSUnknownKeyword" === nodeType ||
      "TSVoidKeyword" === nodeType ||
      "TSThisType" === nodeType ||
      "TSLiteralType" === nodeType
    ) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isNumberLiteral(node, opts) {
    console.trace(
      "The node type NumberLiteral has been renamed to NumericLiteral"
    );
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NumberLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isRegexLiteral(node, opts) {
    console.trace(
      "The node type RegexLiteral has been renamed to RegExpLiteral"
    );
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "RegexLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isRestProperty(node, opts) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "RestProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  function isSpreadProperty(node, opts) {
    console.trace(
      "The node type SpreadProperty has been renamed to SpreadElement"
    );
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SpreadProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual.default)(node, opts);
      }
    }
    return false;
  }
  return generated$4;
}
var hasRequiredMatchesPattern;
function requireMatchesPattern() {
  if (hasRequiredMatchesPattern) return matchesPattern;
  hasRequiredMatchesPattern = 1;
  Object.defineProperty(matchesPattern, "__esModule", { value: true });
  matchesPattern.default = matchesPattern$1;
  var _generated = requireGenerated$4();
  function matchesPattern$1(member, match, allowPartial) {
    if (!(0, _generated.isMemberExpression)(member)) return false;
    const parts = Array.isArray(match) ? match : match.split(".");
    const nodes = [];
    let node;
    for (
      node = member;
      (0, _generated.isMemberExpression)(node);
      node = node.object
    ) {
      nodes.push(node.property);
    }
    nodes.push(node);
    if (nodes.length < parts.length) return false;
    if (!allowPartial && nodes.length > parts.length) return false;
    for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
      const node = nodes[j];
      let value;
      if ((0, _generated.isIdentifier)(node)) {
        value = node.name;
      } else if ((0, _generated.isStringLiteral)(node)) {
        value = node.value;
      } else if ((0, _generated.isThisExpression)(node)) {
        value = "this";
      } else {
        return false;
      }
      if (parts[i] !== value) return false;
    }
    return true;
  }
  return matchesPattern;
}
var hasRequiredBuildMatchMemberExpression;
function requireBuildMatchMemberExpression() {
  if (hasRequiredBuildMatchMemberExpression) return buildMatchMemberExpression;
  hasRequiredBuildMatchMemberExpression = 1;
  Object.defineProperty(buildMatchMemberExpression, "__esModule", {
    value: true,
  });
  buildMatchMemberExpression.default = buildMatchMemberExpression$1;
  var _matchesPattern = requireMatchesPattern();
  function buildMatchMemberExpression$1(match, allowPartial) {
    const parts = match.split(".");
    return (member) =>
      (0, _matchesPattern.default)(member, parts, allowPartial);
  }
  return buildMatchMemberExpression;
}
var hasRequiredIsReactComponent;
function requireIsReactComponent() {
  if (hasRequiredIsReactComponent) return isReactComponent;
  hasRequiredIsReactComponent = 1;
  Object.defineProperty(isReactComponent, "__esModule", { value: true });
  isReactComponent.default = void 0;
  var _buildMatchMemberExpression = requireBuildMatchMemberExpression();
  const isReactComponent$1 = (0, _buildMatchMemberExpression.default)(
    "React.Component"
  );
  var _default = isReactComponent$1;
  isReactComponent.default = _default;
  return isReactComponent;
}
var isCompatTag = {};
var hasRequiredIsCompatTag;
function requireIsCompatTag() {
  if (hasRequiredIsCompatTag) return isCompatTag;
  hasRequiredIsCompatTag = 1;
  Object.defineProperty(isCompatTag, "__esModule", { value: true });
  isCompatTag.default = isCompatTag$1;
  function isCompatTag$1(tagName) {
    return !!tagName && /^[a-z]/.test(tagName);
  }
  return isCompatTag;
}
var buildChildren = {};
var cleanJSXElementLiteralChild = {};
var generated$3 = {};
var validateNode = {};
var validate$1 = {};
var definitions = {};
var core = {};
var is = {};
var isType$1 = {};
var hasRequiredIsType;
function requireIsType() {
  if (hasRequiredIsType) return isType$1;
  hasRequiredIsType = 1;
  Object.defineProperty(isType$1, "__esModule", { value: true });
  isType$1.default = isType;
  var _definitions = requireDefinitions();
  function isType(nodeType, targetType) {
    if (nodeType === targetType) return true;
    if (_definitions.ALIAS_KEYS[targetType]) return false;
    const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];
    if (aliases) {
      if (aliases[0] === nodeType) return true;
      for (const alias of aliases) {
        if (nodeType === alias) return true;
      }
    }
    return false;
  }
  return isType$1;
}
var isPlaceholderType = {};
var hasRequiredIsPlaceholderType;
function requireIsPlaceholderType() {
  if (hasRequiredIsPlaceholderType) return isPlaceholderType;
  hasRequiredIsPlaceholderType = 1;
  Object.defineProperty(isPlaceholderType, "__esModule", { value: true });
  isPlaceholderType.default = isPlaceholderType$1;
  var _definitions = requireDefinitions();
  function isPlaceholderType$1(placeholderType, targetType) {
    if (placeholderType === targetType) return true;
    const aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];
    if (aliases) {
      for (const alias of aliases) {
        if (targetType === alias) return true;
      }
    }
    return false;
  }
  return isPlaceholderType;
}
var hasRequiredIs;
function requireIs() {
  if (hasRequiredIs) return is;
  hasRequiredIs = 1;
  Object.defineProperty(is, "__esModule", { value: true });
  is.default = is$1;
  var _shallowEqual = requireShallowEqual();
  var _isType = requireIsType();
  var _isPlaceholderType = requireIsPlaceholderType();
  var _definitions = requireDefinitions();
  function is$1(type, node, opts) {
    if (!node) return false;
    const matches = (0, _isType.default)(node.type, type);
    if (!matches) {
      if (
        !opts &&
        node.type === "Placeholder" &&
        type in _definitions.FLIPPED_ALIAS_KEYS
      ) {
        return (0, _isPlaceholderType.default)(node.expectedNode, type);
      }
      return false;
    }
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }
  return is;
}
var isValidIdentifier = {};
var hasRequiredIsValidIdentifier;
function requireIsValidIdentifier() {
  if (hasRequiredIsValidIdentifier) return isValidIdentifier;
  hasRequiredIsValidIdentifier = 1;
  Object.defineProperty(isValidIdentifier, "__esModule", { value: true });
  isValidIdentifier.default = isValidIdentifier$1;
  var _helperValidatorIdentifier = lib$4;
  function isValidIdentifier$1(name, reserved = true) {
    if (typeof name !== "string") return false;
    if (reserved) {
      if (
        (0, _helperValidatorIdentifier.isKeyword)(name) ||
        (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)
      ) {
        return false;
      }
    }
    return (0, _helperValidatorIdentifier.isIdentifierName)(name);
  }
  return isValidIdentifier;
}
var lib = {};
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib;
  hasRequiredLib$1 = 1;
  Object.defineProperty(lib, "__esModule", { value: true });
  lib.readCodePoint = readCodePoint;
  lib.readInt = readInt;
  lib.readStringContents = readStringContents;
  var _isDigit = function isDigit(code) {
    return code >= 48 && code <= 57;
  };
  const forbiddenNumericSeparatorSiblings = {
    decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: new Set([46, 88, 95, 120]),
  };
  const isAllowedNumericSeparatorSibling = {
    bin: (ch) => ch === 48 || ch === 49,
    oct: (ch) => ch >= 48 && ch <= 55,
    dec: (ch) => ch >= 48 && ch <= 57,
    hex: (ch) =>
      (ch >= 48 && ch <= 57) ||
      (ch >= 65 && ch <= 70) ||
      (ch >= 97 && ch <= 102),
  };
  function readStringContents(type, input, pos, lineStart, curLine, errors) {
    const initialPos = pos;
    const initialLineStart = lineStart;
    const initialCurLine = curLine;
    let out = "";
    let containsInvalid = false;
    let chunkStart = pos;
    const { length: length } = input;
    for (;;) {
      if (pos >= length) {
        errors.unterminated(initialPos, initialLineStart, initialCurLine);
        out += input.slice(chunkStart, pos);
        break;
      }
      const ch = input.charCodeAt(pos);
      if (isStringEnd(type, ch, input, pos)) {
        out += input.slice(chunkStart, pos);
        break;
      }
      if (ch === 92) {
        out += input.slice(chunkStart, pos);
        let escaped;
        ({
          ch: escaped,
          pos: pos,
          lineStart: lineStart,
          curLine: curLine,
        } = readEscapedChar(
          input,
          pos,
          lineStart,
          curLine,
          type === "template",
          errors
        ));
        if (escaped === null) {
          containsInvalid = true;
        } else {
          out += escaped;
        }
        chunkStart = pos;
      } else if (ch === 8232 || ch === 8233) {
        ++pos;
        ++curLine;
        lineStart = pos;
      } else if (ch === 10 || ch === 13) {
        if (type === "template") {
          out += input.slice(chunkStart, pos) + "\n";
          ++pos;
          if (ch === 13 && input.charCodeAt(pos) === 10) {
            ++pos;
          }
          ++curLine;
          chunkStart = lineStart = pos;
        } else {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
        }
      } else {
        ++pos;
      }
    }
    return {
      pos: pos,
      str: out,
      containsInvalid: containsInvalid,
      lineStart: lineStart,
      curLine: curLine,
    };
  }
  function isStringEnd(type, ch, input, pos) {
    if (type === "template") {
      return ch === 96 || (ch === 36 && input.charCodeAt(pos + 1) === 123);
    }
    return ch === (type === "double" ? 34 : 39);
  }
  function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
    const throwOnInvalid = !inTemplate;
    pos++;
    const res = (ch) => ({
      pos: pos,
      ch: ch,
      lineStart: lineStart,
      curLine: curLine,
    });
    const ch = input.charCodeAt(pos++);
    switch (ch) {
      case 110:
        return res("\n");
      case 114:
        return res("\r");
      case 120: {
        let code;
        ({ code: code, pos: pos } = readHexChar(
          input,
          pos,
          lineStart,
          curLine,
          2,
          false,
          throwOnInvalid,
          errors
        ));
        return res(code === null ? null : String.fromCharCode(code));
      }
      case 117: {
        let code;
        ({ code: code, pos: pos } = readCodePoint(
          input,
          pos,
          lineStart,
          curLine,
          throwOnInvalid,
          errors
        ));
        return res(code === null ? null : String.fromCodePoint(code));
      }
      case 116:
        return res("\t");
      case 98:
        return res("\b");
      case 118:
        return res("\v");
      case 102:
        return res("\f");
      case 13:
        if (input.charCodeAt(pos) === 10) {
          ++pos;
        }
      case 10:
        lineStart = pos;
        ++curLine;
      case 8232:
      case 8233:
        return res("");
      case 56:
      case 57:
        if (inTemplate) {
          return res(null);
        } else {
          errors.strictNumericEscape(pos - 1, lineStart, curLine);
        }
      default:
        if (ch >= 48 && ch <= 55) {
          const startPos = pos - 1;
          const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
          let octalStr = match[0];
          let octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          pos += octalStr.length - 1;
          const next = input.charCodeAt(pos);
          if (octalStr !== "0" || next === 56 || next === 57) {
            if (inTemplate) {
              return res(null);
            } else {
              errors.strictNumericEscape(startPos, lineStart, curLine);
            }
          }
          return res(String.fromCharCode(octal));
        }
        return res(String.fromCharCode(ch));
    }
  }
  function readHexChar(
    input,
    pos,
    lineStart,
    curLine,
    len,
    forceLen,
    throwOnInvalid,
    errors
  ) {
    const initialPos = pos;
    let n;
    ({ n: n, pos: pos } = readInt(
      input,
      pos,
      lineStart,
      curLine,
      16,
      len,
      forceLen,
      false,
      errors
    ));
    if (n === null) {
      if (throwOnInvalid) {
        errors.invalidEscapeSequence(initialPos, lineStart, curLine);
      } else {
        pos = initialPos - 1;
      }
    }
    return { code: n, pos: pos };
  }
  function readInt(
    input,
    pos,
    lineStart,
    curLine,
    radix,
    len,
    forceLen,
    allowNumSeparator,
    errors
  ) {
    const start = pos;
    const forbiddenSiblings =
      radix === 16
        ? forbiddenNumericSeparatorSiblings.hex
        : forbiddenNumericSeparatorSiblings.decBinOct;
    const isAllowedSibling =
      radix === 16
        ? isAllowedNumericSeparatorSibling.hex
        : radix === 10
          ? isAllowedNumericSeparatorSibling.dec
          : radix === 8
            ? isAllowedNumericSeparatorSibling.oct
            : isAllowedNumericSeparatorSibling.bin;
    let invalid = false;
    let total = 0;
    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      const code = input.charCodeAt(pos);
      let val;
      if (code === 95 && allowNumSeparator !== "bail") {
        const prev = input.charCodeAt(pos - 1);
        const next = input.charCodeAt(pos + 1);
        if (!allowNumSeparator) {
          errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
        } else if (
          Number.isNaN(next) ||
          !isAllowedSibling(next) ||
          forbiddenSiblings.has(prev) ||
          forbiddenSiblings.has(next)
        ) {
          errors.unexpectedNumericSeparator(pos, lineStart, curLine);
        }
        ++pos;
        continue;
      }
      if (code >= 97) {
        val = code - 97 + 10;
      } else if (code >= 65) {
        val = code - 65 + 10;
      } else if (_isDigit(code)) {
        val = code - 48;
      } else {
        val = Infinity;
      }
      if (val >= radix) {
        if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
          val = 0;
        } else if (forceLen) {
          val = 0;
          invalid = true;
        } else {
          break;
        }
      }
      ++pos;
      total = total * radix + val;
    }
    if (pos === start || (len != null && pos - start !== len) || invalid) {
      return { n: null, pos: pos };
    }
    return { n: total, pos: pos };
  }
  function readCodePoint(
    input,
    pos,
    lineStart,
    curLine,
    throwOnInvalid,
    errors
  ) {
    const ch = input.charCodeAt(pos);
    let code;
    if (ch === 123) {
      ++pos;
      ({ code: code, pos: pos } = readHexChar(
        input,
        pos,
        lineStart,
        curLine,
        input.indexOf("}", pos) - pos,
        true,
        throwOnInvalid,
        errors
      ));
      ++pos;
      if (code !== null && code > 1114111) {
        if (throwOnInvalid) {
          errors.invalidCodePoint(pos, lineStart, curLine);
        } else {
          return { code: null, pos: pos };
        }
      }
    } else {
      ({ code: code, pos: pos } = readHexChar(
        input,
        pos,
        lineStart,
        curLine,
        4,
        false,
        throwOnInvalid,
        errors
      ));
    }
    return { code: code, pos: pos };
  }
  return lib;
}
var constants = {};
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  Object.defineProperty(constants, "__esModule", { value: true });
  constants.UPDATE_OPERATORS =
    constants.UNARY_OPERATORS =
    constants.STRING_UNARY_OPERATORS =
    constants.STATEMENT_OR_BLOCK_KEYS =
    constants.NUMBER_UNARY_OPERATORS =
    constants.NUMBER_BINARY_OPERATORS =
    constants.NOT_LOCAL_BINDING =
    constants.LOGICAL_OPERATORS =
    constants.INHERIT_KEYS =
    constants.FOR_INIT_KEYS =
    constants.FLATTENABLE_KEYS =
    constants.EQUALITY_BINARY_OPERATORS =
    constants.COMPARISON_BINARY_OPERATORS =
    constants.COMMENT_KEYS =
    constants.BOOLEAN_UNARY_OPERATORS =
    constants.BOOLEAN_NUMBER_BINARY_OPERATORS =
    constants.BOOLEAN_BINARY_OPERATORS =
    constants.BLOCK_SCOPED_SYMBOL =
    constants.BINARY_OPERATORS =
    constants.ASSIGNMENT_OPERATORS =
      void 0;
  const STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
  constants.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
  const FLATTENABLE_KEYS = ["body", "expressions"];
  constants.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
  const FOR_INIT_KEYS = ["left", "init"];
  constants.FOR_INIT_KEYS = FOR_INIT_KEYS;
  const COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
  constants.COMMENT_KEYS = COMMENT_KEYS;
  const LOGICAL_OPERATORS = ["||", "&&", "??"];
  constants.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
  const UPDATE_OPERATORS = ["++", "--"];
  constants.UPDATE_OPERATORS = UPDATE_OPERATORS;
  const BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
  constants.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
  const EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
  constants.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
  const COMPARISON_BINARY_OPERATORS = [
    ...EQUALITY_BINARY_OPERATORS,
    "in",
    "instanceof",
  ];
  constants.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
  const BOOLEAN_BINARY_OPERATORS = [
    ...COMPARISON_BINARY_OPERATORS,
    ...BOOLEAN_NUMBER_BINARY_OPERATORS,
  ];
  constants.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
  const NUMBER_BINARY_OPERATORS = [
    "-",
    "/",
    "%",
    "*",
    "**",
    "&",
    "|",
    ">>",
    ">>>",
    "<<",
    "^",
  ];
  constants.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
  const BINARY_OPERATORS = [
    "+",
    ...NUMBER_BINARY_OPERATORS,
    ...BOOLEAN_BINARY_OPERATORS,
    "|>",
  ];
  constants.BINARY_OPERATORS = BINARY_OPERATORS;
  const ASSIGNMENT_OPERATORS = [
    "=",
    "+=",
    ...NUMBER_BINARY_OPERATORS.map((op) => op + "="),
    ...LOGICAL_OPERATORS.map((op) => op + "="),
  ];
  constants.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
  const BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
  constants.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
  const NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
  constants.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
  const STRING_UNARY_OPERATORS = ["typeof"];
  constants.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
  const UNARY_OPERATORS = [
    "void",
    "throw",
    ...BOOLEAN_UNARY_OPERATORS,
    ...NUMBER_UNARY_OPERATORS,
    ...STRING_UNARY_OPERATORS,
  ];
  constants.UNARY_OPERATORS = UNARY_OPERATORS;
  const INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"],
  };
  constants.INHERIT_KEYS = INHERIT_KEYS;
  const BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
  constants.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
  const NOT_LOCAL_BINDING = Symbol.for(
    "should not be considered a local binding"
  );
  constants.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;
  return constants;
}
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  Object.defineProperty(utils, "__esModule", { value: true });
  utils.VISITOR_KEYS =
    utils.NODE_PARENT_VALIDATIONS =
    utils.NODE_FIELDS =
    utils.FLIPPED_ALIAS_KEYS =
    utils.DEPRECATED_KEYS =
    utils.BUILDER_KEYS =
    utils.ALIAS_KEYS =
      void 0;
  utils.arrayOf = arrayOf;
  utils.arrayOfType = arrayOfType;
  utils.assertEach = assertEach;
  utils.assertNodeOrValueType = assertNodeOrValueType;
  utils.assertNodeType = assertNodeType;
  utils.assertOneOf = assertOneOf;
  utils.assertOptionalChainStart = assertOptionalChainStart;
  utils.assertShape = assertShape;
  utils.assertValueType = assertValueType;
  utils.chain = chain;
  utils.default = defineType;
  utils.defineAliasedType = defineAliasedType;
  utils.typeIs = typeIs;
  utils.validate = validate;
  utils.validateArrayOfType = validateArrayOfType;
  utils.validateOptional = validateOptional;
  utils.validateOptionalType = validateOptionalType;
  utils.validateType = validateType;
  var _is = requireIs();
  var _validate = requireValidate();
  const VISITOR_KEYS = {};
  utils.VISITOR_KEYS = VISITOR_KEYS;
  const ALIAS_KEYS = {};
  utils.ALIAS_KEYS = ALIAS_KEYS;
  const FLIPPED_ALIAS_KEYS = {};
  utils.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
  const NODE_FIELDS = {};
  utils.NODE_FIELDS = NODE_FIELDS;
  const BUILDER_KEYS = {};
  utils.BUILDER_KEYS = BUILDER_KEYS;
  const DEPRECATED_KEYS = {};
  utils.DEPRECATED_KEYS = DEPRECATED_KEYS;
  const NODE_PARENT_VALIDATIONS = {};
  utils.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;
  function getType(val) {
    if (Array.isArray(val)) {
      return "array";
    } else if (val === null) {
      return "null";
    } else {
      return typeof val;
    }
  }
  function validate(validate) {
    return { validate: validate };
  }
  function typeIs(typeName) {
    return typeof typeName === "string"
      ? assertNodeType(typeName)
      : assertNodeType(...typeName);
  }
  function validateType(typeName) {
    return validate(typeIs(typeName));
  }
  function validateOptional(validate) {
    return { validate: validate, optional: true };
  }
  function validateOptionalType(typeName) {
    return { validate: typeIs(typeName), optional: true };
  }
  function arrayOf(elementType) {
    return chain(assertValueType("array"), assertEach(elementType));
  }
  function arrayOfType(typeName) {
    return arrayOf(typeIs(typeName));
  }
  function validateArrayOfType(typeName) {
    return validate(arrayOfType(typeName));
  }
  function assertEach(callback) {
    function validator(node, key, val) {
      if (!Array.isArray(val)) return;
      for (let i = 0; i < val.length; i++) {
        const subkey = `${key}[${i}]`;
        const v = val[i];
        callback(node, subkey, v);
        if (process.env.BABEL_TYPES_8_BREAKING)
          (0, _validate.validateChild)(node, subkey, v);
      }
    }
    validator.each = callback;
    return validator;
  }
  function assertOneOf(...values) {
    function validate(node, key, val) {
      if (values.indexOf(val) < 0) {
        throw new TypeError(
          `Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`
        );
      }
    }
    validate.oneOf = values;
    return validate;
  }
  function assertNodeType(...types) {
    function validate(node, key, val) {
      for (const type of types) {
        if ((0, _is.default)(type, val)) {
          (0, _validate.validateChild)(node, key, val);
          return;
        }
      }
      throw new TypeError(
        `Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`
      );
    }
    validate.oneOfNodeTypes = types;
    return validate;
  }
  function assertNodeOrValueType(...types) {
    function validate(node, key, val) {
      for (const type of types) {
        if (getType(val) === type || (0, _is.default)(type, val)) {
          (0, _validate.validateChild)(node, key, val);
          return;
        }
      }
      throw new TypeError(
        `Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`
      );
    }
    validate.oneOfNodeOrValueTypes = types;
    return validate;
  }
  function assertValueType(type) {
    function validate(node, key, val) {
      const valid = getType(val) === type;
      if (!valid) {
        throw new TypeError(
          `Property ${key} expected type of ${type} but got ${getType(val)}`
        );
      }
    }
    validate.type = type;
    return validate;
  }
  function assertShape(shape) {
    function validate(node, key, val) {
      const errors = [];
      for (const property of Object.keys(shape)) {
        try {
          (0, _validate.validateField)(
            node,
            property,
            val[property],
            shape[property]
          );
        } catch (error) {
          if (error instanceof TypeError) {
            errors.push(error.message);
            continue;
          }
          throw error;
        }
      }
      if (errors.length) {
        throw new TypeError(
          `Property ${key} of ${node.type} expected to have the following:\n${errors.join("\n")}`
        );
      }
    }
    validate.shapeOf = shape;
    return validate;
  }
  function assertOptionalChainStart() {
    function validate(node) {
      var _current;
      let current = node;
      while (node) {
        const { type: type } = current;
        if (type === "OptionalCallExpression") {
          if (current.optional) return;
          current = current.callee;
          continue;
        }
        if (type === "OptionalMemberExpression") {
          if (current.optional) return;
          current = current.object;
          continue;
        }
        break;
      }
      throw new TypeError(
        `Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`
      );
    }
    return validate;
  }
  function chain(...fns) {
    function validate(...args) {
      for (const fn of fns) {
        fn(...args);
      }
    }
    validate.chainOf = fns;
    if (
      fns.length >= 2 &&
      "type" in fns[0] &&
      fns[0].type === "array" &&
      !("each" in fns[1])
    ) {
      throw new Error(
        `An assertValueType("array") validator can only be followed by an assertEach(...) validator.`
      );
    }
    return validate;
  }
  const validTypeOpts = [
    "aliases",
    "builder",
    "deprecatedAlias",
    "fields",
    "inherits",
    "visitor",
    "validate",
  ];
  const validFieldKeys = ["default", "optional", "validate"];
  function defineAliasedType(...aliases) {
    return (type, opts = {}) => {
      let defined = opts.aliases;
      if (!defined) {
        var _store$opts$inherits$, _defined;
        if (opts.inherits)
          defined =
            (_store$opts$inherits$ = store[opts.inherits].aliases) == null
              ? void 0
              : _store$opts$inherits$.slice();
        (_defined = defined) != null ? _defined : (defined = []);
        opts.aliases = defined;
      }
      const additional = aliases.filter((a) => !defined.includes(a));
      defined.unshift(...additional);
      return defineType(type, opts);
    };
  }
  function defineType(type, opts = {}) {
    const inherits = (opts.inherits && store[opts.inherits]) || {};
    let fields = opts.fields;
    if (!fields) {
      fields = {};
      if (inherits.fields) {
        const keys = Object.getOwnPropertyNames(inherits.fields);
        for (const key of keys) {
          const field = inherits.fields[key];
          const def = field.default;
          if (
            Array.isArray(def) ? def.length > 0 : def && typeof def === "object"
          ) {
            throw new Error(
              "field defaults can only be primitives or empty arrays currently"
            );
          }
          fields[key] = {
            default: Array.isArray(def) ? [] : def,
            optional: field.optional,
            validate: field.validate,
          };
        }
      }
    }
    const visitor = opts.visitor || inherits.visitor || [];
    const aliases = opts.aliases || inherits.aliases || [];
    const builder = opts.builder || inherits.builder || opts.visitor || [];
    for (const k of Object.keys(opts)) {
      if (validTypeOpts.indexOf(k) === -1) {
        throw new Error(`Unknown type option "${k}" on ${type}`);
      }
    }
    if (opts.deprecatedAlias) {
      DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    }
    for (const key of visitor.concat(builder)) {
      fields[key] = fields[key] || {};
    }
    for (const key of Object.keys(fields)) {
      const field = fields[key];
      if (field.default !== undefined && builder.indexOf(key) === -1) {
        field.optional = true;
      }
      if (field.default === undefined) {
        field.default = null;
      } else if (!field.validate && field.default != null) {
        field.validate = assertValueType(getType(field.default));
      }
      for (const k of Object.keys(field)) {
        if (validFieldKeys.indexOf(k) === -1) {
          throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
        }
      }
    }
    VISITOR_KEYS[type] = opts.visitor = visitor;
    BUILDER_KEYS[type] = opts.builder = builder;
    NODE_FIELDS[type] = opts.fields = fields;
    ALIAS_KEYS[type] = opts.aliases = aliases;
    aliases.forEach((alias) => {
      FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
      FLIPPED_ALIAS_KEYS[alias].push(type);
    });
    if (opts.validate) {
      NODE_PARENT_VALIDATIONS[type] = opts.validate;
    }
    store[type] = opts;
  }
  const store = {};
  return utils;
}
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore) return core;
  hasRequiredCore = 1;
  Object.defineProperty(core, "__esModule", { value: true });
  core.patternLikeCommon =
    core.functionTypeAnnotationCommon =
    core.functionDeclarationCommon =
    core.functionCommon =
    core.classMethodOrPropertyCommon =
    core.classMethodOrDeclareMethodCommon =
      void 0;
  var _is = requireIs();
  var _isValidIdentifier = requireIsValidIdentifier();
  var _helperValidatorIdentifier = lib$4;
  var _helperStringParser = requireLib$1();
  var _constants = requireConstants();
  var _utils = requireUtils();
  const defineType = (0, _utils.defineAliasedType)("Standardized");
  defineType("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeOrValueType)(
              "null",
              "Expression",
              "SpreadElement"
            )
          )
        ),
        default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined,
      },
    },
    visitor: ["elements"],
    aliases: ["Expression"],
  });
  defineType("AssignmentExpression", {
    fields: {
      operator: {
        validate: (function () {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return (0, _utils.assertValueType)("string");
          }
          const identifier = (0, _utils.assertOneOf)(
            ..._constants.ASSIGNMENT_OPERATORS
          );
          const pattern = (0, _utils.assertOneOf)("=");
          return function (node, key, val) {
            const validator = (0, _is.default)("Pattern", node.left)
              ? pattern
              : identifier;
            validator(node, key, val);
          };
        })(),
      },
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING
          ? (0, _utils.assertNodeType)("LVal")
          : (0, _utils.assertNodeType)(
              "Identifier",
              "MemberExpression",
              "ArrayPattern",
              "ObjectPattern",
              "TSAsExpression",
              "TSTypeAssertion",
              "TSNonNullExpression"
            ),
      },
      right: { validate: (0, _utils.assertNodeType)("Expression") },
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"],
  });
  defineType("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS),
      },
      left: {
        validate: (function () {
          const expression = (0, _utils.assertNodeType)("Expression");
          const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
          const validator = Object.assign(
            function (node, key, val) {
              const validator = node.operator === "in" ? inOp : expression;
              validator(node, key, val);
            },
            { oneOfNodeTypes: ["Expression", "PrivateName"] }
          );
          return validator;
        })(),
      },
      right: { validate: (0, _utils.assertNodeType)("Expression") },
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
  });
  defineType("InterpreterDirective", {
    builder: ["value"],
    fields: { value: { validate: (0, _utils.assertValueType)("string") } },
  });
  defineType("Directive", {
    visitor: ["value"],
    fields: {
      value: { validate: (0, _utils.assertNodeType)("DirectiveLiteral") },
    },
  });
  defineType("DirectiveLiteral", {
    builder: ["value"],
    fields: { value: { validate: (0, _utils.assertValueType)("string") } },
  });
  defineType("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))
        ),
        default: [],
      },
      body: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement"))
        ),
      },
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"],
  });
  defineType("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true,
      },
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  });
  defineType("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign(
      {
        callee: {
          validate: (0, _utils.assertNodeType)(
            "Expression",
            "Super",
            "V8IntrinsicIdentifier"
          ),
        },
        arguments: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)("array"),
            (0, _utils.assertEach)(
              (0, _utils.assertNodeType)(
                "Expression",
                "SpreadElement",
                "JSXNamespacedName",
                "ArgumentPlaceholder"
              )
            )
          ),
        },
      },
      !process.env.BABEL_TYPES_8_BREAKING
        ? {
            optional: {
              validate: (0, _utils.assertOneOf)(true, false),
              optional: true,
            },
          }
        : {},
      {
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true,
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true,
        },
      }
    ),
  });
  defineType("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, _utils.assertNodeType)(
          "Identifier",
          "ArrayPattern",
          "ObjectPattern"
        ),
        optional: true,
      },
      body: { validate: (0, _utils.assertNodeType)("BlockStatement") },
    },
    aliases: ["Scopable", "BlockParent"],
  });
  defineType("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: { validate: (0, _utils.assertNodeType)("Expression") },
      consequent: { validate: (0, _utils.assertNodeType)("Expression") },
      alternate: { validate: (0, _utils.assertNodeType)("Expression") },
    },
    aliases: ["Expression", "Conditional"],
  });
  defineType("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true,
      },
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  });
  defineType("DebuggerStatement", { aliases: ["Statement"] });
  defineType("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: { validate: (0, _utils.assertNodeType)("Expression") },
      body: { validate: (0, _utils.assertNodeType)("Statement") },
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
  });
  defineType("EmptyStatement", { aliases: ["Statement"] });
  defineType("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: { validate: (0, _utils.assertNodeType)("Expression") },
    },
    aliases: ["Statement", "ExpressionWrapper"],
  });
  defineType("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: { validate: (0, _utils.assertNodeType)("Program") },
      comments: {
        validate: !process.env.BABEL_TYPES_8_BREAKING
          ? Object.assign(() => {}, {
              each: { oneOfNodeTypes: ["CommentBlock", "CommentLine"] },
            })
          : (0, _utils.assertEach)(
              (0, _utils.assertNodeType)("CommentBlock", "CommentLine")
            ),
        optional: true,
      },
      tokens: {
        validate: (0, _utils.assertEach)(
          Object.assign(() => {}, { type: "any" })
        ),
        optional: true,
      },
    },
  });
  defineType("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: [
      "Scopable",
      "Statement",
      "For",
      "BlockParent",
      "Loop",
      "ForXStatement",
    ],
    fields: {
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING
          ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal")
          : (0, _utils.assertNodeType)(
              "VariableDeclaration",
              "Identifier",
              "MemberExpression",
              "ArrayPattern",
              "ObjectPattern",
              "TSAsExpression",
              "TSTypeAssertion",
              "TSNonNullExpression"
            ),
      },
      right: { validate: (0, _utils.assertNodeType)("Expression") },
      body: { validate: (0, _utils.assertNodeType)("Statement") },
    },
  });
  defineType("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, _utils.assertNodeType)(
          "VariableDeclaration",
          "Expression"
        ),
        optional: true,
      },
      test: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true,
      },
      update: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true,
      },
      body: { validate: (0, _utils.assertNodeType)("Statement") },
    },
  });
  const functionCommon = () => ({
    params: {
      validate: (0, _utils.chain)(
        (0, _utils.assertValueType)("array"),
        (0, _utils.assertEach)(
          (0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement")
        )
      ),
    },
    generator: { default: false },
    async: { default: false },
  });
  core.functionCommon = functionCommon;
  const functionTypeAnnotationCommon = () => ({
    returnType: {
      validate: (0, _utils.assertNodeType)(
        "TypeAnnotation",
        "TSTypeAnnotation",
        "Noop"
      ),
      optional: true,
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)(
        "TypeParameterDeclaration",
        "TSTypeParameterDeclaration",
        "Noop"
      ),
      optional: true,
    },
  });
  core.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
  const functionDeclarationCommon = () =>
    Object.assign({}, functionCommon(), {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true,
      },
    });
  core.functionDeclarationCommon = functionDeclarationCommon;
  defineType("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign(
      {},
      functionDeclarationCommon(),
      functionTypeAnnotationCommon(),
      {
        body: { validate: (0, _utils.assertNodeType)("BlockStatement") },
        predicate: {
          validate: (0, _utils.assertNodeType)(
            "DeclaredPredicate",
            "InferredPredicate"
          ),
          optional: true,
        },
      }
    ),
    aliases: [
      "Scopable",
      "Function",
      "BlockParent",
      "FunctionParent",
      "Statement",
      "Pureish",
      "Declaration",
    ],
    validate: (function () {
      if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};
      const identifier = (0, _utils.assertNodeType)("Identifier");
      return function (parent, key, node) {
        if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
          identifier(node, "id", node.id);
        }
      };
    })(),
  });
  defineType("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: [
      "Scopable",
      "Function",
      "BlockParent",
      "FunctionParent",
      "Expression",
      "Pureish",
    ],
    fields: Object.assign(
      {},
      functionCommon(),
      functionTypeAnnotationCommon(),
      {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true,
        },
        body: { validate: (0, _utils.assertNodeType)("BlockStatement") },
        predicate: {
          validate: (0, _utils.assertNodeType)(
            "DeclaredPredicate",
            "InferredPredicate"
          ),
          optional: true,
        },
      }
    ),
  });
  const patternLikeCommon = () => ({
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)(
        "TypeAnnotation",
        "TSTypeAnnotation",
        "Noop"
      ),
      optional: true,
    },
    decorators: {
      validate: (0, _utils.chain)(
        (0, _utils.assertValueType)("array"),
        (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
      ),
      optional: true,
    },
  });
  core.patternLikeCommon = patternLikeCommon;
  defineType("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, patternLikeCommon(), {
      name: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("string"),
          Object.assign(
            function (node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING) return;
              if (!(0, _isValidIdentifier.default)(val, false)) {
                throw new TypeError(`"${val}" is not a valid identifier name`);
              }
            },
            { type: "string" }
          )
        ),
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
    }),
    validate(parent, key, node) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      const match = /\.(\w+)$/.exec(key);
      if (!match) return;
      const [, parentKey] = match;
      const nonComp = { computed: false };
      if (parentKey === "property") {
        if ((0, _is.default)("MemberExpression", parent, nonComp)) return;
        if ((0, _is.default)("OptionalMemberExpression", parent, nonComp))
          return;
      } else if (parentKey === "key") {
        if ((0, _is.default)("Property", parent, nonComp)) return;
        if ((0, _is.default)("Method", parent, nonComp)) return;
      } else if (parentKey === "exported") {
        if ((0, _is.default)("ExportSpecifier", parent)) return;
      } else if (parentKey === "imported") {
        if ((0, _is.default)("ImportSpecifier", parent, { imported: node }))
          return;
      } else if (parentKey === "meta") {
        if ((0, _is.default)("MetaProperty", parent, { meta: node })) return;
      }
      if (
        ((0, _helperValidatorIdentifier.isKeyword)(node.name) ||
          (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) &&
        node.name !== "this"
      ) {
        throw new TypeError(`"${node.name}" is not a valid identifier`);
      }
    },
  });
  defineType("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: { validate: (0, _utils.assertNodeType)("Expression") },
      consequent: { validate: (0, _utils.assertNodeType)("Statement") },
      alternate: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Statement"),
      },
    },
  });
  defineType("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: { validate: (0, _utils.assertNodeType)("Identifier") },
      body: { validate: (0, _utils.assertNodeType)("Statement") },
    },
  });
  defineType("StringLiteral", {
    builder: ["value"],
    fields: { value: { validate: (0, _utils.assertValueType)("string") } },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"],
  });
  defineType("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: { value: { validate: (0, _utils.assertValueType)("number") } },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"],
  });
  defineType("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"],
  });
  defineType("BooleanLiteral", {
    builder: ["value"],
    fields: { value: { validate: (0, _utils.assertValueType)("boolean") } },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"],
  });
  defineType("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: { validate: (0, _utils.assertValueType)("string") },
      flags: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("string"),
          Object.assign(
            function (node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING) return;
              const invalid = /[^gimsuy]/.exec(val);
              if (invalid) {
                throw new TypeError(
                  `"${invalid[0]}" is not a valid RegExp flag`
                );
              }
            },
            { type: "string" }
          )
        ),
        default: "",
      },
    },
  });
  defineType("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS),
      },
      left: { validate: (0, _utils.assertNodeType)("Expression") },
      right: { validate: (0, _utils.assertNodeType)("Expression") },
    },
  });
  defineType("MemberExpression", {
    builder: [
      "object",
      "property",
      "computed",
      ...(!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : []),
    ],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign(
      {
        object: { validate: (0, _utils.assertNodeType)("Expression", "Super") },
        property: {
          validate: (function () {
            const normal = (0, _utils.assertNodeType)(
              "Identifier",
              "PrivateName"
            );
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function (node, key, val) {
              const validator = node.computed ? computed : normal;
              validator(node, key, val);
            };
            validator.oneOfNodeTypes = [
              "Expression",
              "Identifier",
              "PrivateName",
            ];
            return validator;
          })(),
        },
        computed: { default: false },
      },
      !process.env.BABEL_TYPES_8_BREAKING
        ? {
            optional: {
              validate: (0, _utils.assertOneOf)(true, false),
              optional: true,
            },
          }
        : {}
    ),
  });
  defineType("NewExpression", { inherits: "CallExpression" });
  defineType("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceFile: { validate: (0, _utils.assertValueType)("string") },
      sourceType: {
        validate: (0, _utils.assertOneOf)("script", "module"),
        default: "script",
      },
      interpreter: {
        validate: (0, _utils.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: true,
      },
      directives: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))
        ),
        default: [],
      },
      body: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement"))
        ),
      },
    },
    aliases: ["Scopable", "BlockParent", "Block"],
  });
  defineType("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)(
              "ObjectMethod",
              "ObjectProperty",
              "SpreadElement"
            )
          )
        ),
      },
    },
  });
  defineType("ObjectMethod", {
    builder: [
      "kind",
      "key",
      "params",
      "body",
      "computed",
      "generator",
      "async",
    ],
    fields: Object.assign(
      {},
      functionCommon(),
      functionTypeAnnotationCommon(),
      {
        kind: Object.assign(
          { validate: (0, _utils.assertOneOf)("method", "get", "set") },
          !process.env.BABEL_TYPES_8_BREAKING ? { default: "method" } : {}
        ),
        computed: { default: false },
        key: {
          validate: (function () {
            const normal = (0, _utils.assertNodeType)(
              "Identifier",
              "StringLiteral",
              "NumericLiteral",
              "BigIntLiteral"
            );
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function (node, key, val) {
              const validator = node.computed ? computed : normal;
              validator(node, key, val);
            };
            validator.oneOfNodeTypes = [
              "Expression",
              "Identifier",
              "StringLiteral",
              "NumericLiteral",
              "BigIntLiteral",
            ];
            return validator;
          })(),
        },
        decorators: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)("array"),
            (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
          ),
          optional: true,
        },
        body: { validate: (0, _utils.assertNodeType)("BlockStatement") },
      }
    ),
    visitor: [
      "key",
      "params",
      "body",
      "decorators",
      "returnType",
      "typeParameters",
    ],
    aliases: [
      "UserWhitespacable",
      "Function",
      "Scopable",
      "BlockParent",
      "FunctionParent",
      "Method",
      "ObjectMember",
    ],
  });
  defineType("ObjectProperty", {
    builder: [
      "key",
      "value",
      "computed",
      "shorthand",
      ...(!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []),
    ],
    fields: {
      computed: { default: false },
      key: {
        validate: (function () {
          const normal = (0, _utils.assertNodeType)(
            "Identifier",
            "StringLiteral",
            "NumericLiteral",
            "BigIntLiteral",
            "DecimalLiteral",
            "PrivateName"
          );
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator = Object.assign(
            function (node, key, val) {
              const validator = node.computed ? computed : normal;
              validator(node, key, val);
            },
            {
              oneOfNodeTypes: [
                "Expression",
                "Identifier",
                "StringLiteral",
                "NumericLiteral",
                "BigIntLiteral",
                "DecimalLiteral",
                "PrivateName",
              ],
            }
          );
          return validator;
        })(),
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression", "PatternLike"),
      },
      shorthand: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("boolean"),
          Object.assign(
            function (node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING) return;
              if (val && node.computed) {
                throw new TypeError(
                  "Property shorthand of ObjectProperty cannot be true if computed is true"
                );
              }
            },
            { type: "boolean" }
          ),
          function (node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING) return;
            if (val && !(0, _is.default)("Identifier", node.key)) {
              throw new TypeError(
                "Property shorthand of ObjectProperty cannot be true if key is not an Identifier"
              );
            }
          }
        ),
        default: false,
      },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
        ),
        optional: true,
      },
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: (function () {
      const pattern = (0, _utils.assertNodeType)(
        "Identifier",
        "Pattern",
        "TSAsExpression",
        "TSNonNullExpression",
        "TSTypeAssertion"
      );
      const expression = (0, _utils.assertNodeType)("Expression");
      return function (parent, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        const validator = (0, _is.default)("ObjectPattern", parent)
          ? pattern
          : expression;
        validator(node, "value", node.value);
      };
    })(),
  });
  defineType("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, patternLikeCommon(), {
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING
          ? (0, _utils.assertNodeType)("LVal")
          : (0, _utils.assertNodeType)(
              "Identifier",
              "ArrayPattern",
              "ObjectPattern",
              "MemberExpression",
              "TSAsExpression",
              "TSTypeAssertion",
              "TSNonNullExpression"
            ),
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
    }),
    validate(parent, key) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      const match = /(\w+)\[(\d+)\]/.exec(key);
      if (!match) throw new Error("Internal Babel error: malformed key.");
      const [, listKey, index] = match;
      if (parent[listKey].length > +index + 1) {
        throw new TypeError(`RestElement must be last element of ${listKey}`);
      }
    },
  });
  defineType("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true,
      },
    },
  });
  defineType("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression"))
        ),
      },
    },
    aliases: ["Expression"],
  });
  defineType("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: { validate: (0, _utils.assertNodeType)("Expression") },
    },
  });
  defineType("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true,
      },
      consequent: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement"))
        ),
      },
    },
  });
  defineType("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: { validate: (0, _utils.assertNodeType)("Expression") },
      cases: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase"))
        ),
      },
    },
  });
  defineType("ThisExpression", { aliases: ["Expression"] });
  defineType("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: { validate: (0, _utils.assertNodeType)("Expression") },
    },
  });
  defineType("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: (0, _utils.chain)(
          (0, _utils.assertNodeType)("BlockStatement"),
          Object.assign(
            function (node) {
              if (!process.env.BABEL_TYPES_8_BREAKING) return;
              if (!node.handler && !node.finalizer) {
                throw new TypeError(
                  "TryStatement expects either a handler or finalizer, or both"
                );
              }
            },
            { oneOfNodeTypes: ["BlockStatement"] }
          )
        ),
      },
      handler: {
        optional: true,
        validate: (0, _utils.assertNodeType)("CatchClause"),
      },
      finalizer: {
        optional: true,
        validate: (0, _utils.assertNodeType)("BlockStatement"),
      },
    },
  });
  defineType("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: { default: true },
      argument: { validate: (0, _utils.assertNodeType)("Expression") },
      operator: {
        validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS),
      },
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"],
  });
  defineType("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: { default: false },
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING
          ? (0, _utils.assertNodeType)("Expression")
          : (0, _utils.assertNodeType)("Identifier", "MemberExpression"),
      },
      operator: {
        validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS),
      },
    },
    visitor: ["argument"],
    aliases: ["Expression"],
  });
  defineType("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      kind: { validate: (0, _utils.assertOneOf)("var", "let", "const") },
      declarations: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)("VariableDeclarator")
          )
        ),
      },
    },
    validate(parent, key, node) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      if (!(0, _is.default)("ForXStatement", parent, { left: node })) return;
      if (node.declarations.length !== 1) {
        throw new TypeError(
          `Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`
        );
      }
    },
  });
  defineType("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: (function () {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return (0, _utils.assertNodeType)("LVal");
          }
          const normal = (0, _utils.assertNodeType)(
            "Identifier",
            "ArrayPattern",
            "ObjectPattern"
          );
          const without = (0, _utils.assertNodeType)("Identifier");
          return function (node, key, val) {
            const validator = node.init ? normal : without;
            validator(node, key, val);
          };
        })(),
      },
      definite: {
        optional: true,
        validate: (0, _utils.assertValueType)("boolean"),
      },
      init: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression"),
      },
    },
  });
  defineType("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: { validate: (0, _utils.assertNodeType)("Expression") },
      body: { validate: (0, _utils.assertNodeType)("Statement") },
    },
  });
  defineType("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: { validate: (0, _utils.assertNodeType)("Expression") },
      body: { validate: (0, _utils.assertNodeType)("Statement") },
    },
  });
  defineType("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      left: {
        validate: (0, _utils.assertNodeType)(
          "Identifier",
          "ObjectPattern",
          "ArrayPattern",
          "MemberExpression",
          "TSAsExpression",
          "TSTypeAssertion",
          "TSNonNullExpression"
        ),
      },
      right: { validate: (0, _utils.assertNodeType)("Expression") },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
        ),
        optional: true,
      },
    }),
  });
  defineType("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      elements: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")
          )
        ),
      },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
        ),
        optional: true,
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
    }),
  });
  defineType("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: [
      "Scopable",
      "Function",
      "BlockParent",
      "FunctionParent",
      "Expression",
      "Pureish",
    ],
    fields: Object.assign(
      {},
      functionCommon(),
      functionTypeAnnotationCommon(),
      {
        expression: { validate: (0, _utils.assertValueType)("boolean") },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement", "Expression"),
        },
        predicate: {
          validate: (0, _utils.assertNodeType)(
            "DeclaredPredicate",
            "InferredPredicate"
          ),
          optional: true,
        },
      }
    ),
  });
  defineType("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)(
              "ClassMethod",
              "ClassPrivateMethod",
              "ClassProperty",
              "ClassPrivateProperty",
              "ClassAccessorProperty",
              "TSDeclareMethod",
              "TSIndexSignature",
              "StaticBlock"
            )
          )
        ),
      },
    },
  });
  defineType("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: [
      "id",
      "body",
      "superClass",
      "mixins",
      "typeParameters",
      "superTypeParameters",
      "implements",
      "decorators",
    ],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true,
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)(
          "TypeParameterDeclaration",
          "TSTypeParameterDeclaration",
          "Noop"
        ),
        optional: true,
      },
      body: { validate: (0, _utils.assertNodeType)("ClassBody") },
      superClass: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression"),
      },
      superTypeParameters: {
        validate: (0, _utils.assertNodeType)(
          "TypeParameterInstantiation",
          "TSTypeParameterInstantiation"
        ),
        optional: true,
      },
      implements: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)(
              "TSExpressionWithTypeArguments",
              "ClassImplements"
            )
          )
        ),
        optional: true,
      },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
        ),
        optional: true,
      },
      mixins: {
        validate: (0, _utils.assertNodeType)("InterfaceExtends"),
        optional: true,
      },
    },
  });
  defineType("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: { validate: (0, _utils.assertNodeType)("Identifier") },
      typeParameters: {
        validate: (0, _utils.assertNodeType)(
          "TypeParameterDeclaration",
          "TSTypeParameterDeclaration",
          "Noop"
        ),
        optional: true,
      },
      body: { validate: (0, _utils.assertNodeType)("ClassBody") },
      superClass: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression"),
      },
      superTypeParameters: {
        validate: (0, _utils.assertNodeType)(
          "TypeParameterInstantiation",
          "TSTypeParameterInstantiation"
        ),
        optional: true,
      },
      implements: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)(
              "TSExpressionWithTypeArguments",
              "ClassImplements"
            )
          )
        ),
        optional: true,
      },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
        ),
        optional: true,
      },
      mixins: {
        validate: (0, _utils.assertNodeType)("InterfaceExtends"),
        optional: true,
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      abstract: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
    },
    validate: (function () {
      const identifier = (0, _utils.assertNodeType)("Identifier");
      return function (parent, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
          identifier(node, "id", node.id);
        }
      };
    })(),
  });
  defineType("ExportAllDeclaration", {
    visitor: ["source"],
    aliases: [
      "Statement",
      "Declaration",
      "ModuleDeclaration",
      "ExportDeclaration",
    ],
    fields: {
      source: { validate: (0, _utils.assertNodeType)("StringLiteral") },
      exportKind: (0, _utils.validateOptional)(
        (0, _utils.assertOneOf)("type", "value")
      ),
      assertions: {
        optional: true,
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute"))
        ),
      },
    },
  });
  defineType("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: [
      "Statement",
      "Declaration",
      "ModuleDeclaration",
      "ExportDeclaration",
    ],
    fields: {
      declaration: {
        validate: (0, _utils.assertNodeType)(
          "TSDeclareFunction",
          "FunctionDeclaration",
          "ClassDeclaration",
          "Expression"
        ),
      },
      exportKind: (0, _utils.validateOptional)(
        (0, _utils.assertOneOf)("value")
      ),
    },
  });
  defineType("ExportNamedDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: [
      "Statement",
      "Declaration",
      "ModuleDeclaration",
      "ExportDeclaration",
    ],
    fields: {
      declaration: {
        optional: true,
        validate: (0, _utils.chain)(
          (0, _utils.assertNodeType)("Declaration"),
          Object.assign(
            function (node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING) return;
              if (val && node.specifiers.length) {
                throw new TypeError(
                  "Only declaration or specifiers is allowed on ExportNamedDeclaration"
                );
              }
            },
            { oneOfNodeTypes: ["Declaration"] }
          ),
          function (node, key, val) {
            if (!process.env.BABEL_TYPES_8_BREAKING) return;
            if (val && node.source) {
              throw new TypeError("Cannot export a declaration from a source");
            }
          }
        ),
      },
      assertions: {
        optional: true,
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute"))
        ),
      },
      specifiers: {
        default: [],
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (function () {
              const sourced = (0, _utils.assertNodeType)(
                "ExportSpecifier",
                "ExportDefaultSpecifier",
                "ExportNamespaceSpecifier"
              );
              const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
              if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;
              return function (node, key, val) {
                const validator = node.source ? sourced : sourceless;
                validator(node, key, val);
              };
            })()
          )
        ),
      },
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral"),
        optional: true,
      },
      exportKind: (0, _utils.validateOptional)(
        (0, _utils.assertOneOf)("type", "value")
      ),
    },
  });
  defineType("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: { validate: (0, _utils.assertNodeType)("Identifier") },
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral"),
      },
      exportKind: {
        validate: (0, _utils.assertOneOf)("type", "value"),
        optional: true,
      },
    },
  });
  defineType("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: [
      "Scopable",
      "Statement",
      "For",
      "BlockParent",
      "Loop",
      "ForXStatement",
    ],
    fields: {
      left: {
        validate: (function () {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
          }
          const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
          const lval = (0, _utils.assertNodeType)(
            "Identifier",
            "MemberExpression",
            "ArrayPattern",
            "ObjectPattern",
            "TSAsExpression",
            "TSTypeAssertion",
            "TSNonNullExpression"
          );
          return function (node, key, val) {
            if ((0, _is.default)("VariableDeclaration", val)) {
              declaration(node, key, val);
            } else {
              lval(node, key, val);
            }
          };
        })(),
      },
      right: { validate: (0, _utils.assertNodeType)("Expression") },
      body: { validate: (0, _utils.assertNodeType)("Statement") },
      await: { default: false },
    },
  });
  defineType("ImportDeclaration", {
    visitor: ["specifiers", "source"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration"],
    fields: {
      assertions: {
        optional: true,
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute"))
        ),
      },
      specifiers: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)(
              "ImportSpecifier",
              "ImportDefaultSpecifier",
              "ImportNamespaceSpecifier"
            )
          )
        ),
      },
      source: { validate: (0, _utils.assertNodeType)("StringLiteral") },
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
        optional: true,
      },
    },
  });
  defineType("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: { local: { validate: (0, _utils.assertNodeType)("Identifier") } },
  });
  defineType("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: { local: { validate: (0, _utils.assertNodeType)("Identifier") } },
  });
  defineType("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: { validate: (0, _utils.assertNodeType)("Identifier") },
      imported: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral"),
      },
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
        optional: true,
      },
    },
  });
  defineType("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: (0, _utils.chain)(
          (0, _utils.assertNodeType)("Identifier"),
          Object.assign(
            function (node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING) return;
              let property;
              switch (val.name) {
                case "function":
                  property = "sent";
                  break;
                case "new":
                  property = "target";
                  break;
                case "import":
                  property = "meta";
                  break;
              }
              if (
                !(0, _is.default)("Identifier", node.property, {
                  name: property,
                })
              ) {
                throw new TypeError("Unrecognised MetaProperty");
              }
            },
            { oneOfNodeTypes: ["Identifier"] }
          )
        ),
      },
      property: { validate: (0, _utils.assertNodeType)("Identifier") },
    },
  });
  const classMethodOrPropertyCommon = () => ({
    abstract: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true,
    },
    accessibility: {
      validate: (0, _utils.assertOneOf)("public", "private", "protected"),
      optional: true,
    },
    static: { default: false },
    override: { default: false },
    computed: { default: false },
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true,
    },
    key: {
      validate: (0, _utils.chain)(
        (function () {
          const normal = (0, _utils.assertNodeType)(
            "Identifier",
            "StringLiteral",
            "NumericLiteral"
          );
          const computed = (0, _utils.assertNodeType)("Expression");
          return function (node, key, val) {
            const validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
        })(),
        (0, _utils.assertNodeType)(
          "Identifier",
          "StringLiteral",
          "NumericLiteral",
          "BigIntLiteral",
          "Expression"
        )
      ),
    },
  });
  core.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
  const classMethodOrDeclareMethodCommon = () =>
    Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
      params: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)(
              "Identifier",
              "Pattern",
              "RestElement",
              "TSParameterProperty"
            )
          )
        ),
      },
      kind: {
        validate: (0, _utils.assertOneOf)(
          "get",
          "set",
          "method",
          "constructor"
        ),
        default: "method",
      },
      access: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("string"),
          (0, _utils.assertOneOf)("public", "private", "protected")
        ),
        optional: true,
      },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
        ),
        optional: true,
      },
    });
  core.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
  defineType("ClassMethod", {
    aliases: [
      "Function",
      "Scopable",
      "BlockParent",
      "FunctionParent",
      "Method",
    ],
    builder: [
      "kind",
      "key",
      "params",
      "body",
      "computed",
      "static",
      "generator",
      "async",
    ],
    visitor: [
      "key",
      "params",
      "body",
      "decorators",
      "returnType",
      "typeParameters",
    ],
    fields: Object.assign(
      {},
      classMethodOrDeclareMethodCommon(),
      functionTypeAnnotationCommon(),
      { body: { validate: (0, _utils.assertNodeType)("BlockStatement") } }
    ),
  });
  defineType("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      properties: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)("RestElement", "ObjectProperty")
          )
        ),
      },
    }),
  });
  defineType("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: { validate: (0, _utils.assertNodeType)("Expression") },
    },
  });
  defineType("Super", { aliases: ["Expression"] });
  defineType("TaggedTemplateExpression", {
    visitor: ["tag", "quasi", "typeParameters"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: { validate: (0, _utils.assertNodeType)("Expression") },
      quasi: { validate: (0, _utils.assertNodeType)("TemplateLiteral") },
      typeParameters: {
        validate: (0, _utils.assertNodeType)(
          "TypeParameterInstantiation",
          "TSTypeParameterInstantiation"
        ),
        optional: true,
      },
    },
  });
  defineType("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, _utils.chain)(
          (0, _utils.assertShape)({
            raw: { validate: (0, _utils.assertValueType)("string") },
            cooked: {
              validate: (0, _utils.assertValueType)("string"),
              optional: true,
            },
          }),
          function templateElementCookedValidator(node) {
            const raw = node.value.raw;
            let str,
              containsInvalid,
              unterminatedCalled = false;
            try {
              const error = () => {
                throw new Error();
              };
              ({ str: str, containsInvalid: containsInvalid } = (0,
              _helperStringParser.readStringContents)(
                "template",
                raw,
                0,
                0,
                0,
                {
                  unterminated() {
                    unterminatedCalled = true;
                  },
                  strictNumericEscape: error,
                  invalidEscapeSequence: error,
                  numericSeparatorInEscapeSequence: error,
                  unexpectedNumericSeparator: error,
                  invalidDigit: error,
                  invalidCodePoint: error,
                }
              ));
            } catch (_unused) {
              unterminatedCalled = true;
              containsInvalid = true;
            }
            if (!unterminatedCalled) throw new Error("Invalid raw");
            node.value.cooked = containsInvalid ? null : str;
          }
        ),
      },
      tail: { default: false },
    },
  });
  defineType("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement"))
        ),
      },
      expressions: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)("Expression", "TSType")
          ),
          function (node, key, val) {
            if (node.quasis.length !== val.length + 1) {
              throw new TypeError(
                `Number of ${node.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`
              );
            }
          }
        ),
      },
    },
  });
  defineType("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("boolean"),
          Object.assign(
            function (node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING) return;
              if (val && !node.argument) {
                throw new TypeError(
                  "Property delegate of YieldExpression cannot be true if there is no argument"
                );
              }
            },
            { type: "boolean" }
          )
        ),
        default: false,
      },
      argument: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression"),
      },
    },
  });
  defineType("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: { validate: (0, _utils.assertNodeType)("Expression") },
    },
  });
  defineType("Import", { aliases: ["Expression"] });
  defineType("BigIntLiteral", {
    builder: ["value"],
    fields: { value: { validate: (0, _utils.assertValueType)("string") } },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"],
  });
  defineType("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: { validate: (0, _utils.assertNodeType)("Identifier") },
    },
  });
  defineType("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: { validate: (0, _utils.assertNodeType)("Expression") },
      property: {
        validate: (function () {
          const normal = (0, _utils.assertNodeType)("Identifier");
          const computed = (0, _utils.assertNodeType)("Expression");
          const validator = Object.assign(
            function (node, key, val) {
              const validator = node.computed ? computed : normal;
              validator(node, key, val);
            },
            { oneOfNodeTypes: ["Expression", "Identifier"] }
          );
          return validator;
        })(),
      },
      computed: { default: false },
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING
          ? (0, _utils.assertValueType)("boolean")
          : (0, _utils.chain)(
              (0, _utils.assertValueType)("boolean"),
              (0, _utils.assertOptionalChainStart)()
            ),
      },
    },
  });
  defineType("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: { validate: (0, _utils.assertNodeType)("Expression") },
      arguments: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)(
              "Expression",
              "SpreadElement",
              "JSXNamespacedName",
              "ArgumentPlaceholder"
            )
          )
        ),
      },
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING
          ? (0, _utils.assertValueType)("boolean")
          : (0, _utils.chain)(
              (0, _utils.assertValueType)("boolean"),
              (0, _utils.assertOptionalChainStart)()
            ),
      },
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
        optional: true,
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true,
      },
    },
  });
  defineType("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: [
      "key",
      "value",
      "typeAnnotation",
      "decorators",
      "computed",
      "static",
    ],
    aliases: ["Property"],
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true,
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)(
          "TypeAnnotation",
          "TSTypeAnnotation",
          "Noop"
        ),
        optional: true,
      },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
        ),
        optional: true,
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true,
      },
    }),
  });
  defineType("ClassAccessorProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: [
      "key",
      "value",
      "typeAnnotation",
      "decorators",
      "computed",
      "static",
    ],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
      key: {
        validate: (0, _utils.chain)(
          (function () {
            const normal = (0, _utils.assertNodeType)(
              "Identifier",
              "StringLiteral",
              "NumericLiteral",
              "BigIntLiteral",
              "PrivateName"
            );
            const computed = (0, _utils.assertNodeType)("Expression");
            return function (node, key, val) {
              const validator = node.computed ? computed : normal;
              validator(node, key, val);
            };
          })(),
          (0, _utils.assertNodeType)(
            "Identifier",
            "StringLiteral",
            "NumericLiteral",
            "BigIntLiteral",
            "Expression",
            "PrivateName"
          )
        ),
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true,
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)(
          "TypeAnnotation",
          "TSTypeAnnotation",
          "Noop"
        ),
        optional: true,
      },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
        ),
        optional: true,
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true,
      },
    }),
  });
  defineType("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators", "typeAnnotation"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: { validate: (0, _utils.assertNodeType)("PrivateName") },
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true,
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)(
          "TypeAnnotation",
          "TSTypeAnnotation",
          "Noop"
        ),
        optional: true,
      },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
        ),
        optional: true,
      },
      static: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false,
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true,
      },
    },
  });
  defineType("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: [
      "key",
      "params",
      "body",
      "decorators",
      "returnType",
      "typeParameters",
    ],
    aliases: [
      "Function",
      "Scopable",
      "BlockParent",
      "FunctionParent",
      "Method",
      "Private",
    ],
    fields: Object.assign(
      {},
      classMethodOrDeclareMethodCommon(),
      functionTypeAnnotationCommon(),
      {
        kind: {
          validate: (0, _utils.assertOneOf)("get", "set", "method"),
          default: "method",
        },
        key: { validate: (0, _utils.assertNodeType)("PrivateName") },
        body: { validate: (0, _utils.assertNodeType)("BlockStatement") },
      }
    ),
  });
  defineType("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: { id: { validate: (0, _utils.assertNodeType)("Identifier") } },
  });
  defineType("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement"))
        ),
      },
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"],
  });
  return core;
}
var flow$1 = {};
var hasRequiredFlow;
function requireFlow() {
  if (hasRequiredFlow) return flow$1;
  hasRequiredFlow = 1;
  var _utils = requireUtils();
  const defineType = (0, _utils.defineAliasedType)("Flow");
  const defineInterfaceishType = (name) => {
    defineType(name, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: [
        "id",
        "typeParameters",
        "extends",
        "mixins",
        "implements",
        "body",
      ],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)(
          "TypeParameterDeclaration"
        ),
        extends: (0, _utils.validateOptional)(
          (0, _utils.arrayOfType)("InterfaceExtends")
        ),
        mixins: (0, _utils.validateOptional)(
          (0, _utils.arrayOfType)("InterfaceExtends")
        ),
        implements: (0, _utils.validateOptional)(
          (0, _utils.arrayOfType)("ClassImplements")
        ),
        body: (0, _utils.validateType)("ObjectTypeAnnotation"),
      },
    });
  };
  defineType("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"],
  });
  defineType("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: { elementType: (0, _utils.validateType)("FlowType") },
  });
  defineType("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"],
  });
  defineType("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    },
  });
  defineType("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"],
  });
  defineType("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TypeParameterInstantiation"
      ),
    },
  });
  defineInterfaceishType("DeclareClass");
  defineType("DeclareFunction", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      predicate: (0, _utils.validateOptionalType)("DeclaredPredicate"),
    },
  });
  defineInterfaceishType("DeclareInterface");
  defineType("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
      body: (0, _utils.validateType)("BlockStatement"),
      kind: (0, _utils.validateOptional)(
        (0, _utils.assertOneOf)("CommonJS", "ES")
      ),
    },
  });
  defineType("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: { typeAnnotation: (0, _utils.validateType)("TypeAnnotation") },
  });
  defineType("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TypeParameterDeclaration"
      ),
      right: (0, _utils.validateType)("FlowType"),
    },
  });
  defineType("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TypeParameterDeclaration"
      ),
      supertype: (0, _utils.validateOptionalType)("FlowType"),
      impltype: (0, _utils.validateOptionalType)("FlowType"),
    },
  });
  defineType("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: { id: (0, _utils.validateType)("Identifier") },
  });
  defineType("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: (0, _utils.validateOptionalType)("Flow"),
      specifiers: (0, _utils.validateOptional)(
        (0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])
      ),
      source: (0, _utils.validateOptionalType)("StringLiteral"),
      default: (0, _utils.validateOptional)(
        (0, _utils.assertValueType)("boolean")
      ),
    },
  });
  defineType("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: (0, _utils.validateType)("StringLiteral"),
      exportKind: (0, _utils.validateOptional)(
        (0, _utils.assertOneOf)("type", "value")
      ),
    },
  });
  defineType("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: { value: (0, _utils.validateType)("Flow") },
  });
  defineType("ExistsTypeAnnotation", { aliases: ["FlowType"] });
  defineType("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, _utils.validateOptionalType)(
        "TypeParameterDeclaration"
      ),
      params: (0, _utils.validate)(
        (0, _utils.arrayOfType)("FunctionTypeParam")
      ),
      rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
      this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, _utils.validateType)("FlowType"),
    },
  });
  defineType("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, _utils.validateOptionalType)("Identifier"),
      typeAnnotation: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validateOptional)(
        (0, _utils.assertValueType)("boolean")
      ),
    },
  });
  defineType("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, _utils.validateOptionalType)(
        "TypeParameterInstantiation"
      ),
    },
  });
  defineType("InferredPredicate", { aliases: ["FlowPredicate"] });
  defineType("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, _utils.validateOptionalType)(
        "TypeParameterInstantiation"
      ),
    },
  });
  defineInterfaceishType("InterfaceDeclaration");
  defineType("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, _utils.validateOptional)(
        (0, _utils.arrayOfType)("InterfaceExtends")
      ),
      body: (0, _utils.validateType)("ObjectTypeAnnotation"),
    },
  });
  defineType("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType")),
    },
  });
  defineType("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"],
  });
  defineType("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"],
  });
  defineType("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: { typeAnnotation: (0, _utils.validateType)("FlowType") },
  });
  defineType("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("number")),
    },
  });
  defineType("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"],
  });
  defineType("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: [
      "properties",
      "indexers",
      "callProperties",
      "internalSlots",
      "exact",
    ],
    fields: {
      properties: (0, _utils.validate)(
        (0, _utils.arrayOfType)([
          "ObjectTypeProperty",
          "ObjectTypeSpreadProperty",
        ])
      ),
      indexers: {
        validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
        optional: true,
        default: [],
      },
      callProperties: {
        validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
        optional: true,
        default: [],
      },
      internalSlots: {
        validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
        optional: true,
        default: [],
      },
      exact: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false,
      },
      inexact: (0, _utils.validateOptional)(
        (0, _utils.assertValueType)("boolean")
      ),
    },
  });
  defineType("ObjectTypeInternalSlot", {
    visitor: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      value: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      method: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    },
  });
  defineType("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, _utils.validateType)("FlowType"),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    },
  });
  defineType("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, _utils.validateOptionalType)("Identifier"),
      key: (0, _utils.validateType)("FlowType"),
      value: (0, _utils.validateType)("FlowType"),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      variance: (0, _utils.validateOptionalType)("Variance"),
    },
  });
  defineType("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
      value: (0, _utils.validateType)("FlowType"),
      kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      variance: (0, _utils.validateOptionalType)("Variance"),
      method: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    },
  });
  defineType("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: { argument: (0, _utils.validateType)("FlowType") },
  });
  defineType("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TypeParameterDeclaration"
      ),
      supertype: (0, _utils.validateOptionalType)("FlowType"),
      impltype: (0, _utils.validateType)("FlowType"),
    },
  });
  defineType("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      qualification: (0, _utils.validateType)([
        "Identifier",
        "QualifiedTypeIdentifier",
      ]),
    },
  });
  defineType("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("string")),
    },
  });
  defineType("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"],
  });
  defineType("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"],
  });
  defineType("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"],
  });
  defineType("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType")),
    },
  });
  defineType("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: { argument: (0, _utils.validateType)("FlowType") },
  });
  defineType("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TypeParameterDeclaration"
      ),
      right: (0, _utils.validateType)("FlowType"),
    },
  });
  defineType("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: { typeAnnotation: (0, _utils.validateType)("FlowType") },
  });
  defineType("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeAnnotation: (0, _utils.validateType)("TypeAnnotation"),
    },
  });
  defineType("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
      bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
      default: (0, _utils.validateOptionalType)("FlowType"),
      variance: (0, _utils.validateOptionalType)("Variance"),
    },
  });
  defineType("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter")),
    },
  });
  defineType("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType")),
    },
  });
  defineType("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType")),
    },
  });
  defineType("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus")),
    },
  });
  defineType("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"],
  });
  defineType("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      body: (0, _utils.validateType)([
        "EnumBooleanBody",
        "EnumNumberBody",
        "EnumStringBody",
        "EnumSymbolBody",
      ]),
    },
  });
  defineType("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)(
        (0, _utils.assertValueType)("boolean")
      ),
      members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, _utils.validate)(
        (0, _utils.assertValueType)("boolean")
      ),
    },
  });
  defineType("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)(
        (0, _utils.assertValueType)("boolean")
      ),
      members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, _utils.validate)(
        (0, _utils.assertValueType)("boolean")
      ),
    },
  });
  defineType("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)(
        (0, _utils.assertValueType)("boolean")
      ),
      members: (0, _utils.validateArrayOfType)([
        "EnumStringMember",
        "EnumDefaultedMember",
      ]),
      hasUnknownMembers: (0, _utils.validate)(
        (0, _utils.assertValueType)("boolean")
      ),
    },
  });
  defineType("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, _utils.validate)(
        (0, _utils.assertValueType)("boolean")
      ),
    },
  });
  defineType("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("BooleanLiteral"),
    },
  });
  defineType("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("NumericLiteral"),
    },
  });
  defineType("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("StringLiteral"),
    },
  });
  defineType("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: { id: (0, _utils.validateType)("Identifier") },
  });
  defineType("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, _utils.validateType)("FlowType"),
      indexType: (0, _utils.validateType)("FlowType"),
    },
  });
  defineType("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, _utils.validateType)("FlowType"),
      indexType: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    },
  });
  return flow$1;
}
var jsx$1 = {};
var hasRequiredJsx;
function requireJsx() {
  if (hasRequiredJsx) return jsx$1;
  hasRequiredJsx = 1;
  var _utils = requireUtils();
  const defineType = (0, _utils.defineAliasedType)("JSX");
  defineType("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)(
          "JSXIdentifier",
          "JSXNamespacedName"
        ),
      },
      value: {
        optional: true,
        validate: (0, _utils.assertNodeType)(
          "JSXElement",
          "JSXFragment",
          "StringLiteral",
          "JSXExpressionContainer"
        ),
      },
    },
  });
  defineType("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)(
          "JSXIdentifier",
          "JSXMemberExpression",
          "JSXNamespacedName"
        ),
      },
    },
  });
  defineType("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign(
      {
        openingElement: {
          validate: (0, _utils.assertNodeType)("JSXOpeningElement"),
        },
        closingElement: {
          optional: true,
          validate: (0, _utils.assertNodeType)("JSXClosingElement"),
        },
        children: {
          validate: (0, _utils.chain)(
            (0, _utils.assertValueType)("array"),
            (0, _utils.assertEach)(
              (0, _utils.assertNodeType)(
                "JSXText",
                "JSXExpressionContainer",
                "JSXSpreadChild",
                "JSXElement",
                "JSXFragment"
              )
            )
          ),
        },
      },
      {
        selfClosing: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true,
        },
      }
    ),
  });
  defineType("JSXEmptyExpression", {});
  defineType("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)(
          "Expression",
          "JSXEmptyExpression"
        ),
      },
    },
  });
  defineType("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: { validate: (0, _utils.assertNodeType)("Expression") },
    },
  });
  defineType("JSXIdentifier", {
    builder: ["name"],
    fields: { name: { validate: (0, _utils.assertValueType)("string") } },
  });
  defineType("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)(
          "JSXMemberExpression",
          "JSXIdentifier"
        ),
      },
      property: { validate: (0, _utils.assertNodeType)("JSXIdentifier") },
    },
  });
  defineType("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: { validate: (0, _utils.assertNodeType)("JSXIdentifier") },
      name: { validate: (0, _utils.assertNodeType)("JSXIdentifier") },
    },
  });
  defineType("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)(
          "JSXIdentifier",
          "JSXMemberExpression",
          "JSXNamespacedName"
        ),
      },
      selfClosing: { default: false },
      attributes: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")
          )
        ),
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)(
          "TypeParameterInstantiation",
          "TSTypeParameterInstantiation"
        ),
        optional: true,
      },
    },
  });
  defineType("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: { validate: (0, _utils.assertNodeType)("Expression") },
    },
  });
  defineType("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: { value: { validate: (0, _utils.assertValueType)("string") } },
  });
  defineType("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, _utils.assertNodeType)("JSXOpeningFragment"),
      },
      closingFragment: {
        validate: (0, _utils.assertNodeType)("JSXClosingFragment"),
      },
      children: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)(
              "JSXText",
              "JSXExpressionContainer",
              "JSXSpreadChild",
              "JSXElement",
              "JSXFragment"
            )
          )
        ),
      },
    },
  });
  defineType("JSXOpeningFragment", { aliases: ["Immutable"] });
  defineType("JSXClosingFragment", { aliases: ["Immutable"] });
  return jsx$1;
}
var misc = {};
var placeholders = {};
var hasRequiredPlaceholders;
function requirePlaceholders() {
  if (hasRequiredPlaceholders) return placeholders;
  hasRequiredPlaceholders = 1;
  Object.defineProperty(placeholders, "__esModule", { value: true });
  placeholders.PLACEHOLDERS_FLIPPED_ALIAS =
    placeholders.PLACEHOLDERS_ALIAS =
    placeholders.PLACEHOLDERS =
      void 0;
  var _utils = requireUtils();
  const PLACEHOLDERS = [
    "Identifier",
    "StringLiteral",
    "Expression",
    "Statement",
    "Declaration",
    "BlockStatement",
    "ClassBody",
    "Pattern",
  ];
  placeholders.PLACEHOLDERS = PLACEHOLDERS;
  const PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"],
  };
  placeholders.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;
  for (const type of PLACEHOLDERS) {
    const alias = _utils.ALIAS_KEYS[type];
    if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;
  }
  const PLACEHOLDERS_FLIPPED_ALIAS = {};
  placeholders.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;
  Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
    PLACEHOLDERS_ALIAS[type].forEach((alias) => {
      if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
        PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
      }
      PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
    });
  });
  return placeholders;
}
var hasRequiredMisc;
function requireMisc() {
  if (hasRequiredMisc) return misc;
  hasRequiredMisc = 1;
  var _utils = requireUtils();
  var _placeholders = requirePlaceholders();
  const defineType = (0, _utils.defineAliasedType)("Miscellaneous");
  {
    defineType("Noop", { visitor: [] });
  }
  defineType("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: { validate: (0, _utils.assertNodeType)("Identifier") },
      expectedNode: {
        validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS),
      },
    },
  });
  defineType("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: { name: { validate: (0, _utils.assertValueType)("string") } },
  });
  return misc;
}
var experimental = {};
var hasRequiredExperimental;
function requireExperimental() {
  if (hasRequiredExperimental) return experimental;
  hasRequiredExperimental = 1;
  var _utils = requireUtils();
  (0, _utils.default)("ArgumentPlaceholder", {});
  (0, _utils.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: !process.env.BABEL_TYPES_8_BREAKING
      ? {
          object: {
            validate: Object.assign(() => {}, {
              oneOfNodeTypes: ["Expression"],
            }),
          },
          callee: {
            validate: Object.assign(() => {}, {
              oneOfNodeTypes: ["Expression"],
            }),
          },
        }
      : {
          object: { validate: (0, _utils.assertNodeType)("Expression") },
          callee: { validate: (0, _utils.assertNodeType)("Expression") },
        },
  });
  (0, _utils.default)("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral"),
      },
      value: { validate: (0, _utils.assertNodeType)("StringLiteral") },
    },
  });
  (0, _utils.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: { validate: (0, _utils.assertNodeType)("Expression") },
    },
  });
  (0, _utils.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: { validate: (0, _utils.assertNodeType)("BlockStatement") },
      async: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: false,
      },
    },
  });
  (0, _utils.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: { validate: (0, _utils.assertNodeType)("Identifier") },
    },
  });
  (0, _utils.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)("ObjectProperty", "SpreadElement")
          )
        ),
      },
    },
  });
  (0, _utils.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)(
            (0, _utils.assertNodeType)("Expression", "SpreadElement")
          )
        ),
        default: [],
      },
    },
    visitor: ["elements"],
    aliases: ["Expression"],
  });
  (0, _utils.default)("DecimalLiteral", {
    builder: ["value"],
    fields: { value: { validate: (0, _utils.assertValueType)("string") } },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"],
  });
  (0, _utils.default)("ModuleExpression", {
    visitor: ["body"],
    fields: { body: { validate: (0, _utils.assertNodeType)("Program") } },
    aliases: ["Expression"],
  });
  (0, _utils.default)("TopicReference", { aliases: ["Expression"] });
  (0, _utils.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: { validate: (0, _utils.assertNodeType)("Expression") },
    },
    aliases: ["Expression"],
  });
  (0, _utils.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: { callee: { validate: (0, _utils.assertNodeType)("Expression") } },
    aliases: ["Expression"],
  });
  (0, _utils.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"],
  });
  return experimental;
}
var typescript$1 = {};
var hasRequiredTypescript;
function requireTypescript() {
  if (hasRequiredTypescript) return typescript$1;
  hasRequiredTypescript = 1;
  var _utils = requireUtils();
  var _core = requireCore();
  var _is = requireIs();
  const defineType = (0, _utils.defineAliasedType)("TypeScript");
  const bool = (0, _utils.assertValueType)("boolean");
  const tSFunctionTypeAnnotationCommon = () => ({
    returnType: {
      validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: true,
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)(
        "TSTypeParameterDeclaration",
        "Noop"
      ),
      optional: true,
    },
  });
  defineType("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true,
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      parameter: {
        validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern"),
      },
      override: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true,
      },
      decorators: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))
        ),
        optional: true,
      },
    },
  });
  defineType("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign(
      {},
      (0, _core.functionDeclarationCommon)(),
      tSFunctionTypeAnnotationCommon()
    ),
  });
  defineType("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign(
      {},
      (0, _core.classMethodOrDeclareMethodCommon)(),
      tSFunctionTypeAnnotationCommon()
    ),
  });
  defineType("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, _utils.validateType)("TSEntityName"),
      right: (0, _utils.validateType)("Identifier"),
    },
  });
  const signatureDeclarationCommon = () => ({
    typeParameters: (0, _utils.validateOptionalType)(
      "TSTypeParameterDeclaration"
    ),
    ["parameters"]: (0, _utils.validateArrayOfType)([
      "Identifier",
      "RestElement",
    ]),
    ["typeAnnotation"]: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
  });
  const callConstructSignatureDeclaration = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: signatureDeclarationCommon(),
  };
  defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
  defineType(
    "TSConstructSignatureDeclaration",
    callConstructSignatureDeclaration
  );
  const namedTypeElementCommon = () => ({
    key: (0, _utils.validateType)("Expression"),
    computed: { default: false },
    optional: (0, _utils.validateOptional)(bool),
  });
  defineType("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation", "initializer"],
    fields: Object.assign({}, namedTypeElementCommon(), {
      readonly: (0, _utils.validateOptional)(bool),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
      initializer: (0, _utils.validateOptionalType)("Expression"),
      kind: { validate: (0, _utils.assertOneOf)("get", "set") },
    }),
  });
  defineType("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign(
      {},
      signatureDeclarationCommon(),
      namedTypeElementCommon(),
      { kind: { validate: (0, _utils.assertOneOf)("method", "get", "set") } }
    ),
  });
  defineType("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, _utils.validateOptional)(bool),
      static: (0, _utils.validateOptional)(bool),
      parameters: (0, _utils.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
    },
  });
  const tsKeywordTypes = [
    "TSAnyKeyword",
    "TSBooleanKeyword",
    "TSBigIntKeyword",
    "TSIntrinsicKeyword",
    "TSNeverKeyword",
    "TSNullKeyword",
    "TSNumberKeyword",
    "TSObjectKeyword",
    "TSStringKeyword",
    "TSSymbolKeyword",
    "TSUndefinedKeyword",
    "TSUnknownKeyword",
    "TSVoidKeyword",
  ];
  for (const type of tsKeywordTypes) {
    defineType(type, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {},
    });
  }
  defineType("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {},
  });
  const fnOrCtrBase = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
  };
  defineType(
    "TSFunctionType",
    Object.assign({}, fnOrCtrBase, { fields: signatureDeclarationCommon() })
  );
  defineType(
    "TSConstructorType",
    Object.assign({}, fnOrCtrBase, {
      fields: Object.assign({}, signatureDeclarationCommon(), {
        abstract: (0, _utils.validateOptional)(bool),
      }),
    })
  );
  defineType("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, _utils.validateType)("TSEntityName"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TSTypeParameterInstantiation"
      ),
    },
  });
  defineType("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, _utils.validateOptional)(bool),
    },
  });
  defineType("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"]),
      typeParameters: (0, _utils.validateOptionalType)(
        "TSTypeParameterInstantiation"
      ),
    },
  });
  defineType("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: { members: (0, _utils.validateArrayOfType)("TSTypeElement") },
  });
  defineType("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: { elementType: (0, _utils.validateType)("TSType") },
  });
  defineType("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, _utils.validateArrayOfType)([
        "TSType",
        "TSNamedTupleMember",
      ]),
    },
  });
  defineType("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: { typeAnnotation: (0, _utils.validateType)("TSType") },
  });
  defineType("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: { typeAnnotation: (0, _utils.validateType)("TSType") },
  });
  defineType("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, _utils.validateType)("Identifier"),
      optional: { validate: bool, default: false },
      elementType: (0, _utils.validateType)("TSType"),
    },
  });
  const unionOrIntersection = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: { types: (0, _utils.validateArrayOfType)("TSType") },
  };
  defineType("TSUnionType", unionOrIntersection);
  defineType("TSIntersectionType", unionOrIntersection);
  defineType("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, _utils.validateType)("TSType"),
      extendsType: (0, _utils.validateType)("TSType"),
      trueType: (0, _utils.validateType)("TSType"),
      falseType: (0, _utils.validateType)("TSType"),
    },
  });
  defineType("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: { typeParameter: (0, _utils.validateType)("TSTypeParameter") },
  });
  defineType("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: { typeAnnotation: (0, _utils.validateType)("TSType") },
  });
  defineType("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
      typeAnnotation: (0, _utils.validateType)("TSType"),
    },
  });
  defineType("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, _utils.validateType)("TSType"),
      indexType: (0, _utils.validateType)("TSType"),
    },
  });
  defineType("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation", "nameType"],
    fields: {
      readonly: (0, _utils.validateOptional)(
        (0, _utils.assertOneOf)(true, false, "+", "-")
      ),
      typeParameter: (0, _utils.validateType)("TSTypeParameter"),
      optional: (0, _utils.validateOptional)(
        (0, _utils.assertOneOf)(true, false, "+", "-")
      ),
      typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
      nameType: (0, _utils.validateOptionalType)("TSType"),
    },
  });
  defineType("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: (function () {
          const unaryExpression = (0, _utils.assertNodeType)(
            "NumericLiteral",
            "BigIntLiteral"
          );
          const unaryOperator = (0, _utils.assertOneOf)("-");
          const literal = (0, _utils.assertNodeType)(
            "NumericLiteral",
            "StringLiteral",
            "BooleanLiteral",
            "BigIntLiteral",
            "TemplateLiteral"
          );
          function validator(parent, key, node) {
            if ((0, _is.default)("UnaryExpression", node)) {
              unaryOperator(node, "operator", node.operator);
              unaryExpression(node, "argument", node.argument);
            } else {
              literal(parent, key, node);
            }
          }
          validator.oneOfNodeTypes = [
            "NumericLiteral",
            "StringLiteral",
            "BooleanLiteral",
            "BigIntLiteral",
            "TemplateLiteral",
            "UnaryExpression",
          ];
          return validator;
        })(),
      },
    },
  });
  defineType("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, _utils.validateType)("TSEntityName"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TSTypeParameterInstantiation"
      ),
    },
  });
  defineType("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TSTypeParameterDeclaration"
      ),
      extends: (0, _utils.validateOptional)(
        (0, _utils.arrayOfType)("TSExpressionWithTypeArguments")
      ),
      body: (0, _utils.validateType)("TSInterfaceBody"),
    },
  });
  defineType("TSInterfaceBody", {
    visitor: ["body"],
    fields: { body: (0, _utils.validateArrayOfType)("TSTypeElement") },
  });
  defineType("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TSTypeParameterDeclaration"
      ),
      typeAnnotation: (0, _utils.validateType)("TSType"),
    },
  });
  defineType("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TSTypeParameterInstantiation"
      ),
    },
  });
  defineType("TSAsExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeAnnotation: (0, _utils.validateType)("TSType"),
    },
  });
  defineType("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType"),
      expression: (0, _utils.validateType)("Expression"),
    },
  });
  defineType("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      const: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      members: (0, _utils.validateArrayOfType)("TSEnumMember"),
      initializer: (0, _utils.validateOptionalType)("Expression"),
    },
  });
  defineType("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
      initializer: (0, _utils.validateOptionalType)("Expression"),
    },
  });
  defineType("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      global: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
      body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"]),
    },
  });
  defineType("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent"],
    visitor: ["body"],
    fields: { body: (0, _utils.validateArrayOfType)("Statement") },
  });
  defineType("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: (0, _utils.validateType)("StringLiteral"),
      qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
      typeParameters: (0, _utils.validateOptionalType)(
        "TSTypeParameterInstantiation"
      ),
    },
  });
  defineType("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: (0, _utils.validate)(bool),
      id: (0, _utils.validateType)("Identifier"),
      moduleReference: (0, _utils.validateType)([
        "TSEntityName",
        "TSExternalModuleReference",
      ]),
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "value"),
        optional: true,
      },
    },
  });
  defineType("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: { expression: (0, _utils.validateType)("StringLiteral") },
  });
  defineType("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: { expression: (0, _utils.validateType)("Expression") },
  });
  defineType("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: { expression: (0, _utils.validateType)("Expression") },
  });
  defineType("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: { id: (0, _utils.validateType)("Identifier") },
  });
  defineType("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: { validate: (0, _utils.assertNodeType)("TSType") },
    },
  });
  defineType("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType"))
        ),
      },
    },
  });
  defineType("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, _utils.chain)(
          (0, _utils.assertValueType)("array"),
          (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter"))
        ),
      },
    },
  });
  defineType("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: { validate: (0, _utils.assertValueType)("string") },
      in: { validate: (0, _utils.assertValueType)("boolean"), optional: true },
      out: { validate: (0, _utils.assertValueType)("boolean"), optional: true },
      constraint: {
        validate: (0, _utils.assertNodeType)("TSType"),
        optional: true,
      },
      default: {
        validate: (0, _utils.assertNodeType)("TSType"),
        optional: true,
      },
    },
  });
  return typescript$1;
}
var hasRequiredDefinitions;
function requireDefinitions() {
  if (hasRequiredDefinitions) return definitions;
  hasRequiredDefinitions = 1;
  (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "ALIAS_KEYS", {
      enumerable: true,
      get: function () {
        return _utils.ALIAS_KEYS;
      },
    });
    Object.defineProperty(exports, "BUILDER_KEYS", {
      enumerable: true,
      get: function () {
        return _utils.BUILDER_KEYS;
      },
    });
    Object.defineProperty(exports, "DEPRECATED_KEYS", {
      enumerable: true,
      get: function () {
        return _utils.DEPRECATED_KEYS;
      },
    });
    Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
      enumerable: true,
      get: function () {
        return _utils.FLIPPED_ALIAS_KEYS;
      },
    });
    Object.defineProperty(exports, "NODE_FIELDS", {
      enumerable: true,
      get: function () {
        return _utils.NODE_FIELDS;
      },
    });
    Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
      enumerable: true,
      get: function () {
        return _utils.NODE_PARENT_VALIDATIONS;
      },
    });
    Object.defineProperty(exports, "PLACEHOLDERS", {
      enumerable: true,
      get: function () {
        return _placeholders.PLACEHOLDERS;
      },
    });
    Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
      enumerable: true,
      get: function () {
        return _placeholders.PLACEHOLDERS_ALIAS;
      },
    });
    Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
      enumerable: true,
      get: function () {
        return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
      },
    });
    exports.TYPES = void 0;
    Object.defineProperty(exports, "VISITOR_KEYS", {
      enumerable: true,
      get: function () {
        return _utils.VISITOR_KEYS;
      },
    });
    var _toFastProperties = toFastProperties;
    requireCore();
    requireFlow();
    requireJsx();
    requireMisc();
    requireExperimental();
    requireTypescript();
    var _utils = requireUtils();
    var _placeholders = requirePlaceholders();
    _toFastProperties(_utils.VISITOR_KEYS);
    _toFastProperties(_utils.ALIAS_KEYS);
    _toFastProperties(_utils.FLIPPED_ALIAS_KEYS);
    _toFastProperties(_utils.NODE_FIELDS);
    _toFastProperties(_utils.BUILDER_KEYS);
    _toFastProperties(_utils.DEPRECATED_KEYS);
    _toFastProperties(_placeholders.PLACEHOLDERS_ALIAS);
    _toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
    const TYPES = [].concat(
      Object.keys(_utils.VISITOR_KEYS),
      Object.keys(_utils.FLIPPED_ALIAS_KEYS),
      Object.keys(_utils.DEPRECATED_KEYS)
    );
    exports.TYPES = TYPES;
  })(definitions);
  return definitions;
}
var hasRequiredValidate;
function requireValidate() {
  if (hasRequiredValidate) return validate$1;
  hasRequiredValidate = 1;
  Object.defineProperty(validate$1, "__esModule", { value: true });
  validate$1.default = validate;
  validate$1.validateChild = validateChild;
  validate$1.validateField = validateField;
  var _definitions = requireDefinitions();
  function validate(node, key, val) {
    if (!node) return;
    const fields = _definitions.NODE_FIELDS[node.type];
    if (!fields) return;
    const field = fields[key];
    validateField(node, key, val, field);
    validateChild(node, key, val);
  }
  function validateField(node, key, val, field) {
    if (!(field != null && field.validate)) return;
    if (field.optional && val == null) return;
    field.validate(node, key, val);
  }
  function validateChild(node, key, val) {
    if (val == null) return;
    const validate = _definitions.NODE_PARENT_VALIDATIONS[val.type];
    if (!validate) return;
    validate(node, key, val);
  }
  return validate$1;
}
var hasRequiredValidateNode;
function requireValidateNode() {
  if (hasRequiredValidateNode) return validateNode;
  hasRequiredValidateNode = 1;
  Object.defineProperty(validateNode, "__esModule", { value: true });
  validateNode.default = validateNode$1;
  var _validate = requireValidate();
  var _ = requireLib();
  function validateNode$1(node) {
    const keys = _.BUILDER_KEYS[node.type];
    for (const key of keys) {
      (0, _validate.default)(node, key, node[key]);
    }
    return node;
  }
  return validateNode;
}
var hasRequiredGenerated$3;
function requireGenerated$3() {
  if (hasRequiredGenerated$3) return generated$3;
  hasRequiredGenerated$3 = 1;
  Object.defineProperty(generated$3, "__esModule", { value: true });
  generated$3.anyTypeAnnotation = anyTypeAnnotation;
  generated$3.argumentPlaceholder = argumentPlaceholder;
  generated$3.arrayExpression = arrayExpression;
  generated$3.arrayPattern = arrayPattern;
  generated$3.arrayTypeAnnotation = arrayTypeAnnotation;
  generated$3.arrowFunctionExpression = arrowFunctionExpression;
  generated$3.assignmentExpression = assignmentExpression;
  generated$3.assignmentPattern = assignmentPattern;
  generated$3.awaitExpression = awaitExpression;
  generated$3.bigIntLiteral = bigIntLiteral;
  generated$3.binaryExpression = binaryExpression;
  generated$3.bindExpression = bindExpression;
  generated$3.blockStatement = blockStatement;
  generated$3.booleanLiteral = booleanLiteral;
  generated$3.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
  generated$3.booleanTypeAnnotation = booleanTypeAnnotation;
  generated$3.breakStatement = breakStatement;
  generated$3.callExpression = callExpression;
  generated$3.catchClause = catchClause;
  generated$3.classAccessorProperty = classAccessorProperty;
  generated$3.classBody = classBody;
  generated$3.classDeclaration = classDeclaration;
  generated$3.classExpression = classExpression;
  generated$3.classImplements = classImplements;
  generated$3.classMethod = classMethod;
  generated$3.classPrivateMethod = classPrivateMethod;
  generated$3.classPrivateProperty = classPrivateProperty;
  generated$3.classProperty = classProperty;
  generated$3.conditionalExpression = conditionalExpression;
  generated$3.continueStatement = continueStatement;
  generated$3.debuggerStatement = debuggerStatement;
  generated$3.decimalLiteral = decimalLiteral;
  generated$3.declareClass = declareClass;
  generated$3.declareExportAllDeclaration = declareExportAllDeclaration;
  generated$3.declareExportDeclaration = declareExportDeclaration;
  generated$3.declareFunction = declareFunction;
  generated$3.declareInterface = declareInterface;
  generated$3.declareModule = declareModule;
  generated$3.declareModuleExports = declareModuleExports;
  generated$3.declareOpaqueType = declareOpaqueType;
  generated$3.declareTypeAlias = declareTypeAlias;
  generated$3.declareVariable = declareVariable;
  generated$3.declaredPredicate = declaredPredicate;
  generated$3.decorator = decorator;
  generated$3.directive = directive;
  generated$3.directiveLiteral = directiveLiteral;
  generated$3.doExpression = doExpression;
  generated$3.doWhileStatement = doWhileStatement;
  generated$3.emptyStatement = emptyStatement;
  generated$3.emptyTypeAnnotation = emptyTypeAnnotation;
  generated$3.enumBooleanBody = enumBooleanBody;
  generated$3.enumBooleanMember = enumBooleanMember;
  generated$3.enumDeclaration = enumDeclaration;
  generated$3.enumDefaultedMember = enumDefaultedMember;
  generated$3.enumNumberBody = enumNumberBody;
  generated$3.enumNumberMember = enumNumberMember;
  generated$3.enumStringBody = enumStringBody;
  generated$3.enumStringMember = enumStringMember;
  generated$3.enumSymbolBody = enumSymbolBody;
  generated$3.existsTypeAnnotation = existsTypeAnnotation;
  generated$3.exportAllDeclaration = exportAllDeclaration;
  generated$3.exportDefaultDeclaration = exportDefaultDeclaration;
  generated$3.exportDefaultSpecifier = exportDefaultSpecifier;
  generated$3.exportNamedDeclaration = exportNamedDeclaration;
  generated$3.exportNamespaceSpecifier = exportNamespaceSpecifier;
  generated$3.exportSpecifier = exportSpecifier;
  generated$3.expressionStatement = expressionStatement;
  generated$3.file = file;
  generated$3.forInStatement = forInStatement;
  generated$3.forOfStatement = forOfStatement;
  generated$3.forStatement = forStatement;
  generated$3.functionDeclaration = functionDeclaration;
  generated$3.functionExpression = functionExpression;
  generated$3.functionTypeAnnotation = functionTypeAnnotation;
  generated$3.functionTypeParam = functionTypeParam;
  generated$3.genericTypeAnnotation = genericTypeAnnotation;
  generated$3.identifier = identifier;
  generated$3.ifStatement = ifStatement;
  generated$3.import = _import;
  generated$3.importAttribute = importAttribute;
  generated$3.importDeclaration = importDeclaration;
  generated$3.importDefaultSpecifier = importDefaultSpecifier;
  generated$3.importNamespaceSpecifier = importNamespaceSpecifier;
  generated$3.importSpecifier = importSpecifier;
  generated$3.indexedAccessType = indexedAccessType;
  generated$3.inferredPredicate = inferredPredicate;
  generated$3.interfaceDeclaration = interfaceDeclaration;
  generated$3.interfaceExtends = interfaceExtends;
  generated$3.interfaceTypeAnnotation = interfaceTypeAnnotation;
  generated$3.interpreterDirective = interpreterDirective;
  generated$3.intersectionTypeAnnotation = intersectionTypeAnnotation;
  generated$3.jSXAttribute = generated$3.jsxAttribute = jsxAttribute;
  generated$3.jSXClosingElement = generated$3.jsxClosingElement =
    jsxClosingElement;
  generated$3.jSXClosingFragment = generated$3.jsxClosingFragment =
    jsxClosingFragment;
  generated$3.jSXElement = generated$3.jsxElement = jsxElement;
  generated$3.jSXEmptyExpression = generated$3.jsxEmptyExpression =
    jsxEmptyExpression;
  generated$3.jSXExpressionContainer = generated$3.jsxExpressionContainer =
    jsxExpressionContainer;
  generated$3.jSXFragment = generated$3.jsxFragment = jsxFragment;
  generated$3.jSXIdentifier = generated$3.jsxIdentifier = jsxIdentifier;
  generated$3.jSXMemberExpression = generated$3.jsxMemberExpression =
    jsxMemberExpression;
  generated$3.jSXNamespacedName = generated$3.jsxNamespacedName =
    jsxNamespacedName;
  generated$3.jSXOpeningElement = generated$3.jsxOpeningElement =
    jsxOpeningElement;
  generated$3.jSXOpeningFragment = generated$3.jsxOpeningFragment =
    jsxOpeningFragment;
  generated$3.jSXSpreadAttribute = generated$3.jsxSpreadAttribute =
    jsxSpreadAttribute;
  generated$3.jSXSpreadChild = generated$3.jsxSpreadChild = jsxSpreadChild;
  generated$3.jSXText = generated$3.jsxText = jsxText;
  generated$3.labeledStatement = labeledStatement;
  generated$3.logicalExpression = logicalExpression;
  generated$3.memberExpression = memberExpression;
  generated$3.metaProperty = metaProperty;
  generated$3.mixedTypeAnnotation = mixedTypeAnnotation;
  generated$3.moduleExpression = moduleExpression;
  generated$3.newExpression = newExpression;
  generated$3.noop = noop;
  generated$3.nullLiteral = nullLiteral;
  generated$3.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
  generated$3.nullableTypeAnnotation = nullableTypeAnnotation;
  generated$3.numberLiteral = NumberLiteral;
  generated$3.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
  generated$3.numberTypeAnnotation = numberTypeAnnotation;
  generated$3.numericLiteral = numericLiteral;
  generated$3.objectExpression = objectExpression;
  generated$3.objectMethod = objectMethod;
  generated$3.objectPattern = objectPattern;
  generated$3.objectProperty = objectProperty;
  generated$3.objectTypeAnnotation = objectTypeAnnotation;
  generated$3.objectTypeCallProperty = objectTypeCallProperty;
  generated$3.objectTypeIndexer = objectTypeIndexer;
  generated$3.objectTypeInternalSlot = objectTypeInternalSlot;
  generated$3.objectTypeProperty = objectTypeProperty;
  generated$3.objectTypeSpreadProperty = objectTypeSpreadProperty;
  generated$3.opaqueType = opaqueType;
  generated$3.optionalCallExpression = optionalCallExpression;
  generated$3.optionalIndexedAccessType = optionalIndexedAccessType;
  generated$3.optionalMemberExpression = optionalMemberExpression;
  generated$3.parenthesizedExpression = parenthesizedExpression;
  generated$3.pipelineBareFunction = pipelineBareFunction;
  generated$3.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
  generated$3.pipelineTopicExpression = pipelineTopicExpression;
  generated$3.placeholder = placeholder;
  generated$3.privateName = privateName;
  generated$3.program = program;
  generated$3.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
  generated$3.recordExpression = recordExpression;
  generated$3.regExpLiteral = regExpLiteral;
  generated$3.regexLiteral = RegexLiteral;
  generated$3.restElement = restElement;
  generated$3.restProperty = RestProperty;
  generated$3.returnStatement = returnStatement;
  generated$3.sequenceExpression = sequenceExpression;
  generated$3.spreadElement = spreadElement;
  generated$3.spreadProperty = SpreadProperty;
  generated$3.staticBlock = staticBlock;
  generated$3.stringLiteral = stringLiteral;
  generated$3.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
  generated$3.stringTypeAnnotation = stringTypeAnnotation;
  generated$3.super = _super;
  generated$3.switchCase = switchCase;
  generated$3.switchStatement = switchStatement;
  generated$3.symbolTypeAnnotation = symbolTypeAnnotation;
  generated$3.taggedTemplateExpression = taggedTemplateExpression;
  generated$3.templateElement = templateElement;
  generated$3.templateLiteral = templateLiteral;
  generated$3.thisExpression = thisExpression;
  generated$3.thisTypeAnnotation = thisTypeAnnotation;
  generated$3.throwStatement = throwStatement;
  generated$3.topicReference = topicReference;
  generated$3.tryStatement = tryStatement;
  generated$3.tSAnyKeyword = generated$3.tsAnyKeyword = tsAnyKeyword;
  generated$3.tSArrayType = generated$3.tsArrayType = tsArrayType;
  generated$3.tSAsExpression = generated$3.tsAsExpression = tsAsExpression;
  generated$3.tSBigIntKeyword = generated$3.tsBigIntKeyword = tsBigIntKeyword;
  generated$3.tSBooleanKeyword = generated$3.tsBooleanKeyword =
    tsBooleanKeyword;
  generated$3.tSCallSignatureDeclaration =
    generated$3.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
  generated$3.tSConditionalType = generated$3.tsConditionalType =
    tsConditionalType;
  generated$3.tSConstructSignatureDeclaration =
    generated$3.tsConstructSignatureDeclaration =
      tsConstructSignatureDeclaration;
  generated$3.tSConstructorType = generated$3.tsConstructorType =
    tsConstructorType;
  generated$3.tSDeclareFunction = generated$3.tsDeclareFunction =
    tsDeclareFunction;
  generated$3.tSDeclareMethod = generated$3.tsDeclareMethod = tsDeclareMethod;
  generated$3.tSEnumDeclaration = generated$3.tsEnumDeclaration =
    tsEnumDeclaration;
  generated$3.tSEnumMember = generated$3.tsEnumMember = tsEnumMember;
  generated$3.tSExportAssignment = generated$3.tsExportAssignment =
    tsExportAssignment;
  generated$3.tSExpressionWithTypeArguments =
    generated$3.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
  generated$3.tSExternalModuleReference =
    generated$3.tsExternalModuleReference = tsExternalModuleReference;
  generated$3.tSFunctionType = generated$3.tsFunctionType = tsFunctionType;
  generated$3.tSImportEqualsDeclaration =
    generated$3.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
  generated$3.tSImportType = generated$3.tsImportType = tsImportType;
  generated$3.tSIndexSignature = generated$3.tsIndexSignature =
    tsIndexSignature;
  generated$3.tSIndexedAccessType = generated$3.tsIndexedAccessType =
    tsIndexedAccessType;
  generated$3.tSInferType = generated$3.tsInferType = tsInferType;
  generated$3.tSInstantiationExpression =
    generated$3.tsInstantiationExpression = tsInstantiationExpression;
  generated$3.tSInterfaceBody = generated$3.tsInterfaceBody = tsInterfaceBody;
  generated$3.tSInterfaceDeclaration = generated$3.tsInterfaceDeclaration =
    tsInterfaceDeclaration;
  generated$3.tSIntersectionType = generated$3.tsIntersectionType =
    tsIntersectionType;
  generated$3.tSIntrinsicKeyword = generated$3.tsIntrinsicKeyword =
    tsIntrinsicKeyword;
  generated$3.tSLiteralType = generated$3.tsLiteralType = tsLiteralType;
  generated$3.tSMappedType = generated$3.tsMappedType = tsMappedType;
  generated$3.tSMethodSignature = generated$3.tsMethodSignature =
    tsMethodSignature;
  generated$3.tSModuleBlock = generated$3.tsModuleBlock = tsModuleBlock;
  generated$3.tSModuleDeclaration = generated$3.tsModuleDeclaration =
    tsModuleDeclaration;
  generated$3.tSNamedTupleMember = generated$3.tsNamedTupleMember =
    tsNamedTupleMember;
  generated$3.tSNamespaceExportDeclaration =
    generated$3.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
  generated$3.tSNeverKeyword = generated$3.tsNeverKeyword = tsNeverKeyword;
  generated$3.tSNonNullExpression = generated$3.tsNonNullExpression =
    tsNonNullExpression;
  generated$3.tSNullKeyword = generated$3.tsNullKeyword = tsNullKeyword;
  generated$3.tSNumberKeyword = generated$3.tsNumberKeyword = tsNumberKeyword;
  generated$3.tSObjectKeyword = generated$3.tsObjectKeyword = tsObjectKeyword;
  generated$3.tSOptionalType = generated$3.tsOptionalType = tsOptionalType;
  generated$3.tSParameterProperty = generated$3.tsParameterProperty =
    tsParameterProperty;
  generated$3.tSParenthesizedType = generated$3.tsParenthesizedType =
    tsParenthesizedType;
  generated$3.tSPropertySignature = generated$3.tsPropertySignature =
    tsPropertySignature;
  generated$3.tSQualifiedName = generated$3.tsQualifiedName = tsQualifiedName;
  generated$3.tSRestType = generated$3.tsRestType = tsRestType;
  generated$3.tSStringKeyword = generated$3.tsStringKeyword = tsStringKeyword;
  generated$3.tSSymbolKeyword = generated$3.tsSymbolKeyword = tsSymbolKeyword;
  generated$3.tSThisType = generated$3.tsThisType = tsThisType;
  generated$3.tSTupleType = generated$3.tsTupleType = tsTupleType;
  generated$3.tSTypeAliasDeclaration = generated$3.tsTypeAliasDeclaration =
    tsTypeAliasDeclaration;
  generated$3.tSTypeAnnotation = generated$3.tsTypeAnnotation =
    tsTypeAnnotation;
  generated$3.tSTypeAssertion = generated$3.tsTypeAssertion = tsTypeAssertion;
  generated$3.tSTypeLiteral = generated$3.tsTypeLiteral = tsTypeLiteral;
  generated$3.tSTypeOperator = generated$3.tsTypeOperator = tsTypeOperator;
  generated$3.tSTypeParameter = generated$3.tsTypeParameter = tsTypeParameter;
  generated$3.tSTypeParameterDeclaration =
    generated$3.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
  generated$3.tSTypeParameterInstantiation =
    generated$3.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
  generated$3.tSTypePredicate = generated$3.tsTypePredicate = tsTypePredicate;
  generated$3.tSTypeQuery = generated$3.tsTypeQuery = tsTypeQuery;
  generated$3.tSTypeReference = generated$3.tsTypeReference = tsTypeReference;
  generated$3.tSUndefinedKeyword = generated$3.tsUndefinedKeyword =
    tsUndefinedKeyword;
  generated$3.tSUnionType = generated$3.tsUnionType = tsUnionType;
  generated$3.tSUnknownKeyword = generated$3.tsUnknownKeyword =
    tsUnknownKeyword;
  generated$3.tSVoidKeyword = generated$3.tsVoidKeyword = tsVoidKeyword;
  generated$3.tupleExpression = tupleExpression;
  generated$3.tupleTypeAnnotation = tupleTypeAnnotation;
  generated$3.typeAlias = typeAlias;
  generated$3.typeAnnotation = typeAnnotation;
  generated$3.typeCastExpression = typeCastExpression;
  generated$3.typeParameter = typeParameter;
  generated$3.typeParameterDeclaration = typeParameterDeclaration;
  generated$3.typeParameterInstantiation = typeParameterInstantiation;
  generated$3.typeofTypeAnnotation = typeofTypeAnnotation;
  generated$3.unaryExpression = unaryExpression;
  generated$3.unionTypeAnnotation = unionTypeAnnotation;
  generated$3.updateExpression = updateExpression;
  generated$3.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
  generated$3.variableDeclaration = variableDeclaration;
  generated$3.variableDeclarator = variableDeclarator;
  generated$3.variance = variance;
  generated$3.voidTypeAnnotation = voidTypeAnnotation;
  generated$3.whileStatement = whileStatement;
  generated$3.withStatement = withStatement;
  generated$3.yieldExpression = yieldExpression;
  var _validateNode = requireValidateNode();
  function arrayExpression(elements = []) {
    return (0, _validateNode.default)({
      type: "ArrayExpression",
      elements: elements,
    });
  }
  function assignmentExpression(operator, left, right) {
    return (0, _validateNode.default)({
      type: "AssignmentExpression",
      operator: operator,
      left: left,
      right: right,
    });
  }
  function binaryExpression(operator, left, right) {
    return (0, _validateNode.default)({
      type: "BinaryExpression",
      operator: operator,
      left: left,
      right: right,
    });
  }
  function interpreterDirective(value) {
    return (0, _validateNode.default)({
      type: "InterpreterDirective",
      value: value,
    });
  }
  function directive(value) {
    return (0, _validateNode.default)({ type: "Directive", value: value });
  }
  function directiveLiteral(value) {
    return (0, _validateNode.default)({
      type: "DirectiveLiteral",
      value: value,
    });
  }
  function blockStatement(body, directives = []) {
    return (0, _validateNode.default)({
      type: "BlockStatement",
      body: body,
      directives: directives,
    });
  }
  function breakStatement(label = null) {
    return (0, _validateNode.default)({ type: "BreakStatement", label: label });
  }
  function callExpression(callee, _arguments) {
    return (0, _validateNode.default)({
      type: "CallExpression",
      callee: callee,
      arguments: _arguments,
    });
  }
  function catchClause(param = null, body) {
    return (0, _validateNode.default)({
      type: "CatchClause",
      param: param,
      body: body,
    });
  }
  function conditionalExpression(test, consequent, alternate) {
    return (0, _validateNode.default)({
      type: "ConditionalExpression",
      test: test,
      consequent: consequent,
      alternate: alternate,
    });
  }
  function continueStatement(label = null) {
    return (0, _validateNode.default)({
      type: "ContinueStatement",
      label: label,
    });
  }
  function debuggerStatement() {
    return { type: "DebuggerStatement" };
  }
  function doWhileStatement(test, body) {
    return (0, _validateNode.default)({
      type: "DoWhileStatement",
      test: test,
      body: body,
    });
  }
  function emptyStatement() {
    return { type: "EmptyStatement" };
  }
  function expressionStatement(expression) {
    return (0, _validateNode.default)({
      type: "ExpressionStatement",
      expression: expression,
    });
  }
  function file(program, comments = null, tokens = null) {
    return (0, _validateNode.default)({
      type: "File",
      program: program,
      comments: comments,
      tokens: tokens,
    });
  }
  function forInStatement(left, right, body) {
    return (0, _validateNode.default)({
      type: "ForInStatement",
      left: left,
      right: right,
      body: body,
    });
  }
  function forStatement(init = null, test = null, update = null, body) {
    return (0, _validateNode.default)({
      type: "ForStatement",
      init: init,
      test: test,
      update: update,
      body: body,
    });
  }
  function functionDeclaration(
    id = null,
    params,
    body,
    generator = false,
    async = false
  ) {
    return (0, _validateNode.default)({
      type: "FunctionDeclaration",
      id: id,
      params: params,
      body: body,
      generator: generator,
      async: async,
    });
  }
  function functionExpression(
    id = null,
    params,
    body,
    generator = false,
    async = false
  ) {
    return (0, _validateNode.default)({
      type: "FunctionExpression",
      id: id,
      params: params,
      body: body,
      generator: generator,
      async: async,
    });
  }
  function identifier(name) {
    return (0, _validateNode.default)({ type: "Identifier", name: name });
  }
  function ifStatement(test, consequent, alternate = null) {
    return (0, _validateNode.default)({
      type: "IfStatement",
      test: test,
      consequent: consequent,
      alternate: alternate,
    });
  }
  function labeledStatement(label, body) {
    return (0, _validateNode.default)({
      type: "LabeledStatement",
      label: label,
      body: body,
    });
  }
  function stringLiteral(value) {
    return (0, _validateNode.default)({ type: "StringLiteral", value: value });
  }
  function numericLiteral(value) {
    return (0, _validateNode.default)({ type: "NumericLiteral", value: value });
  }
  function nullLiteral() {
    return { type: "NullLiteral" };
  }
  function booleanLiteral(value) {
    return (0, _validateNode.default)({ type: "BooleanLiteral", value: value });
  }
  function regExpLiteral(pattern, flags = "") {
    return (0, _validateNode.default)({
      type: "RegExpLiteral",
      pattern: pattern,
      flags: flags,
    });
  }
  function logicalExpression(operator, left, right) {
    return (0, _validateNode.default)({
      type: "LogicalExpression",
      operator: operator,
      left: left,
      right: right,
    });
  }
  function memberExpression(
    object,
    property,
    computed = false,
    optional = null
  ) {
    return (0, _validateNode.default)({
      type: "MemberExpression",
      object: object,
      property: property,
      computed: computed,
      optional: optional,
    });
  }
  function newExpression(callee, _arguments) {
    return (0, _validateNode.default)({
      type: "NewExpression",
      callee: callee,
      arguments: _arguments,
    });
  }
  function program(
    body,
    directives = [],
    sourceType = "script",
    interpreter = null
  ) {
    return (0, _validateNode.default)({
      type: "Program",
      body: body,
      directives: directives,
      sourceType: sourceType,
      interpreter: interpreter,
      sourceFile: null,
    });
  }
  function objectExpression(properties) {
    return (0, _validateNode.default)({
      type: "ObjectExpression",
      properties: properties,
    });
  }
  function objectMethod(
    kind = "method",
    key,
    params,
    body,
    computed = false,
    generator = false,
    async = false
  ) {
    return (0, _validateNode.default)({
      type: "ObjectMethod",
      kind: kind,
      key: key,
      params: params,
      body: body,
      computed: computed,
      generator: generator,
      async: async,
    });
  }
  function objectProperty(
    key,
    value,
    computed = false,
    shorthand = false,
    decorators = null
  ) {
    return (0, _validateNode.default)({
      type: "ObjectProperty",
      key: key,
      value: value,
      computed: computed,
      shorthand: shorthand,
      decorators: decorators,
    });
  }
  function restElement(argument) {
    return (0, _validateNode.default)({
      type: "RestElement",
      argument: argument,
    });
  }
  function returnStatement(argument = null) {
    return (0, _validateNode.default)({
      type: "ReturnStatement",
      argument: argument,
    });
  }
  function sequenceExpression(expressions) {
    return (0, _validateNode.default)({
      type: "SequenceExpression",
      expressions: expressions,
    });
  }
  function parenthesizedExpression(expression) {
    return (0, _validateNode.default)({
      type: "ParenthesizedExpression",
      expression: expression,
    });
  }
  function switchCase(test = null, consequent) {
    return (0, _validateNode.default)({
      type: "SwitchCase",
      test: test,
      consequent: consequent,
    });
  }
  function switchStatement(discriminant, cases) {
    return (0, _validateNode.default)({
      type: "SwitchStatement",
      discriminant: discriminant,
      cases: cases,
    });
  }
  function thisExpression() {
    return { type: "ThisExpression" };
  }
  function throwStatement(argument) {
    return (0, _validateNode.default)({
      type: "ThrowStatement",
      argument: argument,
    });
  }
  function tryStatement(block, handler = null, finalizer = null) {
    return (0, _validateNode.default)({
      type: "TryStatement",
      block: block,
      handler: handler,
      finalizer: finalizer,
    });
  }
  function unaryExpression(operator, argument, prefix = true) {
    return (0, _validateNode.default)({
      type: "UnaryExpression",
      operator: operator,
      argument: argument,
      prefix: prefix,
    });
  }
  function updateExpression(operator, argument, prefix = false) {
    return (0, _validateNode.default)({
      type: "UpdateExpression",
      operator: operator,
      argument: argument,
      prefix: prefix,
    });
  }
  function variableDeclaration(kind, declarations) {
    return (0, _validateNode.default)({
      type: "VariableDeclaration",
      kind: kind,
      declarations: declarations,
    });
  }
  function variableDeclarator(id, init = null) {
    return (0, _validateNode.default)({
      type: "VariableDeclarator",
      id: id,
      init: init,
    });
  }
  function whileStatement(test, body) {
    return (0, _validateNode.default)({
      type: "WhileStatement",
      test: test,
      body: body,
    });
  }
  function withStatement(object, body) {
    return (0, _validateNode.default)({
      type: "WithStatement",
      object: object,
      body: body,
    });
  }
  function assignmentPattern(left, right) {
    return (0, _validateNode.default)({
      type: "AssignmentPattern",
      left: left,
      right: right,
    });
  }
  function arrayPattern(elements) {
    return (0, _validateNode.default)({
      type: "ArrayPattern",
      elements: elements,
    });
  }
  function arrowFunctionExpression(params, body, async = false) {
    return (0, _validateNode.default)({
      type: "ArrowFunctionExpression",
      params: params,
      body: body,
      async: async,
      expression: null,
    });
  }
  function classBody(body) {
    return (0, _validateNode.default)({ type: "ClassBody", body: body });
  }
  function classExpression(
    id = null,
    superClass = null,
    body,
    decorators = null
  ) {
    return (0, _validateNode.default)({
      type: "ClassExpression",
      id: id,
      superClass: superClass,
      body: body,
      decorators: decorators,
    });
  }
  function classDeclaration(id, superClass = null, body, decorators = null) {
    return (0, _validateNode.default)({
      type: "ClassDeclaration",
      id: id,
      superClass: superClass,
      body: body,
      decorators: decorators,
    });
  }
  function exportAllDeclaration(source) {
    return (0, _validateNode.default)({
      type: "ExportAllDeclaration",
      source: source,
    });
  }
  function exportDefaultDeclaration(declaration) {
    return (0, _validateNode.default)({
      type: "ExportDefaultDeclaration",
      declaration: declaration,
    });
  }
  function exportNamedDeclaration(
    declaration = null,
    specifiers = [],
    source = null
  ) {
    return (0, _validateNode.default)({
      type: "ExportNamedDeclaration",
      declaration: declaration,
      specifiers: specifiers,
      source: source,
    });
  }
  function exportSpecifier(local, exported) {
    return (0, _validateNode.default)({
      type: "ExportSpecifier",
      local: local,
      exported: exported,
    });
  }
  function forOfStatement(left, right, body, _await = false) {
    return (0, _validateNode.default)({
      type: "ForOfStatement",
      left: left,
      right: right,
      body: body,
      await: _await,
    });
  }
  function importDeclaration(specifiers, source) {
    return (0, _validateNode.default)({
      type: "ImportDeclaration",
      specifiers: specifiers,
      source: source,
    });
  }
  function importDefaultSpecifier(local) {
    return (0, _validateNode.default)({
      type: "ImportDefaultSpecifier",
      local: local,
    });
  }
  function importNamespaceSpecifier(local) {
    return (0, _validateNode.default)({
      type: "ImportNamespaceSpecifier",
      local: local,
    });
  }
  function importSpecifier(local, imported) {
    return (0, _validateNode.default)({
      type: "ImportSpecifier",
      local: local,
      imported: imported,
    });
  }
  function metaProperty(meta, property) {
    return (0, _validateNode.default)({
      type: "MetaProperty",
      meta: meta,
      property: property,
    });
  }
  function classMethod(
    kind = "method",
    key,
    params,
    body,
    computed = false,
    _static = false,
    generator = false,
    async = false
  ) {
    return (0, _validateNode.default)({
      type: "ClassMethod",
      kind: kind,
      key: key,
      params: params,
      body: body,
      computed: computed,
      static: _static,
      generator: generator,
      async: async,
    });
  }
  function objectPattern(properties) {
    return (0, _validateNode.default)({
      type: "ObjectPattern",
      properties: properties,
    });
  }
  function spreadElement(argument) {
    return (0, _validateNode.default)({
      type: "SpreadElement",
      argument: argument,
    });
  }
  function _super() {
    return { type: "Super" };
  }
  function taggedTemplateExpression(tag, quasi) {
    return (0, _validateNode.default)({
      type: "TaggedTemplateExpression",
      tag: tag,
      quasi: quasi,
    });
  }
  function templateElement(value, tail = false) {
    return (0, _validateNode.default)({
      type: "TemplateElement",
      value: value,
      tail: tail,
    });
  }
  function templateLiteral(quasis, expressions) {
    return (0, _validateNode.default)({
      type: "TemplateLiteral",
      quasis: quasis,
      expressions: expressions,
    });
  }
  function yieldExpression(argument = null, delegate = false) {
    return (0, _validateNode.default)({
      type: "YieldExpression",
      argument: argument,
      delegate: delegate,
    });
  }
  function awaitExpression(argument) {
    return (0, _validateNode.default)({
      type: "AwaitExpression",
      argument: argument,
    });
  }
  function _import() {
    return { type: "Import" };
  }
  function bigIntLiteral(value) {
    return (0, _validateNode.default)({ type: "BigIntLiteral", value: value });
  }
  function exportNamespaceSpecifier(exported) {
    return (0, _validateNode.default)({
      type: "ExportNamespaceSpecifier",
      exported: exported,
    });
  }
  function optionalMemberExpression(
    object,
    property,
    computed = false,
    optional
  ) {
    return (0, _validateNode.default)({
      type: "OptionalMemberExpression",
      object: object,
      property: property,
      computed: computed,
      optional: optional,
    });
  }
  function optionalCallExpression(callee, _arguments, optional) {
    return (0, _validateNode.default)({
      type: "OptionalCallExpression",
      callee: callee,
      arguments: _arguments,
      optional: optional,
    });
  }
  function classProperty(
    key,
    value = null,
    typeAnnotation = null,
    decorators = null,
    computed = false,
    _static = false
  ) {
    return (0, _validateNode.default)({
      type: "ClassProperty",
      key: key,
      value: value,
      typeAnnotation: typeAnnotation,
      decorators: decorators,
      computed: computed,
      static: _static,
    });
  }
  function classAccessorProperty(
    key,
    value = null,
    typeAnnotation = null,
    decorators = null,
    computed = false,
    _static = false
  ) {
    return (0, _validateNode.default)({
      type: "ClassAccessorProperty",
      key: key,
      value: value,
      typeAnnotation: typeAnnotation,
      decorators: decorators,
      computed: computed,
      static: _static,
    });
  }
  function classPrivateProperty(
    key,
    value = null,
    decorators = null,
    _static = false
  ) {
    return (0, _validateNode.default)({
      type: "ClassPrivateProperty",
      key: key,
      value: value,
      decorators: decorators,
      static: _static,
    });
  }
  function classPrivateMethod(
    kind = "method",
    key,
    params,
    body,
    _static = false
  ) {
    return (0, _validateNode.default)({
      type: "ClassPrivateMethod",
      kind: kind,
      key: key,
      params: params,
      body: body,
      static: _static,
    });
  }
  function privateName(id) {
    return (0, _validateNode.default)({ type: "PrivateName", id: id });
  }
  function staticBlock(body) {
    return (0, _validateNode.default)({ type: "StaticBlock", body: body });
  }
  function anyTypeAnnotation() {
    return { type: "AnyTypeAnnotation" };
  }
  function arrayTypeAnnotation(elementType) {
    return (0, _validateNode.default)({
      type: "ArrayTypeAnnotation",
      elementType: elementType,
    });
  }
  function booleanTypeAnnotation() {
    return { type: "BooleanTypeAnnotation" };
  }
  function booleanLiteralTypeAnnotation(value) {
    return (0, _validateNode.default)({
      type: "BooleanLiteralTypeAnnotation",
      value: value,
    });
  }
  function nullLiteralTypeAnnotation() {
    return { type: "NullLiteralTypeAnnotation" };
  }
  function classImplements(id, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "ClassImplements",
      id: id,
      typeParameters: typeParameters,
    });
  }
  function declareClass(id, typeParameters = null, _extends = null, body) {
    return (0, _validateNode.default)({
      type: "DeclareClass",
      id: id,
      typeParameters: typeParameters,
      extends: _extends,
      body: body,
    });
  }
  function declareFunction(id) {
    return (0, _validateNode.default)({ type: "DeclareFunction", id: id });
  }
  function declareInterface(id, typeParameters = null, _extends = null, body) {
    return (0, _validateNode.default)({
      type: "DeclareInterface",
      id: id,
      typeParameters: typeParameters,
      extends: _extends,
      body: body,
    });
  }
  function declareModule(id, body, kind = null) {
    return (0, _validateNode.default)({
      type: "DeclareModule",
      id: id,
      body: body,
      kind: kind,
    });
  }
  function declareModuleExports(typeAnnotation) {
    return (0, _validateNode.default)({
      type: "DeclareModuleExports",
      typeAnnotation: typeAnnotation,
    });
  }
  function declareTypeAlias(id, typeParameters = null, right) {
    return (0, _validateNode.default)({
      type: "DeclareTypeAlias",
      id: id,
      typeParameters: typeParameters,
      right: right,
    });
  }
  function declareOpaqueType(id, typeParameters = null, supertype = null) {
    return (0, _validateNode.default)({
      type: "DeclareOpaqueType",
      id: id,
      typeParameters: typeParameters,
      supertype: supertype,
    });
  }
  function declareVariable(id) {
    return (0, _validateNode.default)({ type: "DeclareVariable", id: id });
  }
  function declareExportDeclaration(
    declaration = null,
    specifiers = null,
    source = null
  ) {
    return (0, _validateNode.default)({
      type: "DeclareExportDeclaration",
      declaration: declaration,
      specifiers: specifiers,
      source: source,
    });
  }
  function declareExportAllDeclaration(source) {
    return (0, _validateNode.default)({
      type: "DeclareExportAllDeclaration",
      source: source,
    });
  }
  function declaredPredicate(value) {
    return (0, _validateNode.default)({
      type: "DeclaredPredicate",
      value: value,
    });
  }
  function existsTypeAnnotation() {
    return { type: "ExistsTypeAnnotation" };
  }
  function functionTypeAnnotation(
    typeParameters = null,
    params,
    rest = null,
    returnType
  ) {
    return (0, _validateNode.default)({
      type: "FunctionTypeAnnotation",
      typeParameters: typeParameters,
      params: params,
      rest: rest,
      returnType: returnType,
    });
  }
  function functionTypeParam(name = null, typeAnnotation) {
    return (0, _validateNode.default)({
      type: "FunctionTypeParam",
      name: name,
      typeAnnotation: typeAnnotation,
    });
  }
  function genericTypeAnnotation(id, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "GenericTypeAnnotation",
      id: id,
      typeParameters: typeParameters,
    });
  }
  function inferredPredicate() {
    return { type: "InferredPredicate" };
  }
  function interfaceExtends(id, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "InterfaceExtends",
      id: id,
      typeParameters: typeParameters,
    });
  }
  function interfaceDeclaration(
    id,
    typeParameters = null,
    _extends = null,
    body
  ) {
    return (0, _validateNode.default)({
      type: "InterfaceDeclaration",
      id: id,
      typeParameters: typeParameters,
      extends: _extends,
      body: body,
    });
  }
  function interfaceTypeAnnotation(_extends = null, body) {
    return (0, _validateNode.default)({
      type: "InterfaceTypeAnnotation",
      extends: _extends,
      body: body,
    });
  }
  function intersectionTypeAnnotation(types) {
    return (0, _validateNode.default)({
      type: "IntersectionTypeAnnotation",
      types: types,
    });
  }
  function mixedTypeAnnotation() {
    return { type: "MixedTypeAnnotation" };
  }
  function emptyTypeAnnotation() {
    return { type: "EmptyTypeAnnotation" };
  }
  function nullableTypeAnnotation(typeAnnotation) {
    return (0, _validateNode.default)({
      type: "NullableTypeAnnotation",
      typeAnnotation: typeAnnotation,
    });
  }
  function numberLiteralTypeAnnotation(value) {
    return (0, _validateNode.default)({
      type: "NumberLiteralTypeAnnotation",
      value: value,
    });
  }
  function numberTypeAnnotation() {
    return { type: "NumberTypeAnnotation" };
  }
  function objectTypeAnnotation(
    properties,
    indexers = [],
    callProperties = [],
    internalSlots = [],
    exact = false
  ) {
    return (0, _validateNode.default)({
      type: "ObjectTypeAnnotation",
      properties: properties,
      indexers: indexers,
      callProperties: callProperties,
      internalSlots: internalSlots,
      exact: exact,
    });
  }
  function objectTypeInternalSlot(id, value, optional, _static, method) {
    return (0, _validateNode.default)({
      type: "ObjectTypeInternalSlot",
      id: id,
      value: value,
      optional: optional,
      static: _static,
      method: method,
    });
  }
  function objectTypeCallProperty(value) {
    return (0, _validateNode.default)({
      type: "ObjectTypeCallProperty",
      value: value,
      static: null,
    });
  }
  function objectTypeIndexer(id = null, key, value, variance = null) {
    return (0, _validateNode.default)({
      type: "ObjectTypeIndexer",
      id: id,
      key: key,
      value: value,
      variance: variance,
      static: null,
    });
  }
  function objectTypeProperty(key, value, variance = null) {
    return (0, _validateNode.default)({
      type: "ObjectTypeProperty",
      key: key,
      value: value,
      variance: variance,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null,
    });
  }
  function objectTypeSpreadProperty(argument) {
    return (0, _validateNode.default)({
      type: "ObjectTypeSpreadProperty",
      argument: argument,
    });
  }
  function opaqueType(id, typeParameters = null, supertype = null, impltype) {
    return (0, _validateNode.default)({
      type: "OpaqueType",
      id: id,
      typeParameters: typeParameters,
      supertype: supertype,
      impltype: impltype,
    });
  }
  function qualifiedTypeIdentifier(id, qualification) {
    return (0, _validateNode.default)({
      type: "QualifiedTypeIdentifier",
      id: id,
      qualification: qualification,
    });
  }
  function stringLiteralTypeAnnotation(value) {
    return (0, _validateNode.default)({
      type: "StringLiteralTypeAnnotation",
      value: value,
    });
  }
  function stringTypeAnnotation() {
    return { type: "StringTypeAnnotation" };
  }
  function symbolTypeAnnotation() {
    return { type: "SymbolTypeAnnotation" };
  }
  function thisTypeAnnotation() {
    return { type: "ThisTypeAnnotation" };
  }
  function tupleTypeAnnotation(types) {
    return (0, _validateNode.default)({
      type: "TupleTypeAnnotation",
      types: types,
    });
  }
  function typeofTypeAnnotation(argument) {
    return (0, _validateNode.default)({
      type: "TypeofTypeAnnotation",
      argument: argument,
    });
  }
  function typeAlias(id, typeParameters = null, right) {
    return (0, _validateNode.default)({
      type: "TypeAlias",
      id: id,
      typeParameters: typeParameters,
      right: right,
    });
  }
  function typeAnnotation(typeAnnotation) {
    return (0, _validateNode.default)({
      type: "TypeAnnotation",
      typeAnnotation: typeAnnotation,
    });
  }
  function typeCastExpression(expression, typeAnnotation) {
    return (0, _validateNode.default)({
      type: "TypeCastExpression",
      expression: expression,
      typeAnnotation: typeAnnotation,
    });
  }
  function typeParameter(bound = null, _default = null, variance = null) {
    return (0, _validateNode.default)({
      type: "TypeParameter",
      bound: bound,
      default: _default,
      variance: variance,
      name: null,
    });
  }
  function typeParameterDeclaration(params) {
    return (0, _validateNode.default)({
      type: "TypeParameterDeclaration",
      params: params,
    });
  }
  function typeParameterInstantiation(params) {
    return (0, _validateNode.default)({
      type: "TypeParameterInstantiation",
      params: params,
    });
  }
  function unionTypeAnnotation(types) {
    return (0, _validateNode.default)({
      type: "UnionTypeAnnotation",
      types: types,
    });
  }
  function variance(kind) {
    return (0, _validateNode.default)({ type: "Variance", kind: kind });
  }
  function voidTypeAnnotation() {
    return { type: "VoidTypeAnnotation" };
  }
  function enumDeclaration(id, body) {
    return (0, _validateNode.default)({
      type: "EnumDeclaration",
      id: id,
      body: body,
    });
  }
  function enumBooleanBody(members) {
    return (0, _validateNode.default)({
      type: "EnumBooleanBody",
      members: members,
      explicitType: null,
      hasUnknownMembers: null,
    });
  }
  function enumNumberBody(members) {
    return (0, _validateNode.default)({
      type: "EnumNumberBody",
      members: members,
      explicitType: null,
      hasUnknownMembers: null,
    });
  }
  function enumStringBody(members) {
    return (0, _validateNode.default)({
      type: "EnumStringBody",
      members: members,
      explicitType: null,
      hasUnknownMembers: null,
    });
  }
  function enumSymbolBody(members) {
    return (0, _validateNode.default)({
      type: "EnumSymbolBody",
      members: members,
      hasUnknownMembers: null,
    });
  }
  function enumBooleanMember(id) {
    return (0, _validateNode.default)({
      type: "EnumBooleanMember",
      id: id,
      init: null,
    });
  }
  function enumNumberMember(id, init) {
    return (0, _validateNode.default)({
      type: "EnumNumberMember",
      id: id,
      init: init,
    });
  }
  function enumStringMember(id, init) {
    return (0, _validateNode.default)({
      type: "EnumStringMember",
      id: id,
      init: init,
    });
  }
  function enumDefaultedMember(id) {
    return (0, _validateNode.default)({ type: "EnumDefaultedMember", id: id });
  }
  function indexedAccessType(objectType, indexType) {
    return (0, _validateNode.default)({
      type: "IndexedAccessType",
      objectType: objectType,
      indexType: indexType,
    });
  }
  function optionalIndexedAccessType(objectType, indexType) {
    return (0, _validateNode.default)({
      type: "OptionalIndexedAccessType",
      objectType: objectType,
      indexType: indexType,
      optional: null,
    });
  }
  function jsxAttribute(name, value = null) {
    return (0, _validateNode.default)({
      type: "JSXAttribute",
      name: name,
      value: value,
    });
  }
  function jsxClosingElement(name) {
    return (0, _validateNode.default)({
      type: "JSXClosingElement",
      name: name,
    });
  }
  function jsxElement(
    openingElement,
    closingElement = null,
    children,
    selfClosing = null
  ) {
    return (0, _validateNode.default)({
      type: "JSXElement",
      openingElement: openingElement,
      closingElement: closingElement,
      children: children,
      selfClosing: selfClosing,
    });
  }
  function jsxEmptyExpression() {
    return { type: "JSXEmptyExpression" };
  }
  function jsxExpressionContainer(expression) {
    return (0, _validateNode.default)({
      type: "JSXExpressionContainer",
      expression: expression,
    });
  }
  function jsxSpreadChild(expression) {
    return (0, _validateNode.default)({
      type: "JSXSpreadChild",
      expression: expression,
    });
  }
  function jsxIdentifier(name) {
    return (0, _validateNode.default)({ type: "JSXIdentifier", name: name });
  }
  function jsxMemberExpression(object, property) {
    return (0, _validateNode.default)({
      type: "JSXMemberExpression",
      object: object,
      property: property,
    });
  }
  function jsxNamespacedName(namespace, name) {
    return (0, _validateNode.default)({
      type: "JSXNamespacedName",
      namespace: namespace,
      name: name,
    });
  }
  function jsxOpeningElement(name, attributes, selfClosing = false) {
    return (0, _validateNode.default)({
      type: "JSXOpeningElement",
      name: name,
      attributes: attributes,
      selfClosing: selfClosing,
    });
  }
  function jsxSpreadAttribute(argument) {
    return (0, _validateNode.default)({
      type: "JSXSpreadAttribute",
      argument: argument,
    });
  }
  function jsxText(value) {
    return (0, _validateNode.default)({ type: "JSXText", value: value });
  }
  function jsxFragment(openingFragment, closingFragment, children) {
    return (0, _validateNode.default)({
      type: "JSXFragment",
      openingFragment: openingFragment,
      closingFragment: closingFragment,
      children: children,
    });
  }
  function jsxOpeningFragment() {
    return { type: "JSXOpeningFragment" };
  }
  function jsxClosingFragment() {
    return { type: "JSXClosingFragment" };
  }
  function noop() {
    return { type: "Noop" };
  }
  function placeholder(expectedNode, name) {
    return (0, _validateNode.default)({
      type: "Placeholder",
      expectedNode: expectedNode,
      name: name,
    });
  }
  function v8IntrinsicIdentifier(name) {
    return (0, _validateNode.default)({
      type: "V8IntrinsicIdentifier",
      name: name,
    });
  }
  function argumentPlaceholder() {
    return { type: "ArgumentPlaceholder" };
  }
  function bindExpression(object, callee) {
    return (0, _validateNode.default)({
      type: "BindExpression",
      object: object,
      callee: callee,
    });
  }
  function importAttribute(key, value) {
    return (0, _validateNode.default)({
      type: "ImportAttribute",
      key: key,
      value: value,
    });
  }
  function decorator(expression) {
    return (0, _validateNode.default)({
      type: "Decorator",
      expression: expression,
    });
  }
  function doExpression(body, async = false) {
    return (0, _validateNode.default)({
      type: "DoExpression",
      body: body,
      async: async,
    });
  }
  function exportDefaultSpecifier(exported) {
    return (0, _validateNode.default)({
      type: "ExportDefaultSpecifier",
      exported: exported,
    });
  }
  function recordExpression(properties) {
    return (0, _validateNode.default)({
      type: "RecordExpression",
      properties: properties,
    });
  }
  function tupleExpression(elements = []) {
    return (0, _validateNode.default)({
      type: "TupleExpression",
      elements: elements,
    });
  }
  function decimalLiteral(value) {
    return (0, _validateNode.default)({ type: "DecimalLiteral", value: value });
  }
  function moduleExpression(body) {
    return (0, _validateNode.default)({ type: "ModuleExpression", body: body });
  }
  function topicReference() {
    return { type: "TopicReference" };
  }
  function pipelineTopicExpression(expression) {
    return (0, _validateNode.default)({
      type: "PipelineTopicExpression",
      expression: expression,
    });
  }
  function pipelineBareFunction(callee) {
    return (0, _validateNode.default)({
      type: "PipelineBareFunction",
      callee: callee,
    });
  }
  function pipelinePrimaryTopicReference() {
    return { type: "PipelinePrimaryTopicReference" };
  }
  function tsParameterProperty(parameter) {
    return (0, _validateNode.default)({
      type: "TSParameterProperty",
      parameter: parameter,
    });
  }
  function tsDeclareFunction(
    id = null,
    typeParameters = null,
    params,
    returnType = null
  ) {
    return (0, _validateNode.default)({
      type: "TSDeclareFunction",
      id: id,
      typeParameters: typeParameters,
      params: params,
      returnType: returnType,
    });
  }
  function tsDeclareMethod(
    decorators = null,
    key,
    typeParameters = null,
    params,
    returnType = null
  ) {
    return (0, _validateNode.default)({
      type: "TSDeclareMethod",
      decorators: decorators,
      key: key,
      typeParameters: typeParameters,
      params: params,
      returnType: returnType,
    });
  }
  function tsQualifiedName(left, right) {
    return (0, _validateNode.default)({
      type: "TSQualifiedName",
      left: left,
      right: right,
    });
  }
  function tsCallSignatureDeclaration(
    typeParameters = null,
    parameters,
    typeAnnotation = null
  ) {
    return (0, _validateNode.default)({
      type: "TSCallSignatureDeclaration",
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation,
    });
  }
  function tsConstructSignatureDeclaration(
    typeParameters = null,
    parameters,
    typeAnnotation = null
  ) {
    return (0, _validateNode.default)({
      type: "TSConstructSignatureDeclaration",
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation,
    });
  }
  function tsPropertySignature(key, typeAnnotation = null, initializer = null) {
    return (0, _validateNode.default)({
      type: "TSPropertySignature",
      key: key,
      typeAnnotation: typeAnnotation,
      initializer: initializer,
      kind: null,
    });
  }
  function tsMethodSignature(
    key,
    typeParameters = null,
    parameters,
    typeAnnotation = null
  ) {
    return (0, _validateNode.default)({
      type: "TSMethodSignature",
      key: key,
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation,
      kind: null,
    });
  }
  function tsIndexSignature(parameters, typeAnnotation = null) {
    return (0, _validateNode.default)({
      type: "TSIndexSignature",
      parameters: parameters,
      typeAnnotation: typeAnnotation,
    });
  }
  function tsAnyKeyword() {
    return { type: "TSAnyKeyword" };
  }
  function tsBooleanKeyword() {
    return { type: "TSBooleanKeyword" };
  }
  function tsBigIntKeyword() {
    return { type: "TSBigIntKeyword" };
  }
  function tsIntrinsicKeyword() {
    return { type: "TSIntrinsicKeyword" };
  }
  function tsNeverKeyword() {
    return { type: "TSNeverKeyword" };
  }
  function tsNullKeyword() {
    return { type: "TSNullKeyword" };
  }
  function tsNumberKeyword() {
    return { type: "TSNumberKeyword" };
  }
  function tsObjectKeyword() {
    return { type: "TSObjectKeyword" };
  }
  function tsStringKeyword() {
    return { type: "TSStringKeyword" };
  }
  function tsSymbolKeyword() {
    return { type: "TSSymbolKeyword" };
  }
  function tsUndefinedKeyword() {
    return { type: "TSUndefinedKeyword" };
  }
  function tsUnknownKeyword() {
    return { type: "TSUnknownKeyword" };
  }
  function tsVoidKeyword() {
    return { type: "TSVoidKeyword" };
  }
  function tsThisType() {
    return { type: "TSThisType" };
  }
  function tsFunctionType(
    typeParameters = null,
    parameters,
    typeAnnotation = null
  ) {
    return (0, _validateNode.default)({
      type: "TSFunctionType",
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation,
    });
  }
  function tsConstructorType(
    typeParameters = null,
    parameters,
    typeAnnotation = null
  ) {
    return (0, _validateNode.default)({
      type: "TSConstructorType",
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation,
    });
  }
  function tsTypeReference(typeName, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "TSTypeReference",
      typeName: typeName,
      typeParameters: typeParameters,
    });
  }
  function tsTypePredicate(
    parameterName,
    typeAnnotation = null,
    asserts = null
  ) {
    return (0, _validateNode.default)({
      type: "TSTypePredicate",
      parameterName: parameterName,
      typeAnnotation: typeAnnotation,
      asserts: asserts,
    });
  }
  function tsTypeQuery(exprName, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "TSTypeQuery",
      exprName: exprName,
      typeParameters: typeParameters,
    });
  }
  function tsTypeLiteral(members) {
    return (0, _validateNode.default)({
      type: "TSTypeLiteral",
      members: members,
    });
  }
  function tsArrayType(elementType) {
    return (0, _validateNode.default)({
      type: "TSArrayType",
      elementType: elementType,
    });
  }
  function tsTupleType(elementTypes) {
    return (0, _validateNode.default)({
      type: "TSTupleType",
      elementTypes: elementTypes,
    });
  }
  function tsOptionalType(typeAnnotation) {
    return (0, _validateNode.default)({
      type: "TSOptionalType",
      typeAnnotation: typeAnnotation,
    });
  }
  function tsRestType(typeAnnotation) {
    return (0, _validateNode.default)({
      type: "TSRestType",
      typeAnnotation: typeAnnotation,
    });
  }
  function tsNamedTupleMember(label, elementType, optional = false) {
    return (0, _validateNode.default)({
      type: "TSNamedTupleMember",
      label: label,
      elementType: elementType,
      optional: optional,
    });
  }
  function tsUnionType(types) {
    return (0, _validateNode.default)({ type: "TSUnionType", types: types });
  }
  function tsIntersectionType(types) {
    return (0, _validateNode.default)({
      type: "TSIntersectionType",
      types: types,
    });
  }
  function tsConditionalType(checkType, extendsType, trueType, falseType) {
    return (0, _validateNode.default)({
      type: "TSConditionalType",
      checkType: checkType,
      extendsType: extendsType,
      trueType: trueType,
      falseType: falseType,
    });
  }
  function tsInferType(typeParameter) {
    return (0, _validateNode.default)({
      type: "TSInferType",
      typeParameter: typeParameter,
    });
  }
  function tsParenthesizedType(typeAnnotation) {
    return (0, _validateNode.default)({
      type: "TSParenthesizedType",
      typeAnnotation: typeAnnotation,
    });
  }
  function tsTypeOperator(typeAnnotation) {
    return (0, _validateNode.default)({
      type: "TSTypeOperator",
      typeAnnotation: typeAnnotation,
      operator: null,
    });
  }
  function tsIndexedAccessType(objectType, indexType) {
    return (0, _validateNode.default)({
      type: "TSIndexedAccessType",
      objectType: objectType,
      indexType: indexType,
    });
  }
  function tsMappedType(typeParameter, typeAnnotation = null, nameType = null) {
    return (0, _validateNode.default)({
      type: "TSMappedType",
      typeParameter: typeParameter,
      typeAnnotation: typeAnnotation,
      nameType: nameType,
    });
  }
  function tsLiteralType(literal) {
    return (0, _validateNode.default)({
      type: "TSLiteralType",
      literal: literal,
    });
  }
  function tsExpressionWithTypeArguments(expression, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "TSExpressionWithTypeArguments",
      expression: expression,
      typeParameters: typeParameters,
    });
  }
  function tsInterfaceDeclaration(
    id,
    typeParameters = null,
    _extends = null,
    body
  ) {
    return (0, _validateNode.default)({
      type: "TSInterfaceDeclaration",
      id: id,
      typeParameters: typeParameters,
      extends: _extends,
      body: body,
    });
  }
  function tsInterfaceBody(body) {
    return (0, _validateNode.default)({ type: "TSInterfaceBody", body: body });
  }
  function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation) {
    return (0, _validateNode.default)({
      type: "TSTypeAliasDeclaration",
      id: id,
      typeParameters: typeParameters,
      typeAnnotation: typeAnnotation,
    });
  }
  function tsInstantiationExpression(expression, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "TSInstantiationExpression",
      expression: expression,
      typeParameters: typeParameters,
    });
  }
  function tsAsExpression(expression, typeAnnotation) {
    return (0, _validateNode.default)({
      type: "TSAsExpression",
      expression: expression,
      typeAnnotation: typeAnnotation,
    });
  }
  function tsTypeAssertion(typeAnnotation, expression) {
    return (0, _validateNode.default)({
      type: "TSTypeAssertion",
      typeAnnotation: typeAnnotation,
      expression: expression,
    });
  }
  function tsEnumDeclaration(id, members) {
    return (0, _validateNode.default)({
      type: "TSEnumDeclaration",
      id: id,
      members: members,
    });
  }
  function tsEnumMember(id, initializer = null) {
    return (0, _validateNode.default)({
      type: "TSEnumMember",
      id: id,
      initializer: initializer,
    });
  }
  function tsModuleDeclaration(id, body) {
    return (0, _validateNode.default)({
      type: "TSModuleDeclaration",
      id: id,
      body: body,
    });
  }
  function tsModuleBlock(body) {
    return (0, _validateNode.default)({ type: "TSModuleBlock", body: body });
  }
  function tsImportType(argument, qualifier = null, typeParameters = null) {
    return (0, _validateNode.default)({
      type: "TSImportType",
      argument: argument,
      qualifier: qualifier,
      typeParameters: typeParameters,
    });
  }
  function tsImportEqualsDeclaration(id, moduleReference) {
    return (0, _validateNode.default)({
      type: "TSImportEqualsDeclaration",
      id: id,
      moduleReference: moduleReference,
      isExport: null,
    });
  }
  function tsExternalModuleReference(expression) {
    return (0, _validateNode.default)({
      type: "TSExternalModuleReference",
      expression: expression,
    });
  }
  function tsNonNullExpression(expression) {
    return (0, _validateNode.default)({
      type: "TSNonNullExpression",
      expression: expression,
    });
  }
  function tsExportAssignment(expression) {
    return (0, _validateNode.default)({
      type: "TSExportAssignment",
      expression: expression,
    });
  }
  function tsNamespaceExportDeclaration(id) {
    return (0, _validateNode.default)({
      type: "TSNamespaceExportDeclaration",
      id: id,
    });
  }
  function tsTypeAnnotation(typeAnnotation) {
    return (0, _validateNode.default)({
      type: "TSTypeAnnotation",
      typeAnnotation: typeAnnotation,
    });
  }
  function tsTypeParameterInstantiation(params) {
    return (0, _validateNode.default)({
      type: "TSTypeParameterInstantiation",
      params: params,
    });
  }
  function tsTypeParameterDeclaration(params) {
    return (0, _validateNode.default)({
      type: "TSTypeParameterDeclaration",
      params: params,
    });
  }
  function tsTypeParameter(constraint = null, _default = null, name) {
    return (0, _validateNode.default)({
      type: "TSTypeParameter",
      constraint: constraint,
      default: _default,
      name: name,
    });
  }
  function NumberLiteral(value) {
    console.trace(
      "The node type NumberLiteral has been renamed to NumericLiteral"
    );
    return numericLiteral(value);
  }
  function RegexLiteral(pattern, flags = "") {
    console.trace(
      "The node type RegexLiteral has been renamed to RegExpLiteral"
    );
    return regExpLiteral(pattern, flags);
  }
  function RestProperty(argument) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    return restElement(argument);
  }
  function SpreadProperty(argument) {
    console.trace(
      "The node type SpreadProperty has been renamed to SpreadElement"
    );
    return spreadElement(argument);
  }
  return generated$3;
}
var hasRequiredCleanJSXElementLiteralChild;
function requireCleanJSXElementLiteralChild() {
  if (hasRequiredCleanJSXElementLiteralChild)
    return cleanJSXElementLiteralChild;
  hasRequiredCleanJSXElementLiteralChild = 1;
  Object.defineProperty(cleanJSXElementLiteralChild, "__esModule", {
    value: true,
  });
  cleanJSXElementLiteralChild.default = cleanJSXElementLiteralChild$1;
  var _generated = requireGenerated$3();
  function cleanJSXElementLiteralChild$1(child, args) {
    const lines = child.value.split(/\r\n|\n|\r/);
    let lastNonEmptyLine = 0;
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].match(/[^ \t]/)) {
        lastNonEmptyLine = i;
      }
    }
    let str = "";
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const isFirstLine = i === 0;
      const isLastLine = i === lines.length - 1;
      const isLastNonEmptyLine = i === lastNonEmptyLine;
      let trimmedLine = line.replace(/\t/g, " ");
      if (!isFirstLine) {
        trimmedLine = trimmedLine.replace(/^[ ]+/, "");
      }
      if (!isLastLine) {
        trimmedLine = trimmedLine.replace(/[ ]+$/, "");
      }
      if (trimmedLine) {
        if (!isLastNonEmptyLine) {
          trimmedLine += " ";
        }
        str += trimmedLine;
      }
    }
    if (str) args.push((0, _generated.stringLiteral)(str));
  }
  return cleanJSXElementLiteralChild;
}
var hasRequiredBuildChildren;
function requireBuildChildren() {
  if (hasRequiredBuildChildren) return buildChildren;
  hasRequiredBuildChildren = 1;
  Object.defineProperty(buildChildren, "__esModule", { value: true });
  buildChildren.default = buildChildren$1;
  var _generated = requireGenerated$4();
  var _cleanJSXElementLiteralChild = requireCleanJSXElementLiteralChild();
  function buildChildren$1(node) {
    const elements = [];
    for (let i = 0; i < node.children.length; i++) {
      let child = node.children[i];
      if ((0, _generated.isJSXText)(child)) {
        (0, _cleanJSXElementLiteralChild.default)(child, elements);
        continue;
      }
      if ((0, _generated.isJSXExpressionContainer)(child))
        child = child.expression;
      if ((0, _generated.isJSXEmptyExpression)(child)) continue;
      elements.push(child);
    }
    return elements;
  }
  return buildChildren;
}
var assertNode = {};
var isNode = {};
var hasRequiredIsNode;
function requireIsNode() {
  if (hasRequiredIsNode) return isNode;
  hasRequiredIsNode = 1;
  Object.defineProperty(isNode, "__esModule", { value: true });
  isNode.default = isNode$1;
  var _definitions = requireDefinitions();
  function isNode$1(node) {
    return !!(node && _definitions.VISITOR_KEYS[node.type]);
  }
  return isNode;
}
var hasRequiredAssertNode;
function requireAssertNode() {
  if (hasRequiredAssertNode) return assertNode;
  hasRequiredAssertNode = 1;
  Object.defineProperty(assertNode, "__esModule", { value: true });
  assertNode.default = assertNode$1;
  var _isNode = requireIsNode();
  function assertNode$1(node) {
    if (!(0, _isNode.default)(node)) {
      var _node$type;
      const type =
        (_node$type = node == null ? void 0 : node.type) != null
          ? _node$type
          : JSON.stringify(node);
      throw new TypeError(`Not a valid node of type "${type}"`);
    }
  }
  return assertNode;
}
var generated$2 = {};
var hasRequiredGenerated$2;
function requireGenerated$2() {
  if (hasRequiredGenerated$2) return generated$2;
  hasRequiredGenerated$2 = 1;
  Object.defineProperty(generated$2, "__esModule", { value: true });
  generated$2.assertAccessor = assertAccessor;
  generated$2.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
  generated$2.assertArgumentPlaceholder = assertArgumentPlaceholder;
  generated$2.assertArrayExpression = assertArrayExpression;
  generated$2.assertArrayPattern = assertArrayPattern;
  generated$2.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
  generated$2.assertArrowFunctionExpression = assertArrowFunctionExpression;
  generated$2.assertAssignmentExpression = assertAssignmentExpression;
  generated$2.assertAssignmentPattern = assertAssignmentPattern;
  generated$2.assertAwaitExpression = assertAwaitExpression;
  generated$2.assertBigIntLiteral = assertBigIntLiteral;
  generated$2.assertBinary = assertBinary;
  generated$2.assertBinaryExpression = assertBinaryExpression;
  generated$2.assertBindExpression = assertBindExpression;
  generated$2.assertBlock = assertBlock;
  generated$2.assertBlockParent = assertBlockParent;
  generated$2.assertBlockStatement = assertBlockStatement;
  generated$2.assertBooleanLiteral = assertBooleanLiteral;
  generated$2.assertBooleanLiteralTypeAnnotation =
    assertBooleanLiteralTypeAnnotation;
  generated$2.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
  generated$2.assertBreakStatement = assertBreakStatement;
  generated$2.assertCallExpression = assertCallExpression;
  generated$2.assertCatchClause = assertCatchClause;
  generated$2.assertClass = assertClass;
  generated$2.assertClassAccessorProperty = assertClassAccessorProperty;
  generated$2.assertClassBody = assertClassBody;
  generated$2.assertClassDeclaration = assertClassDeclaration;
  generated$2.assertClassExpression = assertClassExpression;
  generated$2.assertClassImplements = assertClassImplements;
  generated$2.assertClassMethod = assertClassMethod;
  generated$2.assertClassPrivateMethod = assertClassPrivateMethod;
  generated$2.assertClassPrivateProperty = assertClassPrivateProperty;
  generated$2.assertClassProperty = assertClassProperty;
  generated$2.assertCompletionStatement = assertCompletionStatement;
  generated$2.assertConditional = assertConditional;
  generated$2.assertConditionalExpression = assertConditionalExpression;
  generated$2.assertContinueStatement = assertContinueStatement;
  generated$2.assertDebuggerStatement = assertDebuggerStatement;
  generated$2.assertDecimalLiteral = assertDecimalLiteral;
  generated$2.assertDeclaration = assertDeclaration;
  generated$2.assertDeclareClass = assertDeclareClass;
  generated$2.assertDeclareExportAllDeclaration =
    assertDeclareExportAllDeclaration;
  generated$2.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
  generated$2.assertDeclareFunction = assertDeclareFunction;
  generated$2.assertDeclareInterface = assertDeclareInterface;
  generated$2.assertDeclareModule = assertDeclareModule;
  generated$2.assertDeclareModuleExports = assertDeclareModuleExports;
  generated$2.assertDeclareOpaqueType = assertDeclareOpaqueType;
  generated$2.assertDeclareTypeAlias = assertDeclareTypeAlias;
  generated$2.assertDeclareVariable = assertDeclareVariable;
  generated$2.assertDeclaredPredicate = assertDeclaredPredicate;
  generated$2.assertDecorator = assertDecorator;
  generated$2.assertDirective = assertDirective;
  generated$2.assertDirectiveLiteral = assertDirectiveLiteral;
  generated$2.assertDoExpression = assertDoExpression;
  generated$2.assertDoWhileStatement = assertDoWhileStatement;
  generated$2.assertEmptyStatement = assertEmptyStatement;
  generated$2.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
  generated$2.assertEnumBody = assertEnumBody;
  generated$2.assertEnumBooleanBody = assertEnumBooleanBody;
  generated$2.assertEnumBooleanMember = assertEnumBooleanMember;
  generated$2.assertEnumDeclaration = assertEnumDeclaration;
  generated$2.assertEnumDefaultedMember = assertEnumDefaultedMember;
  generated$2.assertEnumMember = assertEnumMember;
  generated$2.assertEnumNumberBody = assertEnumNumberBody;
  generated$2.assertEnumNumberMember = assertEnumNumberMember;
  generated$2.assertEnumStringBody = assertEnumStringBody;
  generated$2.assertEnumStringMember = assertEnumStringMember;
  generated$2.assertEnumSymbolBody = assertEnumSymbolBody;
  generated$2.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
  generated$2.assertExportAllDeclaration = assertExportAllDeclaration;
  generated$2.assertExportDeclaration = assertExportDeclaration;
  generated$2.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
  generated$2.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
  generated$2.assertExportNamedDeclaration = assertExportNamedDeclaration;
  generated$2.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
  generated$2.assertExportSpecifier = assertExportSpecifier;
  generated$2.assertExpression = assertExpression;
  generated$2.assertExpressionStatement = assertExpressionStatement;
  generated$2.assertExpressionWrapper = assertExpressionWrapper;
  generated$2.assertFile = assertFile;
  generated$2.assertFlow = assertFlow;
  generated$2.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
  generated$2.assertFlowDeclaration = assertFlowDeclaration;
  generated$2.assertFlowPredicate = assertFlowPredicate;
  generated$2.assertFlowType = assertFlowType;
  generated$2.assertFor = assertFor;
  generated$2.assertForInStatement = assertForInStatement;
  generated$2.assertForOfStatement = assertForOfStatement;
  generated$2.assertForStatement = assertForStatement;
  generated$2.assertForXStatement = assertForXStatement;
  generated$2.assertFunction = assertFunction;
  generated$2.assertFunctionDeclaration = assertFunctionDeclaration;
  generated$2.assertFunctionExpression = assertFunctionExpression;
  generated$2.assertFunctionParent = assertFunctionParent;
  generated$2.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
  generated$2.assertFunctionTypeParam = assertFunctionTypeParam;
  generated$2.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
  generated$2.assertIdentifier = assertIdentifier;
  generated$2.assertIfStatement = assertIfStatement;
  generated$2.assertImmutable = assertImmutable;
  generated$2.assertImport = assertImport;
  generated$2.assertImportAttribute = assertImportAttribute;
  generated$2.assertImportDeclaration = assertImportDeclaration;
  generated$2.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
  generated$2.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
  generated$2.assertImportSpecifier = assertImportSpecifier;
  generated$2.assertIndexedAccessType = assertIndexedAccessType;
  generated$2.assertInferredPredicate = assertInferredPredicate;
  generated$2.assertInterfaceDeclaration = assertInterfaceDeclaration;
  generated$2.assertInterfaceExtends = assertInterfaceExtends;
  generated$2.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
  generated$2.assertInterpreterDirective = assertInterpreterDirective;
  generated$2.assertIntersectionTypeAnnotation =
    assertIntersectionTypeAnnotation;
  generated$2.assertJSX = assertJSX;
  generated$2.assertJSXAttribute = assertJSXAttribute;
  generated$2.assertJSXClosingElement = assertJSXClosingElement;
  generated$2.assertJSXClosingFragment = assertJSXClosingFragment;
  generated$2.assertJSXElement = assertJSXElement;
  generated$2.assertJSXEmptyExpression = assertJSXEmptyExpression;
  generated$2.assertJSXExpressionContainer = assertJSXExpressionContainer;
  generated$2.assertJSXFragment = assertJSXFragment;
  generated$2.assertJSXIdentifier = assertJSXIdentifier;
  generated$2.assertJSXMemberExpression = assertJSXMemberExpression;
  generated$2.assertJSXNamespacedName = assertJSXNamespacedName;
  generated$2.assertJSXOpeningElement = assertJSXOpeningElement;
  generated$2.assertJSXOpeningFragment = assertJSXOpeningFragment;
  generated$2.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
  generated$2.assertJSXSpreadChild = assertJSXSpreadChild;
  generated$2.assertJSXText = assertJSXText;
  generated$2.assertLVal = assertLVal;
  generated$2.assertLabeledStatement = assertLabeledStatement;
  generated$2.assertLiteral = assertLiteral;
  generated$2.assertLogicalExpression = assertLogicalExpression;
  generated$2.assertLoop = assertLoop;
  generated$2.assertMemberExpression = assertMemberExpression;
  generated$2.assertMetaProperty = assertMetaProperty;
  generated$2.assertMethod = assertMethod;
  generated$2.assertMiscellaneous = assertMiscellaneous;
  generated$2.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
  generated$2.assertModuleDeclaration = assertModuleDeclaration;
  generated$2.assertModuleExpression = assertModuleExpression;
  generated$2.assertModuleSpecifier = assertModuleSpecifier;
  generated$2.assertNewExpression = assertNewExpression;
  generated$2.assertNoop = assertNoop;
  generated$2.assertNullLiteral = assertNullLiteral;
  generated$2.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
  generated$2.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
  generated$2.assertNumberLiteral = assertNumberLiteral;
  generated$2.assertNumberLiteralTypeAnnotation =
    assertNumberLiteralTypeAnnotation;
  generated$2.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
  generated$2.assertNumericLiteral = assertNumericLiteral;
  generated$2.assertObjectExpression = assertObjectExpression;
  generated$2.assertObjectMember = assertObjectMember;
  generated$2.assertObjectMethod = assertObjectMethod;
  generated$2.assertObjectPattern = assertObjectPattern;
  generated$2.assertObjectProperty = assertObjectProperty;
  generated$2.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
  generated$2.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
  generated$2.assertObjectTypeIndexer = assertObjectTypeIndexer;
  generated$2.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
  generated$2.assertObjectTypeProperty = assertObjectTypeProperty;
  generated$2.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
  generated$2.assertOpaqueType = assertOpaqueType;
  generated$2.assertOptionalCallExpression = assertOptionalCallExpression;
  generated$2.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
  generated$2.assertOptionalMemberExpression = assertOptionalMemberExpression;
  generated$2.assertParenthesizedExpression = assertParenthesizedExpression;
  generated$2.assertPattern = assertPattern;
  generated$2.assertPatternLike = assertPatternLike;
  generated$2.assertPipelineBareFunction = assertPipelineBareFunction;
  generated$2.assertPipelinePrimaryTopicReference =
    assertPipelinePrimaryTopicReference;
  generated$2.assertPipelineTopicExpression = assertPipelineTopicExpression;
  generated$2.assertPlaceholder = assertPlaceholder;
  generated$2.assertPrivate = assertPrivate;
  generated$2.assertPrivateName = assertPrivateName;
  generated$2.assertProgram = assertProgram;
  generated$2.assertProperty = assertProperty;
  generated$2.assertPureish = assertPureish;
  generated$2.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
  generated$2.assertRecordExpression = assertRecordExpression;
  generated$2.assertRegExpLiteral = assertRegExpLiteral;
  generated$2.assertRegexLiteral = assertRegexLiteral;
  generated$2.assertRestElement = assertRestElement;
  generated$2.assertRestProperty = assertRestProperty;
  generated$2.assertReturnStatement = assertReturnStatement;
  generated$2.assertScopable = assertScopable;
  generated$2.assertSequenceExpression = assertSequenceExpression;
  generated$2.assertSpreadElement = assertSpreadElement;
  generated$2.assertSpreadProperty = assertSpreadProperty;
  generated$2.assertStandardized = assertStandardized;
  generated$2.assertStatement = assertStatement;
  generated$2.assertStaticBlock = assertStaticBlock;
  generated$2.assertStringLiteral = assertStringLiteral;
  generated$2.assertStringLiteralTypeAnnotation =
    assertStringLiteralTypeAnnotation;
  generated$2.assertStringTypeAnnotation = assertStringTypeAnnotation;
  generated$2.assertSuper = assertSuper;
  generated$2.assertSwitchCase = assertSwitchCase;
  generated$2.assertSwitchStatement = assertSwitchStatement;
  generated$2.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
  generated$2.assertTSAnyKeyword = assertTSAnyKeyword;
  generated$2.assertTSArrayType = assertTSArrayType;
  generated$2.assertTSAsExpression = assertTSAsExpression;
  generated$2.assertTSBaseType = assertTSBaseType;
  generated$2.assertTSBigIntKeyword = assertTSBigIntKeyword;
  generated$2.assertTSBooleanKeyword = assertTSBooleanKeyword;
  generated$2.assertTSCallSignatureDeclaration =
    assertTSCallSignatureDeclaration;
  generated$2.assertTSConditionalType = assertTSConditionalType;
  generated$2.assertTSConstructSignatureDeclaration =
    assertTSConstructSignatureDeclaration;
  generated$2.assertTSConstructorType = assertTSConstructorType;
  generated$2.assertTSDeclareFunction = assertTSDeclareFunction;
  generated$2.assertTSDeclareMethod = assertTSDeclareMethod;
  generated$2.assertTSEntityName = assertTSEntityName;
  generated$2.assertTSEnumDeclaration = assertTSEnumDeclaration;
  generated$2.assertTSEnumMember = assertTSEnumMember;
  generated$2.assertTSExportAssignment = assertTSExportAssignment;
  generated$2.assertTSExpressionWithTypeArguments =
    assertTSExpressionWithTypeArguments;
  generated$2.assertTSExternalModuleReference = assertTSExternalModuleReference;
  generated$2.assertTSFunctionType = assertTSFunctionType;
  generated$2.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
  generated$2.assertTSImportType = assertTSImportType;
  generated$2.assertTSIndexSignature = assertTSIndexSignature;
  generated$2.assertTSIndexedAccessType = assertTSIndexedAccessType;
  generated$2.assertTSInferType = assertTSInferType;
  generated$2.assertTSInstantiationExpression = assertTSInstantiationExpression;
  generated$2.assertTSInterfaceBody = assertTSInterfaceBody;
  generated$2.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
  generated$2.assertTSIntersectionType = assertTSIntersectionType;
  generated$2.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
  generated$2.assertTSLiteralType = assertTSLiteralType;
  generated$2.assertTSMappedType = assertTSMappedType;
  generated$2.assertTSMethodSignature = assertTSMethodSignature;
  generated$2.assertTSModuleBlock = assertTSModuleBlock;
  generated$2.assertTSModuleDeclaration = assertTSModuleDeclaration;
  generated$2.assertTSNamedTupleMember = assertTSNamedTupleMember;
  generated$2.assertTSNamespaceExportDeclaration =
    assertTSNamespaceExportDeclaration;
  generated$2.assertTSNeverKeyword = assertTSNeverKeyword;
  generated$2.assertTSNonNullExpression = assertTSNonNullExpression;
  generated$2.assertTSNullKeyword = assertTSNullKeyword;
  generated$2.assertTSNumberKeyword = assertTSNumberKeyword;
  generated$2.assertTSObjectKeyword = assertTSObjectKeyword;
  generated$2.assertTSOptionalType = assertTSOptionalType;
  generated$2.assertTSParameterProperty = assertTSParameterProperty;
  generated$2.assertTSParenthesizedType = assertTSParenthesizedType;
  generated$2.assertTSPropertySignature = assertTSPropertySignature;
  generated$2.assertTSQualifiedName = assertTSQualifiedName;
  generated$2.assertTSRestType = assertTSRestType;
  generated$2.assertTSStringKeyword = assertTSStringKeyword;
  generated$2.assertTSSymbolKeyword = assertTSSymbolKeyword;
  generated$2.assertTSThisType = assertTSThisType;
  generated$2.assertTSTupleType = assertTSTupleType;
  generated$2.assertTSType = assertTSType;
  generated$2.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
  generated$2.assertTSTypeAnnotation = assertTSTypeAnnotation;
  generated$2.assertTSTypeAssertion = assertTSTypeAssertion;
  generated$2.assertTSTypeElement = assertTSTypeElement;
  generated$2.assertTSTypeLiteral = assertTSTypeLiteral;
  generated$2.assertTSTypeOperator = assertTSTypeOperator;
  generated$2.assertTSTypeParameter = assertTSTypeParameter;
  generated$2.assertTSTypeParameterDeclaration =
    assertTSTypeParameterDeclaration;
  generated$2.assertTSTypeParameterInstantiation =
    assertTSTypeParameterInstantiation;
  generated$2.assertTSTypePredicate = assertTSTypePredicate;
  generated$2.assertTSTypeQuery = assertTSTypeQuery;
  generated$2.assertTSTypeReference = assertTSTypeReference;
  generated$2.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
  generated$2.assertTSUnionType = assertTSUnionType;
  generated$2.assertTSUnknownKeyword = assertTSUnknownKeyword;
  generated$2.assertTSVoidKeyword = assertTSVoidKeyword;
  generated$2.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
  generated$2.assertTemplateElement = assertTemplateElement;
  generated$2.assertTemplateLiteral = assertTemplateLiteral;
  generated$2.assertTerminatorless = assertTerminatorless;
  generated$2.assertThisExpression = assertThisExpression;
  generated$2.assertThisTypeAnnotation = assertThisTypeAnnotation;
  generated$2.assertThrowStatement = assertThrowStatement;
  generated$2.assertTopicReference = assertTopicReference;
  generated$2.assertTryStatement = assertTryStatement;
  generated$2.assertTupleExpression = assertTupleExpression;
  generated$2.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
  generated$2.assertTypeAlias = assertTypeAlias;
  generated$2.assertTypeAnnotation = assertTypeAnnotation;
  generated$2.assertTypeCastExpression = assertTypeCastExpression;
  generated$2.assertTypeParameter = assertTypeParameter;
  generated$2.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
  generated$2.assertTypeParameterInstantiation =
    assertTypeParameterInstantiation;
  generated$2.assertTypeScript = assertTypeScript;
  generated$2.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
  generated$2.assertUnaryExpression = assertUnaryExpression;
  generated$2.assertUnaryLike = assertUnaryLike;
  generated$2.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
  generated$2.assertUpdateExpression = assertUpdateExpression;
  generated$2.assertUserWhitespacable = assertUserWhitespacable;
  generated$2.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
  generated$2.assertVariableDeclaration = assertVariableDeclaration;
  generated$2.assertVariableDeclarator = assertVariableDeclarator;
  generated$2.assertVariance = assertVariance;
  generated$2.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
  generated$2.assertWhile = assertWhile;
  generated$2.assertWhileStatement = assertWhileStatement;
  generated$2.assertWithStatement = assertWithStatement;
  generated$2.assertYieldExpression = assertYieldExpression;
  var _is = requireIs();
  function assert(type, node, opts) {
    if (!(0, _is.default)(type, node, opts)) {
      throw new Error(
        `Expected type "${type}" with option ${JSON.stringify(opts)}, ` +
          `but instead got "${node.type}".`
      );
    }
  }
  function assertArrayExpression(node, opts) {
    assert("ArrayExpression", node, opts);
  }
  function assertAssignmentExpression(node, opts) {
    assert("AssignmentExpression", node, opts);
  }
  function assertBinaryExpression(node, opts) {
    assert("BinaryExpression", node, opts);
  }
  function assertInterpreterDirective(node, opts) {
    assert("InterpreterDirective", node, opts);
  }
  function assertDirective(node, opts) {
    assert("Directive", node, opts);
  }
  function assertDirectiveLiteral(node, opts) {
    assert("DirectiveLiteral", node, opts);
  }
  function assertBlockStatement(node, opts) {
    assert("BlockStatement", node, opts);
  }
  function assertBreakStatement(node, opts) {
    assert("BreakStatement", node, opts);
  }
  function assertCallExpression(node, opts) {
    assert("CallExpression", node, opts);
  }
  function assertCatchClause(node, opts) {
    assert("CatchClause", node, opts);
  }
  function assertConditionalExpression(node, opts) {
    assert("ConditionalExpression", node, opts);
  }
  function assertContinueStatement(node, opts) {
    assert("ContinueStatement", node, opts);
  }
  function assertDebuggerStatement(node, opts) {
    assert("DebuggerStatement", node, opts);
  }
  function assertDoWhileStatement(node, opts) {
    assert("DoWhileStatement", node, opts);
  }
  function assertEmptyStatement(node, opts) {
    assert("EmptyStatement", node, opts);
  }
  function assertExpressionStatement(node, opts) {
    assert("ExpressionStatement", node, opts);
  }
  function assertFile(node, opts) {
    assert("File", node, opts);
  }
  function assertForInStatement(node, opts) {
    assert("ForInStatement", node, opts);
  }
  function assertForStatement(node, opts) {
    assert("ForStatement", node, opts);
  }
  function assertFunctionDeclaration(node, opts) {
    assert("FunctionDeclaration", node, opts);
  }
  function assertFunctionExpression(node, opts) {
    assert("FunctionExpression", node, opts);
  }
  function assertIdentifier(node, opts) {
    assert("Identifier", node, opts);
  }
  function assertIfStatement(node, opts) {
    assert("IfStatement", node, opts);
  }
  function assertLabeledStatement(node, opts) {
    assert("LabeledStatement", node, opts);
  }
  function assertStringLiteral(node, opts) {
    assert("StringLiteral", node, opts);
  }
  function assertNumericLiteral(node, opts) {
    assert("NumericLiteral", node, opts);
  }
  function assertNullLiteral(node, opts) {
    assert("NullLiteral", node, opts);
  }
  function assertBooleanLiteral(node, opts) {
    assert("BooleanLiteral", node, opts);
  }
  function assertRegExpLiteral(node, opts) {
    assert("RegExpLiteral", node, opts);
  }
  function assertLogicalExpression(node, opts) {
    assert("LogicalExpression", node, opts);
  }
  function assertMemberExpression(node, opts) {
    assert("MemberExpression", node, opts);
  }
  function assertNewExpression(node, opts) {
    assert("NewExpression", node, opts);
  }
  function assertProgram(node, opts) {
    assert("Program", node, opts);
  }
  function assertObjectExpression(node, opts) {
    assert("ObjectExpression", node, opts);
  }
  function assertObjectMethod(node, opts) {
    assert("ObjectMethod", node, opts);
  }
  function assertObjectProperty(node, opts) {
    assert("ObjectProperty", node, opts);
  }
  function assertRestElement(node, opts) {
    assert("RestElement", node, opts);
  }
  function assertReturnStatement(node, opts) {
    assert("ReturnStatement", node, opts);
  }
  function assertSequenceExpression(node, opts) {
    assert("SequenceExpression", node, opts);
  }
  function assertParenthesizedExpression(node, opts) {
    assert("ParenthesizedExpression", node, opts);
  }
  function assertSwitchCase(node, opts) {
    assert("SwitchCase", node, opts);
  }
  function assertSwitchStatement(node, opts) {
    assert("SwitchStatement", node, opts);
  }
  function assertThisExpression(node, opts) {
    assert("ThisExpression", node, opts);
  }
  function assertThrowStatement(node, opts) {
    assert("ThrowStatement", node, opts);
  }
  function assertTryStatement(node, opts) {
    assert("TryStatement", node, opts);
  }
  function assertUnaryExpression(node, opts) {
    assert("UnaryExpression", node, opts);
  }
  function assertUpdateExpression(node, opts) {
    assert("UpdateExpression", node, opts);
  }
  function assertVariableDeclaration(node, opts) {
    assert("VariableDeclaration", node, opts);
  }
  function assertVariableDeclarator(node, opts) {
    assert("VariableDeclarator", node, opts);
  }
  function assertWhileStatement(node, opts) {
    assert("WhileStatement", node, opts);
  }
  function assertWithStatement(node, opts) {
    assert("WithStatement", node, opts);
  }
  function assertAssignmentPattern(node, opts) {
    assert("AssignmentPattern", node, opts);
  }
  function assertArrayPattern(node, opts) {
    assert("ArrayPattern", node, opts);
  }
  function assertArrowFunctionExpression(node, opts) {
    assert("ArrowFunctionExpression", node, opts);
  }
  function assertClassBody(node, opts) {
    assert("ClassBody", node, opts);
  }
  function assertClassExpression(node, opts) {
    assert("ClassExpression", node, opts);
  }
  function assertClassDeclaration(node, opts) {
    assert("ClassDeclaration", node, opts);
  }
  function assertExportAllDeclaration(node, opts) {
    assert("ExportAllDeclaration", node, opts);
  }
  function assertExportDefaultDeclaration(node, opts) {
    assert("ExportDefaultDeclaration", node, opts);
  }
  function assertExportNamedDeclaration(node, opts) {
    assert("ExportNamedDeclaration", node, opts);
  }
  function assertExportSpecifier(node, opts) {
    assert("ExportSpecifier", node, opts);
  }
  function assertForOfStatement(node, opts) {
    assert("ForOfStatement", node, opts);
  }
  function assertImportDeclaration(node, opts) {
    assert("ImportDeclaration", node, opts);
  }
  function assertImportDefaultSpecifier(node, opts) {
    assert("ImportDefaultSpecifier", node, opts);
  }
  function assertImportNamespaceSpecifier(node, opts) {
    assert("ImportNamespaceSpecifier", node, opts);
  }
  function assertImportSpecifier(node, opts) {
    assert("ImportSpecifier", node, opts);
  }
  function assertMetaProperty(node, opts) {
    assert("MetaProperty", node, opts);
  }
  function assertClassMethod(node, opts) {
    assert("ClassMethod", node, opts);
  }
  function assertObjectPattern(node, opts) {
    assert("ObjectPattern", node, opts);
  }
  function assertSpreadElement(node, opts) {
    assert("SpreadElement", node, opts);
  }
  function assertSuper(node, opts) {
    assert("Super", node, opts);
  }
  function assertTaggedTemplateExpression(node, opts) {
    assert("TaggedTemplateExpression", node, opts);
  }
  function assertTemplateElement(node, opts) {
    assert("TemplateElement", node, opts);
  }
  function assertTemplateLiteral(node, opts) {
    assert("TemplateLiteral", node, opts);
  }
  function assertYieldExpression(node, opts) {
    assert("YieldExpression", node, opts);
  }
  function assertAwaitExpression(node, opts) {
    assert("AwaitExpression", node, opts);
  }
  function assertImport(node, opts) {
    assert("Import", node, opts);
  }
  function assertBigIntLiteral(node, opts) {
    assert("BigIntLiteral", node, opts);
  }
  function assertExportNamespaceSpecifier(node, opts) {
    assert("ExportNamespaceSpecifier", node, opts);
  }
  function assertOptionalMemberExpression(node, opts) {
    assert("OptionalMemberExpression", node, opts);
  }
  function assertOptionalCallExpression(node, opts) {
    assert("OptionalCallExpression", node, opts);
  }
  function assertClassProperty(node, opts) {
    assert("ClassProperty", node, opts);
  }
  function assertClassAccessorProperty(node, opts) {
    assert("ClassAccessorProperty", node, opts);
  }
  function assertClassPrivateProperty(node, opts) {
    assert("ClassPrivateProperty", node, opts);
  }
  function assertClassPrivateMethod(node, opts) {
    assert("ClassPrivateMethod", node, opts);
  }
  function assertPrivateName(node, opts) {
    assert("PrivateName", node, opts);
  }
  function assertStaticBlock(node, opts) {
    assert("StaticBlock", node, opts);
  }
  function assertAnyTypeAnnotation(node, opts) {
    assert("AnyTypeAnnotation", node, opts);
  }
  function assertArrayTypeAnnotation(node, opts) {
    assert("ArrayTypeAnnotation", node, opts);
  }
  function assertBooleanTypeAnnotation(node, opts) {
    assert("BooleanTypeAnnotation", node, opts);
  }
  function assertBooleanLiteralTypeAnnotation(node, opts) {
    assert("BooleanLiteralTypeAnnotation", node, opts);
  }
  function assertNullLiteralTypeAnnotation(node, opts) {
    assert("NullLiteralTypeAnnotation", node, opts);
  }
  function assertClassImplements(node, opts) {
    assert("ClassImplements", node, opts);
  }
  function assertDeclareClass(node, opts) {
    assert("DeclareClass", node, opts);
  }
  function assertDeclareFunction(node, opts) {
    assert("DeclareFunction", node, opts);
  }
  function assertDeclareInterface(node, opts) {
    assert("DeclareInterface", node, opts);
  }
  function assertDeclareModule(node, opts) {
    assert("DeclareModule", node, opts);
  }
  function assertDeclareModuleExports(node, opts) {
    assert("DeclareModuleExports", node, opts);
  }
  function assertDeclareTypeAlias(node, opts) {
    assert("DeclareTypeAlias", node, opts);
  }
  function assertDeclareOpaqueType(node, opts) {
    assert("DeclareOpaqueType", node, opts);
  }
  function assertDeclareVariable(node, opts) {
    assert("DeclareVariable", node, opts);
  }
  function assertDeclareExportDeclaration(node, opts) {
    assert("DeclareExportDeclaration", node, opts);
  }
  function assertDeclareExportAllDeclaration(node, opts) {
    assert("DeclareExportAllDeclaration", node, opts);
  }
  function assertDeclaredPredicate(node, opts) {
    assert("DeclaredPredicate", node, opts);
  }
  function assertExistsTypeAnnotation(node, opts) {
    assert("ExistsTypeAnnotation", node, opts);
  }
  function assertFunctionTypeAnnotation(node, opts) {
    assert("FunctionTypeAnnotation", node, opts);
  }
  function assertFunctionTypeParam(node, opts) {
    assert("FunctionTypeParam", node, opts);
  }
  function assertGenericTypeAnnotation(node, opts) {
    assert("GenericTypeAnnotation", node, opts);
  }
  function assertInferredPredicate(node, opts) {
    assert("InferredPredicate", node, opts);
  }
  function assertInterfaceExtends(node, opts) {
    assert("InterfaceExtends", node, opts);
  }
  function assertInterfaceDeclaration(node, opts) {
    assert("InterfaceDeclaration", node, opts);
  }
  function assertInterfaceTypeAnnotation(node, opts) {
    assert("InterfaceTypeAnnotation", node, opts);
  }
  function assertIntersectionTypeAnnotation(node, opts) {
    assert("IntersectionTypeAnnotation", node, opts);
  }
  function assertMixedTypeAnnotation(node, opts) {
    assert("MixedTypeAnnotation", node, opts);
  }
  function assertEmptyTypeAnnotation(node, opts) {
    assert("EmptyTypeAnnotation", node, opts);
  }
  function assertNullableTypeAnnotation(node, opts) {
    assert("NullableTypeAnnotation", node, opts);
  }
  function assertNumberLiteralTypeAnnotation(node, opts) {
    assert("NumberLiteralTypeAnnotation", node, opts);
  }
  function assertNumberTypeAnnotation(node, opts) {
    assert("NumberTypeAnnotation", node, opts);
  }
  function assertObjectTypeAnnotation(node, opts) {
    assert("ObjectTypeAnnotation", node, opts);
  }
  function assertObjectTypeInternalSlot(node, opts) {
    assert("ObjectTypeInternalSlot", node, opts);
  }
  function assertObjectTypeCallProperty(node, opts) {
    assert("ObjectTypeCallProperty", node, opts);
  }
  function assertObjectTypeIndexer(node, opts) {
    assert("ObjectTypeIndexer", node, opts);
  }
  function assertObjectTypeProperty(node, opts) {
    assert("ObjectTypeProperty", node, opts);
  }
  function assertObjectTypeSpreadProperty(node, opts) {
    assert("ObjectTypeSpreadProperty", node, opts);
  }
  function assertOpaqueType(node, opts) {
    assert("OpaqueType", node, opts);
  }
  function assertQualifiedTypeIdentifier(node, opts) {
    assert("QualifiedTypeIdentifier", node, opts);
  }
  function assertStringLiteralTypeAnnotation(node, opts) {
    assert("StringLiteralTypeAnnotation", node, opts);
  }
  function assertStringTypeAnnotation(node, opts) {
    assert("StringTypeAnnotation", node, opts);
  }
  function assertSymbolTypeAnnotation(node, opts) {
    assert("SymbolTypeAnnotation", node, opts);
  }
  function assertThisTypeAnnotation(node, opts) {
    assert("ThisTypeAnnotation", node, opts);
  }
  function assertTupleTypeAnnotation(node, opts) {
    assert("TupleTypeAnnotation", node, opts);
  }
  function assertTypeofTypeAnnotation(node, opts) {
    assert("TypeofTypeAnnotation", node, opts);
  }
  function assertTypeAlias(node, opts) {
    assert("TypeAlias", node, opts);
  }
  function assertTypeAnnotation(node, opts) {
    assert("TypeAnnotation", node, opts);
  }
  function assertTypeCastExpression(node, opts) {
    assert("TypeCastExpression", node, opts);
  }
  function assertTypeParameter(node, opts) {
    assert("TypeParameter", node, opts);
  }
  function assertTypeParameterDeclaration(node, opts) {
    assert("TypeParameterDeclaration", node, opts);
  }
  function assertTypeParameterInstantiation(node, opts) {
    assert("TypeParameterInstantiation", node, opts);
  }
  function assertUnionTypeAnnotation(node, opts) {
    assert("UnionTypeAnnotation", node, opts);
  }
  function assertVariance(node, opts) {
    assert("Variance", node, opts);
  }
  function assertVoidTypeAnnotation(node, opts) {
    assert("VoidTypeAnnotation", node, opts);
  }
  function assertEnumDeclaration(node, opts) {
    assert("EnumDeclaration", node, opts);
  }
  function assertEnumBooleanBody(node, opts) {
    assert("EnumBooleanBody", node, opts);
  }
  function assertEnumNumberBody(node, opts) {
    assert("EnumNumberBody", node, opts);
  }
  function assertEnumStringBody(node, opts) {
    assert("EnumStringBody", node, opts);
  }
  function assertEnumSymbolBody(node, opts) {
    assert("EnumSymbolBody", node, opts);
  }
  function assertEnumBooleanMember(node, opts) {
    assert("EnumBooleanMember", node, opts);
  }
  function assertEnumNumberMember(node, opts) {
    assert("EnumNumberMember", node, opts);
  }
  function assertEnumStringMember(node, opts) {
    assert("EnumStringMember", node, opts);
  }
  function assertEnumDefaultedMember(node, opts) {
    assert("EnumDefaultedMember", node, opts);
  }
  function assertIndexedAccessType(node, opts) {
    assert("IndexedAccessType", node, opts);
  }
  function assertOptionalIndexedAccessType(node, opts) {
    assert("OptionalIndexedAccessType", node, opts);
  }
  function assertJSXAttribute(node, opts) {
    assert("JSXAttribute", node, opts);
  }
  function assertJSXClosingElement(node, opts) {
    assert("JSXClosingElement", node, opts);
  }
  function assertJSXElement(node, opts) {
    assert("JSXElement", node, opts);
  }
  function assertJSXEmptyExpression(node, opts) {
    assert("JSXEmptyExpression", node, opts);
  }
  function assertJSXExpressionContainer(node, opts) {
    assert("JSXExpressionContainer", node, opts);
  }
  function assertJSXSpreadChild(node, opts) {
    assert("JSXSpreadChild", node, opts);
  }
  function assertJSXIdentifier(node, opts) {
    assert("JSXIdentifier", node, opts);
  }
  function assertJSXMemberExpression(node, opts) {
    assert("JSXMemberExpression", node, opts);
  }
  function assertJSXNamespacedName(node, opts) {
    assert("JSXNamespacedName", node, opts);
  }
  function assertJSXOpeningElement(node, opts) {
    assert("JSXOpeningElement", node, opts);
  }
  function assertJSXSpreadAttribute(node, opts) {
    assert("JSXSpreadAttribute", node, opts);
  }
  function assertJSXText(node, opts) {
    assert("JSXText", node, opts);
  }
  function assertJSXFragment(node, opts) {
    assert("JSXFragment", node, opts);
  }
  function assertJSXOpeningFragment(node, opts) {
    assert("JSXOpeningFragment", node, opts);
  }
  function assertJSXClosingFragment(node, opts) {
    assert("JSXClosingFragment", node, opts);
  }
  function assertNoop(node, opts) {
    assert("Noop", node, opts);
  }
  function assertPlaceholder(node, opts) {
    assert("Placeholder", node, opts);
  }
  function assertV8IntrinsicIdentifier(node, opts) {
    assert("V8IntrinsicIdentifier", node, opts);
  }
  function assertArgumentPlaceholder(node, opts) {
    assert("ArgumentPlaceholder", node, opts);
  }
  function assertBindExpression(node, opts) {
    assert("BindExpression", node, opts);
  }
  function assertImportAttribute(node, opts) {
    assert("ImportAttribute", node, opts);
  }
  function assertDecorator(node, opts) {
    assert("Decorator", node, opts);
  }
  function assertDoExpression(node, opts) {
    assert("DoExpression", node, opts);
  }
  function assertExportDefaultSpecifier(node, opts) {
    assert("ExportDefaultSpecifier", node, opts);
  }
  function assertRecordExpression(node, opts) {
    assert("RecordExpression", node, opts);
  }
  function assertTupleExpression(node, opts) {
    assert("TupleExpression", node, opts);
  }
  function assertDecimalLiteral(node, opts) {
    assert("DecimalLiteral", node, opts);
  }
  function assertModuleExpression(node, opts) {
    assert("ModuleExpression", node, opts);
  }
  function assertTopicReference(node, opts) {
    assert("TopicReference", node, opts);
  }
  function assertPipelineTopicExpression(node, opts) {
    assert("PipelineTopicExpression", node, opts);
  }
  function assertPipelineBareFunction(node, opts) {
    assert("PipelineBareFunction", node, opts);
  }
  function assertPipelinePrimaryTopicReference(node, opts) {
    assert("PipelinePrimaryTopicReference", node, opts);
  }
  function assertTSParameterProperty(node, opts) {
    assert("TSParameterProperty", node, opts);
  }
  function assertTSDeclareFunction(node, opts) {
    assert("TSDeclareFunction", node, opts);
  }
  function assertTSDeclareMethod(node, opts) {
    assert("TSDeclareMethod", node, opts);
  }
  function assertTSQualifiedName(node, opts) {
    assert("TSQualifiedName", node, opts);
  }
  function assertTSCallSignatureDeclaration(node, opts) {
    assert("TSCallSignatureDeclaration", node, opts);
  }
  function assertTSConstructSignatureDeclaration(node, opts) {
    assert("TSConstructSignatureDeclaration", node, opts);
  }
  function assertTSPropertySignature(node, opts) {
    assert("TSPropertySignature", node, opts);
  }
  function assertTSMethodSignature(node, opts) {
    assert("TSMethodSignature", node, opts);
  }
  function assertTSIndexSignature(node, opts) {
    assert("TSIndexSignature", node, opts);
  }
  function assertTSAnyKeyword(node, opts) {
    assert("TSAnyKeyword", node, opts);
  }
  function assertTSBooleanKeyword(node, opts) {
    assert("TSBooleanKeyword", node, opts);
  }
  function assertTSBigIntKeyword(node, opts) {
    assert("TSBigIntKeyword", node, opts);
  }
  function assertTSIntrinsicKeyword(node, opts) {
    assert("TSIntrinsicKeyword", node, opts);
  }
  function assertTSNeverKeyword(node, opts) {
    assert("TSNeverKeyword", node, opts);
  }
  function assertTSNullKeyword(node, opts) {
    assert("TSNullKeyword", node, opts);
  }
  function assertTSNumberKeyword(node, opts) {
    assert("TSNumberKeyword", node, opts);
  }
  function assertTSObjectKeyword(node, opts) {
    assert("TSObjectKeyword", node, opts);
  }
  function assertTSStringKeyword(node, opts) {
    assert("TSStringKeyword", node, opts);
  }
  function assertTSSymbolKeyword(node, opts) {
    assert("TSSymbolKeyword", node, opts);
  }
  function assertTSUndefinedKeyword(node, opts) {
    assert("TSUndefinedKeyword", node, opts);
  }
  function assertTSUnknownKeyword(node, opts) {
    assert("TSUnknownKeyword", node, opts);
  }
  function assertTSVoidKeyword(node, opts) {
    assert("TSVoidKeyword", node, opts);
  }
  function assertTSThisType(node, opts) {
    assert("TSThisType", node, opts);
  }
  function assertTSFunctionType(node, opts) {
    assert("TSFunctionType", node, opts);
  }
  function assertTSConstructorType(node, opts) {
    assert("TSConstructorType", node, opts);
  }
  function assertTSTypeReference(node, opts) {
    assert("TSTypeReference", node, opts);
  }
  function assertTSTypePredicate(node, opts) {
    assert("TSTypePredicate", node, opts);
  }
  function assertTSTypeQuery(node, opts) {
    assert("TSTypeQuery", node, opts);
  }
  function assertTSTypeLiteral(node, opts) {
    assert("TSTypeLiteral", node, opts);
  }
  function assertTSArrayType(node, opts) {
    assert("TSArrayType", node, opts);
  }
  function assertTSTupleType(node, opts) {
    assert("TSTupleType", node, opts);
  }
  function assertTSOptionalType(node, opts) {
    assert("TSOptionalType", node, opts);
  }
  function assertTSRestType(node, opts) {
    assert("TSRestType", node, opts);
  }
  function assertTSNamedTupleMember(node, opts) {
    assert("TSNamedTupleMember", node, opts);
  }
  function assertTSUnionType(node, opts) {
    assert("TSUnionType", node, opts);
  }
  function assertTSIntersectionType(node, opts) {
    assert("TSIntersectionType", node, opts);
  }
  function assertTSConditionalType(node, opts) {
    assert("TSConditionalType", node, opts);
  }
  function assertTSInferType(node, opts) {
    assert("TSInferType", node, opts);
  }
  function assertTSParenthesizedType(node, opts) {
    assert("TSParenthesizedType", node, opts);
  }
  function assertTSTypeOperator(node, opts) {
    assert("TSTypeOperator", node, opts);
  }
  function assertTSIndexedAccessType(node, opts) {
    assert("TSIndexedAccessType", node, opts);
  }
  function assertTSMappedType(node, opts) {
    assert("TSMappedType", node, opts);
  }
  function assertTSLiteralType(node, opts) {
    assert("TSLiteralType", node, opts);
  }
  function assertTSExpressionWithTypeArguments(node, opts) {
    assert("TSExpressionWithTypeArguments", node, opts);
  }
  function assertTSInterfaceDeclaration(node, opts) {
    assert("TSInterfaceDeclaration", node, opts);
  }
  function assertTSInterfaceBody(node, opts) {
    assert("TSInterfaceBody", node, opts);
  }
  function assertTSTypeAliasDeclaration(node, opts) {
    assert("TSTypeAliasDeclaration", node, opts);
  }
  function assertTSInstantiationExpression(node, opts) {
    assert("TSInstantiationExpression", node, opts);
  }
  function assertTSAsExpression(node, opts) {
    assert("TSAsExpression", node, opts);
  }
  function assertTSTypeAssertion(node, opts) {
    assert("TSTypeAssertion", node, opts);
  }
  function assertTSEnumDeclaration(node, opts) {
    assert("TSEnumDeclaration", node, opts);
  }
  function assertTSEnumMember(node, opts) {
    assert("TSEnumMember", node, opts);
  }
  function assertTSModuleDeclaration(node, opts) {
    assert("TSModuleDeclaration", node, opts);
  }
  function assertTSModuleBlock(node, opts) {
    assert("TSModuleBlock", node, opts);
  }
  function assertTSImportType(node, opts) {
    assert("TSImportType", node, opts);
  }
  function assertTSImportEqualsDeclaration(node, opts) {
    assert("TSImportEqualsDeclaration", node, opts);
  }
  function assertTSExternalModuleReference(node, opts) {
    assert("TSExternalModuleReference", node, opts);
  }
  function assertTSNonNullExpression(node, opts) {
    assert("TSNonNullExpression", node, opts);
  }
  function assertTSExportAssignment(node, opts) {
    assert("TSExportAssignment", node, opts);
  }
  function assertTSNamespaceExportDeclaration(node, opts) {
    assert("TSNamespaceExportDeclaration", node, opts);
  }
  function assertTSTypeAnnotation(node, opts) {
    assert("TSTypeAnnotation", node, opts);
  }
  function assertTSTypeParameterInstantiation(node, opts) {
    assert("TSTypeParameterInstantiation", node, opts);
  }
  function assertTSTypeParameterDeclaration(node, opts) {
    assert("TSTypeParameterDeclaration", node, opts);
  }
  function assertTSTypeParameter(node, opts) {
    assert("TSTypeParameter", node, opts);
  }
  function assertStandardized(node, opts) {
    assert("Standardized", node, opts);
  }
  function assertExpression(node, opts) {
    assert("Expression", node, opts);
  }
  function assertBinary(node, opts) {
    assert("Binary", node, opts);
  }
  function assertScopable(node, opts) {
    assert("Scopable", node, opts);
  }
  function assertBlockParent(node, opts) {
    assert("BlockParent", node, opts);
  }
  function assertBlock(node, opts) {
    assert("Block", node, opts);
  }
  function assertStatement(node, opts) {
    assert("Statement", node, opts);
  }
  function assertTerminatorless(node, opts) {
    assert("Terminatorless", node, opts);
  }
  function assertCompletionStatement(node, opts) {
    assert("CompletionStatement", node, opts);
  }
  function assertConditional(node, opts) {
    assert("Conditional", node, opts);
  }
  function assertLoop(node, opts) {
    assert("Loop", node, opts);
  }
  function assertWhile(node, opts) {
    assert("While", node, opts);
  }
  function assertExpressionWrapper(node, opts) {
    assert("ExpressionWrapper", node, opts);
  }
  function assertFor(node, opts) {
    assert("For", node, opts);
  }
  function assertForXStatement(node, opts) {
    assert("ForXStatement", node, opts);
  }
  function assertFunction(node, opts) {
    assert("Function", node, opts);
  }
  function assertFunctionParent(node, opts) {
    assert("FunctionParent", node, opts);
  }
  function assertPureish(node, opts) {
    assert("Pureish", node, opts);
  }
  function assertDeclaration(node, opts) {
    assert("Declaration", node, opts);
  }
  function assertPatternLike(node, opts) {
    assert("PatternLike", node, opts);
  }
  function assertLVal(node, opts) {
    assert("LVal", node, opts);
  }
  function assertTSEntityName(node, opts) {
    assert("TSEntityName", node, opts);
  }
  function assertLiteral(node, opts) {
    assert("Literal", node, opts);
  }
  function assertImmutable(node, opts) {
    assert("Immutable", node, opts);
  }
  function assertUserWhitespacable(node, opts) {
    assert("UserWhitespacable", node, opts);
  }
  function assertMethod(node, opts) {
    assert("Method", node, opts);
  }
  function assertObjectMember(node, opts) {
    assert("ObjectMember", node, opts);
  }
  function assertProperty(node, opts) {
    assert("Property", node, opts);
  }
  function assertUnaryLike(node, opts) {
    assert("UnaryLike", node, opts);
  }
  function assertPattern(node, opts) {
    assert("Pattern", node, opts);
  }
  function assertClass(node, opts) {
    assert("Class", node, opts);
  }
  function assertModuleDeclaration(node, opts) {
    assert("ModuleDeclaration", node, opts);
  }
  function assertExportDeclaration(node, opts) {
    assert("ExportDeclaration", node, opts);
  }
  function assertModuleSpecifier(node, opts) {
    assert("ModuleSpecifier", node, opts);
  }
  function assertAccessor(node, opts) {
    assert("Accessor", node, opts);
  }
  function assertPrivate(node, opts) {
    assert("Private", node, opts);
  }
  function assertFlow(node, opts) {
    assert("Flow", node, opts);
  }
  function assertFlowType(node, opts) {
    assert("FlowType", node, opts);
  }
  function assertFlowBaseAnnotation(node, opts) {
    assert("FlowBaseAnnotation", node, opts);
  }
  function assertFlowDeclaration(node, opts) {
    assert("FlowDeclaration", node, opts);
  }
  function assertFlowPredicate(node, opts) {
    assert("FlowPredicate", node, opts);
  }
  function assertEnumBody(node, opts) {
    assert("EnumBody", node, opts);
  }
  function assertEnumMember(node, opts) {
    assert("EnumMember", node, opts);
  }
  function assertJSX(node, opts) {
    assert("JSX", node, opts);
  }
  function assertMiscellaneous(node, opts) {
    assert("Miscellaneous", node, opts);
  }
  function assertTypeScript(node, opts) {
    assert("TypeScript", node, opts);
  }
  function assertTSTypeElement(node, opts) {
    assert("TSTypeElement", node, opts);
  }
  function assertTSType(node, opts) {
    assert("TSType", node, opts);
  }
  function assertTSBaseType(node, opts) {
    assert("TSBaseType", node, opts);
  }
  function assertNumberLiteral(node, opts) {
    console.trace(
      "The node type NumberLiteral has been renamed to NumericLiteral"
    );
    assert("NumberLiteral", node, opts);
  }
  function assertRegexLiteral(node, opts) {
    console.trace(
      "The node type RegexLiteral has been renamed to RegExpLiteral"
    );
    assert("RegexLiteral", node, opts);
  }
  function assertRestProperty(node, opts) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    assert("RestProperty", node, opts);
  }
  function assertSpreadProperty(node, opts) {
    console.trace(
      "The node type SpreadProperty has been renamed to SpreadElement"
    );
    assert("SpreadProperty", node, opts);
  }
  return generated$2;
}
var createTypeAnnotationBasedOnTypeof = {};
var hasRequiredCreateTypeAnnotationBasedOnTypeof;
function requireCreateTypeAnnotationBasedOnTypeof() {
  if (hasRequiredCreateTypeAnnotationBasedOnTypeof)
    return createTypeAnnotationBasedOnTypeof;
  hasRequiredCreateTypeAnnotationBasedOnTypeof = 1;
  Object.defineProperty(createTypeAnnotationBasedOnTypeof, "__esModule", {
    value: true,
  });
  createTypeAnnotationBasedOnTypeof.default = void 0;
  var _generated = requireGenerated$3();
  var _default = createTypeAnnotationBasedOnTypeof$1;
  createTypeAnnotationBasedOnTypeof.default = _default;
  function createTypeAnnotationBasedOnTypeof$1(type) {
    switch (type) {
      case "string":
        return (0, _generated.stringTypeAnnotation)();
      case "number":
        return (0, _generated.numberTypeAnnotation)();
      case "undefined":
        return (0, _generated.voidTypeAnnotation)();
      case "boolean":
        return (0, _generated.booleanTypeAnnotation)();
      case "function":
        return (0, _generated.genericTypeAnnotation)(
          (0, _generated.identifier)("Function")
        );
      case "object":
        return (0, _generated.genericTypeAnnotation)(
          (0, _generated.identifier)("Object")
        );
      case "symbol":
        return (0, _generated.genericTypeAnnotation)(
          (0, _generated.identifier)("Symbol")
        );
      case "bigint":
        return (0, _generated.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + type);
  }
  return createTypeAnnotationBasedOnTypeof;
}
var createFlowUnionType = {};
var removeTypeDuplicates$1 = {};
var hasRequiredRemoveTypeDuplicates$1;
function requireRemoveTypeDuplicates$1() {
  if (hasRequiredRemoveTypeDuplicates$1) return removeTypeDuplicates$1;
  hasRequiredRemoveTypeDuplicates$1 = 1;
  Object.defineProperty(removeTypeDuplicates$1, "__esModule", { value: true });
  removeTypeDuplicates$1.default = removeTypeDuplicates;
  var _generated = requireGenerated$4();
  function getQualifiedName(node) {
    return (0, _generated.isIdentifier)(node)
      ? node.name
      : `${node.id.name}.${getQualifiedName(node.qualification)}`;
  }
  function removeTypeDuplicates(nodes) {
    const generics = new Map();
    const bases = new Map();
    const typeGroups = new Set();
    const types = [];
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (!node) continue;
      if (types.indexOf(node) >= 0) {
        continue;
      }
      if ((0, _generated.isAnyTypeAnnotation)(node)) {
        return [node];
      }
      if ((0, _generated.isFlowBaseAnnotation)(node)) {
        bases.set(node.type, node);
        continue;
      }
      if ((0, _generated.isUnionTypeAnnotation)(node)) {
        if (!typeGroups.has(node.types)) {
          nodes = nodes.concat(node.types);
          typeGroups.add(node.types);
        }
        continue;
      }
      if ((0, _generated.isGenericTypeAnnotation)(node)) {
        const name = getQualifiedName(node.id);
        if (generics.has(name)) {
          let existing = generics.get(name);
          if (existing.typeParameters) {
            if (node.typeParameters) {
              existing.typeParameters.params = removeTypeDuplicates(
                existing.typeParameters.params.concat(
                  node.typeParameters.params
                )
              );
            }
          } else {
            existing = node.typeParameters;
          }
        } else {
          generics.set(name, node);
        }
        continue;
      }
      types.push(node);
    }
    for (const [, baseType] of bases) {
      types.push(baseType);
    }
    for (const [, genericName] of generics) {
      types.push(genericName);
    }
    return types;
  }
  return removeTypeDuplicates$1;
}
var hasRequiredCreateFlowUnionType;
function requireCreateFlowUnionType() {
  if (hasRequiredCreateFlowUnionType) return createFlowUnionType;
  hasRequiredCreateFlowUnionType = 1;
  Object.defineProperty(createFlowUnionType, "__esModule", { value: true });
  createFlowUnionType.default = createFlowUnionType$1;
  var _generated = requireGenerated$3();
  var _removeTypeDuplicates = requireRemoveTypeDuplicates$1();
  function createFlowUnionType$1(types) {
    const flattened = (0, _removeTypeDuplicates.default)(types);
    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return (0, _generated.unionTypeAnnotation)(flattened);
    }
  }
  return createFlowUnionType;
}
var createTSUnionType = {};
var removeTypeDuplicates = {};
var hasRequiredRemoveTypeDuplicates;
function requireRemoveTypeDuplicates() {
  if (hasRequiredRemoveTypeDuplicates) return removeTypeDuplicates;
  hasRequiredRemoveTypeDuplicates = 1;
  Object.defineProperty(removeTypeDuplicates, "__esModule", { value: true });
  removeTypeDuplicates.default = removeTypeDuplicates$1;
  var _generated = requireGenerated$4();
  function getQualifiedName(node) {
    return (0, _generated.isIdentifier)(node)
      ? node.name
      : `${node.right.name}.${getQualifiedName(node.left)}`;
  }
  function removeTypeDuplicates$1(nodes) {
    const generics = new Map();
    const bases = new Map();
    const typeGroups = new Set();
    const types = [];
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (!node) continue;
      if (types.indexOf(node) >= 0) {
        continue;
      }
      if ((0, _generated.isTSAnyKeyword)(node)) {
        return [node];
      }
      if ((0, _generated.isTSBaseType)(node)) {
        bases.set(node.type, node);
        continue;
      }
      if ((0, _generated.isTSUnionType)(node)) {
        if (!typeGroups.has(node.types)) {
          nodes.push(...node.types);
          typeGroups.add(node.types);
        }
        continue;
      }
      if ((0, _generated.isTSTypeReference)(node) && node.typeParameters) {
        const name = getQualifiedName(node.typeName);
        if (generics.has(name)) {
          let existing = generics.get(name);
          if (existing.typeParameters) {
            if (node.typeParameters) {
              existing.typeParameters.params = removeTypeDuplicates$1(
                existing.typeParameters.params.concat(
                  node.typeParameters.params
                )
              );
            }
          } else {
            existing = node.typeParameters;
          }
        } else {
          generics.set(name, node);
        }
        continue;
      }
      types.push(node);
    }
    for (const [, baseType] of bases) {
      types.push(baseType);
    }
    for (const [, genericName] of generics) {
      types.push(genericName);
    }
    return types;
  }
  return removeTypeDuplicates;
}
var hasRequiredCreateTSUnionType;
function requireCreateTSUnionType() {
  if (hasRequiredCreateTSUnionType) return createTSUnionType;
  hasRequiredCreateTSUnionType = 1;
  Object.defineProperty(createTSUnionType, "__esModule", { value: true });
  createTSUnionType.default = createTSUnionType$1;
  var _generated = requireGenerated$3();
  var _removeTypeDuplicates = requireRemoveTypeDuplicates();
  var _index = requireGenerated$4();
  function createTSUnionType$1(typeAnnotations) {
    const types = typeAnnotations.map((type) =>
      (0, _index.isTSTypeAnnotation)(type) ? type.typeAnnotation : type
    );
    const flattened = (0, _removeTypeDuplicates.default)(types);
    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return (0, _generated.tsUnionType)(flattened);
    }
  }
  return createTSUnionType;
}
var uppercase = {};
var hasRequiredUppercase;
function requireUppercase() {
  if (hasRequiredUppercase) return uppercase;
  hasRequiredUppercase = 1;
  (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    Object.defineProperty(exports, "AnyTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.anyTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "ArgumentPlaceholder", {
      enumerable: true,
      get: function () {
        return _index.argumentPlaceholder;
      },
    });
    Object.defineProperty(exports, "ArrayExpression", {
      enumerable: true,
      get: function () {
        return _index.arrayExpression;
      },
    });
    Object.defineProperty(exports, "ArrayPattern", {
      enumerable: true,
      get: function () {
        return _index.arrayPattern;
      },
    });
    Object.defineProperty(exports, "ArrayTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.arrayTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "ArrowFunctionExpression", {
      enumerable: true,
      get: function () {
        return _index.arrowFunctionExpression;
      },
    });
    Object.defineProperty(exports, "AssignmentExpression", {
      enumerable: true,
      get: function () {
        return _index.assignmentExpression;
      },
    });
    Object.defineProperty(exports, "AssignmentPattern", {
      enumerable: true,
      get: function () {
        return _index.assignmentPattern;
      },
    });
    Object.defineProperty(exports, "AwaitExpression", {
      enumerable: true,
      get: function () {
        return _index.awaitExpression;
      },
    });
    Object.defineProperty(exports, "BigIntLiteral", {
      enumerable: true,
      get: function () {
        return _index.bigIntLiteral;
      },
    });
    Object.defineProperty(exports, "BinaryExpression", {
      enumerable: true,
      get: function () {
        return _index.binaryExpression;
      },
    });
    Object.defineProperty(exports, "BindExpression", {
      enumerable: true,
      get: function () {
        return _index.bindExpression;
      },
    });
    Object.defineProperty(exports, "BlockStatement", {
      enumerable: true,
      get: function () {
        return _index.blockStatement;
      },
    });
    Object.defineProperty(exports, "BooleanLiteral", {
      enumerable: true,
      get: function () {
        return _index.booleanLiteral;
      },
    });
    Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.booleanLiteralTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "BooleanTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.booleanTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "BreakStatement", {
      enumerable: true,
      get: function () {
        return _index.breakStatement;
      },
    });
    Object.defineProperty(exports, "CallExpression", {
      enumerable: true,
      get: function () {
        return _index.callExpression;
      },
    });
    Object.defineProperty(exports, "CatchClause", {
      enumerable: true,
      get: function () {
        return _index.catchClause;
      },
    });
    Object.defineProperty(exports, "ClassAccessorProperty", {
      enumerable: true,
      get: function () {
        return _index.classAccessorProperty;
      },
    });
    Object.defineProperty(exports, "ClassBody", {
      enumerable: true,
      get: function () {
        return _index.classBody;
      },
    });
    Object.defineProperty(exports, "ClassDeclaration", {
      enumerable: true,
      get: function () {
        return _index.classDeclaration;
      },
    });
    Object.defineProperty(exports, "ClassExpression", {
      enumerable: true,
      get: function () {
        return _index.classExpression;
      },
    });
    Object.defineProperty(exports, "ClassImplements", {
      enumerable: true,
      get: function () {
        return _index.classImplements;
      },
    });
    Object.defineProperty(exports, "ClassMethod", {
      enumerable: true,
      get: function () {
        return _index.classMethod;
      },
    });
    Object.defineProperty(exports, "ClassPrivateMethod", {
      enumerable: true,
      get: function () {
        return _index.classPrivateMethod;
      },
    });
    Object.defineProperty(exports, "ClassPrivateProperty", {
      enumerable: true,
      get: function () {
        return _index.classPrivateProperty;
      },
    });
    Object.defineProperty(exports, "ClassProperty", {
      enumerable: true,
      get: function () {
        return _index.classProperty;
      },
    });
    Object.defineProperty(exports, "ConditionalExpression", {
      enumerable: true,
      get: function () {
        return _index.conditionalExpression;
      },
    });
    Object.defineProperty(exports, "ContinueStatement", {
      enumerable: true,
      get: function () {
        return _index.continueStatement;
      },
    });
    Object.defineProperty(exports, "DebuggerStatement", {
      enumerable: true,
      get: function () {
        return _index.debuggerStatement;
      },
    });
    Object.defineProperty(exports, "DecimalLiteral", {
      enumerable: true,
      get: function () {
        return _index.decimalLiteral;
      },
    });
    Object.defineProperty(exports, "DeclareClass", {
      enumerable: true,
      get: function () {
        return _index.declareClass;
      },
    });
    Object.defineProperty(exports, "DeclareExportAllDeclaration", {
      enumerable: true,
      get: function () {
        return _index.declareExportAllDeclaration;
      },
    });
    Object.defineProperty(exports, "DeclareExportDeclaration", {
      enumerable: true,
      get: function () {
        return _index.declareExportDeclaration;
      },
    });
    Object.defineProperty(exports, "DeclareFunction", {
      enumerable: true,
      get: function () {
        return _index.declareFunction;
      },
    });
    Object.defineProperty(exports, "DeclareInterface", {
      enumerable: true,
      get: function () {
        return _index.declareInterface;
      },
    });
    Object.defineProperty(exports, "DeclareModule", {
      enumerable: true,
      get: function () {
        return _index.declareModule;
      },
    });
    Object.defineProperty(exports, "DeclareModuleExports", {
      enumerable: true,
      get: function () {
        return _index.declareModuleExports;
      },
    });
    Object.defineProperty(exports, "DeclareOpaqueType", {
      enumerable: true,
      get: function () {
        return _index.declareOpaqueType;
      },
    });
    Object.defineProperty(exports, "DeclareTypeAlias", {
      enumerable: true,
      get: function () {
        return _index.declareTypeAlias;
      },
    });
    Object.defineProperty(exports, "DeclareVariable", {
      enumerable: true,
      get: function () {
        return _index.declareVariable;
      },
    });
    Object.defineProperty(exports, "DeclaredPredicate", {
      enumerable: true,
      get: function () {
        return _index.declaredPredicate;
      },
    });
    Object.defineProperty(exports, "Decorator", {
      enumerable: true,
      get: function () {
        return _index.decorator;
      },
    });
    Object.defineProperty(exports, "Directive", {
      enumerable: true,
      get: function () {
        return _index.directive;
      },
    });
    Object.defineProperty(exports, "DirectiveLiteral", {
      enumerable: true,
      get: function () {
        return _index.directiveLiteral;
      },
    });
    Object.defineProperty(exports, "DoExpression", {
      enumerable: true,
      get: function () {
        return _index.doExpression;
      },
    });
    Object.defineProperty(exports, "DoWhileStatement", {
      enumerable: true,
      get: function () {
        return _index.doWhileStatement;
      },
    });
    Object.defineProperty(exports, "EmptyStatement", {
      enumerable: true,
      get: function () {
        return _index.emptyStatement;
      },
    });
    Object.defineProperty(exports, "EmptyTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.emptyTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "EnumBooleanBody", {
      enumerable: true,
      get: function () {
        return _index.enumBooleanBody;
      },
    });
    Object.defineProperty(exports, "EnumBooleanMember", {
      enumerable: true,
      get: function () {
        return _index.enumBooleanMember;
      },
    });
    Object.defineProperty(exports, "EnumDeclaration", {
      enumerable: true,
      get: function () {
        return _index.enumDeclaration;
      },
    });
    Object.defineProperty(exports, "EnumDefaultedMember", {
      enumerable: true,
      get: function () {
        return _index.enumDefaultedMember;
      },
    });
    Object.defineProperty(exports, "EnumNumberBody", {
      enumerable: true,
      get: function () {
        return _index.enumNumberBody;
      },
    });
    Object.defineProperty(exports, "EnumNumberMember", {
      enumerable: true,
      get: function () {
        return _index.enumNumberMember;
      },
    });
    Object.defineProperty(exports, "EnumStringBody", {
      enumerable: true,
      get: function () {
        return _index.enumStringBody;
      },
    });
    Object.defineProperty(exports, "EnumStringMember", {
      enumerable: true,
      get: function () {
        return _index.enumStringMember;
      },
    });
    Object.defineProperty(exports, "EnumSymbolBody", {
      enumerable: true,
      get: function () {
        return _index.enumSymbolBody;
      },
    });
    Object.defineProperty(exports, "ExistsTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.existsTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "ExportAllDeclaration", {
      enumerable: true,
      get: function () {
        return _index.exportAllDeclaration;
      },
    });
    Object.defineProperty(exports, "ExportDefaultDeclaration", {
      enumerable: true,
      get: function () {
        return _index.exportDefaultDeclaration;
      },
    });
    Object.defineProperty(exports, "ExportDefaultSpecifier", {
      enumerable: true,
      get: function () {
        return _index.exportDefaultSpecifier;
      },
    });
    Object.defineProperty(exports, "ExportNamedDeclaration", {
      enumerable: true,
      get: function () {
        return _index.exportNamedDeclaration;
      },
    });
    Object.defineProperty(exports, "ExportNamespaceSpecifier", {
      enumerable: true,
      get: function () {
        return _index.exportNamespaceSpecifier;
      },
    });
    Object.defineProperty(exports, "ExportSpecifier", {
      enumerable: true,
      get: function () {
        return _index.exportSpecifier;
      },
    });
    Object.defineProperty(exports, "ExpressionStatement", {
      enumerable: true,
      get: function () {
        return _index.expressionStatement;
      },
    });
    Object.defineProperty(exports, "File", {
      enumerable: true,
      get: function () {
        return _index.file;
      },
    });
    Object.defineProperty(exports, "ForInStatement", {
      enumerable: true,
      get: function () {
        return _index.forInStatement;
      },
    });
    Object.defineProperty(exports, "ForOfStatement", {
      enumerable: true,
      get: function () {
        return _index.forOfStatement;
      },
    });
    Object.defineProperty(exports, "ForStatement", {
      enumerable: true,
      get: function () {
        return _index.forStatement;
      },
    });
    Object.defineProperty(exports, "FunctionDeclaration", {
      enumerable: true,
      get: function () {
        return _index.functionDeclaration;
      },
    });
    Object.defineProperty(exports, "FunctionExpression", {
      enumerable: true,
      get: function () {
        return _index.functionExpression;
      },
    });
    Object.defineProperty(exports, "FunctionTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.functionTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "FunctionTypeParam", {
      enumerable: true,
      get: function () {
        return _index.functionTypeParam;
      },
    });
    Object.defineProperty(exports, "GenericTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.genericTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "Identifier", {
      enumerable: true,
      get: function () {
        return _index.identifier;
      },
    });
    Object.defineProperty(exports, "IfStatement", {
      enumerable: true,
      get: function () {
        return _index.ifStatement;
      },
    });
    Object.defineProperty(exports, "Import", {
      enumerable: true,
      get: function () {
        return _index.import;
      },
    });
    Object.defineProperty(exports, "ImportAttribute", {
      enumerable: true,
      get: function () {
        return _index.importAttribute;
      },
    });
    Object.defineProperty(exports, "ImportDeclaration", {
      enumerable: true,
      get: function () {
        return _index.importDeclaration;
      },
    });
    Object.defineProperty(exports, "ImportDefaultSpecifier", {
      enumerable: true,
      get: function () {
        return _index.importDefaultSpecifier;
      },
    });
    Object.defineProperty(exports, "ImportNamespaceSpecifier", {
      enumerable: true,
      get: function () {
        return _index.importNamespaceSpecifier;
      },
    });
    Object.defineProperty(exports, "ImportSpecifier", {
      enumerable: true,
      get: function () {
        return _index.importSpecifier;
      },
    });
    Object.defineProperty(exports, "IndexedAccessType", {
      enumerable: true,
      get: function () {
        return _index.indexedAccessType;
      },
    });
    Object.defineProperty(exports, "InferredPredicate", {
      enumerable: true,
      get: function () {
        return _index.inferredPredicate;
      },
    });
    Object.defineProperty(exports, "InterfaceDeclaration", {
      enumerable: true,
      get: function () {
        return _index.interfaceDeclaration;
      },
    });
    Object.defineProperty(exports, "InterfaceExtends", {
      enumerable: true,
      get: function () {
        return _index.interfaceExtends;
      },
    });
    Object.defineProperty(exports, "InterfaceTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.interfaceTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "InterpreterDirective", {
      enumerable: true,
      get: function () {
        return _index.interpreterDirective;
      },
    });
    Object.defineProperty(exports, "IntersectionTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.intersectionTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "JSXAttribute", {
      enumerable: true,
      get: function () {
        return _index.jsxAttribute;
      },
    });
    Object.defineProperty(exports, "JSXClosingElement", {
      enumerable: true,
      get: function () {
        return _index.jsxClosingElement;
      },
    });
    Object.defineProperty(exports, "JSXClosingFragment", {
      enumerable: true,
      get: function () {
        return _index.jsxClosingFragment;
      },
    });
    Object.defineProperty(exports, "JSXElement", {
      enumerable: true,
      get: function () {
        return _index.jsxElement;
      },
    });
    Object.defineProperty(exports, "JSXEmptyExpression", {
      enumerable: true,
      get: function () {
        return _index.jsxEmptyExpression;
      },
    });
    Object.defineProperty(exports, "JSXExpressionContainer", {
      enumerable: true,
      get: function () {
        return _index.jsxExpressionContainer;
      },
    });
    Object.defineProperty(exports, "JSXFragment", {
      enumerable: true,
      get: function () {
        return _index.jsxFragment;
      },
    });
    Object.defineProperty(exports, "JSXIdentifier", {
      enumerable: true,
      get: function () {
        return _index.jsxIdentifier;
      },
    });
    Object.defineProperty(exports, "JSXMemberExpression", {
      enumerable: true,
      get: function () {
        return _index.jsxMemberExpression;
      },
    });
    Object.defineProperty(exports, "JSXNamespacedName", {
      enumerable: true,
      get: function () {
        return _index.jsxNamespacedName;
      },
    });
    Object.defineProperty(exports, "JSXOpeningElement", {
      enumerable: true,
      get: function () {
        return _index.jsxOpeningElement;
      },
    });
    Object.defineProperty(exports, "JSXOpeningFragment", {
      enumerable: true,
      get: function () {
        return _index.jsxOpeningFragment;
      },
    });
    Object.defineProperty(exports, "JSXSpreadAttribute", {
      enumerable: true,
      get: function () {
        return _index.jsxSpreadAttribute;
      },
    });
    Object.defineProperty(exports, "JSXSpreadChild", {
      enumerable: true,
      get: function () {
        return _index.jsxSpreadChild;
      },
    });
    Object.defineProperty(exports, "JSXText", {
      enumerable: true,
      get: function () {
        return _index.jsxText;
      },
    });
    Object.defineProperty(exports, "LabeledStatement", {
      enumerable: true,
      get: function () {
        return _index.labeledStatement;
      },
    });
    Object.defineProperty(exports, "LogicalExpression", {
      enumerable: true,
      get: function () {
        return _index.logicalExpression;
      },
    });
    Object.defineProperty(exports, "MemberExpression", {
      enumerable: true,
      get: function () {
        return _index.memberExpression;
      },
    });
    Object.defineProperty(exports, "MetaProperty", {
      enumerable: true,
      get: function () {
        return _index.metaProperty;
      },
    });
    Object.defineProperty(exports, "MixedTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.mixedTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "ModuleExpression", {
      enumerable: true,
      get: function () {
        return _index.moduleExpression;
      },
    });
    Object.defineProperty(exports, "NewExpression", {
      enumerable: true,
      get: function () {
        return _index.newExpression;
      },
    });
    Object.defineProperty(exports, "Noop", {
      enumerable: true,
      get: function () {
        return _index.noop;
      },
    });
    Object.defineProperty(exports, "NullLiteral", {
      enumerable: true,
      get: function () {
        return _index.nullLiteral;
      },
    });
    Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.nullLiteralTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "NullableTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.nullableTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "NumberLiteral", {
      enumerable: true,
      get: function () {
        return _index.numberLiteral;
      },
    });
    Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.numberLiteralTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "NumberTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.numberTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "NumericLiteral", {
      enumerable: true,
      get: function () {
        return _index.numericLiteral;
      },
    });
    Object.defineProperty(exports, "ObjectExpression", {
      enumerable: true,
      get: function () {
        return _index.objectExpression;
      },
    });
    Object.defineProperty(exports, "ObjectMethod", {
      enumerable: true,
      get: function () {
        return _index.objectMethod;
      },
    });
    Object.defineProperty(exports, "ObjectPattern", {
      enumerable: true,
      get: function () {
        return _index.objectPattern;
      },
    });
    Object.defineProperty(exports, "ObjectProperty", {
      enumerable: true,
      get: function () {
        return _index.objectProperty;
      },
    });
    Object.defineProperty(exports, "ObjectTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.objectTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "ObjectTypeCallProperty", {
      enumerable: true,
      get: function () {
        return _index.objectTypeCallProperty;
      },
    });
    Object.defineProperty(exports, "ObjectTypeIndexer", {
      enumerable: true,
      get: function () {
        return _index.objectTypeIndexer;
      },
    });
    Object.defineProperty(exports, "ObjectTypeInternalSlot", {
      enumerable: true,
      get: function () {
        return _index.objectTypeInternalSlot;
      },
    });
    Object.defineProperty(exports, "ObjectTypeProperty", {
      enumerable: true,
      get: function () {
        return _index.objectTypeProperty;
      },
    });
    Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
      enumerable: true,
      get: function () {
        return _index.objectTypeSpreadProperty;
      },
    });
    Object.defineProperty(exports, "OpaqueType", {
      enumerable: true,
      get: function () {
        return _index.opaqueType;
      },
    });
    Object.defineProperty(exports, "OptionalCallExpression", {
      enumerable: true,
      get: function () {
        return _index.optionalCallExpression;
      },
    });
    Object.defineProperty(exports, "OptionalIndexedAccessType", {
      enumerable: true,
      get: function () {
        return _index.optionalIndexedAccessType;
      },
    });
    Object.defineProperty(exports, "OptionalMemberExpression", {
      enumerable: true,
      get: function () {
        return _index.optionalMemberExpression;
      },
    });
    Object.defineProperty(exports, "ParenthesizedExpression", {
      enumerable: true,
      get: function () {
        return _index.parenthesizedExpression;
      },
    });
    Object.defineProperty(exports, "PipelineBareFunction", {
      enumerable: true,
      get: function () {
        return _index.pipelineBareFunction;
      },
    });
    Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
      enumerable: true,
      get: function () {
        return _index.pipelinePrimaryTopicReference;
      },
    });
    Object.defineProperty(exports, "PipelineTopicExpression", {
      enumerable: true,
      get: function () {
        return _index.pipelineTopicExpression;
      },
    });
    Object.defineProperty(exports, "Placeholder", {
      enumerable: true,
      get: function () {
        return _index.placeholder;
      },
    });
    Object.defineProperty(exports, "PrivateName", {
      enumerable: true,
      get: function () {
        return _index.privateName;
      },
    });
    Object.defineProperty(exports, "Program", {
      enumerable: true,
      get: function () {
        return _index.program;
      },
    });
    Object.defineProperty(exports, "QualifiedTypeIdentifier", {
      enumerable: true,
      get: function () {
        return _index.qualifiedTypeIdentifier;
      },
    });
    Object.defineProperty(exports, "RecordExpression", {
      enumerable: true,
      get: function () {
        return _index.recordExpression;
      },
    });
    Object.defineProperty(exports, "RegExpLiteral", {
      enumerable: true,
      get: function () {
        return _index.regExpLiteral;
      },
    });
    Object.defineProperty(exports, "RegexLiteral", {
      enumerable: true,
      get: function () {
        return _index.regexLiteral;
      },
    });
    Object.defineProperty(exports, "RestElement", {
      enumerable: true,
      get: function () {
        return _index.restElement;
      },
    });
    Object.defineProperty(exports, "RestProperty", {
      enumerable: true,
      get: function () {
        return _index.restProperty;
      },
    });
    Object.defineProperty(exports, "ReturnStatement", {
      enumerable: true,
      get: function () {
        return _index.returnStatement;
      },
    });
    Object.defineProperty(exports, "SequenceExpression", {
      enumerable: true,
      get: function () {
        return _index.sequenceExpression;
      },
    });
    Object.defineProperty(exports, "SpreadElement", {
      enumerable: true,
      get: function () {
        return _index.spreadElement;
      },
    });
    Object.defineProperty(exports, "SpreadProperty", {
      enumerable: true,
      get: function () {
        return _index.spreadProperty;
      },
    });
    Object.defineProperty(exports, "StaticBlock", {
      enumerable: true,
      get: function () {
        return _index.staticBlock;
      },
    });
    Object.defineProperty(exports, "StringLiteral", {
      enumerable: true,
      get: function () {
        return _index.stringLiteral;
      },
    });
    Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.stringLiteralTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "StringTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.stringTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "Super", {
      enumerable: true,
      get: function () {
        return _index.super;
      },
    });
    Object.defineProperty(exports, "SwitchCase", {
      enumerable: true,
      get: function () {
        return _index.switchCase;
      },
    });
    Object.defineProperty(exports, "SwitchStatement", {
      enumerable: true,
      get: function () {
        return _index.switchStatement;
      },
    });
    Object.defineProperty(exports, "SymbolTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.symbolTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "TSAnyKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsAnyKeyword;
      },
    });
    Object.defineProperty(exports, "TSArrayType", {
      enumerable: true,
      get: function () {
        return _index.tsArrayType;
      },
    });
    Object.defineProperty(exports, "TSAsExpression", {
      enumerable: true,
      get: function () {
        return _index.tsAsExpression;
      },
    });
    Object.defineProperty(exports, "TSBigIntKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsBigIntKeyword;
      },
    });
    Object.defineProperty(exports, "TSBooleanKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsBooleanKeyword;
      },
    });
    Object.defineProperty(exports, "TSCallSignatureDeclaration", {
      enumerable: true,
      get: function () {
        return _index.tsCallSignatureDeclaration;
      },
    });
    Object.defineProperty(exports, "TSConditionalType", {
      enumerable: true,
      get: function () {
        return _index.tsConditionalType;
      },
    });
    Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
      enumerable: true,
      get: function () {
        return _index.tsConstructSignatureDeclaration;
      },
    });
    Object.defineProperty(exports, "TSConstructorType", {
      enumerable: true,
      get: function () {
        return _index.tsConstructorType;
      },
    });
    Object.defineProperty(exports, "TSDeclareFunction", {
      enumerable: true,
      get: function () {
        return _index.tsDeclareFunction;
      },
    });
    Object.defineProperty(exports, "TSDeclareMethod", {
      enumerable: true,
      get: function () {
        return _index.tsDeclareMethod;
      },
    });
    Object.defineProperty(exports, "TSEnumDeclaration", {
      enumerable: true,
      get: function () {
        return _index.tsEnumDeclaration;
      },
    });
    Object.defineProperty(exports, "TSEnumMember", {
      enumerable: true,
      get: function () {
        return _index.tsEnumMember;
      },
    });
    Object.defineProperty(exports, "TSExportAssignment", {
      enumerable: true,
      get: function () {
        return _index.tsExportAssignment;
      },
    });
    Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
      enumerable: true,
      get: function () {
        return _index.tsExpressionWithTypeArguments;
      },
    });
    Object.defineProperty(exports, "TSExternalModuleReference", {
      enumerable: true,
      get: function () {
        return _index.tsExternalModuleReference;
      },
    });
    Object.defineProperty(exports, "TSFunctionType", {
      enumerable: true,
      get: function () {
        return _index.tsFunctionType;
      },
    });
    Object.defineProperty(exports, "TSImportEqualsDeclaration", {
      enumerable: true,
      get: function () {
        return _index.tsImportEqualsDeclaration;
      },
    });
    Object.defineProperty(exports, "TSImportType", {
      enumerable: true,
      get: function () {
        return _index.tsImportType;
      },
    });
    Object.defineProperty(exports, "TSIndexSignature", {
      enumerable: true,
      get: function () {
        return _index.tsIndexSignature;
      },
    });
    Object.defineProperty(exports, "TSIndexedAccessType", {
      enumerable: true,
      get: function () {
        return _index.tsIndexedAccessType;
      },
    });
    Object.defineProperty(exports, "TSInferType", {
      enumerable: true,
      get: function () {
        return _index.tsInferType;
      },
    });
    Object.defineProperty(exports, "TSInstantiationExpression", {
      enumerable: true,
      get: function () {
        return _index.tsInstantiationExpression;
      },
    });
    Object.defineProperty(exports, "TSInterfaceBody", {
      enumerable: true,
      get: function () {
        return _index.tsInterfaceBody;
      },
    });
    Object.defineProperty(exports, "TSInterfaceDeclaration", {
      enumerable: true,
      get: function () {
        return _index.tsInterfaceDeclaration;
      },
    });
    Object.defineProperty(exports, "TSIntersectionType", {
      enumerable: true,
      get: function () {
        return _index.tsIntersectionType;
      },
    });
    Object.defineProperty(exports, "TSIntrinsicKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsIntrinsicKeyword;
      },
    });
    Object.defineProperty(exports, "TSLiteralType", {
      enumerable: true,
      get: function () {
        return _index.tsLiteralType;
      },
    });
    Object.defineProperty(exports, "TSMappedType", {
      enumerable: true,
      get: function () {
        return _index.tsMappedType;
      },
    });
    Object.defineProperty(exports, "TSMethodSignature", {
      enumerable: true,
      get: function () {
        return _index.tsMethodSignature;
      },
    });
    Object.defineProperty(exports, "TSModuleBlock", {
      enumerable: true,
      get: function () {
        return _index.tsModuleBlock;
      },
    });
    Object.defineProperty(exports, "TSModuleDeclaration", {
      enumerable: true,
      get: function () {
        return _index.tsModuleDeclaration;
      },
    });
    Object.defineProperty(exports, "TSNamedTupleMember", {
      enumerable: true,
      get: function () {
        return _index.tsNamedTupleMember;
      },
    });
    Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
      enumerable: true,
      get: function () {
        return _index.tsNamespaceExportDeclaration;
      },
    });
    Object.defineProperty(exports, "TSNeverKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsNeverKeyword;
      },
    });
    Object.defineProperty(exports, "TSNonNullExpression", {
      enumerable: true,
      get: function () {
        return _index.tsNonNullExpression;
      },
    });
    Object.defineProperty(exports, "TSNullKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsNullKeyword;
      },
    });
    Object.defineProperty(exports, "TSNumberKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsNumberKeyword;
      },
    });
    Object.defineProperty(exports, "TSObjectKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsObjectKeyword;
      },
    });
    Object.defineProperty(exports, "TSOptionalType", {
      enumerable: true,
      get: function () {
        return _index.tsOptionalType;
      },
    });
    Object.defineProperty(exports, "TSParameterProperty", {
      enumerable: true,
      get: function () {
        return _index.tsParameterProperty;
      },
    });
    Object.defineProperty(exports, "TSParenthesizedType", {
      enumerable: true,
      get: function () {
        return _index.tsParenthesizedType;
      },
    });
    Object.defineProperty(exports, "TSPropertySignature", {
      enumerable: true,
      get: function () {
        return _index.tsPropertySignature;
      },
    });
    Object.defineProperty(exports, "TSQualifiedName", {
      enumerable: true,
      get: function () {
        return _index.tsQualifiedName;
      },
    });
    Object.defineProperty(exports, "TSRestType", {
      enumerable: true,
      get: function () {
        return _index.tsRestType;
      },
    });
    Object.defineProperty(exports, "TSStringKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsStringKeyword;
      },
    });
    Object.defineProperty(exports, "TSSymbolKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsSymbolKeyword;
      },
    });
    Object.defineProperty(exports, "TSThisType", {
      enumerable: true,
      get: function () {
        return _index.tsThisType;
      },
    });
    Object.defineProperty(exports, "TSTupleType", {
      enumerable: true,
      get: function () {
        return _index.tsTupleType;
      },
    });
    Object.defineProperty(exports, "TSTypeAliasDeclaration", {
      enumerable: true,
      get: function () {
        return _index.tsTypeAliasDeclaration;
      },
    });
    Object.defineProperty(exports, "TSTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.tsTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "TSTypeAssertion", {
      enumerable: true,
      get: function () {
        return _index.tsTypeAssertion;
      },
    });
    Object.defineProperty(exports, "TSTypeLiteral", {
      enumerable: true,
      get: function () {
        return _index.tsTypeLiteral;
      },
    });
    Object.defineProperty(exports, "TSTypeOperator", {
      enumerable: true,
      get: function () {
        return _index.tsTypeOperator;
      },
    });
    Object.defineProperty(exports, "TSTypeParameter", {
      enumerable: true,
      get: function () {
        return _index.tsTypeParameter;
      },
    });
    Object.defineProperty(exports, "TSTypeParameterDeclaration", {
      enumerable: true,
      get: function () {
        return _index.tsTypeParameterDeclaration;
      },
    });
    Object.defineProperty(exports, "TSTypeParameterInstantiation", {
      enumerable: true,
      get: function () {
        return _index.tsTypeParameterInstantiation;
      },
    });
    Object.defineProperty(exports, "TSTypePredicate", {
      enumerable: true,
      get: function () {
        return _index.tsTypePredicate;
      },
    });
    Object.defineProperty(exports, "TSTypeQuery", {
      enumerable: true,
      get: function () {
        return _index.tsTypeQuery;
      },
    });
    Object.defineProperty(exports, "TSTypeReference", {
      enumerable: true,
      get: function () {
        return _index.tsTypeReference;
      },
    });
    Object.defineProperty(exports, "TSUndefinedKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsUndefinedKeyword;
      },
    });
    Object.defineProperty(exports, "TSUnionType", {
      enumerable: true,
      get: function () {
        return _index.tsUnionType;
      },
    });
    Object.defineProperty(exports, "TSUnknownKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsUnknownKeyword;
      },
    });
    Object.defineProperty(exports, "TSVoidKeyword", {
      enumerable: true,
      get: function () {
        return _index.tsVoidKeyword;
      },
    });
    Object.defineProperty(exports, "TaggedTemplateExpression", {
      enumerable: true,
      get: function () {
        return _index.taggedTemplateExpression;
      },
    });
    Object.defineProperty(exports, "TemplateElement", {
      enumerable: true,
      get: function () {
        return _index.templateElement;
      },
    });
    Object.defineProperty(exports, "TemplateLiteral", {
      enumerable: true,
      get: function () {
        return _index.templateLiteral;
      },
    });
    Object.defineProperty(exports, "ThisExpression", {
      enumerable: true,
      get: function () {
        return _index.thisExpression;
      },
    });
    Object.defineProperty(exports, "ThisTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.thisTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "ThrowStatement", {
      enumerable: true,
      get: function () {
        return _index.throwStatement;
      },
    });
    Object.defineProperty(exports, "TopicReference", {
      enumerable: true,
      get: function () {
        return _index.topicReference;
      },
    });
    Object.defineProperty(exports, "TryStatement", {
      enumerable: true,
      get: function () {
        return _index.tryStatement;
      },
    });
    Object.defineProperty(exports, "TupleExpression", {
      enumerable: true,
      get: function () {
        return _index.tupleExpression;
      },
    });
    Object.defineProperty(exports, "TupleTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.tupleTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "TypeAlias", {
      enumerable: true,
      get: function () {
        return _index.typeAlias;
      },
    });
    Object.defineProperty(exports, "TypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.typeAnnotation;
      },
    });
    Object.defineProperty(exports, "TypeCastExpression", {
      enumerable: true,
      get: function () {
        return _index.typeCastExpression;
      },
    });
    Object.defineProperty(exports, "TypeParameter", {
      enumerable: true,
      get: function () {
        return _index.typeParameter;
      },
    });
    Object.defineProperty(exports, "TypeParameterDeclaration", {
      enumerable: true,
      get: function () {
        return _index.typeParameterDeclaration;
      },
    });
    Object.defineProperty(exports, "TypeParameterInstantiation", {
      enumerable: true,
      get: function () {
        return _index.typeParameterInstantiation;
      },
    });
    Object.defineProperty(exports, "TypeofTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.typeofTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "UnaryExpression", {
      enumerable: true,
      get: function () {
        return _index.unaryExpression;
      },
    });
    Object.defineProperty(exports, "UnionTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.unionTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "UpdateExpression", {
      enumerable: true,
      get: function () {
        return _index.updateExpression;
      },
    });
    Object.defineProperty(exports, "V8IntrinsicIdentifier", {
      enumerable: true,
      get: function () {
        return _index.v8IntrinsicIdentifier;
      },
    });
    Object.defineProperty(exports, "VariableDeclaration", {
      enumerable: true,
      get: function () {
        return _index.variableDeclaration;
      },
    });
    Object.defineProperty(exports, "VariableDeclarator", {
      enumerable: true,
      get: function () {
        return _index.variableDeclarator;
      },
    });
    Object.defineProperty(exports, "Variance", {
      enumerable: true,
      get: function () {
        return _index.variance;
      },
    });
    Object.defineProperty(exports, "VoidTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _index.voidTypeAnnotation;
      },
    });
    Object.defineProperty(exports, "WhileStatement", {
      enumerable: true,
      get: function () {
        return _index.whileStatement;
      },
    });
    Object.defineProperty(exports, "WithStatement", {
      enumerable: true,
      get: function () {
        return _index.withStatement;
      },
    });
    Object.defineProperty(exports, "YieldExpression", {
      enumerable: true,
      get: function () {
        return _index.yieldExpression;
      },
    });
    var _index = requireGenerated$3();
  })(uppercase);
  return uppercase;
}
var cloneNode = {};
var hasRequiredCloneNode;
function requireCloneNode() {
  if (hasRequiredCloneNode) return cloneNode;
  hasRequiredCloneNode = 1;
  Object.defineProperty(cloneNode, "__esModule", { value: true });
  cloneNode.default = cloneNode$1;
  var _definitions = requireDefinitions();
  var _generated = requireGenerated$4();
  const has = Function.call.bind(Object.prototype.hasOwnProperty);
  function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
    if (obj && typeof obj.type === "string") {
      return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
    }
    return obj;
  }
  function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
    if (Array.isArray(obj)) {
      return obj.map((node) =>
        cloneIfNode(node, deep, withoutLoc, commentsCache)
      );
    }
    return cloneIfNode(obj, deep, withoutLoc, commentsCache);
  }
  function cloneNode$1(node, deep = true, withoutLoc = false) {
    return cloneNodeInternal(node, deep, withoutLoc, new Map());
  }
  function cloneNodeInternal(
    node,
    deep = true,
    withoutLoc = false,
    commentsCache
  ) {
    if (!node) return node;
    const { type: type } = node;
    const newNode = { type: node.type };
    if ((0, _generated.isIdentifier)(node)) {
      newNode.name = node.name;
      if (has(node, "optional") && typeof node.optional === "boolean") {
        newNode.optional = node.optional;
      }
      if (has(node, "typeAnnotation")) {
        newNode.typeAnnotation = deep
          ? cloneIfNodeOrArray(
              node.typeAnnotation,
              true,
              withoutLoc,
              commentsCache
            )
          : node.typeAnnotation;
      }
    } else if (!has(_definitions.NODE_FIELDS, type)) {
      throw new Error(`Unknown node type: "${type}"`);
    } else {
      for (const field of Object.keys(_definitions.NODE_FIELDS[type])) {
        if (has(node, field)) {
          if (deep) {
            newNode[field] =
              (0, _generated.isFile)(node) && field === "comments"
                ? maybeCloneComments(
                    node.comments,
                    deep,
                    withoutLoc,
                    commentsCache
                  )
                : cloneIfNodeOrArray(
                    node[field],
                    true,
                    withoutLoc,
                    commentsCache
                  );
          } else {
            newNode[field] = node[field];
          }
        }
      }
    }
    if (has(node, "loc")) {
      if (withoutLoc) {
        newNode.loc = null;
      } else {
        newNode.loc = node.loc;
      }
    }
    if (has(node, "leadingComments")) {
      newNode.leadingComments = maybeCloneComments(
        node.leadingComments,
        deep,
        withoutLoc,
        commentsCache
      );
    }
    if (has(node, "innerComments")) {
      newNode.innerComments = maybeCloneComments(
        node.innerComments,
        deep,
        withoutLoc,
        commentsCache
      );
    }
    if (has(node, "trailingComments")) {
      newNode.trailingComments = maybeCloneComments(
        node.trailingComments,
        deep,
        withoutLoc,
        commentsCache
      );
    }
    if (has(node, "extra")) {
      newNode.extra = Object.assign({}, node.extra);
    }
    return newNode;
  }
  function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
    if (!comments || !deep) {
      return comments;
    }
    return comments.map((comment) => {
      const cache = commentsCache.get(comment);
      if (cache) return cache;
      const { type: type, value: value, loc: loc } = comment;
      const ret = { type: type, value: value, loc: loc };
      if (withoutLoc) {
        ret.loc = null;
      }
      commentsCache.set(comment, ret);
      return ret;
    });
  }
  return cloneNode;
}
var clone = {};
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone) return clone;
  hasRequiredClone = 1;
  Object.defineProperty(clone, "__esModule", { value: true });
  clone.default = clone$1;
  var _cloneNode = requireCloneNode();
  function clone$1(node) {
    return (0, _cloneNode.default)(node, false);
  }
  return clone;
}
var cloneDeep = {};
var hasRequiredCloneDeep;
function requireCloneDeep() {
  if (hasRequiredCloneDeep) return cloneDeep;
  hasRequiredCloneDeep = 1;
  Object.defineProperty(cloneDeep, "__esModule", { value: true });
  cloneDeep.default = cloneDeep$1;
  var _cloneNode = requireCloneNode();
  function cloneDeep$1(node) {
    return (0, _cloneNode.default)(node);
  }
  return cloneDeep;
}
var cloneDeepWithoutLoc = {};
var hasRequiredCloneDeepWithoutLoc;
function requireCloneDeepWithoutLoc() {
  if (hasRequiredCloneDeepWithoutLoc) return cloneDeepWithoutLoc;
  hasRequiredCloneDeepWithoutLoc = 1;
  Object.defineProperty(cloneDeepWithoutLoc, "__esModule", { value: true });
  cloneDeepWithoutLoc.default = cloneDeepWithoutLoc$1;
  var _cloneNode = requireCloneNode();
  function cloneDeepWithoutLoc$1(node) {
    return (0, _cloneNode.default)(node, true, true);
  }
  return cloneDeepWithoutLoc;
}
var cloneWithoutLoc = {};
var hasRequiredCloneWithoutLoc;
function requireCloneWithoutLoc() {
  if (hasRequiredCloneWithoutLoc) return cloneWithoutLoc;
  hasRequiredCloneWithoutLoc = 1;
  Object.defineProperty(cloneWithoutLoc, "__esModule", { value: true });
  cloneWithoutLoc.default = cloneWithoutLoc$1;
  var _cloneNode = requireCloneNode();
  function cloneWithoutLoc$1(node) {
    return (0, _cloneNode.default)(node, false, true);
  }
  return cloneWithoutLoc;
}
var addComment = {};
var addComments = {};
var hasRequiredAddComments;
function requireAddComments() {
  if (hasRequiredAddComments) return addComments;
  hasRequiredAddComments = 1;
  Object.defineProperty(addComments, "__esModule", { value: true });
  addComments.default = addComments$1;
  function addComments$1(node, type, comments) {
    if (!comments || !node) return node;
    const key = `${type}Comments`;
    if (node[key]) {
      if (type === "leading") {
        node[key] = comments.concat(node[key]);
      } else {
        node[key].push(...comments);
      }
    } else {
      node[key] = comments;
    }
    return node;
  }
  return addComments;
}
var hasRequiredAddComment;
function requireAddComment() {
  if (hasRequiredAddComment) return addComment;
  hasRequiredAddComment = 1;
  Object.defineProperty(addComment, "__esModule", { value: true });
  addComment.default = addComment$1;
  var _addComments = requireAddComments();
  function addComment$1(node, type, content, line) {
    return (0, _addComments.default)(node, type, [
      { type: line ? "CommentLine" : "CommentBlock", value: content },
    ]);
  }
  return addComment;
}
var inheritInnerComments = {};
var inherit = {};
var hasRequiredInherit;
function requireInherit() {
  if (hasRequiredInherit) return inherit;
  hasRequiredInherit = 1;
  Object.defineProperty(inherit, "__esModule", { value: true });
  inherit.default = inherit$1;
  function inherit$1(key, child, parent) {
    if (child && parent) {
      child[key] = Array.from(
        new Set([].concat(child[key], parent[key]).filter(Boolean))
      );
    }
  }
  return inherit;
}
var hasRequiredInheritInnerComments;
function requireInheritInnerComments() {
  if (hasRequiredInheritInnerComments) return inheritInnerComments;
  hasRequiredInheritInnerComments = 1;
  Object.defineProperty(inheritInnerComments, "__esModule", { value: true });
  inheritInnerComments.default = inheritInnerComments$1;
  var _inherit = requireInherit();
  function inheritInnerComments$1(child, parent) {
    (0, _inherit.default)("innerComments", child, parent);
  }
  return inheritInnerComments;
}
var inheritLeadingComments = {};
var hasRequiredInheritLeadingComments;
function requireInheritLeadingComments() {
  if (hasRequiredInheritLeadingComments) return inheritLeadingComments;
  hasRequiredInheritLeadingComments = 1;
  Object.defineProperty(inheritLeadingComments, "__esModule", { value: true });
  inheritLeadingComments.default = inheritLeadingComments$1;
  var _inherit = requireInherit();
  function inheritLeadingComments$1(child, parent) {
    (0, _inherit.default)("leadingComments", child, parent);
  }
  return inheritLeadingComments;
}
var inheritsComments = {};
var inheritTrailingComments = {};
var hasRequiredInheritTrailingComments;
function requireInheritTrailingComments() {
  if (hasRequiredInheritTrailingComments) return inheritTrailingComments;
  hasRequiredInheritTrailingComments = 1;
  Object.defineProperty(inheritTrailingComments, "__esModule", { value: true });
  inheritTrailingComments.default = inheritTrailingComments$1;
  var _inherit = requireInherit();
  function inheritTrailingComments$1(child, parent) {
    (0, _inherit.default)("trailingComments", child, parent);
  }
  return inheritTrailingComments;
}
var hasRequiredInheritsComments;
function requireInheritsComments() {
  if (hasRequiredInheritsComments) return inheritsComments;
  hasRequiredInheritsComments = 1;
  Object.defineProperty(inheritsComments, "__esModule", { value: true });
  inheritsComments.default = inheritsComments$1;
  var _inheritTrailingComments = requireInheritTrailingComments();
  var _inheritLeadingComments = requireInheritLeadingComments();
  var _inheritInnerComments = requireInheritInnerComments();
  function inheritsComments$1(child, parent) {
    (0, _inheritTrailingComments.default)(child, parent);
    (0, _inheritLeadingComments.default)(child, parent);
    (0, _inheritInnerComments.default)(child, parent);
    return child;
  }
  return inheritsComments;
}
var removeComments = {};
var hasRequiredRemoveComments;
function requireRemoveComments() {
  if (hasRequiredRemoveComments) return removeComments;
  hasRequiredRemoveComments = 1;
  Object.defineProperty(removeComments, "__esModule", { value: true });
  removeComments.default = removeComments$1;
  var _constants = requireConstants();
  function removeComments$1(node) {
    _constants.COMMENT_KEYS.forEach((key) => {
      node[key] = null;
    });
    return node;
  }
  return removeComments;
}
var generated$1 = {};
var hasRequiredGenerated$1;
function requireGenerated$1() {
  if (hasRequiredGenerated$1) return generated$1;
  hasRequiredGenerated$1 = 1;
  Object.defineProperty(generated$1, "__esModule", { value: true });
  generated$1.WHILE_TYPES =
    generated$1.USERWHITESPACABLE_TYPES =
    generated$1.UNARYLIKE_TYPES =
    generated$1.TYPESCRIPT_TYPES =
    generated$1.TSTYPE_TYPES =
    generated$1.TSTYPEELEMENT_TYPES =
    generated$1.TSENTITYNAME_TYPES =
    generated$1.TSBASETYPE_TYPES =
    generated$1.TERMINATORLESS_TYPES =
    generated$1.STATEMENT_TYPES =
    generated$1.STANDARDIZED_TYPES =
    generated$1.SCOPABLE_TYPES =
    generated$1.PUREISH_TYPES =
    generated$1.PROPERTY_TYPES =
    generated$1.PRIVATE_TYPES =
    generated$1.PATTERN_TYPES =
    generated$1.PATTERNLIKE_TYPES =
    generated$1.OBJECTMEMBER_TYPES =
    generated$1.MODULESPECIFIER_TYPES =
    generated$1.MODULEDECLARATION_TYPES =
    generated$1.MISCELLANEOUS_TYPES =
    generated$1.METHOD_TYPES =
    generated$1.LVAL_TYPES =
    generated$1.LOOP_TYPES =
    generated$1.LITERAL_TYPES =
    generated$1.JSX_TYPES =
    generated$1.IMMUTABLE_TYPES =
    generated$1.FUNCTION_TYPES =
    generated$1.FUNCTIONPARENT_TYPES =
    generated$1.FOR_TYPES =
    generated$1.FORXSTATEMENT_TYPES =
    generated$1.FLOW_TYPES =
    generated$1.FLOWTYPE_TYPES =
    generated$1.FLOWPREDICATE_TYPES =
    generated$1.FLOWDECLARATION_TYPES =
    generated$1.FLOWBASEANNOTATION_TYPES =
    generated$1.EXPRESSION_TYPES =
    generated$1.EXPRESSIONWRAPPER_TYPES =
    generated$1.EXPORTDECLARATION_TYPES =
    generated$1.ENUMMEMBER_TYPES =
    generated$1.ENUMBODY_TYPES =
    generated$1.DECLARATION_TYPES =
    generated$1.CONDITIONAL_TYPES =
    generated$1.COMPLETIONSTATEMENT_TYPES =
    generated$1.CLASS_TYPES =
    generated$1.BLOCK_TYPES =
    generated$1.BLOCKPARENT_TYPES =
    generated$1.BINARY_TYPES =
    generated$1.ACCESSOR_TYPES =
      void 0;
  var _definitions = requireDefinitions();
  const STANDARDIZED_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Standardized"];
  generated$1.STANDARDIZED_TYPES = STANDARDIZED_TYPES;
  const EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Expression"];
  generated$1.EXPRESSION_TYPES = EXPRESSION_TYPES;
  const BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Binary"];
  generated$1.BINARY_TYPES = BINARY_TYPES;
  const SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Scopable"];
  generated$1.SCOPABLE_TYPES = SCOPABLE_TYPES;
  const BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["BlockParent"];
  generated$1.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
  const BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Block"];
  generated$1.BLOCK_TYPES = BLOCK_TYPES;
  const STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Statement"];
  generated$1.STATEMENT_TYPES = STATEMENT_TYPES;
  const TERMINATORLESS_TYPES =
    _definitions.FLIPPED_ALIAS_KEYS["Terminatorless"];
  generated$1.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
  const COMPLETIONSTATEMENT_TYPES =
    _definitions.FLIPPED_ALIAS_KEYS["CompletionStatement"];
  generated$1.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
  const CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Conditional"];
  generated$1.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
  const LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Loop"];
  generated$1.LOOP_TYPES = LOOP_TYPES;
  const WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["While"];
  generated$1.WHILE_TYPES = WHILE_TYPES;
  const EXPRESSIONWRAPPER_TYPES =
    _definitions.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
  generated$1.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
  const FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["For"];
  generated$1.FOR_TYPES = FOR_TYPES;
  const FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ForXStatement"];
  generated$1.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
  const FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Function"];
  generated$1.FUNCTION_TYPES = FUNCTION_TYPES;
  const FUNCTIONPARENT_TYPES =
    _definitions.FLIPPED_ALIAS_KEYS["FunctionParent"];
  generated$1.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
  const PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pureish"];
  generated$1.PUREISH_TYPES = PUREISH_TYPES;
  const DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Declaration"];
  generated$1.DECLARATION_TYPES = DECLARATION_TYPES;
  const PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["PatternLike"];
  generated$1.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
  const LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["LVal"];
  generated$1.LVAL_TYPES = LVAL_TYPES;
  const TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSEntityName"];
  generated$1.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
  const LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Literal"];
  generated$1.LITERAL_TYPES = LITERAL_TYPES;
  const IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Immutable"];
  generated$1.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
  const USERWHITESPACABLE_TYPES =
    _definitions.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
  generated$1.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
  const METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Method"];
  generated$1.METHOD_TYPES = METHOD_TYPES;
  const OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ObjectMember"];
  generated$1.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
  const PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Property"];
  generated$1.PROPERTY_TYPES = PROPERTY_TYPES;
  const UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UnaryLike"];
  generated$1.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
  const PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pattern"];
  generated$1.PATTERN_TYPES = PATTERN_TYPES;
  const CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Class"];
  generated$1.CLASS_TYPES = CLASS_TYPES;
  const MODULEDECLARATION_TYPES =
    _definitions.FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
  generated$1.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
  const EXPORTDECLARATION_TYPES =
    _definitions.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
  generated$1.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
  const MODULESPECIFIER_TYPES =
    _definitions.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
  generated$1.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
  const ACCESSOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Accessor"];
  generated$1.ACCESSOR_TYPES = ACCESSOR_TYPES;
  const PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Private"];
  generated$1.PRIVATE_TYPES = PRIVATE_TYPES;
  const FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Flow"];
  generated$1.FLOW_TYPES = FLOW_TYPES;
  const FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowType"];
  generated$1.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
  const FLOWBASEANNOTATION_TYPES =
    _definitions.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
  generated$1.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
  const FLOWDECLARATION_TYPES =
    _definitions.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
  generated$1.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
  const FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowPredicate"];
  generated$1.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
  const ENUMBODY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumBody"];
  generated$1.ENUMBODY_TYPES = ENUMBODY_TYPES;
  const ENUMMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumMember"];
  generated$1.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
  const JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS["JSX"];
  generated$1.JSX_TYPES = JSX_TYPES;
  const MISCELLANEOUS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Miscellaneous"];
  generated$1.MISCELLANEOUS_TYPES = MISCELLANEOUS_TYPES;
  const TYPESCRIPT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TypeScript"];
  generated$1.TYPESCRIPT_TYPES = TYPESCRIPT_TYPES;
  const TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSTypeElement"];
  generated$1.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
  const TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSType"];
  generated$1.TSTYPE_TYPES = TSTYPE_TYPES;
  const TSBASETYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSBaseType"];
  generated$1.TSBASETYPE_TYPES = TSBASETYPE_TYPES;
  return generated$1;
}
var ensureBlock = {};
var toBlock = {};
var hasRequiredToBlock;
function requireToBlock() {
  if (hasRequiredToBlock) return toBlock;
  hasRequiredToBlock = 1;
  Object.defineProperty(toBlock, "__esModule", { value: true });
  toBlock.default = toBlock$1;
  var _generated = requireGenerated$4();
  var _generated2 = requireGenerated$3();
  function toBlock$1(node, parent) {
    if ((0, _generated.isBlockStatement)(node)) {
      return node;
    }
    let blockNodes = [];
    if ((0, _generated.isEmptyStatement)(node)) {
      blockNodes = [];
    } else {
      if (!(0, _generated.isStatement)(node)) {
        if ((0, _generated.isFunction)(parent)) {
          node = (0, _generated2.returnStatement)(node);
        } else {
          node = (0, _generated2.expressionStatement)(node);
        }
      }
      blockNodes = [node];
    }
    return (0, _generated2.blockStatement)(blockNodes);
  }
  return toBlock;
}
var hasRequiredEnsureBlock;
function requireEnsureBlock() {
  if (hasRequiredEnsureBlock) return ensureBlock;
  hasRequiredEnsureBlock = 1;
  Object.defineProperty(ensureBlock, "__esModule", { value: true });
  ensureBlock.default = ensureBlock$1;
  var _toBlock = requireToBlock();
  function ensureBlock$1(node, key = "body") {
    const result = (0, _toBlock.default)(node[key], node);
    node[key] = result;
    return result;
  }
  return ensureBlock;
}
var toBindingIdentifierName = {};
var toIdentifier = {};
var hasRequiredToIdentifier;
function requireToIdentifier() {
  if (hasRequiredToIdentifier) return toIdentifier;
  hasRequiredToIdentifier = 1;
  Object.defineProperty(toIdentifier, "__esModule", { value: true });
  toIdentifier.default = toIdentifier$1;
  var _isValidIdentifier = requireIsValidIdentifier();
  var _helperValidatorIdentifier = lib$4;
  function toIdentifier$1(input) {
    input = input + "";
    let name = "";
    for (const c of input) {
      name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0))
        ? c
        : "-";
    }
    name = name.replace(/^[-0-9]+/, "");
    name = name.replace(/[-\s]+(.)?/g, function (match, c) {
      return c ? c.toUpperCase() : "";
    });
    if (!(0, _isValidIdentifier.default)(name)) {
      name = `_${name}`;
    }
    return name || "_";
  }
  return toIdentifier;
}
var hasRequiredToBindingIdentifierName;
function requireToBindingIdentifierName() {
  if (hasRequiredToBindingIdentifierName) return toBindingIdentifierName;
  hasRequiredToBindingIdentifierName = 1;
  Object.defineProperty(toBindingIdentifierName, "__esModule", { value: true });
  toBindingIdentifierName.default = toBindingIdentifierName$1;
  var _toIdentifier = requireToIdentifier();
  function toBindingIdentifierName$1(name) {
    name = (0, _toIdentifier.default)(name);
    if (name === "eval" || name === "arguments") name = "_" + name;
    return name;
  }
  return toBindingIdentifierName;
}
var toComputedKey = {};
var hasRequiredToComputedKey;
function requireToComputedKey() {
  if (hasRequiredToComputedKey) return toComputedKey;
  hasRequiredToComputedKey = 1;
  Object.defineProperty(toComputedKey, "__esModule", { value: true });
  toComputedKey.default = toComputedKey$1;
  var _generated = requireGenerated$4();
  var _generated2 = requireGenerated$3();
  function toComputedKey$1(node, key = node.key || node.property) {
    if (!node.computed && (0, _generated.isIdentifier)(key))
      key = (0, _generated2.stringLiteral)(key.name);
    return key;
  }
  return toComputedKey;
}
var toExpression = {};
var hasRequiredToExpression;
function requireToExpression() {
  if (hasRequiredToExpression) return toExpression;
  hasRequiredToExpression = 1;
  Object.defineProperty(toExpression, "__esModule", { value: true });
  toExpression.default = void 0;
  var _generated = requireGenerated$4();
  var _default = toExpression$1;
  toExpression.default = _default;
  function toExpression$1(node) {
    if ((0, _generated.isExpressionStatement)(node)) {
      node = node.expression;
    }
    if ((0, _generated.isExpression)(node)) {
      return node;
    }
    if ((0, _generated.isClass)(node)) {
      node.type = "ClassExpression";
    } else if ((0, _generated.isFunction)(node)) {
      node.type = "FunctionExpression";
    }
    if (!(0, _generated.isExpression)(node)) {
      throw new Error(`cannot turn ${node.type} to an expression`);
    }
    return node;
  }
  return toExpression;
}
var toKeyAlias = {};
var removePropertiesDeep = {};
var traverseFast = {};
var hasRequiredTraverseFast;
function requireTraverseFast() {
  if (hasRequiredTraverseFast) return traverseFast;
  hasRequiredTraverseFast = 1;
  Object.defineProperty(traverseFast, "__esModule", { value: true });
  traverseFast.default = traverseFast$1;
  var _definitions = requireDefinitions();
  function traverseFast$1(node, enter, opts) {
    if (!node) return;
    const keys = _definitions.VISITOR_KEYS[node.type];
    if (!keys) return;
    opts = opts || {};
    enter(node, opts);
    for (const key of keys) {
      const subNode = node[key];
      if (Array.isArray(subNode)) {
        for (const node of subNode) {
          traverseFast$1(node, enter, opts);
        }
      } else {
        traverseFast$1(subNode, enter, opts);
      }
    }
  }
  return traverseFast;
}
var removeProperties = {};
var hasRequiredRemoveProperties;
function requireRemoveProperties() {
  if (hasRequiredRemoveProperties) return removeProperties;
  hasRequiredRemoveProperties = 1;
  Object.defineProperty(removeProperties, "__esModule", { value: true });
  removeProperties.default = removeProperties$1;
  var _constants = requireConstants();
  const CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
  const CLEAR_KEYS_PLUS_COMMENTS = [
    ..._constants.COMMENT_KEYS,
    "comments",
    ...CLEAR_KEYS,
  ];
  function removeProperties$1(node, opts = {}) {
    const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
    for (const key of map) {
      if (node[key] != null) node[key] = undefined;
    }
    for (const key of Object.keys(node)) {
      if (key[0] === "_" && node[key] != null) node[key] = undefined;
    }
    const symbols = Object.getOwnPropertySymbols(node);
    for (const sym of symbols) {
      node[sym] = null;
    }
  }
  return removeProperties;
}
var hasRequiredRemovePropertiesDeep;
function requireRemovePropertiesDeep() {
  if (hasRequiredRemovePropertiesDeep) return removePropertiesDeep;
  hasRequiredRemovePropertiesDeep = 1;
  Object.defineProperty(removePropertiesDeep, "__esModule", { value: true });
  removePropertiesDeep.default = removePropertiesDeep$1;
  var _traverseFast = requireTraverseFast();
  var _removeProperties = requireRemoveProperties();
  function removePropertiesDeep$1(tree, opts) {
    (0, _traverseFast.default)(tree, _removeProperties.default, opts);
    return tree;
  }
  return removePropertiesDeep;
}
var hasRequiredToKeyAlias;
function requireToKeyAlias() {
  if (hasRequiredToKeyAlias) return toKeyAlias;
  hasRequiredToKeyAlias = 1;
  Object.defineProperty(toKeyAlias, "__esModule", { value: true });
  toKeyAlias.default = toKeyAlias$1;
  var _generated = requireGenerated$4();
  var _cloneNode = requireCloneNode();
  var _removePropertiesDeep = requireRemovePropertiesDeep();
  function toKeyAlias$1(node, key = node.key) {
    let alias;
    if (node.kind === "method") {
      return toKeyAlias$1.increment() + "";
    } else if ((0, _generated.isIdentifier)(key)) {
      alias = key.name;
    } else if ((0, _generated.isStringLiteral)(key)) {
      alias = JSON.stringify(key.value);
    } else {
      alias = JSON.stringify(
        (0, _removePropertiesDeep.default)((0, _cloneNode.default)(key))
      );
    }
    if (node.computed) {
      alias = `[${alias}]`;
    }
    if (node.static) {
      alias = `static:${alias}`;
    }
    return alias;
  }
  toKeyAlias$1.uid = 0;
  toKeyAlias$1.increment = function () {
    if (toKeyAlias$1.uid >= Number.MAX_SAFE_INTEGER) {
      return (toKeyAlias$1.uid = 0);
    } else {
      return toKeyAlias$1.uid++;
    }
  };
  return toKeyAlias;
}
var toSequenceExpression = {};
var gatherSequenceExpressions = {};
var getBindingIdentifiers = {};
var hasRequiredGetBindingIdentifiers;
function requireGetBindingIdentifiers() {
  if (hasRequiredGetBindingIdentifiers) return getBindingIdentifiers;
  hasRequiredGetBindingIdentifiers = 1;
  Object.defineProperty(getBindingIdentifiers, "__esModule", { value: true });
  getBindingIdentifiers.default = getBindingIdentifiers$1;
  var _generated = requireGenerated$4();
  function getBindingIdentifiers$1(node, duplicates, outerOnly) {
    const search = [].concat(node);
    const ids = Object.create(null);
    while (search.length) {
      const id = search.shift();
      if (!id) continue;
      const keys = getBindingIdentifiers$1.keys[id.type];
      if ((0, _generated.isIdentifier)(id)) {
        if (duplicates) {
          const _ids = (ids[id.name] = ids[id.name] || []);
          _ids.push(id);
        } else {
          ids[id.name] = id;
        }
        continue;
      }
      if (
        (0, _generated.isExportDeclaration)(id) &&
        !(0, _generated.isExportAllDeclaration)(id)
      ) {
        if ((0, _generated.isDeclaration)(id.declaration)) {
          search.push(id.declaration);
        }
        continue;
      }
      if (outerOnly) {
        if ((0, _generated.isFunctionDeclaration)(id)) {
          search.push(id.id);
          continue;
        }
        if ((0, _generated.isFunctionExpression)(id)) {
          continue;
        }
      }
      if (keys) {
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const nodes = id[key];
          if (nodes) {
            Array.isArray(nodes) ? search.push(...nodes) : search.push(nodes);
          }
        }
      }
    }
    return ids;
  }
  getBindingIdentifiers$1.keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"],
  };
  return getBindingIdentifiers;
}
var hasRequiredGatherSequenceExpressions;
function requireGatherSequenceExpressions() {
  if (hasRequiredGatherSequenceExpressions) return gatherSequenceExpressions;
  hasRequiredGatherSequenceExpressions = 1;
  Object.defineProperty(gatherSequenceExpressions, "__esModule", {
    value: true,
  });
  gatherSequenceExpressions.default = gatherSequenceExpressions$1;
  var _getBindingIdentifiers = requireGetBindingIdentifiers();
  var _generated = requireGenerated$4();
  var _generated2 = requireGenerated$3();
  var _cloneNode = requireCloneNode();
  function gatherSequenceExpressions$1(nodes, scope, declars) {
    const exprs = [];
    let ensureLastUndefined = true;
    for (const node of nodes) {
      if (!(0, _generated.isEmptyStatement)(node)) {
        ensureLastUndefined = false;
      }
      if ((0, _generated.isExpression)(node)) {
        exprs.push(node);
      } else if ((0, _generated.isExpressionStatement)(node)) {
        exprs.push(node.expression);
      } else if ((0, _generated.isVariableDeclaration)(node)) {
        if (node.kind !== "var") return;
        for (const declar of node.declarations) {
          const bindings = (0, _getBindingIdentifiers.default)(declar);
          for (const key of Object.keys(bindings)) {
            declars.push({
              kind: node.kind,
              id: (0, _cloneNode.default)(bindings[key]),
            });
          }
          if (declar.init) {
            exprs.push(
              (0, _generated2.assignmentExpression)("=", declar.id, declar.init)
            );
          }
        }
        ensureLastUndefined = true;
      } else if ((0, _generated.isIfStatement)(node)) {
        const consequent = node.consequent
          ? gatherSequenceExpressions$1([node.consequent], scope, declars)
          : scope.buildUndefinedNode();
        const alternate = node.alternate
          ? gatherSequenceExpressions$1([node.alternate], scope, declars)
          : scope.buildUndefinedNode();
        if (!consequent || !alternate) return;
        exprs.push(
          (0, _generated2.conditionalExpression)(
            node.test,
            consequent,
            alternate
          )
        );
      } else if ((0, _generated.isBlockStatement)(node)) {
        const body = gatherSequenceExpressions$1(node.body, scope, declars);
        if (!body) return;
        exprs.push(body);
      } else if ((0, _generated.isEmptyStatement)(node)) {
        if (nodes.indexOf(node) === 0) {
          ensureLastUndefined = true;
        }
      } else {
        return;
      }
    }
    if (ensureLastUndefined) {
      exprs.push(scope.buildUndefinedNode());
    }
    if (exprs.length === 1) {
      return exprs[0];
    } else {
      return (0, _generated2.sequenceExpression)(exprs);
    }
  }
  return gatherSequenceExpressions;
}
var hasRequiredToSequenceExpression;
function requireToSequenceExpression() {
  if (hasRequiredToSequenceExpression) return toSequenceExpression;
  hasRequiredToSequenceExpression = 1;
  Object.defineProperty(toSequenceExpression, "__esModule", { value: true });
  toSequenceExpression.default = toSequenceExpression$1;
  var _gatherSequenceExpressions = requireGatherSequenceExpressions();
  function toSequenceExpression$1(nodes, scope) {
    if (!(nodes != null && nodes.length)) return;
    const declars = [];
    const result = (0, _gatherSequenceExpressions.default)(
      nodes,
      scope,
      declars
    );
    if (!result) return;
    for (const declar of declars) {
      scope.push(declar);
    }
    return result;
  }
  return toSequenceExpression;
}
var toStatement = {};
var hasRequiredToStatement;
function requireToStatement() {
  if (hasRequiredToStatement) return toStatement;
  hasRequiredToStatement = 1;
  Object.defineProperty(toStatement, "__esModule", { value: true });
  toStatement.default = void 0;
  var _generated = requireGenerated$4();
  var _generated2 = requireGenerated$3();
  var _default = toStatement$1;
  toStatement.default = _default;
  function toStatement$1(node, ignore) {
    if ((0, _generated.isStatement)(node)) {
      return node;
    }
    let mustHaveId = false;
    let newType;
    if ((0, _generated.isClass)(node)) {
      mustHaveId = true;
      newType = "ClassDeclaration";
    } else if ((0, _generated.isFunction)(node)) {
      mustHaveId = true;
      newType = "FunctionDeclaration";
    } else if ((0, _generated.isAssignmentExpression)(node)) {
      return (0, _generated2.expressionStatement)(node);
    }
    if (mustHaveId && !node.id) {
      newType = false;
    }
    if (!newType) {
      if (ignore) {
        return false;
      } else {
        throw new Error(`cannot turn ${node.type} to a statement`);
      }
    }
    node.type = newType;
    return node;
  }
  return toStatement;
}
var valueToNode = {};
var hasRequiredValueToNode;
function requireValueToNode() {
  if (hasRequiredValueToNode) return valueToNode;
  hasRequiredValueToNode = 1;
  Object.defineProperty(valueToNode, "__esModule", { value: true });
  valueToNode.default = void 0;
  var _isValidIdentifier = requireIsValidIdentifier();
  var _generated = requireGenerated$3();
  var _default = valueToNode$1;
  valueToNode.default = _default;
  const objectToString = Function.call.bind(Object.prototype.toString);
  function isRegExp(value) {
    return objectToString(value) === "[object RegExp]";
  }
  function isPlainObject(value) {
    if (
      typeof value !== "object" ||
      value === null ||
      Object.prototype.toString.call(value) !== "[object Object]"
    ) {
      return false;
    }
    const proto = Object.getPrototypeOf(value);
    return proto === null || Object.getPrototypeOf(proto) === null;
  }
  function valueToNode$1(value) {
    if (value === undefined) {
      return (0, _generated.identifier)("undefined");
    }
    if (value === true || value === false) {
      return (0, _generated.booleanLiteral)(value);
    }
    if (value === null) {
      return (0, _generated.nullLiteral)();
    }
    if (typeof value === "string") {
      return (0, _generated.stringLiteral)(value);
    }
    if (typeof value === "number") {
      let result;
      if (Number.isFinite(value)) {
        result = (0, _generated.numericLiteral)(Math.abs(value));
      } else {
        let numerator;
        if (Number.isNaN(value)) {
          numerator = (0, _generated.numericLiteral)(0);
        } else {
          numerator = (0, _generated.numericLiteral)(1);
        }
        result = (0, _generated.binaryExpression)(
          "/",
          numerator,
          (0, _generated.numericLiteral)(0)
        );
      }
      if (value < 0 || Object.is(value, -0)) {
        result = (0, _generated.unaryExpression)("-", result);
      }
      return result;
    }
    if (isRegExp(value)) {
      const pattern = value.source;
      const flags = value.toString().match(/\/([a-z]+|)$/)[1];
      return (0, _generated.regExpLiteral)(pattern, flags);
    }
    if (Array.isArray(value)) {
      return (0, _generated.arrayExpression)(value.map(valueToNode$1));
    }
    if (isPlainObject(value)) {
      const props = [];
      for (const key of Object.keys(value)) {
        let nodeKey;
        if ((0, _isValidIdentifier.default)(key)) {
          nodeKey = (0, _generated.identifier)(key);
        } else {
          nodeKey = (0, _generated.stringLiteral)(key);
        }
        props.push(
          (0, _generated.objectProperty)(nodeKey, valueToNode$1(value[key]))
        );
      }
      return (0, _generated.objectExpression)(props);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  return valueToNode;
}
var appendToMemberExpression = {};
var hasRequiredAppendToMemberExpression;
function requireAppendToMemberExpression() {
  if (hasRequiredAppendToMemberExpression) return appendToMemberExpression;
  hasRequiredAppendToMemberExpression = 1;
  Object.defineProperty(appendToMemberExpression, "__esModule", {
    value: true,
  });
  appendToMemberExpression.default = appendToMemberExpression$1;
  var _generated = requireGenerated$3();
  function appendToMemberExpression$1(member, append, computed = false) {
    member.object = (0, _generated.memberExpression)(
      member.object,
      member.property,
      member.computed
    );
    member.property = append;
    member.computed = !!computed;
    return member;
  }
  return appendToMemberExpression;
}
var inherits = {};
var hasRequiredInherits;
function requireInherits() {
  if (hasRequiredInherits) return inherits;
  hasRequiredInherits = 1;
  Object.defineProperty(inherits, "__esModule", { value: true });
  inherits.default = inherits$1;
  var _constants = requireConstants();
  var _inheritsComments = requireInheritsComments();
  function inherits$1(child, parent) {
    if (!child || !parent) return child;
    for (const key of _constants.INHERIT_KEYS.optional) {
      if (child[key] == null) {
        child[key] = parent[key];
      }
    }
    for (const key of Object.keys(parent)) {
      if (key[0] === "_" && key !== "__clone") {
        child[key] = parent[key];
      }
    }
    for (const key of _constants.INHERIT_KEYS.force) {
      child[key] = parent[key];
    }
    (0, _inheritsComments.default)(child, parent);
    return child;
  }
  return inherits;
}
var prependToMemberExpression = {};
var hasRequiredPrependToMemberExpression;
function requirePrependToMemberExpression() {
  if (hasRequiredPrependToMemberExpression) return prependToMemberExpression;
  hasRequiredPrependToMemberExpression = 1;
  Object.defineProperty(prependToMemberExpression, "__esModule", {
    value: true,
  });
  prependToMemberExpression.default = prependToMemberExpression$1;
  var _generated = requireGenerated$3();
  var _ = requireLib();
  function prependToMemberExpression$1(member, prepend) {
    if ((0, _.isSuper)(member.object)) {
      throw new Error(
        "Cannot prepend node to super property access (`super.foo`)."
      );
    }
    member.object = (0, _generated.memberExpression)(prepend, member.object);
    return member;
  }
  return prependToMemberExpression;
}
var getOuterBindingIdentifiers = {};
var hasRequiredGetOuterBindingIdentifiers;
function requireGetOuterBindingIdentifiers() {
  if (hasRequiredGetOuterBindingIdentifiers) return getOuterBindingIdentifiers;
  hasRequiredGetOuterBindingIdentifiers = 1;
  Object.defineProperty(getOuterBindingIdentifiers, "__esModule", {
    value: true,
  });
  getOuterBindingIdentifiers.default = void 0;
  var _getBindingIdentifiers = requireGetBindingIdentifiers();
  var _default = getOuterBindingIdentifiers$1;
  getOuterBindingIdentifiers.default = _default;
  function getOuterBindingIdentifiers$1(node, duplicates) {
    return (0, _getBindingIdentifiers.default)(node, duplicates, true);
  }
  return getOuterBindingIdentifiers;
}
var traverse = {};
var hasRequiredTraverse;
function requireTraverse() {
  if (hasRequiredTraverse) return traverse;
  hasRequiredTraverse = 1;
  Object.defineProperty(traverse, "__esModule", { value: true });
  traverse.default = traverse$1;
  var _definitions = requireDefinitions();
  function traverse$1(node, handlers, state) {
    if (typeof handlers === "function") {
      handlers = { enter: handlers };
    }
    const { enter: enter, exit: exit } = handlers;
    traverseSimpleImpl(node, enter, exit, state, []);
  }
  function traverseSimpleImpl(node, enter, exit, state, ancestors) {
    const keys = _definitions.VISITOR_KEYS[node.type];
    if (!keys) return;
    if (enter) enter(node, ancestors, state);
    for (const key of keys) {
      const subNode = node[key];
      if (Array.isArray(subNode)) {
        for (let i = 0; i < subNode.length; i++) {
          const child = subNode[i];
          if (!child) continue;
          ancestors.push({ node: node, key: key, index: i });
          traverseSimpleImpl(child, enter, exit, state, ancestors);
          ancestors.pop();
        }
      } else if (subNode) {
        ancestors.push({ node: node, key: key });
        traverseSimpleImpl(subNode, enter, exit, state, ancestors);
        ancestors.pop();
      }
    }
    if (exit) exit(node, ancestors, state);
  }
  return traverse;
}
var isBinding = {};
var hasRequiredIsBinding;
function requireIsBinding() {
  if (hasRequiredIsBinding) return isBinding;
  hasRequiredIsBinding = 1;
  Object.defineProperty(isBinding, "__esModule", { value: true });
  isBinding.default = isBinding$1;
  var _getBindingIdentifiers = requireGetBindingIdentifiers();
  function isBinding$1(node, parent, grandparent) {
    if (
      grandparent &&
      node.type === "Identifier" &&
      parent.type === "ObjectProperty" &&
      grandparent.type === "ObjectExpression"
    ) {
      return false;
    }
    const keys = _getBindingIdentifiers.default.keys[parent.type];
    if (keys) {
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const val = parent[key];
        if (Array.isArray(val)) {
          if (val.indexOf(node) >= 0) return true;
        } else {
          if (val === node) return true;
        }
      }
    }
    return false;
  }
  return isBinding;
}
var isBlockScoped = {};
var isLet = {};
var hasRequiredIsLet;
function requireIsLet() {
  if (hasRequiredIsLet) return isLet;
  hasRequiredIsLet = 1;
  Object.defineProperty(isLet, "__esModule", { value: true });
  isLet.default = isLet$1;
  var _generated = requireGenerated$4();
  var _constants = requireConstants();
  function isLet$1(node) {
    return (
      (0, _generated.isVariableDeclaration)(node) &&
      (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL])
    );
  }
  return isLet;
}
var hasRequiredIsBlockScoped;
function requireIsBlockScoped() {
  if (hasRequiredIsBlockScoped) return isBlockScoped;
  hasRequiredIsBlockScoped = 1;
  Object.defineProperty(isBlockScoped, "__esModule", { value: true });
  isBlockScoped.default = isBlockScoped$1;
  var _generated = requireGenerated$4();
  var _isLet = requireIsLet();
  function isBlockScoped$1(node) {
    return (
      (0, _generated.isFunctionDeclaration)(node) ||
      (0, _generated.isClassDeclaration)(node) ||
      (0, _isLet.default)(node)
    );
  }
  return isBlockScoped;
}
var isImmutable = {};
var hasRequiredIsImmutable;
function requireIsImmutable() {
  if (hasRequiredIsImmutable) return isImmutable;
  hasRequiredIsImmutable = 1;
  Object.defineProperty(isImmutable, "__esModule", { value: true });
  isImmutable.default = isImmutable$1;
  var _isType = requireIsType();
  var _generated = requireGenerated$4();
  function isImmutable$1(node) {
    if ((0, _isType.default)(node.type, "Immutable")) return true;
    if ((0, _generated.isIdentifier)(node)) {
      if (node.name === "undefined") {
        return true;
      } else {
        return false;
      }
    }
    return false;
  }
  return isImmutable;
}
var isNodesEquivalent = {};
var hasRequiredIsNodesEquivalent;
function requireIsNodesEquivalent() {
  if (hasRequiredIsNodesEquivalent) return isNodesEquivalent;
  hasRequiredIsNodesEquivalent = 1;
  Object.defineProperty(isNodesEquivalent, "__esModule", { value: true });
  isNodesEquivalent.default = isNodesEquivalent$1;
  var _definitions = requireDefinitions();
  function isNodesEquivalent$1(a, b) {
    if (
      typeof a !== "object" ||
      typeof b !== "object" ||
      a == null ||
      b == null
    ) {
      return a === b;
    }
    if (a.type !== b.type) {
      return false;
    }
    const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);
    const visitorKeys = _definitions.VISITOR_KEYS[a.type];
    for (const field of fields) {
      const val_a = a[field];
      const val_b = b[field];
      if (typeof val_a !== typeof val_b) {
        return false;
      }
      if (val_a == null && val_b == null) {
        continue;
      } else if (val_a == null || val_b == null) {
        return false;
      }
      if (Array.isArray(val_a)) {
        if (!Array.isArray(val_b)) {
          return false;
        }
        if (val_a.length !== val_b.length) {
          return false;
        }
        for (let i = 0; i < val_a.length; i++) {
          if (!isNodesEquivalent$1(val_a[i], val_b[i])) {
            return false;
          }
        }
        continue;
      }
      if (
        typeof val_a === "object" &&
        !(visitorKeys != null && visitorKeys.includes(field))
      ) {
        for (const key of Object.keys(val_a)) {
          if (val_a[key] !== val_b[key]) {
            return false;
          }
        }
        continue;
      }
      if (!isNodesEquivalent$1(val_a, val_b)) {
        return false;
      }
    }
    return true;
  }
  return isNodesEquivalent;
}
var isReferenced = {};
var hasRequiredIsReferenced;
function requireIsReferenced() {
  if (hasRequiredIsReferenced) return isReferenced;
  hasRequiredIsReferenced = 1;
  Object.defineProperty(isReferenced, "__esModule", { value: true });
  isReferenced.default = isReferenced$1;
  function isReferenced$1(node, parent, grandparent) {
    switch (parent.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        if (parent.property === node) {
          return !!parent.computed;
        }
        return parent.object === node;
      case "JSXMemberExpression":
        return parent.object === node;
      case "VariableDeclarator":
        return parent.init === node;
      case "ArrowFunctionExpression":
        return parent.body === node;
      case "PrivateName":
        return false;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        if (parent.key === node) {
          return !!parent.computed;
        }
        return false;
      case "ObjectProperty":
        if (parent.key === node) {
          return !!parent.computed;
        }
        return !grandparent || grandparent.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        if (parent.key === node) {
          return !!parent.computed;
        }
        return true;
      case "ClassPrivateProperty":
        return parent.key !== node;
      case "ClassDeclaration":
      case "ClassExpression":
        return parent.superClass === node;
      case "AssignmentExpression":
        return parent.right === node;
      case "AssignmentPattern":
        return parent.right === node;
      case "LabeledStatement":
        return false;
      case "CatchClause":
        return false;
      case "RestElement":
        return false;
      case "BreakStatement":
      case "ContinueStatement":
        return false;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return false;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return false;
      case "ExportSpecifier":
        if (grandparent != null && grandparent.source) {
          return false;
        }
        return parent.local === node;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return false;
      case "ImportAttribute":
        return false;
      case "JSXAttribute":
        return false;
      case "ObjectPattern":
      case "ArrayPattern":
        return false;
      case "MetaProperty":
        return false;
      case "ObjectTypeProperty":
        return parent.key !== node;
      case "TSEnumMember":
        return parent.id !== node;
      case "TSPropertySignature":
        if (parent.key === node) {
          return !!parent.computed;
        }
        return true;
    }
    return true;
  }
  return isReferenced;
}
var isScope = {};
var hasRequiredIsScope;
function requireIsScope() {
  if (hasRequiredIsScope) return isScope;
  hasRequiredIsScope = 1;
  Object.defineProperty(isScope, "__esModule", { value: true });
  isScope.default = isScope$1;
  var _generated = requireGenerated$4();
  function isScope$1(node, parent) {
    if (
      (0, _generated.isBlockStatement)(node) &&
      ((0, _generated.isFunction)(parent) ||
        (0, _generated.isCatchClause)(parent))
    ) {
      return false;
    }
    if (
      (0, _generated.isPattern)(node) &&
      ((0, _generated.isFunction)(parent) ||
        (0, _generated.isCatchClause)(parent))
    ) {
      return true;
    }
    return (0, _generated.isScopable)(node);
  }
  return isScope;
}
var isSpecifierDefault = {};
var hasRequiredIsSpecifierDefault;
function requireIsSpecifierDefault() {
  if (hasRequiredIsSpecifierDefault) return isSpecifierDefault;
  hasRequiredIsSpecifierDefault = 1;
  Object.defineProperty(isSpecifierDefault, "__esModule", { value: true });
  isSpecifierDefault.default = isSpecifierDefault$1;
  var _generated = requireGenerated$4();
  function isSpecifierDefault$1(specifier) {
    return (
      (0, _generated.isImportDefaultSpecifier)(specifier) ||
      (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {
        name: "default",
      })
    );
  }
  return isSpecifierDefault;
}
var isValidES3Identifier = {};
var hasRequiredIsValidES3Identifier;
function requireIsValidES3Identifier() {
  if (hasRequiredIsValidES3Identifier) return isValidES3Identifier;
  hasRequiredIsValidES3Identifier = 1;
  Object.defineProperty(isValidES3Identifier, "__esModule", { value: true });
  isValidES3Identifier.default = isValidES3Identifier$1;
  var _isValidIdentifier = requireIsValidIdentifier();
  const RESERVED_WORDS_ES3_ONLY = new Set([
    "abstract",
    "boolean",
    "byte",
    "char",
    "double",
    "enum",
    "final",
    "float",
    "goto",
    "implements",
    "int",
    "interface",
    "long",
    "native",
    "package",
    "private",
    "protected",
    "public",
    "short",
    "static",
    "synchronized",
    "throws",
    "transient",
    "volatile",
  ]);
  function isValidES3Identifier$1(name) {
    return (
      (0, _isValidIdentifier.default)(name) &&
      !RESERVED_WORDS_ES3_ONLY.has(name)
    );
  }
  return isValidES3Identifier;
}
var isVar = {};
var hasRequiredIsVar;
function requireIsVar() {
  if (hasRequiredIsVar) return isVar;
  hasRequiredIsVar = 1;
  Object.defineProperty(isVar, "__esModule", { value: true });
  isVar.default = isVar$1;
  var _generated = requireGenerated$4();
  var _constants = requireConstants();
  function isVar$1(node) {
    return (
      (0, _generated.isVariableDeclaration)(node, { kind: "var" }) &&
      !node[_constants.BLOCK_SCOPED_SYMBOL]
    );
  }
  return isVar;
}
var generated = {};
var hasRequiredGenerated;
function requireGenerated() {
  if (hasRequiredGenerated) return generated;
  hasRequiredGenerated = 1;
  return generated;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$1;
  hasRequiredLib = 1;
  (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var _exportNames = {
      react: true,
      assertNode: true,
      createTypeAnnotationBasedOnTypeof: true,
      createUnionTypeAnnotation: true,
      createFlowUnionType: true,
      createTSUnionType: true,
      cloneNode: true,
      clone: true,
      cloneDeep: true,
      cloneDeepWithoutLoc: true,
      cloneWithoutLoc: true,
      addComment: true,
      addComments: true,
      inheritInnerComments: true,
      inheritLeadingComments: true,
      inheritsComments: true,
      inheritTrailingComments: true,
      removeComments: true,
      ensureBlock: true,
      toBindingIdentifierName: true,
      toBlock: true,
      toComputedKey: true,
      toExpression: true,
      toIdentifier: true,
      toKeyAlias: true,
      toSequenceExpression: true,
      toStatement: true,
      valueToNode: true,
      appendToMemberExpression: true,
      inherits: true,
      prependToMemberExpression: true,
      removeProperties: true,
      removePropertiesDeep: true,
      removeTypeDuplicates: true,
      getBindingIdentifiers: true,
      getOuterBindingIdentifiers: true,
      traverse: true,
      traverseFast: true,
      shallowEqual: true,
      is: true,
      isBinding: true,
      isBlockScoped: true,
      isImmutable: true,
      isLet: true,
      isNode: true,
      isNodesEquivalent: true,
      isPlaceholderType: true,
      isReferenced: true,
      isScope: true,
      isSpecifierDefault: true,
      isType: true,
      isValidES3Identifier: true,
      isValidIdentifier: true,
      isVar: true,
      matchesPattern: true,
      validate: true,
      buildMatchMemberExpression: true,
    };
    Object.defineProperty(exports, "addComment", {
      enumerable: true,
      get: function () {
        return _addComment.default;
      },
    });
    Object.defineProperty(exports, "addComments", {
      enumerable: true,
      get: function () {
        return _addComments.default;
      },
    });
    Object.defineProperty(exports, "appendToMemberExpression", {
      enumerable: true,
      get: function () {
        return _appendToMemberExpression.default;
      },
    });
    Object.defineProperty(exports, "assertNode", {
      enumerable: true,
      get: function () {
        return _assertNode.default;
      },
    });
    Object.defineProperty(exports, "buildMatchMemberExpression", {
      enumerable: true,
      get: function () {
        return _buildMatchMemberExpression.default;
      },
    });
    Object.defineProperty(exports, "clone", {
      enumerable: true,
      get: function () {
        return _clone.default;
      },
    });
    Object.defineProperty(exports, "cloneDeep", {
      enumerable: true,
      get: function () {
        return _cloneDeep.default;
      },
    });
    Object.defineProperty(exports, "cloneDeepWithoutLoc", {
      enumerable: true,
      get: function () {
        return _cloneDeepWithoutLoc.default;
      },
    });
    Object.defineProperty(exports, "cloneNode", {
      enumerable: true,
      get: function () {
        return _cloneNode.default;
      },
    });
    Object.defineProperty(exports, "cloneWithoutLoc", {
      enumerable: true,
      get: function () {
        return _cloneWithoutLoc.default;
      },
    });
    Object.defineProperty(exports, "createFlowUnionType", {
      enumerable: true,
      get: function () {
        return _createFlowUnionType.default;
      },
    });
    Object.defineProperty(exports, "createTSUnionType", {
      enumerable: true,
      get: function () {
        return _createTSUnionType.default;
      },
    });
    Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
      enumerable: true,
      get: function () {
        return _createTypeAnnotationBasedOnTypeof.default;
      },
    });
    Object.defineProperty(exports, "createUnionTypeAnnotation", {
      enumerable: true,
      get: function () {
        return _createFlowUnionType.default;
      },
    });
    Object.defineProperty(exports, "ensureBlock", {
      enumerable: true,
      get: function () {
        return _ensureBlock.default;
      },
    });
    Object.defineProperty(exports, "getBindingIdentifiers", {
      enumerable: true,
      get: function () {
        return _getBindingIdentifiers.default;
      },
    });
    Object.defineProperty(exports, "getOuterBindingIdentifiers", {
      enumerable: true,
      get: function () {
        return _getOuterBindingIdentifiers.default;
      },
    });
    Object.defineProperty(exports, "inheritInnerComments", {
      enumerable: true,
      get: function () {
        return _inheritInnerComments.default;
      },
    });
    Object.defineProperty(exports, "inheritLeadingComments", {
      enumerable: true,
      get: function () {
        return _inheritLeadingComments.default;
      },
    });
    Object.defineProperty(exports, "inheritTrailingComments", {
      enumerable: true,
      get: function () {
        return _inheritTrailingComments.default;
      },
    });
    Object.defineProperty(exports, "inherits", {
      enumerable: true,
      get: function () {
        return _inherits.default;
      },
    });
    Object.defineProperty(exports, "inheritsComments", {
      enumerable: true,
      get: function () {
        return _inheritsComments.default;
      },
    });
    Object.defineProperty(exports, "is", {
      enumerable: true,
      get: function () {
        return _is.default;
      },
    });
    Object.defineProperty(exports, "isBinding", {
      enumerable: true,
      get: function () {
        return _isBinding.default;
      },
    });
    Object.defineProperty(exports, "isBlockScoped", {
      enumerable: true,
      get: function () {
        return _isBlockScoped.default;
      },
    });
    Object.defineProperty(exports, "isImmutable", {
      enumerable: true,
      get: function () {
        return _isImmutable.default;
      },
    });
    Object.defineProperty(exports, "isLet", {
      enumerable: true,
      get: function () {
        return _isLet.default;
      },
    });
    Object.defineProperty(exports, "isNode", {
      enumerable: true,
      get: function () {
        return _isNode.default;
      },
    });
    Object.defineProperty(exports, "isNodesEquivalent", {
      enumerable: true,
      get: function () {
        return _isNodesEquivalent.default;
      },
    });
    Object.defineProperty(exports, "isPlaceholderType", {
      enumerable: true,
      get: function () {
        return _isPlaceholderType.default;
      },
    });
    Object.defineProperty(exports, "isReferenced", {
      enumerable: true,
      get: function () {
        return _isReferenced.default;
      },
    });
    Object.defineProperty(exports, "isScope", {
      enumerable: true,
      get: function () {
        return _isScope.default;
      },
    });
    Object.defineProperty(exports, "isSpecifierDefault", {
      enumerable: true,
      get: function () {
        return _isSpecifierDefault.default;
      },
    });
    Object.defineProperty(exports, "isType", {
      enumerable: true,
      get: function () {
        return _isType.default;
      },
    });
    Object.defineProperty(exports, "isValidES3Identifier", {
      enumerable: true,
      get: function () {
        return _isValidES3Identifier.default;
      },
    });
    Object.defineProperty(exports, "isValidIdentifier", {
      enumerable: true,
      get: function () {
        return _isValidIdentifier.default;
      },
    });
    Object.defineProperty(exports, "isVar", {
      enumerable: true,
      get: function () {
        return _isVar.default;
      },
    });
    Object.defineProperty(exports, "matchesPattern", {
      enumerable: true,
      get: function () {
        return _matchesPattern.default;
      },
    });
    Object.defineProperty(exports, "prependToMemberExpression", {
      enumerable: true,
      get: function () {
        return _prependToMemberExpression.default;
      },
    });
    exports.react = void 0;
    Object.defineProperty(exports, "removeComments", {
      enumerable: true,
      get: function () {
        return _removeComments.default;
      },
    });
    Object.defineProperty(exports, "removeProperties", {
      enumerable: true,
      get: function () {
        return _removeProperties.default;
      },
    });
    Object.defineProperty(exports, "removePropertiesDeep", {
      enumerable: true,
      get: function () {
        return _removePropertiesDeep.default;
      },
    });
    Object.defineProperty(exports, "removeTypeDuplicates", {
      enumerable: true,
      get: function () {
        return _removeTypeDuplicates.default;
      },
    });
    Object.defineProperty(exports, "shallowEqual", {
      enumerable: true,
      get: function () {
        return _shallowEqual.default;
      },
    });
    Object.defineProperty(exports, "toBindingIdentifierName", {
      enumerable: true,
      get: function () {
        return _toBindingIdentifierName.default;
      },
    });
    Object.defineProperty(exports, "toBlock", {
      enumerable: true,
      get: function () {
        return _toBlock.default;
      },
    });
    Object.defineProperty(exports, "toComputedKey", {
      enumerable: true,
      get: function () {
        return _toComputedKey.default;
      },
    });
    Object.defineProperty(exports, "toExpression", {
      enumerable: true,
      get: function () {
        return _toExpression.default;
      },
    });
    Object.defineProperty(exports, "toIdentifier", {
      enumerable: true,
      get: function () {
        return _toIdentifier.default;
      },
    });
    Object.defineProperty(exports, "toKeyAlias", {
      enumerable: true,
      get: function () {
        return _toKeyAlias.default;
      },
    });
    Object.defineProperty(exports, "toSequenceExpression", {
      enumerable: true,
      get: function () {
        return _toSequenceExpression.default;
      },
    });
    Object.defineProperty(exports, "toStatement", {
      enumerable: true,
      get: function () {
        return _toStatement.default;
      },
    });
    Object.defineProperty(exports, "traverse", {
      enumerable: true,
      get: function () {
        return _traverse.default;
      },
    });
    Object.defineProperty(exports, "traverseFast", {
      enumerable: true,
      get: function () {
        return _traverseFast.default;
      },
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function () {
        return _validate.default;
      },
    });
    Object.defineProperty(exports, "valueToNode", {
      enumerable: true,
      get: function () {
        return _valueToNode.default;
      },
    });
    var _isReactComponent = requireIsReactComponent();
    var _isCompatTag = requireIsCompatTag();
    var _buildChildren = requireBuildChildren();
    var _assertNode = requireAssertNode();
    var _generated = requireGenerated$2();
    Object.keys(_generated).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _generated[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _generated[key];
        },
      });
    });
    var _createTypeAnnotationBasedOnTypeof =
      requireCreateTypeAnnotationBasedOnTypeof();
    var _createFlowUnionType = requireCreateFlowUnionType();
    var _createTSUnionType = requireCreateTSUnionType();
    var _generated2 = requireGenerated$3();
    Object.keys(_generated2).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _generated2[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _generated2[key];
        },
      });
    });
    var _uppercase = requireUppercase();
    Object.keys(_uppercase).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _uppercase[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _uppercase[key];
        },
      });
    });
    var _cloneNode = requireCloneNode();
    var _clone = requireClone();
    var _cloneDeep = requireCloneDeep();
    var _cloneDeepWithoutLoc = requireCloneDeepWithoutLoc();
    var _cloneWithoutLoc = requireCloneWithoutLoc();
    var _addComment = requireAddComment();
    var _addComments = requireAddComments();
    var _inheritInnerComments = requireInheritInnerComments();
    var _inheritLeadingComments = requireInheritLeadingComments();
    var _inheritsComments = requireInheritsComments();
    var _inheritTrailingComments = requireInheritTrailingComments();
    var _removeComments = requireRemoveComments();
    var _generated3 = requireGenerated$1();
    Object.keys(_generated3).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _generated3[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _generated3[key];
        },
      });
    });
    var _constants = requireConstants();
    Object.keys(_constants).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _constants[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _constants[key];
        },
      });
    });
    var _ensureBlock = requireEnsureBlock();
    var _toBindingIdentifierName = requireToBindingIdentifierName();
    var _toBlock = requireToBlock();
    var _toComputedKey = requireToComputedKey();
    var _toExpression = requireToExpression();
    var _toIdentifier = requireToIdentifier();
    var _toKeyAlias = requireToKeyAlias();
    var _toSequenceExpression = requireToSequenceExpression();
    var _toStatement = requireToStatement();
    var _valueToNode = requireValueToNode();
    var _definitions = requireDefinitions();
    Object.keys(_definitions).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _definitions[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _definitions[key];
        },
      });
    });
    var _appendToMemberExpression = requireAppendToMemberExpression();
    var _inherits = requireInherits();
    var _prependToMemberExpression = requirePrependToMemberExpression();
    var _removeProperties = requireRemoveProperties();
    var _removePropertiesDeep = requireRemovePropertiesDeep();
    var _removeTypeDuplicates = requireRemoveTypeDuplicates$1();
    var _getBindingIdentifiers = requireGetBindingIdentifiers();
    var _getOuterBindingIdentifiers = requireGetOuterBindingIdentifiers();
    var _traverse = requireTraverse();
    Object.keys(_traverse).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _traverse[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _traverse[key];
        },
      });
    });
    var _traverseFast = requireTraverseFast();
    var _shallowEqual = requireShallowEqual();
    var _is = requireIs();
    var _isBinding = requireIsBinding();
    var _isBlockScoped = requireIsBlockScoped();
    var _isImmutable = requireIsImmutable();
    var _isLet = requireIsLet();
    var _isNode = requireIsNode();
    var _isNodesEquivalent = requireIsNodesEquivalent();
    var _isPlaceholderType = requireIsPlaceholderType();
    var _isReferenced = requireIsReferenced();
    var _isScope = requireIsScope();
    var _isSpecifierDefault = requireIsSpecifierDefault();
    var _isType = requireIsType();
    var _isValidES3Identifier = requireIsValidES3Identifier();
    var _isValidIdentifier = requireIsValidIdentifier();
    var _isVar = requireIsVar();
    var _matchesPattern = requireMatchesPattern();
    var _validate = requireValidate();
    var _buildMatchMemberExpression = requireBuildMatchMemberExpression();
    var _generated4 = requireGenerated$4();
    Object.keys(_generated4).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _generated4[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _generated4[key];
        },
      });
    });
    var _generated5 = requireGenerated();
    Object.keys(_generated5).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _generated5[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function () {
          return _generated5[key];
        },
      });
    });
    const react = {
      isReactComponent: _isReactComponent.default,
      isCompatTag: _isCompatTag.default,
      buildChildren: _buildChildren.default,
    };
    exports.react = react;
  })(lib$1);
  return lib$1;
}
Object.defineProperty(whitespace$1, "__esModule", { value: true });
whitespace$1.list = whitespace$1.nodes = void 0;
function t$9() {
  const data = _interopRequireWildcard$a(requireLib());
  t$9 = function () {
    return data;
  };
  return data;
}
function _interopRequireWildcard$a(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function crawl(node, state = {}) {
  if (t$9().isMemberExpression(node)) {
    crawl(node.object, state);
    if (node.computed) crawl(node.property, state);
  } else if (t$9().isBinary(node) || t$9().isAssignmentExpression(node)) {
    crawl(node.left, state);
    crawl(node.right, state);
  } else if (t$9().isCallExpression(node)) {
    state.hasCall = true;
    crawl(node.callee, state);
  } else if (t$9().isFunction(node)) {
    state.hasFunction = true;
  } else if (t$9().isIdentifier(node)) {
    state.hasHelper = state.hasHelper || isHelper(node.callee);
  }
  return state;
}
function isHelper(node) {
  if (t$9().isMemberExpression(node)) {
    return isHelper(node.object) || isHelper(node.property);
  } else if (t$9().isIdentifier(node)) {
    return node.name === "require" || node.name[0] === "_";
  } else if (t$9().isCallExpression(node)) {
    return isHelper(node.callee);
  } else if (t$9().isBinary(node) || t$9().isAssignmentExpression(node)) {
    return (
      (t$9().isIdentifier(node.left) && isHelper(node.left)) ||
      isHelper(node.right)
    );
  } else {
    return false;
  }
}
function isType(node) {
  return (
    t$9().isLiteral(node) ||
    t$9().isObjectExpression(node) ||
    t$9().isArrayExpression(node) ||
    t$9().isIdentifier(node) ||
    t$9().isMemberExpression(node)
  );
}
const nodes = {
  AssignmentExpression(node) {
    const state = crawl(node.right);
    if ((state.hasCall && state.hasHelper) || state.hasFunction) {
      return { before: state.hasFunction, after: true };
    }
  },
  SwitchCase(node, parent) {
    return {
      before: node.consequent.length || parent.cases[0] === node,
      after:
        !node.consequent.length &&
        parent.cases[parent.cases.length - 1] === node,
    };
  },
  LogicalExpression(node) {
    if (t$9().isFunction(node.left) || t$9().isFunction(node.right)) {
      return { after: true };
    }
  },
  Literal(node) {
    if (node.value === "use strict") {
      return { after: true };
    }
  },
  CallExpression(node) {
    if (t$9().isFunction(node.callee) || isHelper(node)) {
      return { before: true, after: true };
    }
  },
  VariableDeclaration(node) {
    for (let i = 0; i < node.declarations.length; i++) {
      const declar = node.declarations[i];
      let enabled = isHelper(declar.id) && !isType(declar.init);
      if (!enabled) {
        const state = crawl(declar.init);
        enabled = (isHelper(declar.init) && state.hasCall) || state.hasFunction;
      }
      if (enabled) {
        return { before: true, after: true };
      }
    }
  },
  IfStatement(node) {
    if (t$9().isBlockStatement(node.consequent)) {
      return { before: true, after: true };
    }
  },
};
whitespace$1.nodes = nodes;
nodes.ObjectProperty =
  nodes.ObjectTypeProperty =
  nodes.ObjectMethod =
    function (node, parent) {
      if (parent.properties[0] === node) {
        return { before: true };
      }
    };
nodes.ObjectTypeCallProperty = function (node, parent) {
  if (
    parent.callProperties[0] === node &&
    (!parent.properties || !parent.properties.length)
  ) {
    return { before: true };
  }
};
nodes.ObjectTypeIndexer = function (node, parent) {
  if (
    parent.indexers[0] === node &&
    (!parent.properties || !parent.properties.length) &&
    (!parent.callProperties || !parent.callProperties.length)
  ) {
    return { before: true };
  }
};
nodes.ObjectTypeInternalSlot = function (node, parent) {
  if (
    parent.internalSlots[0] === node &&
    (!parent.properties || !parent.properties.length) &&
    (!parent.callProperties || !parent.callProperties.length) &&
    (!parent.indexers || !parent.indexers.length)
  ) {
    return { before: true };
  }
};
const list = {
  VariableDeclaration(node) {
    return node.declarations.map((decl) => decl.init);
  },
  ArrayExpression(node) {
    return node.elements;
  },
  ObjectExpression(node) {
    return node.properties;
  },
};
whitespace$1.list = list;
[
  ["Function", true],
  ["Class", true],
  ["Loop", true],
  ["LabeledStatement", true],
  ["SwitchStatement", true],
  ["TryStatement", true],
].forEach(function ([type, amounts]) {
  if (typeof amounts === "boolean") {
    amounts = { after: amounts, before: amounts };
  }
  [type].concat(t$9().FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {
    nodes[type] = function () {
      return amounts;
    };
  });
});
var parentheses = {};
Object.defineProperty(parentheses, "__esModule", { value: true });
parentheses.FunctionTypeAnnotation = parentheses.NullableTypeAnnotation =
  NullableTypeAnnotation;
parentheses.UpdateExpression = UpdateExpression$1;
parentheses.ObjectExpression = ObjectExpression$1;
parentheses.DoExpression = DoExpression$1;
parentheses.Binary = Binary;
parentheses.IntersectionTypeAnnotation = parentheses.UnionTypeAnnotation =
  UnionTypeAnnotation;
parentheses.TSAsExpression = TSAsExpression$1;
parentheses.TSTypeAssertion = TSTypeAssertion$1;
parentheses.BinaryExpression = BinaryExpression;
parentheses.SequenceExpression = SequenceExpression$1;
parentheses.AwaitExpression = parentheses.YieldExpression = YieldExpression$1;
parentheses.ClassExpression = ClassExpression;
parentheses.UnaryLike = UnaryLike;
parentheses.FunctionExpression = FunctionExpression$1;
parentheses.ArrowFunctionExpression = ArrowFunctionExpression$1;
parentheses.ConditionalExpression = ConditionalExpression$1;
parentheses.OptionalMemberExpression = OptionalMemberExpression$1;
parentheses.AssignmentExpression = AssignmentExpression$1;
parentheses.NewExpression = NewExpression$1;
function t$8() {
  const data = _interopRequireWildcard$9(requireLib());
  t$8 = function () {
    return data;
  };
  return data;
}
function _interopRequireWildcard$9(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
const PRECEDENCE = {
  "||": 0,
  "&&": 1,
  "|": 2,
  "^": 3,
  "&": 4,
  "==": 5,
  "===": 5,
  "!=": 5,
  "!==": 5,
  "<": 6,
  ">": 6,
  "<=": 6,
  ">=": 6,
  in: 6,
  instanceof: 6,
  ">>": 7,
  "<<": 7,
  ">>>": 7,
  "+": 8,
  "-": 8,
  "*": 9,
  "/": 9,
  "%": 9,
  "**": 10,
};
const isClassExtendsClause = (node, parent) =>
  (t$8().isClassDeclaration(parent) || t$8().isClassExpression(parent)) &&
  parent.superClass === node;
function NullableTypeAnnotation(node, parent) {
  return t$8().isArrayTypeAnnotation(parent);
}
function UpdateExpression$1(node, parent) {
  return (
    t$8().isMemberExpression(parent, { object: node }) ||
    t$8().isCallExpression(parent, { callee: node }) ||
    t$8().isNewExpression(parent, { callee: node }) ||
    isClassExtendsClause(node, parent)
  );
}
function ObjectExpression$1(node, parent, printStack) {
  return isFirstInStatement(printStack, { considerArrow: true });
}
function DoExpression$1(node, parent, printStack) {
  return isFirstInStatement(printStack);
}
function Binary(node, parent) {
  if (
    node.operator === "**" &&
    t$8().isBinaryExpression(parent, { operator: "**" })
  ) {
    return parent.left === node;
  }
  if (isClassExtendsClause(node, parent)) {
    return true;
  }
  if (
    ((t$8().isCallExpression(parent) || t$8().isNewExpression(parent)) &&
      parent.callee === node) ||
    t$8().isUnaryLike(parent) ||
    (t$8().isMemberExpression(parent) && parent.object === node) ||
    t$8().isAwaitExpression(parent)
  ) {
    return true;
  }
  if (t$8().isBinary(parent)) {
    const parentOp = parent.operator;
    const parentPos = PRECEDENCE[parentOp];
    const nodeOp = node.operator;
    const nodePos = PRECEDENCE[nodeOp];
    if (
      (parentPos === nodePos &&
        parent.right === node &&
        !t$8().isLogicalExpression(parent)) ||
      parentPos > nodePos
    ) {
      return true;
    }
  }
  return false;
}
function UnionTypeAnnotation(node, parent) {
  return (
    t$8().isArrayTypeAnnotation(parent) ||
    t$8().isNullableTypeAnnotation(parent) ||
    t$8().isIntersectionTypeAnnotation(parent) ||
    t$8().isUnionTypeAnnotation(parent)
  );
}
function TSAsExpression$1() {
  return true;
}
function TSTypeAssertion$1() {
  return true;
}
function BinaryExpression(node, parent) {
  return (
    node.operator === "in" &&
    (t$8().isVariableDeclarator(parent) || t$8().isFor(parent))
  );
}
function SequenceExpression$1(node, parent) {
  if (
    t$8().isForStatement(parent) ||
    t$8().isThrowStatement(parent) ||
    t$8().isReturnStatement(parent) ||
    (t$8().isIfStatement(parent) && parent.test === node) ||
    (t$8().isWhileStatement(parent) && parent.test === node) ||
    (t$8().isForInStatement(parent) && parent.right === node) ||
    (t$8().isSwitchStatement(parent) && parent.discriminant === node) ||
    (t$8().isExpressionStatement(parent) && parent.expression === node)
  ) {
    return false;
  }
  return true;
}
function YieldExpression$1(node, parent) {
  return (
    t$8().isBinary(parent) ||
    t$8().isUnaryLike(parent) ||
    t$8().isCallExpression(parent) ||
    t$8().isMemberExpression(parent) ||
    t$8().isNewExpression(parent) ||
    (t$8().isAwaitExpression(parent) && t$8().isYieldExpression(node)) ||
    (t$8().isConditionalExpression(parent) && node === parent.test) ||
    isClassExtendsClause(node, parent)
  );
}
function ClassExpression(node, parent, printStack) {
  return isFirstInStatement(printStack, { considerDefaultExports: true });
}
function UnaryLike(node, parent) {
  return (
    t$8().isMemberExpression(parent, { object: node }) ||
    t$8().isCallExpression(parent, { callee: node }) ||
    t$8().isNewExpression(parent, { callee: node }) ||
    t$8().isBinaryExpression(parent, { operator: "**", left: node }) ||
    isClassExtendsClause(node, parent)
  );
}
function FunctionExpression$1(node, parent, printStack) {
  return isFirstInStatement(printStack, { considerDefaultExports: true });
}
function ArrowFunctionExpression$1(node, parent) {
  return (
    t$8().isExportDeclaration(parent) || ConditionalExpression$1(node, parent)
  );
}
function ConditionalExpression$1(node, parent) {
  if (
    t$8().isUnaryLike(parent) ||
    t$8().isBinary(parent) ||
    t$8().isConditionalExpression(parent, { test: node }) ||
    t$8().isAwaitExpression(parent) ||
    t$8().isOptionalMemberExpression(parent) ||
    t$8().isTaggedTemplateExpression(parent) ||
    t$8().isTSTypeAssertion(parent) ||
    t$8().isTSAsExpression(parent)
  ) {
    return true;
  }
  return UnaryLike(node, parent);
}
function OptionalMemberExpression$1(node, parent) {
  return t$8().isCallExpression(parent) || t$8().isMemberExpression(parent);
}
function AssignmentExpression$1(node) {
  if (t$8().isObjectPattern(node.left)) {
    return true;
  } else {
    return ConditionalExpression$1(...arguments);
  }
}
function NewExpression$1(node, parent) {
  return isClassExtendsClause(node, parent);
}
function isFirstInStatement(
  printStack,
  {
    considerArrow: considerArrow = false,
    considerDefaultExports: considerDefaultExports = false,
  } = {}
) {
  let i = printStack.length - 1;
  let node = printStack[i];
  i--;
  let parent = printStack[i];
  while (i > 0) {
    if (
      t$8().isExpressionStatement(parent, { expression: node }) ||
      t$8().isTaggedTemplateExpression(parent) ||
      (considerDefaultExports &&
        t$8().isExportDefaultDeclaration(parent, { declaration: node })) ||
      (considerArrow && t$8().isArrowFunctionExpression(parent, { body: node }))
    ) {
      return true;
    }
    if (
      t$8().isCallExpression(parent, { callee: node }) ||
      (t$8().isSequenceExpression(parent) && parent.expressions[0] === node) ||
      t$8().isMemberExpression(parent, { object: node }) ||
      t$8().isConditional(parent, { test: node }) ||
      t$8().isBinary(parent, { left: node }) ||
      t$8().isAssignmentExpression(parent, { left: node })
    ) {
      node = parent;
      i--;
      parent = printStack[i];
    } else {
      return false;
    }
  }
  return false;
}
Object.defineProperty(node, "__esModule", { value: true });
node.needsWhitespace = needsWhitespace;
node.needsWhitespaceBefore = needsWhitespaceBefore;
node.needsWhitespaceAfter = needsWhitespaceAfter;
node.needsParens = needsParens;
var whitespace = _interopRequireWildcard$8(whitespace$1);
var parens = _interopRequireWildcard$8(parentheses);
function t$7() {
  const data = _interopRequireWildcard$8(requireLib());
  t$7 = function () {
    return data;
  };
  return data;
}
function _interopRequireWildcard$8(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function expandAliases(obj) {
  const newObj = {};
  function add(type, func) {
    const fn = newObj[type];
    newObj[type] = fn
      ? function (node, parent, stack) {
          const result = fn(node, parent, stack);
          return result == null ? func(node, parent, stack) : result;
        }
      : func;
  }
  for (const type of Object.keys(obj)) {
    const aliases = t$7().FLIPPED_ALIAS_KEYS[type];
    if (aliases) {
      for (const alias of aliases) {
        add(alias, obj[type]);
      }
    } else {
      add(type, obj[type]);
    }
  }
  return newObj;
}
const expandedParens = expandAliases(parens);
const expandedWhitespaceNodes = expandAliases(whitespace.nodes);
const expandedWhitespaceList = expandAliases(whitespace.list);
function find(obj, node, parent, printStack) {
  const fn = obj[node.type];
  return fn ? fn(node, parent, printStack) : null;
}
function isOrHasCallExpression(node) {
  if (t$7().isCallExpression(node)) {
    return true;
  }
  if (t$7().isMemberExpression(node)) {
    return (
      isOrHasCallExpression(node.object) ||
      (!node.computed && isOrHasCallExpression(node.property))
    );
  } else {
    return false;
  }
}
function needsWhitespace(node, parent, type) {
  if (!node) return 0;
  if (t$7().isExpressionStatement(node)) {
    node = node.expression;
  }
  let linesInfo = find(expandedWhitespaceNodes, node, parent);
  if (!linesInfo) {
    const items = find(expandedWhitespaceList, node, parent);
    if (items) {
      for (let i = 0; i < items.length; i++) {
        linesInfo = needsWhitespace(items[i], node, type);
        if (linesInfo) break;
      }
    }
  }
  if (typeof linesInfo === "object" && linesInfo !== null) {
    return linesInfo[type] || 0;
  }
  return 0;
}
function needsWhitespaceBefore(node, parent) {
  return needsWhitespace(node, parent, "before");
}
function needsWhitespaceAfter(node, parent) {
  return needsWhitespace(node, parent, "after");
}
function needsParens(node, parent, printStack) {
  if (!parent) return false;
  if (t$7().isNewExpression(parent) && parent.callee === node) {
    if (isOrHasCallExpression(node)) return true;
  }
  return find(expandedParens, node, parent, printStack);
}
var generators = {};
var templateLiterals = {};
Object.defineProperty(templateLiterals, "__esModule", { value: true });
templateLiterals.TaggedTemplateExpression = TaggedTemplateExpression;
templateLiterals.TemplateElement = TemplateElement;
templateLiterals.TemplateLiteral = TemplateLiteral;
function TaggedTemplateExpression(node) {
  this.print(node.tag, node);
  this.print(node.typeParameters, node);
  this.print(node.quasi, node);
}
function TemplateElement(node, parent) {
  const isFirst = parent.quasis[0] === node;
  const isLast = parent.quasis[parent.quasis.length - 1] === node;
  const value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
  this.token(value);
}
function TemplateLiteral(node) {
  const quasis = node.quasis;
  for (let i = 0; i < quasis.length; i++) {
    this.print(quasis[i], node);
    if (i + 1 < quasis.length) {
      this.print(node.expressions[i], node);
    }
  }
}
var expressions = {};
Object.defineProperty(expressions, "__esModule", { value: true });
expressions.UnaryExpression = UnaryExpression;
expressions.DoExpression = DoExpression;
expressions.ParenthesizedExpression = ParenthesizedExpression;
expressions.UpdateExpression = UpdateExpression;
expressions.ConditionalExpression = ConditionalExpression;
expressions.NewExpression = NewExpression;
expressions.SequenceExpression = SequenceExpression;
expressions.ThisExpression = ThisExpression;
expressions.Super = Super;
expressions.Decorator = Decorator;
expressions.OptionalMemberExpression = OptionalMemberExpression;
expressions.OptionalCallExpression = OptionalCallExpression;
expressions.CallExpression = CallExpression;
expressions.Import = Import;
expressions.EmptyStatement = EmptyStatement;
expressions.ExpressionStatement = ExpressionStatement;
expressions.AssignmentPattern = AssignmentPattern;
expressions.LogicalExpression =
  expressions.BinaryExpression =
  expressions.AssignmentExpression =
    AssignmentExpression;
expressions.BindExpression = BindExpression;
expressions.MemberExpression = MemberExpression;
expressions.MetaProperty = MetaProperty;
expressions.PrivateName = PrivateName;
expressions.AwaitExpression = expressions.YieldExpression = void 0;
function t$6() {
  const data = _interopRequireWildcard$7(requireLib());
  t$6 = function () {
    return data;
  };
  return data;
}
var n$1 = _interopRequireWildcard$7(node);
function _interopRequireWildcard$7(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function UnaryExpression(node) {
  if (
    node.operator === "void" ||
    node.operator === "delete" ||
    node.operator === "typeof" ||
    node.operator === "throw"
  ) {
    this.word(node.operator);
    this.space();
  } else {
    this.token(node.operator);
  }
  this.print(node.argument, node);
}
function DoExpression(node) {
  this.word("do");
  this.space();
  this.print(node.body, node);
}
function ParenthesizedExpression(node) {
  this.token("(");
  this.print(node.expression, node);
  this.token(")");
}
function UpdateExpression(node) {
  if (node.prefix) {
    this.token(node.operator);
    this.print(node.argument, node);
  } else {
    this.startTerminatorless(true);
    this.print(node.argument, node);
    this.endTerminatorless();
    this.token(node.operator);
  }
}
function ConditionalExpression(node) {
  this.print(node.test, node);
  this.space();
  this.token("?");
  this.space();
  this.print(node.consequent, node);
  this.space();
  this.token(":");
  this.space();
  this.print(node.alternate, node);
}
function NewExpression(node, parent) {
  this.word("new");
  this.space();
  this.print(node.callee, node);
  if (
    this.format.minified &&
    node.arguments.length === 0 &&
    !node.optional &&
    !t$6().isCallExpression(parent, { callee: node }) &&
    !t$6().isMemberExpression(parent) &&
    !t$6().isNewExpression(parent)
  ) {
    return;
  }
  this.print(node.typeArguments, node);
  this.print(node.typeParameters, node);
  if (node.optional) {
    this.token("?.");
  }
  this.token("(");
  this.printList(node.arguments, node);
  this.token(")");
}
function SequenceExpression(node) {
  this.printList(node.expressions, node);
}
function ThisExpression() {
  this.word("this");
}
function Super() {
  this.word("super");
}
function Decorator(node) {
  this.token("@");
  this.print(node.expression, node);
  this.newline();
}
function OptionalMemberExpression(node) {
  this.print(node.object, node);
  if (!node.computed && t$6().isMemberExpression(node.property)) {
    throw new TypeError("Got a MemberExpression for MemberExpression property");
  }
  let computed = node.computed;
  if (
    t$6().isLiteral(node.property) &&
    typeof node.property.value === "number"
  ) {
    computed = true;
  }
  if (node.optional) {
    this.token("?.");
  }
  if (computed) {
    this.token("[");
    this.print(node.property, node);
    this.token("]");
  } else {
    if (!node.optional) {
      this.token(".");
    }
    this.print(node.property, node);
  }
}
function OptionalCallExpression(node) {
  this.print(node.callee, node);
  this.print(node.typeArguments, node);
  this.print(node.typeParameters, node);
  if (node.optional) {
    this.token("?.");
  }
  this.token("(");
  this.printList(node.arguments, node);
  this.token(")");
}
function CallExpression(node) {
  this.print(node.callee, node);
  this.print(node.typeArguments, node);
  this.print(node.typeParameters, node);
  this.token("(");
  this.printList(node.arguments, node);
  this.token(")");
}
function Import() {
  this.word("import");
}
function buildYieldAwait(keyword) {
  return function (node) {
    this.word(keyword);
    if (node.delegate) {
      this.token("*");
    }
    if (node.argument) {
      this.space();
      const terminatorState = this.startTerminatorless();
      this.print(node.argument, node);
      this.endTerminatorless(terminatorState);
    }
  };
}
const YieldExpression = buildYieldAwait("yield");
expressions.YieldExpression = YieldExpression;
const AwaitExpression = buildYieldAwait("await");
expressions.AwaitExpression = AwaitExpression;
function EmptyStatement() {
  this.semicolon(true);
}
function ExpressionStatement(node) {
  this.print(node.expression, node);
  this.semicolon();
}
function AssignmentPattern(node) {
  this.print(node.left, node);
  if (node.left.optional) this.token("?");
  this.print(node.left.typeAnnotation, node);
  this.space();
  this.token("=");
  this.space();
  this.print(node.right, node);
}
function AssignmentExpression(node, parent) {
  const parens =
    this.inForStatementInitCounter &&
    node.operator === "in" &&
    !n$1.needsParens(node, parent);
  if (parens) {
    this.token("(");
  }
  this.print(node.left, node);
  this.space();
  if (node.operator === "in" || node.operator === "instanceof") {
    this.word(node.operator);
  } else {
    this.token(node.operator);
  }
  this.space();
  this.print(node.right, node);
  if (parens) {
    this.token(")");
  }
}
function BindExpression(node) {
  this.print(node.object, node);
  this.token("::");
  this.print(node.callee, node);
}
function MemberExpression(node) {
  this.print(node.object, node);
  if (!node.computed && t$6().isMemberExpression(node.property)) {
    throw new TypeError("Got a MemberExpression for MemberExpression property");
  }
  let computed = node.computed;
  if (
    t$6().isLiteral(node.property) &&
    typeof node.property.value === "number"
  ) {
    computed = true;
  }
  if (computed) {
    this.token("[");
    this.print(node.property, node);
    this.token("]");
  } else {
    this.token(".");
    this.print(node.property, node);
  }
}
function MetaProperty(node) {
  this.print(node.meta, node);
  this.token(".");
  this.print(node.property, node);
}
function PrivateName(node) {
  this.token("#");
  this.print(node.id, node);
}
var statements = {};
Object.defineProperty(statements, "__esModule", { value: true });
statements.WithStatement = WithStatement;
statements.IfStatement = IfStatement;
statements.ForStatement = ForStatement;
statements.WhileStatement = WhileStatement;
statements.DoWhileStatement = DoWhileStatement;
statements.LabeledStatement = LabeledStatement;
statements.TryStatement = TryStatement;
statements.CatchClause = CatchClause;
statements.SwitchStatement = SwitchStatement;
statements.SwitchCase = SwitchCase;
statements.DebuggerStatement = DebuggerStatement;
statements.VariableDeclaration = VariableDeclaration;
statements.VariableDeclarator = VariableDeclarator;
statements.ThrowStatement =
  statements.BreakStatement =
  statements.ReturnStatement =
  statements.ContinueStatement =
  statements.ForOfStatement =
  statements.ForInStatement =
    void 0;
function t$5() {
  const data = _interopRequireWildcard$6(requireLib());
  t$5 = function () {
    return data;
  };
  return data;
}
function _interopRequireWildcard$6(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function WithStatement(node) {
  this.word("with");
  this.space();
  this.token("(");
  this.print(node.object, node);
  this.token(")");
  this.printBlock(node);
}
function IfStatement(node) {
  this.word("if");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.space();
  const needsBlock =
    node.alternate && t$5().isIfStatement(getLastStatement(node.consequent));
  if (needsBlock) {
    this.token("{");
    this.newline();
    this.indent();
  }
  this.printAndIndentOnComments(node.consequent, node);
  if (needsBlock) {
    this.dedent();
    this.newline();
    this.token("}");
  }
  if (node.alternate) {
    if (this.endsWith("}")) this.space();
    this.word("else");
    this.space();
    this.printAndIndentOnComments(node.alternate, node);
  }
}
function getLastStatement(statement) {
  if (!t$5().isStatement(statement.body)) return statement;
  return getLastStatement(statement.body);
}
function ForStatement(node) {
  this.word("for");
  this.space();
  this.token("(");
  this.inForStatementInitCounter++;
  this.print(node.init, node);
  this.inForStatementInitCounter--;
  this.token(";");
  if (node.test) {
    this.space();
    this.print(node.test, node);
  }
  this.token(";");
  if (node.update) {
    this.space();
    this.print(node.update, node);
  }
  this.token(")");
  this.printBlock(node);
}
function WhileStatement(node) {
  this.word("while");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.printBlock(node);
}
const buildForXStatement = function (op) {
  return function (node) {
    this.word("for");
    this.space();
    if (op === "of" && node.await) {
      this.word("await");
      this.space();
    }
    this.token("(");
    this.print(node.left, node);
    this.space();
    this.word(op);
    this.space();
    this.print(node.right, node);
    this.token(")");
    this.printBlock(node);
  };
};
const ForInStatement = buildForXStatement("in");
statements.ForInStatement = ForInStatement;
const ForOfStatement = buildForXStatement("of");
statements.ForOfStatement = ForOfStatement;
function DoWhileStatement(node) {
  this.word("do");
  this.space();
  this.print(node.body, node);
  this.space();
  this.word("while");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.semicolon();
}
function buildLabelStatement(prefix, key = "label") {
  return function (node) {
    this.word(prefix);
    const label = node[key];
    if (label) {
      this.space();
      const isLabel = key == "label";
      const terminatorState = this.startTerminatorless(isLabel);
      this.print(label, node);
      this.endTerminatorless(terminatorState);
    }
    this.semicolon();
  };
}
const ContinueStatement = buildLabelStatement("continue");
statements.ContinueStatement = ContinueStatement;
const ReturnStatement = buildLabelStatement("return", "argument");
statements.ReturnStatement = ReturnStatement;
const BreakStatement = buildLabelStatement("break");
statements.BreakStatement = BreakStatement;
const ThrowStatement = buildLabelStatement("throw", "argument");
statements.ThrowStatement = ThrowStatement;
function LabeledStatement(node) {
  this.print(node.label, node);
  this.token(":");
  this.space();
  this.print(node.body, node);
}
function TryStatement(node) {
  this.word("try");
  this.space();
  this.print(node.block, node);
  this.space();
  if (node.handlers) {
    this.print(node.handlers[0], node);
  } else {
    this.print(node.handler, node);
  }
  if (node.finalizer) {
    this.space();
    this.word("finally");
    this.space();
    this.print(node.finalizer, node);
  }
}
function CatchClause(node) {
  this.word("catch");
  this.space();
  if (node.param) {
    this.token("(");
    this.print(node.param, node);
    this.token(")");
    this.space();
  }
  this.print(node.body, node);
}
function SwitchStatement(node) {
  this.word("switch");
  this.space();
  this.token("(");
  this.print(node.discriminant, node);
  this.token(")");
  this.space();
  this.token("{");
  this.printSequence(node.cases, node, {
    indent: true,
    addNewlines(leading, cas) {
      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
    },
  });
  this.token("}");
}
function SwitchCase(node) {
  if (node.test) {
    this.word("case");
    this.space();
    this.print(node.test, node);
    this.token(":");
  } else {
    this.word("default");
    this.token(":");
  }
  if (node.consequent.length) {
    this.newline();
    this.printSequence(node.consequent, node, { indent: true });
  }
}
function DebuggerStatement() {
  this.word("debugger");
  this.semicolon();
}
function variableDeclarationIndent() {
  this.token(",");
  this.newline();
  if (this.endsWith("\n")) for (let i = 0; i < 4; i++) this.space(true);
}
function constDeclarationIndent() {
  this.token(",");
  this.newline();
  if (this.endsWith("\n")) for (let i = 0; i < 6; i++) this.space(true);
}
function VariableDeclaration(node, parent) {
  if (node.declare) {
    this.word("declare");
    this.space();
  }
  this.word(node.kind);
  this.space();
  let hasInits = false;
  if (!t$5().isFor(parent)) {
    for (const declar of node.declarations) {
      if (declar.init) {
        hasInits = true;
      }
    }
  }
  let separator;
  if (hasInits) {
    separator =
      node.kind === "const"
        ? constDeclarationIndent
        : variableDeclarationIndent;
  }
  this.printList(node.declarations, node, { separator: separator });
  if (t$5().isFor(parent)) {
    if (parent.left === node || parent.init === node) return;
  }
  this.semicolon();
}
function VariableDeclarator(node) {
  this.print(node.id, node);
  if (node.definite) this.token("!");
  this.print(node.id.typeAnnotation, node);
  if (node.init) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.init, node);
  }
}
var classes = {};
Object.defineProperty(classes, "__esModule", { value: true });
classes.ClassExpression = classes.ClassDeclaration = ClassDeclaration;
classes.ClassBody = ClassBody;
classes.ClassProperty = ClassProperty;
classes.ClassPrivateProperty = ClassPrivateProperty;
classes.ClassMethod = ClassMethod;
classes.ClassPrivateMethod = ClassPrivateMethod;
classes._classMethodHead = _classMethodHead;
function t$4() {
  const data = _interopRequireWildcard$5(requireLib());
  t$4 = function () {
    return data;
  };
  return data;
}
function _interopRequireWildcard$5(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function ClassDeclaration(node, parent) {
  if (
    !this.format.decoratorsBeforeExport ||
    (!t$4().isExportDefaultDeclaration(parent) &&
      !t$4().isExportNamedDeclaration(parent))
  ) {
    this.printJoin(node.decorators, node);
  }
  if (node.declare) {
    this.word("declare");
    this.space();
  }
  if (node.abstract) {
    this.word("abstract");
    this.space();
  }
  this.word("class");
  if (node.id) {
    this.space();
    this.print(node.id, node);
  }
  this.print(node.typeParameters, node);
  if (node.superClass) {
    this.space();
    this.word("extends");
    this.space();
    this.print(node.superClass, node);
    this.print(node.superTypeParameters, node);
  }
  if (node.implements) {
    this.space();
    this.word("implements");
    this.space();
    this.printList(node.implements, node);
  }
  this.space();
  this.print(node.body, node);
}
function ClassBody(node) {
  this.token("{");
  this.printInnerComments(node);
  if (node.body.length === 0) {
    this.token("}");
  } else {
    this.newline();
    this.indent();
    this.printSequence(node.body, node);
    this.dedent();
    if (!this.endsWith("\n")) this.newline();
    this.rightBrace();
  }
}
function ClassProperty(node) {
  this.printJoin(node.decorators, node);
  if (node.accessibility) {
    this.word(node.accessibility);
    this.space();
  }
  if (node.static) {
    this.word("static");
    this.space();
  }
  if (node.abstract) {
    this.word("abstract");
    this.space();
  }
  if (node.readonly) {
    this.word("readonly");
    this.space();
  }
  if (node.computed) {
    this.token("[");
    this.print(node.key, node);
    this.token("]");
  } else {
    this._variance(node);
    this.print(node.key, node);
  }
  if (node.optional) {
    this.token("?");
  }
  if (node.definite) {
    this.token("!");
  }
  this.print(node.typeAnnotation, node);
  if (node.value) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.value, node);
  }
  this.semicolon();
}
function ClassPrivateProperty(node) {
  if (node.static) {
    this.word("static");
    this.space();
  }
  this.print(node.key, node);
  this.print(node.typeAnnotation, node);
  if (node.value) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.value, node);
  }
  this.semicolon();
}
function ClassMethod(node) {
  this._classMethodHead(node);
  this.space();
  this.print(node.body, node);
}
function ClassPrivateMethod(node) {
  this._classMethodHead(node);
  this.space();
  this.print(node.body, node);
}
function _classMethodHead(node) {
  this.printJoin(node.decorators, node);
  if (node.accessibility) {
    this.word(node.accessibility);
    this.space();
  }
  if (node.abstract) {
    this.word("abstract");
    this.space();
  }
  if (node.static) {
    this.word("static");
    this.space();
  }
  this._methodHead(node);
}
var methods = {};
Object.defineProperty(methods, "__esModule", { value: true });
methods._params = _params;
methods._parameters = _parameters;
methods._param = _param;
methods._methodHead = _methodHead;
methods._predicate = _predicate;
methods._functionHead = _functionHead;
methods.FunctionDeclaration = methods.FunctionExpression = FunctionExpression;
methods.ArrowFunctionExpression = ArrowFunctionExpression;
function t$3() {
  const data = _interopRequireWildcard$4(requireLib());
  t$3 = function () {
    return data;
  };
  return data;
}
function _interopRequireWildcard$4(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function _params(node) {
  this.print(node.typeParameters, node);
  this.token("(");
  this._parameters(node.params, node);
  this.token(")");
  this.print(node.returnType, node);
}
function _parameters(parameters, parent) {
  for (let i = 0; i < parameters.length; i++) {
    this._param(parameters[i], parent);
    if (i < parameters.length - 1) {
      this.token(",");
      this.space();
    }
  }
}
function _param(parameter, parent) {
  this.printJoin(parameter.decorators, parameter);
  this.print(parameter, parent);
  if (parameter.optional) this.token("?");
  this.print(parameter.typeAnnotation, parameter);
}
function _methodHead(node) {
  const kind = node.kind;
  const key = node.key;
  if (kind === "get" || kind === "set") {
    this.word(kind);
    this.space();
  }
  if (node.async) {
    this.word("async");
    this.space();
  }
  if (kind === "method" || kind === "init") {
    if (node.generator) {
      this.token("*");
    }
  }
  if (node.computed) {
    this.token("[");
    this.print(key, node);
    this.token("]");
  } else {
    this.print(key, node);
  }
  if (node.optional) {
    this.token("?");
  }
  this._params(node);
}
function _predicate(node) {
  if (node.predicate) {
    if (!node.returnType) {
      this.token(":");
    }
    this.space();
    this.print(node.predicate, node);
  }
}
function _functionHead(node) {
  if (node.async) {
    this.word("async");
    this.space();
  }
  this.word("function");
  if (node.generator) this.token("*");
  this.space();
  if (node.id) {
    this.print(node.id, node);
  }
  this._params(node);
  this._predicate(node);
}
function FunctionExpression(node) {
  this._functionHead(node);
  this.space();
  this.print(node.body, node);
}
function ArrowFunctionExpression(node) {
  if (node.async) {
    this.word("async");
    this.space();
  }
  const firstParam = node.params[0];
  if (
    node.params.length === 1 &&
    t$3().isIdentifier(firstParam) &&
    !hasTypes(node, firstParam)
  ) {
    if (
      this.format.retainLines &&
      node.loc &&
      node.body.loc &&
      node.loc.start.line < node.body.loc.start.line
    ) {
      this.token("(");
      if (firstParam.loc && firstParam.loc.start.line > node.loc.start.line) {
        this.indent();
        this.print(firstParam, node);
        this.dedent();
        this._catchUp("start", node.body.loc);
      } else {
        this.print(firstParam, node);
      }
      this.token(")");
    } else {
      this.print(firstParam, node);
    }
  } else {
    this._params(node);
  }
  this._predicate(node);
  this.space();
  this.token("=>");
  this.space();
  this.print(node.body, node);
}
function hasTypes(node, param) {
  return (
    node.typeParameters ||
    node.returnType ||
    param.typeAnnotation ||
    param.optional ||
    param.trailingComments
  );
}
var modules = {};
Object.defineProperty(modules, "__esModule", { value: true });
modules.ImportSpecifier = ImportSpecifier;
modules.ImportDefaultSpecifier = ImportDefaultSpecifier;
modules.ExportDefaultSpecifier = ExportDefaultSpecifier;
modules.ExportSpecifier = ExportSpecifier;
modules.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
modules.ExportAllDeclaration = ExportAllDeclaration;
modules.ExportNamedDeclaration = ExportNamedDeclaration;
modules.ExportDefaultDeclaration = ExportDefaultDeclaration;
modules.ImportDeclaration = ImportDeclaration;
modules.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
function t$2() {
  const data = _interopRequireWildcard$3(requireLib());
  t$2 = function () {
    return data;
  };
  return data;
}
function _interopRequireWildcard$3(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function ImportSpecifier(node) {
  if (node.importKind === "type" || node.importKind === "typeof") {
    this.word(node.importKind);
    this.space();
  }
  this.print(node.imported, node);
  if (node.local && node.local.name !== node.imported.name) {
    this.space();
    this.word("as");
    this.space();
    this.print(node.local, node);
  }
}
function ImportDefaultSpecifier(node) {
  this.print(node.local, node);
}
function ExportDefaultSpecifier(node) {
  this.print(node.exported, node);
}
function ExportSpecifier(node) {
  this.print(node.local, node);
  if (node.exported && node.local.name !== node.exported.name) {
    this.space();
    this.word("as");
    this.space();
    this.print(node.exported, node);
  }
}
function ExportNamespaceSpecifier(node) {
  this.token("*");
  this.space();
  this.word("as");
  this.space();
  this.print(node.exported, node);
}
function ExportAllDeclaration(node) {
  this.word("export");
  this.space();
  if (node.exportKind === "type") {
    this.word("type");
    this.space();
  }
  this.token("*");
  this.space();
  this.word("from");
  this.space();
  this.print(node.source, node);
  this.semicolon();
}
function ExportNamedDeclaration(node) {
  if (
    this.format.decoratorsBeforeExport &&
    t$2().isClassDeclaration(node.declaration)
  ) {
    this.printJoin(node.declaration.decorators, node);
  }
  this.word("export");
  this.space();
  ExportDeclaration.apply(this, arguments);
}
function ExportDefaultDeclaration(node) {
  if (
    this.format.decoratorsBeforeExport &&
    t$2().isClassDeclaration(node.declaration)
  ) {
    this.printJoin(node.declaration.decorators, node);
  }
  this.word("export");
  this.space();
  this.word("default");
  this.space();
  ExportDeclaration.apply(this, arguments);
}
function ExportDeclaration(node) {
  if (node.declaration) {
    const declar = node.declaration;
    this.print(declar, node);
    if (!t$2().isStatement(declar)) this.semicolon();
  } else {
    if (node.exportKind === "type") {
      this.word("type");
      this.space();
    }
    const specifiers = node.specifiers.slice(0);
    let hasSpecial = false;
    while (true) {
      const first = specifiers[0];
      if (
        t$2().isExportDefaultSpecifier(first) ||
        t$2().isExportNamespaceSpecifier(first)
      ) {
        hasSpecial = true;
        this.print(specifiers.shift(), node);
        if (specifiers.length) {
          this.token(",");
          this.space();
        }
      } else {
        break;
      }
    }
    if (specifiers.length || (!specifiers.length && !hasSpecial)) {
      this.token("{");
      if (specifiers.length) {
        this.space();
        this.printList(specifiers, node);
        this.space();
      }
      this.token("}");
    }
    if (node.source) {
      this.space();
      this.word("from");
      this.space();
      this.print(node.source, node);
    }
    this.semicolon();
  }
}
function ImportDeclaration(node) {
  this.word("import");
  this.space();
  if (node.importKind === "type" || node.importKind === "typeof") {
    this.word(node.importKind);
    this.space();
  }
  const specifiers = node.specifiers.slice(0);
  if (specifiers && specifiers.length) {
    while (true) {
      const first = specifiers[0];
      if (
        t$2().isImportDefaultSpecifier(first) ||
        t$2().isImportNamespaceSpecifier(first)
      ) {
        this.print(specifiers.shift(), node);
        if (specifiers.length) {
          this.token(",");
          this.space();
        }
      } else {
        break;
      }
    }
    if (specifiers.length) {
      this.token("{");
      this.space();
      this.printList(specifiers, node);
      this.space();
      this.token("}");
    }
    this.space();
    this.word("from");
    this.space();
  }
  this.print(node.source, node);
  this.semicolon();
}
function ImportNamespaceSpecifier(node) {
  this.token("*");
  this.space();
  this.word("as");
  this.space();
  this.print(node.local, node);
}
var types = {};
var jsesc_1;
var hasRequiredJsesc;
function requireJsesc() {
  if (hasRequiredJsesc) return jsesc_1;
  hasRequiredJsesc = 1;
  const object = {};
  const hasOwnProperty = object.hasOwnProperty;
  const forOwn = (object, callback) => {
    for (const key in object) {
      if (hasOwnProperty.call(object, key)) {
        callback(key, object[key]);
      }
    }
  };
  const extend = (destination, source) => {
    if (!source) {
      return destination;
    }
    forOwn(source, (key, value) => {
      destination[key] = value;
    });
    return destination;
  };
  const forEach = (array, callback) => {
    const length = array.length;
    let index = -1;
    while (++index < length) {
      callback(array[index]);
    }
  };
  const toString = object.toString;
  const isArray = Array.isArray;
  const isBuffer = Buffer.isBuffer;
  const isObject = (value) => toString.call(value) == "[object Object]";
  const isString = (value) =>
    typeof value == "string" || toString.call(value) == "[object String]";
  const isNumber = (value) =>
    typeof value == "number" || toString.call(value) == "[object Number]";
  const isFunction = (value) => typeof value == "function";
  const isMap = (value) => toString.call(value) == "[object Map]";
  const isSet = (value) => toString.call(value) == "[object Set]";
  const singleEscapes = {
    '"': '\\"',
    "'": "\\'",
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "\t": "\\t",
  };
  const regexSingleEscape = /["'\\\b\f\n\r\t]/;
  const regexDigit = /[0-9]/;
  const regexWhitelist = /[ !#-&\(-\[\]-_a-~]/;
  const jsesc = (argument, options) => {
    const increaseIndentation = () => {
      oldIndent = indent;
      ++options.indentLevel;
      indent = options.indent.repeat(options.indentLevel);
    };
    const defaults = {
      escapeEverything: false,
      minimal: false,
      isScriptContext: false,
      quotes: "single",
      wrap: false,
      es6: false,
      json: false,
      compact: true,
      lowercaseHex: false,
      numbers: "decimal",
      indent: "\t",
      indentLevel: 0,
      __inline1__: false,
      __inline2__: false,
    };
    const json = options && options.json;
    if (json) {
      defaults.quotes = "double";
      defaults.wrap = true;
    }
    options = extend(defaults, options);
    if (
      options.quotes != "single" &&
      options.quotes != "double" &&
      options.quotes != "backtick"
    ) {
      options.quotes = "single";
    }
    const quote =
      options.quotes == "double"
        ? '"'
        : options.quotes == "backtick"
          ? "`"
          : "'";
    const compact = options.compact;
    const lowercaseHex = options.lowercaseHex;
    let indent = options.indent.repeat(options.indentLevel);
    let oldIndent = "";
    const inline1 = options.__inline1__;
    const inline2 = options.__inline2__;
    const newLine = compact ? "" : "\n";
    let result;
    let isEmpty = true;
    const useBinNumbers = options.numbers == "binary";
    const useOctNumbers = options.numbers == "octal";
    const useDecNumbers = options.numbers == "decimal";
    const useHexNumbers = options.numbers == "hexadecimal";
    if (json && argument && isFunction(argument.toJSON)) {
      argument = argument.toJSON();
    }
    if (!isString(argument)) {
      if (isMap(argument)) {
        if (argument.size == 0) {
          return "new Map()";
        }
        if (!compact) {
          options.__inline1__ = true;
          options.__inline2__ = false;
        }
        return "new Map(" + jsesc(Array.from(argument), options) + ")";
      }
      if (isSet(argument)) {
        if (argument.size == 0) {
          return "new Set()";
        }
        return "new Set(" + jsesc(Array.from(argument), options) + ")";
      }
      if (isBuffer(argument)) {
        if (argument.length == 0) {
          return "Buffer.from([])";
        }
        return "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
      }
      if (isArray(argument)) {
        result = [];
        options.wrap = true;
        if (inline1) {
          options.__inline1__ = false;
          options.__inline2__ = true;
        }
        if (!inline2) {
          increaseIndentation();
        }
        forEach(argument, (value) => {
          isEmpty = false;
          if (inline2) {
            options.__inline2__ = false;
          }
          result.push(
            (compact || inline2 ? "" : indent) + jsesc(value, options)
          );
        });
        if (isEmpty) {
          return "[]";
        }
        if (inline2) {
          return "[" + result.join(", ") + "]";
        }
        return (
          "[" +
          newLine +
          result.join("," + newLine) +
          newLine +
          (compact ? "" : oldIndent) +
          "]"
        );
      } else if (isNumber(argument)) {
        if (json) {
          return JSON.stringify(argument);
        }
        if (useDecNumbers) {
          return String(argument);
        }
        if (useHexNumbers) {
          let hexadecimal = argument.toString(16);
          if (!lowercaseHex) {
            hexadecimal = hexadecimal.toUpperCase();
          }
          return "0x" + hexadecimal;
        }
        if (useBinNumbers) {
          return "0b" + argument.toString(2);
        }
        if (useOctNumbers) {
          return "0o" + argument.toString(8);
        }
      } else if (!isObject(argument)) {
        if (json) {
          return JSON.stringify(argument) || "null";
        }
        return String(argument);
      } else {
        result = [];
        options.wrap = true;
        increaseIndentation();
        forOwn(argument, (key, value) => {
          isEmpty = false;
          result.push(
            (compact ? "" : indent) +
              jsesc(key, options) +
              ":" +
              (compact ? "" : " ") +
              jsesc(value, options)
          );
        });
        if (isEmpty) {
          return "{}";
        }
        return (
          "{" +
          newLine +
          result.join("," + newLine) +
          newLine +
          (compact ? "" : oldIndent) +
          "}"
        );
      }
    }
    const string = argument;
    let index = -1;
    const length = string.length;
    result = "";
    while (++index < length) {
      const character = string.charAt(index);
      if (options.es6) {
        const first = string.charCodeAt(index);
        if (first >= 55296 && first <= 56319 && length > index + 1) {
          const second = string.charCodeAt(index + 1);
          if (second >= 56320 && second <= 57343) {
            const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
            let hexadecimal = codePoint.toString(16);
            if (!lowercaseHex) {
              hexadecimal = hexadecimal.toUpperCase();
            }
            result += "\\u{" + hexadecimal + "}";
            ++index;
            continue;
          }
        }
      }
      if (!options.escapeEverything) {
        if (regexWhitelist.test(character)) {
          result += character;
          continue;
        }
        if (character == '"') {
          result += quote == character ? '\\"' : character;
          continue;
        }
        if (character == "`") {
          result += quote == character ? "\\`" : character;
          continue;
        }
        if (character == "'") {
          result += quote == character ? "\\'" : character;
          continue;
        }
      }
      if (
        character == "\0" &&
        !json &&
        !regexDigit.test(string.charAt(index + 1))
      ) {
        result += "\\0";
        continue;
      }
      if (regexSingleEscape.test(character)) {
        result += singleEscapes[character];
        continue;
      }
      const charCode = character.charCodeAt(0);
      if (options.minimal && charCode != 8232 && charCode != 8233) {
        result += character;
        continue;
      }
      let hexadecimal = charCode.toString(16);
      if (!lowercaseHex) {
        hexadecimal = hexadecimal.toUpperCase();
      }
      const longhand = hexadecimal.length > 2 || json;
      const escaped =
        "\\" +
        (longhand ? "u" : "x") +
        ("0000" + hexadecimal).slice(longhand ? -4 : -2);
      result += escaped;
      continue;
    }
    if (options.wrap) {
      result = quote + result + quote;
    }
    if (quote == "`") {
      result = result.replace(/\$\{/g, "\\${");
    }
    if (options.isScriptContext) {
      return result
        .replace(/<\/(script|style)/gi, "<\\/$1")
        .replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--");
    }
    return result;
  };
  jsesc.version = "2.5.2";
  jsesc_1 = jsesc;
  return jsesc_1;
}
Object.defineProperty(types, "__esModule", { value: true });
types.Identifier = Identifier;
types.SpreadElement = types.RestElement = RestElement;
types.ObjectPattern = types.ObjectExpression = ObjectExpression;
types.ObjectMethod = ObjectMethod;
types.ObjectProperty = ObjectProperty;
types.ArrayPattern = types.ArrayExpression = ArrayExpression;
types.RegExpLiteral = RegExpLiteral;
types.BooleanLiteral = BooleanLiteral;
types.NullLiteral = NullLiteral;
types.NumericLiteral = NumericLiteral;
types.StringLiteral = StringLiteral;
types.BigIntLiteral = BigIntLiteral;
function t$1() {
  const data = _interopRequireWildcard$2(requireLib());
  t$1 = function () {
    return data;
  };
  return data;
}
function _jsesc() {
  const data = _interopRequireDefault$5(requireJsesc());
  _jsesc = function () {
    return data;
  };
  return data;
}
function _interopRequireDefault$5(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _interopRequireWildcard$2(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function Identifier(node) {
  this.exactSource(node.loc, () => {
    this.word(node.name);
  });
}
function RestElement(node) {
  this.token("...");
  this.print(node.argument, node);
}
function ObjectExpression(node) {
  const props = node.properties;
  this.token("{");
  this.printInnerComments(node);
  if (props.length) {
    this.space();
    this.printList(props, node, { indent: true, statement: true });
    this.space();
  }
  this.token("}");
}
function ObjectMethod(node) {
  this.printJoin(node.decorators, node);
  this._methodHead(node);
  this.space();
  this.print(node.body, node);
}
function ObjectProperty(node) {
  this.printJoin(node.decorators, node);
  if (node.computed) {
    this.token("[");
    this.print(node.key, node);
    this.token("]");
  } else {
    if (
      t$1().isAssignmentPattern(node.value) &&
      t$1().isIdentifier(node.key) &&
      node.key.name === node.value.left.name
    ) {
      this.print(node.value, node);
      return;
    }
    this.print(node.key, node);
    if (
      node.shorthand &&
      t$1().isIdentifier(node.key) &&
      t$1().isIdentifier(node.value) &&
      node.key.name === node.value.name
    ) {
      return;
    }
  }
  this.token(":");
  this.space();
  this.print(node.value, node);
}
function ArrayExpression(node) {
  const elems = node.elements;
  const len = elems.length;
  this.token("[");
  this.printInnerComments(node);
  for (let i = 0; i < elems.length; i++) {
    const elem = elems[i];
    if (elem) {
      if (i > 0) this.space();
      this.print(elem, node);
      if (i < len - 1) this.token(",");
    } else {
      this.token(",");
    }
  }
  this.token("]");
}
function RegExpLiteral(node) {
  this.word(`/${node.pattern}/${node.flags}`);
}
function BooleanLiteral(node) {
  this.word(node.value ? "true" : "false");
}
function NullLiteral() {
  this.word("null");
}
function NumericLiteral(node) {
  const raw = this.getPossibleRaw(node);
  const value = node.value + "";
  if (raw == null) {
    this.number(value);
  } else if (this.format.minified) {
    this.number(raw.length < value.length ? raw : value);
  } else {
    this.number(raw);
  }
}
function StringLiteral(node) {
  const raw = this.getPossibleRaw(node);
  if (!this.format.minified && raw != null) {
    this.token(raw);
    return;
  }
  const opts = this.format.jsescOption;
  if (this.format.jsonCompatibleStrings) {
    opts.json = true;
  }
  const val = (0, _jsesc().default)(node.value, opts);
  return this.token(val);
}
function BigIntLiteral(node) {
  const raw = this.getPossibleRaw(node);
  if (!this.format.minified && raw != null) {
    this.token(raw);
    return;
  }
  this.token(node.value);
}
var flow = {};
(function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnyTypeAnnotation = AnyTypeAnnotation;
  exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
  exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
  exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
  exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
  exports.DeclareClass = DeclareClass;
  exports.DeclareFunction = DeclareFunction;
  exports.InferredPredicate = InferredPredicate;
  exports.DeclaredPredicate = DeclaredPredicate;
  exports.DeclareInterface = DeclareInterface;
  exports.DeclareModule = DeclareModule;
  exports.DeclareModuleExports = DeclareModuleExports;
  exports.DeclareTypeAlias = DeclareTypeAlias;
  exports.DeclareOpaqueType = DeclareOpaqueType;
  exports.DeclareVariable = DeclareVariable;
  exports.DeclareExportDeclaration = DeclareExportDeclaration;
  exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
  exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
  exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
  exports.FunctionTypeParam = FunctionTypeParam;
  exports.GenericTypeAnnotation =
    exports.ClassImplements =
    exports.InterfaceExtends =
      InterfaceExtends;
  exports._interfaceish = _interfaceish;
  exports._variance = _variance;
  exports.InterfaceDeclaration = InterfaceDeclaration;
  exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
  exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
  exports.MixedTypeAnnotation = MixedTypeAnnotation;
  exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
  exports.NullableTypeAnnotation = NullableTypeAnnotation;
  exports.NumberTypeAnnotation = NumberTypeAnnotation;
  exports.StringTypeAnnotation = StringTypeAnnotation;
  exports.ThisTypeAnnotation = ThisTypeAnnotation;
  exports.TupleTypeAnnotation = TupleTypeAnnotation;
  exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
  exports.TypeAlias = TypeAlias;
  exports.TypeAnnotation = TypeAnnotation;
  exports.TypeParameterDeclaration = exports.TypeParameterInstantiation =
    TypeParameterInstantiation;
  exports.TypeParameter = TypeParameter;
  exports.OpaqueType = OpaqueType;
  exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
  exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
  exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
  exports.ObjectTypeIndexer = ObjectTypeIndexer;
  exports.ObjectTypeProperty = ObjectTypeProperty;
  exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
  exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
  exports.UnionTypeAnnotation = UnionTypeAnnotation;
  exports.TypeCastExpression = TypeCastExpression;
  exports.Variance = Variance;
  exports.VoidTypeAnnotation = VoidTypeAnnotation;
  Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _types2.NumericLiteral;
    },
  });
  Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _types2.StringLiteral;
    },
  });
  function t() {
    const data = _interopRequireWildcard(requireLib());
    t = function () {
      return data;
    };
    return data;
  }
  var _modules = modules;
  var _types2 = types;
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc =
              Object.defineProperty && Object.getOwnPropertyDescriptor
                ? Object.getOwnPropertyDescriptor(obj, key)
                : {};
            if (desc.get || desc.set) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function AnyTypeAnnotation() {
    this.word("any");
  }
  function ArrayTypeAnnotation(node) {
    this.print(node.elementType, node);
    this.token("[");
    this.token("]");
  }
  function BooleanTypeAnnotation() {
    this.word("boolean");
  }
  function BooleanLiteralTypeAnnotation(node) {
    this.word(node.value ? "true" : "false");
  }
  function NullLiteralTypeAnnotation() {
    this.word("null");
  }
  function DeclareClass(node, parent) {
    if (!t().isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }
    this.word("class");
    this.space();
    this._interfaceish(node);
  }
  function DeclareFunction(node, parent) {
    if (!t().isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }
    this.word("function");
    this.space();
    this.print(node.id, node);
    this.print(node.id.typeAnnotation.typeAnnotation, node);
    if (node.predicate) {
      this.space();
      this.print(node.predicate, node);
    }
    this.semicolon();
  }
  function InferredPredicate() {
    this.token("%");
    this.word("checks");
  }
  function DeclaredPredicate(node) {
    this.token("%");
    this.word("checks");
    this.token("(");
    this.print(node.value, node);
    this.token(")");
  }
  function DeclareInterface(node) {
    this.word("declare");
    this.space();
    this.InterfaceDeclaration(node);
  }
  function DeclareModule(node) {
    this.word("declare");
    this.space();
    this.word("module");
    this.space();
    this.print(node.id, node);
    this.space();
    this.print(node.body, node);
  }
  function DeclareModuleExports(node) {
    this.word("declare");
    this.space();
    this.word("module");
    this.token(".");
    this.word("exports");
    this.print(node.typeAnnotation, node);
  }
  function DeclareTypeAlias(node) {
    this.word("declare");
    this.space();
    this.TypeAlias(node);
  }
  function DeclareOpaqueType(node, parent) {
    if (!t().isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }
    this.OpaqueType(node);
  }
  function DeclareVariable(node, parent) {
    if (!t().isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }
    this.word("var");
    this.space();
    this.print(node.id, node);
    this.print(node.id.typeAnnotation, node);
    this.semicolon();
  }
  function DeclareExportDeclaration(node) {
    this.word("declare");
    this.space();
    this.word("export");
    this.space();
    if (node.default) {
      this.word("default");
      this.space();
    }
    FlowExportDeclaration.apply(this, arguments);
  }
  function DeclareExportAllDeclaration() {
    this.word("declare");
    this.space();
    _modules.ExportAllDeclaration.apply(this, arguments);
  }
  function FlowExportDeclaration(node) {
    if (node.declaration) {
      const declar = node.declaration;
      this.print(declar, node);
      if (!t().isStatement(declar)) this.semicolon();
    } else {
      this.token("{");
      if (node.specifiers.length) {
        this.space();
        this.printList(node.specifiers, node);
        this.space();
      }
      this.token("}");
      if (node.source) {
        this.space();
        this.word("from");
        this.space();
        this.print(node.source, node);
      }
      this.semicolon();
    }
  }
  function ExistsTypeAnnotation() {
    this.token("*");
  }
  function FunctionTypeAnnotation(node, parent) {
    this.print(node.typeParameters, node);
    this.token("(");
    this.printList(node.params, node);
    if (node.rest) {
      if (node.params.length) {
        this.token(",");
        this.space();
      }
      this.token("...");
      this.print(node.rest, node);
    }
    this.token(")");
    if (
      parent.type === "ObjectTypeCallProperty" ||
      parent.type === "DeclareFunction" ||
      (parent.type === "ObjectTypeProperty" && parent.method)
    ) {
      this.token(":");
    } else {
      this.space();
      this.token("=>");
    }
    this.space();
    this.print(node.returnType, node);
  }
  function FunctionTypeParam(node) {
    this.print(node.name, node);
    if (node.optional) this.token("?");
    if (node.name) {
      this.token(":");
      this.space();
    }
    this.print(node.typeAnnotation, node);
  }
  function InterfaceExtends(node) {
    this.print(node.id, node);
    this.print(node.typeParameters, node);
  }
  function _interfaceish(node) {
    this.print(node.id, node);
    this.print(node.typeParameters, node);
    if (node.extends.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(node.extends, node);
    }
    if (node.mixins && node.mixins.length) {
      this.space();
      this.word("mixins");
      this.space();
      this.printList(node.mixins, node);
    }
    if (node.implements && node.implements.length) {
      this.space();
      this.word("implements");
      this.space();
      this.printList(node.implements, node);
    }
    this.space();
    this.print(node.body, node);
  }
  function _variance(node) {
    if (node.variance) {
      if (node.variance.kind === "plus") {
        this.token("+");
      } else if (node.variance.kind === "minus") {
        this.token("-");
      }
    }
  }
  function InterfaceDeclaration(node) {
    this.word("interface");
    this.space();
    this._interfaceish(node);
  }
  function andSeparator() {
    this.space();
    this.token("&");
    this.space();
  }
  function InterfaceTypeAnnotation(node) {
    this.word("interface");
    if (node.extends && node.extends.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(node.extends, node);
    }
    this.space();
    this.print(node.body, node);
  }
  function IntersectionTypeAnnotation(node) {
    this.printJoin(node.types, node, { separator: andSeparator });
  }
  function MixedTypeAnnotation() {
    this.word("mixed");
  }
  function EmptyTypeAnnotation() {
    this.word("empty");
  }
  function NullableTypeAnnotation(node) {
    this.token("?");
    this.print(node.typeAnnotation, node);
  }
  function NumberTypeAnnotation() {
    this.word("number");
  }
  function StringTypeAnnotation() {
    this.word("string");
  }
  function ThisTypeAnnotation() {
    this.word("this");
  }
  function TupleTypeAnnotation(node) {
    this.token("[");
    this.printList(node.types, node);
    this.token("]");
  }
  function TypeofTypeAnnotation(node) {
    this.word("typeof");
    this.space();
    this.print(node.argument, node);
  }
  function TypeAlias(node) {
    this.word("type");
    this.space();
    this.print(node.id, node);
    this.print(node.typeParameters, node);
    this.space();
    this.token("=");
    this.space();
    this.print(node.right, node);
    this.semicolon();
  }
  function TypeAnnotation(node) {
    this.token(":");
    this.space();
    if (node.optional) this.token("?");
    this.print(node.typeAnnotation, node);
  }
  function TypeParameterInstantiation(node) {
    this.token("<");
    this.printList(node.params, node, {});
    this.token(">");
  }
  function TypeParameter(node) {
    this._variance(node);
    this.word(node.name);
    if (node.bound) {
      this.print(node.bound, node);
    }
    if (node.default) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.default, node);
    }
  }
  function OpaqueType(node) {
    this.word("opaque");
    this.space();
    this.word("type");
    this.space();
    this.print(node.id, node);
    this.print(node.typeParameters, node);
    if (node.supertype) {
      this.token(":");
      this.space();
      this.print(node.supertype, node);
    }
    if (node.impltype) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.impltype, node);
    }
    this.semicolon();
  }
  function ObjectTypeAnnotation(node) {
    if (node.exact) {
      this.token("{|");
    } else {
      this.token("{");
    }
    const props = node.properties.concat(
      node.callProperties || [],
      node.indexers || [],
      node.internalSlots || []
    );
    if (props.length) {
      this.space();
      this.printJoin(props, node, {
        addNewlines(leading) {
          if (leading && !props[0]) return 1;
        },
        indent: true,
        statement: true,
        iterator: () => {
          if (props.length !== 1) {
            this.token(",");
            this.space();
          }
        },
      });
      this.space();
    }
    if (node.exact) {
      this.token("|}");
    } else {
      this.token("}");
    }
  }
  function ObjectTypeInternalSlot(node) {
    if (node.static) {
      this.word("static");
      this.space();
    }
    this.token("[");
    this.token("[");
    this.print(node.id, node);
    this.token("]");
    this.token("]");
    if (node.optional) this.token("?");
    if (!node.method) {
      this.token(":");
      this.space();
    }
    this.print(node.value, node);
  }
  function ObjectTypeCallProperty(node) {
    if (node.static) {
      this.word("static");
      this.space();
    }
    this.print(node.value, node);
  }
  function ObjectTypeIndexer(node) {
    if (node.static) {
      this.word("static");
      this.space();
    }
    this._variance(node);
    this.token("[");
    if (node.id) {
      this.print(node.id, node);
      this.token(":");
      this.space();
    }
    this.print(node.key, node);
    this.token("]");
    this.token(":");
    this.space();
    this.print(node.value, node);
  }
  function ObjectTypeProperty(node) {
    if (node.proto) {
      this.word("proto");
      this.space();
    }
    if (node.static) {
      this.word("static");
      this.space();
    }
    this._variance(node);
    this.print(node.key, node);
    if (node.optional) this.token("?");
    if (!node.method) {
      this.token(":");
      this.space();
    }
    this.print(node.value, node);
  }
  function ObjectTypeSpreadProperty(node) {
    this.token("...");
    this.print(node.argument, node);
  }
  function QualifiedTypeIdentifier(node) {
    this.print(node.qualification, node);
    this.token(".");
    this.print(node.id, node);
  }
  function orSeparator() {
    this.space();
    this.token("|");
    this.space();
  }
  function UnionTypeAnnotation(node) {
    this.printJoin(node.types, node, { separator: orSeparator });
  }
  function TypeCastExpression(node) {
    this.token("(");
    this.print(node.expression, node);
    this.print(node.typeAnnotation, node);
    this.token(")");
  }
  function Variance(node) {
    if (node.kind === "plus") {
      this.token("+");
    } else {
      this.token("-");
    }
  }
  function VoidTypeAnnotation() {
    this.word("void");
  }
})(flow);
var base = {};
(function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.File = File;
  exports.Program = Program;
  exports.BlockStatement = BlockStatement;
  exports.Noop = Noop;
  exports.Directive = Directive;
  exports.InterpreterDirective = InterpreterDirective;
  Object.defineProperty(exports, "DirectiveLiteral", {
    enumerable: true,
    get: function () {
      return _types.StringLiteral;
    },
  });
  var _types = types;
  function File(node) {
    if (node.program) {
      this.print(node.program.interpreter, node);
    }
    this.print(node.program, node);
  }
  function Program(node) {
    this.printInnerComments(node, false);
    this.printSequence(node.directives, node);
    if (node.directives && node.directives.length) this.newline();
    this.printSequence(node.body, node);
  }
  function BlockStatement(node) {
    this.token("{");
    this.printInnerComments(node);
    const hasDirectives = node.directives && node.directives.length;
    if (node.body.length || hasDirectives) {
      this.newline();
      this.printSequence(node.directives, node, { indent: true });
      if (hasDirectives) this.newline();
      this.printSequence(node.body, node, { indent: true });
      this.removeTrailingNewline();
      this.source("end", node.loc);
      if (!this.endsWith("\n")) this.newline();
      this.rightBrace();
    } else {
      this.source("end", node.loc);
      this.token("}");
    }
  }
  function Noop() {}
  function Directive(node) {
    this.print(node.value, node);
    this.semicolon();
  }
  function InterpreterDirective(node) {
    this.token(`#!${node.value}\n`);
  }
})(base);
var jsx = {};
Object.defineProperty(jsx, "__esModule", { value: true });
jsx.JSXAttribute = JSXAttribute;
jsx.JSXIdentifier = JSXIdentifier;
jsx.JSXNamespacedName = JSXNamespacedName;
jsx.JSXMemberExpression = JSXMemberExpression;
jsx.JSXSpreadAttribute = JSXSpreadAttribute;
jsx.JSXExpressionContainer = JSXExpressionContainer;
jsx.JSXSpreadChild = JSXSpreadChild;
jsx.JSXText = JSXText;
jsx.JSXElement = JSXElement;
jsx.JSXOpeningElement = JSXOpeningElement;
jsx.JSXClosingElement = JSXClosingElement;
jsx.JSXEmptyExpression = JSXEmptyExpression;
jsx.JSXFragment = JSXFragment;
jsx.JSXOpeningFragment = JSXOpeningFragment;
jsx.JSXClosingFragment = JSXClosingFragment;
function JSXAttribute(node) {
  this.print(node.name, node);
  if (node.value) {
    this.token("=");
    this.print(node.value, node);
  }
}
function JSXIdentifier(node) {
  this.word(node.name);
}
function JSXNamespacedName(node) {
  this.print(node.namespace, node);
  this.token(":");
  this.print(node.name, node);
}
function JSXMemberExpression(node) {
  this.print(node.object, node);
  this.token(".");
  this.print(node.property, node);
}
function JSXSpreadAttribute(node) {
  this.token("{");
  this.token("...");
  this.print(node.argument, node);
  this.token("}");
}
function JSXExpressionContainer(node) {
  this.token("{");
  this.print(node.expression, node);
  this.token("}");
}
function JSXSpreadChild(node) {
  this.token("{");
  this.token("...");
  this.print(node.expression, node);
  this.token("}");
}
function JSXText(node) {
  const raw = this.getPossibleRaw(node);
  if (raw != null) {
    this.token(raw);
  } else {
    this.token(node.value);
  }
}
function JSXElement(node) {
  const open = node.openingElement;
  this.print(open, node);
  if (open.selfClosing) return;
  this.indent();
  for (const child of node.children) {
    this.print(child, node);
  }
  this.dedent();
  this.print(node.closingElement, node);
}
function spaceSeparator() {
  this.space();
}
function JSXOpeningElement(node) {
  this.token("<");
  this.print(node.name, node);
  this.print(node.typeParameters, node);
  if (node.attributes.length > 0) {
    this.space();
    this.printJoin(node.attributes, node, { separator: spaceSeparator });
  }
  if (node.selfClosing) {
    this.space();
    this.token("/>");
  } else {
    this.token(">");
  }
}
function JSXClosingElement(node) {
  this.token("</");
  this.print(node.name, node);
  this.token(">");
}
function JSXEmptyExpression(node) {
  this.printInnerComments(node);
}
function JSXFragment(node) {
  this.print(node.openingFragment, node);
  this.indent();
  for (const child of node.children) {
    this.print(child, node);
  }
  this.dedent();
  this.print(node.closingFragment, node);
}
function JSXOpeningFragment() {
  this.token("<");
  this.token(">");
}
function JSXClosingFragment() {
  this.token("</");
  this.token(">");
}
var typescript = {};
Object.defineProperty(typescript, "__esModule", { value: true });
typescript.TSTypeAnnotation = TSTypeAnnotation;
typescript.TSTypeParameterDeclaration =
  typescript.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
typescript.TSTypeParameter = TSTypeParameter;
typescript.TSParameterProperty = TSParameterProperty;
typescript.TSDeclareFunction = TSDeclareFunction;
typescript.TSDeclareMethod = TSDeclareMethod;
typescript.TSQualifiedName = TSQualifiedName;
typescript.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
typescript.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
typescript.TSPropertySignature = TSPropertySignature;
typescript.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
typescript.TSMethodSignature = TSMethodSignature;
typescript.TSIndexSignature = TSIndexSignature;
typescript.TSAnyKeyword = TSAnyKeyword;
typescript.TSUnknownKeyword = TSUnknownKeyword;
typescript.TSNumberKeyword = TSNumberKeyword;
typescript.TSObjectKeyword = TSObjectKeyword;
typescript.TSBooleanKeyword = TSBooleanKeyword;
typescript.TSStringKeyword = TSStringKeyword;
typescript.TSSymbolKeyword = TSSymbolKeyword;
typescript.TSVoidKeyword = TSVoidKeyword;
typescript.TSUndefinedKeyword = TSUndefinedKeyword;
typescript.TSNullKeyword = TSNullKeyword;
typescript.TSNeverKeyword = TSNeverKeyword;
typescript.TSThisType = TSThisType;
typescript.TSFunctionType = TSFunctionType;
typescript.TSConstructorType = TSConstructorType;
typescript.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
typescript.TSTypeReference = TSTypeReference;
typescript.TSTypePredicate = TSTypePredicate;
typescript.TSTypeQuery = TSTypeQuery;
typescript.TSTypeLiteral = TSTypeLiteral;
typescript.tsPrintTypeLiteralOrInterfaceBody =
  tsPrintTypeLiteralOrInterfaceBody;
typescript.tsPrintBraced = tsPrintBraced;
typescript.TSArrayType = TSArrayType;
typescript.TSTupleType = TSTupleType;
typescript.TSOptionalType = TSOptionalType;
typescript.TSRestType = TSRestType;
typescript.TSUnionType = TSUnionType;
typescript.TSIntersectionType = TSIntersectionType;
typescript.tsPrintUnionOrIntersectionType = tsPrintUnionOrIntersectionType;
typescript.TSConditionalType = TSConditionalType;
typescript.TSInferType = TSInferType;
typescript.TSParenthesizedType = TSParenthesizedType;
typescript.TSTypeOperator = TSTypeOperator;
typescript.TSIndexedAccessType = TSIndexedAccessType;
typescript.TSMappedType = TSMappedType;
typescript.TSLiteralType = TSLiteralType;
typescript.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
typescript.TSInterfaceDeclaration = TSInterfaceDeclaration;
typescript.TSInterfaceBody = TSInterfaceBody;
typescript.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
typescript.TSAsExpression = TSAsExpression;
typescript.TSTypeAssertion = TSTypeAssertion;
typescript.TSEnumDeclaration = TSEnumDeclaration;
typescript.TSEnumMember = TSEnumMember;
typescript.TSModuleDeclaration = TSModuleDeclaration;
typescript.TSModuleBlock = TSModuleBlock;
typescript.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
typescript.TSExternalModuleReference = TSExternalModuleReference;
typescript.TSNonNullExpression = TSNonNullExpression;
typescript.TSExportAssignment = TSExportAssignment;
typescript.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
typescript.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
function TSTypeAnnotation(node) {
  this.token(":");
  this.space();
  if (node.optional) this.token("?");
  this.print(node.typeAnnotation, node);
}
function TSTypeParameterInstantiation(node) {
  this.token("<");
  this.printList(node.params, node, {});
  this.token(">");
}
function TSTypeParameter(node) {
  this.word(node.name);
  if (node.constraint) {
    this.space();
    this.word("extends");
    this.space();
    this.print(node.constraint, node);
  }
  if (node.default) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.default, node);
  }
}
function TSParameterProperty(node) {
  if (node.accessibility) {
    this.word(node.accessibility);
    this.space();
  }
  if (node.readonly) {
    this.word("readonly");
    this.space();
  }
  this._param(node.parameter);
}
function TSDeclareFunction(node) {
  if (node.declare) {
    this.word("declare");
    this.space();
  }
  this._functionHead(node);
  this.token(";");
}
function TSDeclareMethod(node) {
  this._classMethodHead(node);
  this.token(";");
}
function TSQualifiedName(node) {
  this.print(node.left, node);
  this.token(".");
  this.print(node.right, node);
}
function TSCallSignatureDeclaration(node) {
  this.tsPrintSignatureDeclarationBase(node);
}
function TSConstructSignatureDeclaration(node) {
  this.word("new");
  this.space();
  this.tsPrintSignatureDeclarationBase(node);
}
function TSPropertySignature(node) {
  const { readonly: readonly, initializer: initializer } = node;
  if (readonly) {
    this.word("readonly");
    this.space();
  }
  this.tsPrintPropertyOrMethodName(node);
  this.print(node.typeAnnotation, node);
  if (initializer) {
    this.space();
    this.token("=");
    this.space();
    this.print(initializer, node);
  }
  this.token(";");
}
function tsPrintPropertyOrMethodName(node) {
  if (node.computed) {
    this.token("[");
  }
  this.print(node.key, node);
  if (node.computed) {
    this.token("]");
  }
  if (node.optional) {
    this.token("?");
  }
}
function TSMethodSignature(node) {
  this.tsPrintPropertyOrMethodName(node);
  this.tsPrintSignatureDeclarationBase(node);
  this.token(";");
}
function TSIndexSignature(node) {
  const { readonly: readonly } = node;
  if (readonly) {
    this.word("readonly");
    this.space();
  }
  this.token("[");
  this._parameters(node.parameters, node);
  this.token("]");
  this.print(node.typeAnnotation, node);
  this.token(";");
}
function TSAnyKeyword() {
  this.word("any");
}
function TSUnknownKeyword() {
  this.word("unknown");
}
function TSNumberKeyword() {
  this.word("number");
}
function TSObjectKeyword() {
  this.word("object");
}
function TSBooleanKeyword() {
  this.word("boolean");
}
function TSStringKeyword() {
  this.word("string");
}
function TSSymbolKeyword() {
  this.word("symbol");
}
function TSVoidKeyword() {
  this.word("void");
}
function TSUndefinedKeyword() {
  this.word("undefined");
}
function TSNullKeyword() {
  this.word("null");
}
function TSNeverKeyword() {
  this.word("never");
}
function TSThisType() {
  this.word("this");
}
function TSFunctionType(node) {
  this.tsPrintFunctionOrConstructorType(node);
}
function TSConstructorType(node) {
  this.word("new");
  this.space();
  this.tsPrintFunctionOrConstructorType(node);
}
function tsPrintFunctionOrConstructorType(node) {
  const { typeParameters: typeParameters, parameters: parameters } = node;
  this.print(typeParameters, node);
  this.token("(");
  this._parameters(parameters, node);
  this.token(")");
  this.space();
  this.token("=>");
  this.space();
  this.print(node.typeAnnotation.typeAnnotation, node);
}
function TSTypeReference(node) {
  this.print(node.typeName, node);
  this.print(node.typeParameters, node);
}
function TSTypePredicate(node) {
  this.print(node.parameterName);
  this.space();
  this.word("is");
  this.space();
  this.print(node.typeAnnotation.typeAnnotation);
}
function TSTypeQuery(node) {
  this.word("typeof");
  this.space();
  this.print(node.exprName);
}
function TSTypeLiteral(node) {
  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
}
function tsPrintTypeLiteralOrInterfaceBody(members, node) {
  this.tsPrintBraced(members, node);
}
function tsPrintBraced(members, node) {
  this.token("{");
  if (members.length) {
    this.indent();
    this.newline();
    for (const member of members) {
      this.print(member, node);
      this.newline();
    }
    this.dedent();
    this.rightBrace();
  } else {
    this.token("}");
  }
}
function TSArrayType(node) {
  this.print(node.elementType);
  this.token("[]");
}
function TSTupleType(node) {
  this.token("[");
  this.printList(node.elementTypes, node);
  this.token("]");
}
function TSOptionalType(node) {
  this.print(node.typeAnnotation, node);
  this.token("?");
}
function TSRestType(node) {
  this.token("...");
  this.print(node.typeAnnotation, node);
}
function TSUnionType(node) {
  this.tsPrintUnionOrIntersectionType(node, "|");
}
function TSIntersectionType(node) {
  this.tsPrintUnionOrIntersectionType(node, "&");
}
function tsPrintUnionOrIntersectionType(node, sep) {
  this.printJoin(node.types, node, {
    separator() {
      this.space();
      this.token(sep);
      this.space();
    },
  });
}
function TSConditionalType(node) {
  this.print(node.checkType);
  this.space();
  this.word("extends");
  this.space();
  this.print(node.extendsType);
  this.space();
  this.token("?");
  this.space();
  this.print(node.trueType);
  this.space();
  this.token(":");
  this.space();
  this.print(node.falseType);
}
function TSInferType(node) {
  this.token("infer");
  this.space();
  this.print(node.typeParameter);
}
function TSParenthesizedType(node) {
  this.token("(");
  this.print(node.typeAnnotation, node);
  this.token(")");
}
function TSTypeOperator(node) {
  this.token(node.operator);
  this.space();
  this.print(node.typeAnnotation, node);
}
function TSIndexedAccessType(node) {
  this.print(node.objectType, node);
  this.token("[");
  this.print(node.indexType, node);
  this.token("]");
}
function TSMappedType(node) {
  const {
    readonly: readonly,
    typeParameter: typeParameter,
    optional: optional,
  } = node;
  this.token("{");
  this.space();
  if (readonly) {
    tokenIfPlusMinus(this, readonly);
    this.word("readonly");
    this.space();
  }
  this.token("[");
  this.word(typeParameter.name);
  this.space();
  this.word("in");
  this.space();
  this.print(typeParameter.constraint, typeParameter);
  this.token("]");
  if (optional) {
    tokenIfPlusMinus(this, optional);
    this.token("?");
  }
  this.token(":");
  this.space();
  this.print(node.typeAnnotation, node);
  this.space();
  this.token("}");
}
function tokenIfPlusMinus(self, tok) {
  if (tok !== true) {
    self.token(tok);
  }
}
function TSLiteralType(node) {
  this.print(node.literal, node);
}
function TSExpressionWithTypeArguments(node) {
  this.print(node.expression, node);
  this.print(node.typeParameters, node);
}
function TSInterfaceDeclaration(node) {
  const {
    declare: declare,
    id: id,
    typeParameters: typeParameters,
    extends: extendz,
    body: body,
  } = node;
  if (declare) {
    this.word("declare");
    this.space();
  }
  this.word("interface");
  this.space();
  this.print(id, node);
  this.print(typeParameters, node);
  if (extendz) {
    this.space();
    this.word("extends");
    this.space();
    this.printList(extendz, node);
  }
  this.space();
  this.print(body, node);
}
function TSInterfaceBody(node) {
  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
}
function TSTypeAliasDeclaration(node) {
  const {
    declare: declare,
    id: id,
    typeParameters: typeParameters,
    typeAnnotation: typeAnnotation,
  } = node;
  if (declare) {
    this.word("declare");
    this.space();
  }
  this.word("type");
  this.space();
  this.print(id, node);
  this.print(typeParameters, node);
  this.space();
  this.token("=");
  this.space();
  this.print(typeAnnotation, node);
  this.token(";");
}
function TSAsExpression(node) {
  const { expression: expression, typeAnnotation: typeAnnotation } = node;
  this.print(expression, node);
  this.space();
  this.word("as");
  this.space();
  this.print(typeAnnotation, node);
}
function TSTypeAssertion(node) {
  const { typeAnnotation: typeAnnotation, expression: expression } = node;
  this.token("<");
  this.print(typeAnnotation, node);
  this.token(">");
  this.space();
  this.print(expression, node);
}
function TSEnumDeclaration(node) {
  const { declare: declare, const: isConst, id: id, members: members } = node;
  if (declare) {
    this.word("declare");
    this.space();
  }
  if (isConst) {
    this.word("const");
    this.space();
  }
  this.word("enum");
  this.space();
  this.print(id, node);
  this.space();
  this.tsPrintBraced(members, node);
}
function TSEnumMember(node) {
  const { id: id, initializer: initializer } = node;
  this.print(id, node);
  if (initializer) {
    this.space();
    this.token("=");
    this.space();
    this.print(initializer, node);
  }
  this.token(",");
}
function TSModuleDeclaration(node) {
  const { declare: declare, id: id } = node;
  if (declare) {
    this.word("declare");
    this.space();
  }
  if (!node.global) {
    this.word(id.type === "Identifier" ? "namespace" : "module");
    this.space();
  }
  this.print(id, node);
  if (!node.body) {
    this.token(";");
    return;
  }
  let body = node.body;
  while (body.type === "TSModuleDeclaration") {
    this.token(".");
    this.print(body.id, body);
    body = body.body;
  }
  this.space();
  this.print(body, node);
}
function TSModuleBlock(node) {
  this.tsPrintBraced(node.body, node);
}
function TSImportEqualsDeclaration(node) {
  const { isExport: isExport, id: id, moduleReference: moduleReference } = node;
  if (isExport) {
    this.word("export");
    this.space();
  }
  this.word("import");
  this.space();
  this.print(id, node);
  this.space();
  this.token("=");
  this.space();
  this.print(moduleReference, node);
  this.token(";");
}
function TSExternalModuleReference(node) {
  this.token("require(");
  this.print(node.expression, node);
  this.token(")");
}
function TSNonNullExpression(node) {
  this.print(node.expression, node);
  this.token("!");
}
function TSExportAssignment(node) {
  this.word("export");
  this.space();
  this.token("=");
  this.space();
  this.print(node.expression, node);
  this.token(";");
}
function TSNamespaceExportDeclaration(node) {
  this.word("export");
  this.space();
  this.word("as");
  this.space();
  this.word("namespace");
  this.space();
  this.print(node.id, node);
}
function tsPrintSignatureDeclarationBase(node) {
  const { typeParameters: typeParameters, parameters: parameters } = node;
  this.print(typeParameters, node);
  this.token("(");
  this._parameters(parameters, node);
  this.token(")");
  this.print(node.typeAnnotation, node);
}
(function (exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var _templateLiterals = templateLiterals;
  Object.keys(_templateLiterals).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _templateLiterals[key];
      },
    });
  });
  var _expressions = expressions;
  Object.keys(_expressions).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _expressions[key];
      },
    });
  });
  var _statements = statements;
  Object.keys(_statements).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _statements[key];
      },
    });
  });
  var _classes = classes;
  Object.keys(_classes).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _classes[key];
      },
    });
  });
  var _methods = methods;
  Object.keys(_methods).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _methods[key];
      },
    });
  });
  var _modules = modules;
  Object.keys(_modules).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _modules[key];
      },
    });
  });
  var _types = types;
  Object.keys(_types).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _types[key];
      },
    });
  });
  var _flow = flow;
  Object.keys(_flow).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _flow[key];
      },
    });
  });
  var _base = base;
  Object.keys(_base).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _base[key];
      },
    });
  });
  var _jsx = jsx;
  Object.keys(_jsx).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _jsx[key];
      },
    });
  });
  var _typescript = typescript;
  Object.keys(_typescript).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _typescript[key];
      },
    });
  });
})(generators);
Object.defineProperty(printer$1, "__esModule", { value: true });
printer$1.default = void 0;
function _isInteger() {
  const data = _interopRequireDefault$4(requireIsInteger());
  _isInteger = function () {
    return data;
  };
  return data;
}
function _repeat() {
  const data = _interopRequireDefault$4(requireRepeat());
  _repeat = function () {
    return data;
  };
  return data;
}
var _buffer = _interopRequireDefault$4(buffer);
var n = _interopRequireWildcard$1(node);
function t() {
  const data = _interopRequireWildcard$1(requireLib());
  t = function () {
    return data;
  };
  return data;
}
var generatorFunctions = _interopRequireWildcard$1(generators);
function _interopRequireWildcard$1(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function _interopRequireDefault$4(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const SCIENTIFIC_NOTATION = /e/i;
const ZERO_DECIMAL_INTEGER = /\.0+$/;
const NON_DECIMAL_LITERAL = /^0[box]/;
class Printer {
  constructor(format, map) {
    this.inForStatementInitCounter = 0;
    this._printStack = [];
    this._indent = 0;
    this._insideAux = false;
    this._printedCommentStarts = {};
    this._parenPushNewlineState = null;
    this._noLineTerminator = false;
    this._printAuxAfterOnNextUserNode = false;
    this._printedComments = new WeakSet();
    this._endsWithInteger = false;
    this._endsWithWord = false;
    this.format = format || {};
    this._buf = new _buffer.default(map);
  }
  generate(ast) {
    this.print(ast);
    this._maybeAddAuxComment();
    return this._buf.get();
  }
  indent() {
    if (this.format.compact || this.format.concise) return;
    this._indent++;
  }
  dedent() {
    if (this.format.compact || this.format.concise) return;
    this._indent--;
  }
  semicolon(force = false) {
    this._maybeAddAuxComment();
    this._append(";", !force);
  }
  rightBrace() {
    if (this.format.minified) {
      this._buf.removeLastSemicolon();
    }
    this.token("}");
  }
  space(force = false) {
    if (this.format.compact) return;
    if (
      (this._buf.hasContent() && !this.endsWith(" ") && !this.endsWith("\n")) ||
      force
    ) {
      this._space();
    }
  }
  word(str) {
    if (this._endsWithWord || (this.endsWith("/") && str.indexOf("/") === 0)) {
      this._space();
    }
    this._maybeAddAuxComment();
    this._append(str);
    this._endsWithWord = true;
  }
  number(str) {
    this.word(str);
    this._endsWithInteger =
      (0, _isInteger().default)(+str) &&
      !NON_DECIMAL_LITERAL.test(str) &&
      !SCIENTIFIC_NOTATION.test(str) &&
      !ZERO_DECIMAL_INTEGER.test(str) &&
      str[str.length - 1] !== ".";
  }
  token(str) {
    if (
      (str === "--" && this.endsWith("!")) ||
      (str[0] === "+" && this.endsWith("+")) ||
      (str[0] === "-" && this.endsWith("-")) ||
      (str[0] === "." && this._endsWithInteger)
    ) {
      this._space();
    }
    this._maybeAddAuxComment();
    this._append(str);
  }
  newline(i) {
    if (this.format.retainLines || this.format.compact) return;
    if (this.format.concise) {
      this.space();
      return;
    }
    if (this.endsWith("\n\n")) return;
    if (typeof i !== "number") i = 1;
    i = Math.min(2, i);
    if (this.endsWith("{\n") || this.endsWith(":\n")) i--;
    if (i <= 0) return;
    for (let j = 0; j < i; j++) {
      this._newline();
    }
  }
  endsWith(str) {
    return this._buf.endsWith(str);
  }
  removeTrailingNewline() {
    this._buf.removeTrailingNewline();
  }
  exactSource(loc, cb) {
    this._catchUp("start", loc);
    this._buf.exactSource(loc, cb);
  }
  source(prop, loc) {
    this._catchUp(prop, loc);
    this._buf.source(prop, loc);
  }
  withSource(prop, loc, cb) {
    this._catchUp(prop, loc);
    this._buf.withSource(prop, loc, cb);
  }
  _space() {
    this._append(" ", true);
  }
  _newline() {
    this._append("\n", true);
  }
  _append(str, queue = false) {
    this._maybeAddParen(str);
    this._maybeIndent(str);
    if (queue) this._buf.queue(str);
    else this._buf.append(str);
    this._endsWithWord = false;
    this._endsWithInteger = false;
  }
  _maybeIndent(str) {
    if (this._indent && this.endsWith("\n") && str[0] !== "\n") {
      this._buf.queue(this._getIndent());
    }
  }
  _maybeAddParen(str) {
    const parenPushNewlineState = this._parenPushNewlineState;
    if (!parenPushNewlineState) return;
    this._parenPushNewlineState = null;
    let i;
    for (i = 0; i < str.length && str[i] === " "; i++) continue;
    if (i === str.length) return;
    const cha = str[i];
    if (cha !== "\n") {
      if (cha !== "/") return;
      if (i + 1 === str.length) return;
      const chaPost = str[i + 1];
      if (chaPost !== "/" && chaPost !== "*") return;
    }
    this.token("(");
    this.indent();
    parenPushNewlineState.printed = true;
  }
  _catchUp(prop, loc) {
    if (!this.format.retainLines) return;
    const pos = loc ? loc[prop] : null;
    if (pos && pos.line !== null) {
      const count = pos.line - this._buf.getCurrentLine();
      for (let i = 0; i < count; i++) {
        this._newline();
      }
    }
  }
  _getIndent() {
    return (0, _repeat().default)(this.format.indent.style, this._indent);
  }
  startTerminatorless(isLabel = false) {
    if (isLabel) {
      this._noLineTerminator = true;
      return null;
    } else {
      return (this._parenPushNewlineState = { printed: false });
    }
  }
  endTerminatorless(state) {
    this._noLineTerminator = false;
    if (state && state.printed) {
      this.dedent();
      this.newline();
      this.token(")");
    }
  }
  print(node, parent) {
    if (!node) return;
    const oldConcise = this.format.concise;
    if (node._compact) {
      this.format.concise = true;
    }
    const printMethod = this[node.type];
    if (!printMethod) {
      throw new ReferenceError(
        `unknown node of type ${JSON.stringify(node.type)} with constructor ${JSON.stringify(node && node.constructor.name)}`
      );
    }
    this._printStack.push(node);
    const oldInAux = this._insideAux;
    this._insideAux = !node.loc;
    this._maybeAddAuxComment(this._insideAux && !oldInAux);
    let needsParens = n.needsParens(node, parent, this._printStack);
    if (
      this.format.retainFunctionParens &&
      node.type === "FunctionExpression" &&
      node.extra &&
      node.extra.parenthesized
    ) {
      needsParens = true;
    }
    if (needsParens) this.token("(");
    this._printLeadingComments(node);
    const loc = t().isProgram(node) || t().isFile(node) ? null : node.loc;
    this.withSource("start", loc, () => {
      this[node.type](node, parent);
    });
    this._printTrailingComments(node);
    if (needsParens) this.token(")");
    this._printStack.pop();
    this.format.concise = oldConcise;
    this._insideAux = oldInAux;
  }
  _maybeAddAuxComment(enteredPositionlessNode) {
    if (enteredPositionlessNode) this._printAuxBeforeComment();
    if (!this._insideAux) this._printAuxAfterComment();
  }
  _printAuxBeforeComment() {
    if (this._printAuxAfterOnNextUserNode) return;
    this._printAuxAfterOnNextUserNode = true;
    const comment = this.format.auxiliaryCommentBefore;
    if (comment) {
      this._printComment({ type: "CommentBlock", value: comment });
    }
  }
  _printAuxAfterComment() {
    if (!this._printAuxAfterOnNextUserNode) return;
    this._printAuxAfterOnNextUserNode = false;
    const comment = this.format.auxiliaryCommentAfter;
    if (comment) {
      this._printComment({ type: "CommentBlock", value: comment });
    }
  }
  getPossibleRaw(node) {
    const extra = node.extra;
    if (
      extra &&
      extra.raw != null &&
      extra.rawValue != null &&
      node.value === extra.rawValue
    ) {
      return extra.raw;
    }
  }
  printJoin(nodes, parent, opts = {}) {
    if (!nodes || !nodes.length) return;
    if (opts.indent) this.indent();
    const newlineOpts = { addNewlines: opts.addNewlines };
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (!node) continue;
      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);
      this.print(node, parent);
      if (opts.iterator) {
        opts.iterator(node, i);
      }
      if (opts.separator && i < nodes.length - 1) {
        opts.separator.call(this);
      }
      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);
    }
    if (opts.indent) this.dedent();
  }
  printAndIndentOnComments(node, parent) {
    const indent = node.leadingComments && node.leadingComments.length > 0;
    if (indent) this.indent();
    this.print(node, parent);
    if (indent) this.dedent();
  }
  printBlock(parent) {
    const node = parent.body;
    if (!t().isEmptyStatement(node)) {
      this.space();
    }
    this.print(node, parent);
  }
  _printTrailingComments(node) {
    this._printComments(this._getComments(false, node));
  }
  _printLeadingComments(node) {
    this._printComments(this._getComments(true, node));
  }
  printInnerComments(node, indent = true) {
    if (!node.innerComments || !node.innerComments.length) return;
    if (indent) this.indent();
    this._printComments(node.innerComments);
    if (indent) this.dedent();
  }
  printSequence(nodes, parent, opts = {}) {
    opts.statement = true;
    return this.printJoin(nodes, parent, opts);
  }
  printList(items, parent, opts = {}) {
    if (opts.separator == null) {
      opts.separator = commaSeparator;
    }
    return this.printJoin(items, parent, opts);
  }
  _printNewline(leading, node, parent, opts) {
    if (this.format.retainLines || this.format.compact) return;
    if (this.format.concise) {
      this.space();
      return;
    }
    let lines = 0;
    if (this._buf.hasContent()) {
      if (!leading) lines++;
      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;
      const needs = leading ? n.needsWhitespaceBefore : n.needsWhitespaceAfter;
      if (needs(node, parent)) lines++;
    }
    this.newline(lines);
  }
  _getComments(leading, node) {
    return (
      (node && (leading ? node.leadingComments : node.trailingComments)) || []
    );
  }
  _printComment(comment) {
    if (!this.format.shouldPrintComment(comment.value)) return;
    if (comment.ignore) return;
    if (this._printedComments.has(comment)) return;
    this._printedComments.add(comment);
    if (comment.start != null) {
      if (this._printedCommentStarts[comment.start]) return;
      this._printedCommentStarts[comment.start] = true;
    }
    const isBlockComment = comment.type === "CommentBlock";
    this.newline(
      this._buf.hasContent() && !this._noLineTerminator && isBlockComment
        ? 1
        : 0
    );
    if (!this.endsWith("[") && !this.endsWith("{")) this.space();
    let val =
      !isBlockComment && !this._noLineTerminator
        ? `//${comment.value}\n`
        : `/*${comment.value}*/`;
    if (isBlockComment && this.format.indent.adjustMultilineComment) {
      const offset = comment.loc && comment.loc.start.column;
      if (offset) {
        const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
        val = val.replace(newlineRegex, "\n");
      }
      const indentSize = Math.max(
        this._getIndent().length,
        this._buf.getCurrentColumn()
      );
      val = val.replace(
        /\n(?!$)/g,
        `\n${(0, _repeat().default)(" ", indentSize)}`
      );
    }
    if (this.endsWith("/")) this._space();
    this.withSource("start", comment.loc, () => {
      this._append(val);
    });
    this.newline(isBlockComment && !this._noLineTerminator ? 1 : 0);
  }
  _printComments(comments) {
    if (!comments || !comments.length) return;
    for (const comment of comments) {
      this._printComment(comment);
    }
  }
}
printer$1.default = Printer;
Object.assign(Printer.prototype, generatorFunctions);
function commaSeparator() {
  this.token(",");
  this.space();
}
Object.defineProperty(lib$2, "__esModule", { value: true });
var default_1 = (lib$2.default = _default$7);
lib$2.CodeGenerator = void 0;
var _sourceMap = _interopRequireDefault$3(sourceMap$1);
var _printer = _interopRequireDefault$3(printer$1);
function _interopRequireDefault$3(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
class Generator extends _printer.default {
  constructor(ast, opts = {}, code) {
    const format = normalizeOptions(code, opts);
    const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
    super(format, map);
    this.ast = ast;
  }
  generate() {
    return super.generate(this.ast);
  }
}
function normalizeOptions(code, opts) {
  const format = {
    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
    shouldPrintComment: opts.shouldPrintComment,
    retainLines: opts.retainLines,
    retainFunctionParens: opts.retainFunctionParens,
    comments: opts.comments == null || opts.comments,
    compact: opts.compact,
    minified: opts.minified,
    concise: opts.concise,
    jsonCompatibleStrings: opts.jsonCompatibleStrings,
    indent: { adjustMultilineComment: true, style: "  ", base: 0 },
    decoratorsBeforeExport: !!opts.decoratorsBeforeExport,
    jsescOption: Object.assign(
      { quotes: "double", wrap: true },
      opts.jsescOption
    ),
  };
  if (format.minified) {
    format.compact = true;
    format.shouldPrintComment =
      format.shouldPrintComment || (() => format.comments);
  } else {
    format.shouldPrintComment =
      format.shouldPrintComment ||
      ((value) =>
        format.comments ||
        value.indexOf("@license") >= 0 ||
        value.indexOf("@preserve") >= 0);
  }
  if (format.compact === "auto") {
    format.compact = code.length > 5e5;
    if (format.compact) {
      console.error(
        "[BABEL] Note: The code generator has deoptimised the styling of " +
          `${opts.filename} as it exceeds the max of ${"500KB"}.`
      );
    }
  }
  if (format.compact) {
    format.indent.adjustMultilineComment = false;
  }
  return format;
}
class CodeGenerator {
  constructor(ast, opts, code) {
    this._generator = new Generator(ast, opts, code);
  }
  generate() {
    return this._generator.generate();
  }
}
lib$2.CodeGenerator = CodeGenerator;
function _default$7(ast, opts, code) {
  const gen = new Generator(ast, opts, code);
  return gen.generate();
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (
    typeof state === "function"
      ? receiver !== state || !f
      : !state.has(receiver)
  )
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it"
    );
  return kind === "m"
    ? f
    : kind === "a"
      ? f.call(receiver)
      : f
        ? f.value
        : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (
    typeof state === "function"
      ? receiver !== state || !f
      : !state.has(receiver)
  )
    throw new TypeError(
      "Cannot write private member to an object whose class did not declare it"
    );
  return (
    kind === "a"
      ? f.call(receiver, value)
      : f
        ? (f.value = value)
        : state.set(receiver, value),
    value
  );
}
var _Writer_out, _Writer_line, _Writer_depth;
function printReactiveFunction(fn) {
  const writer = new Writer();
  writer.writeLine(`function ${fn.id !== null ? fn.id : "<unknown>"}(`);
  writer.indented(() => {
    for (const param of fn.params) {
      if (param.kind === "Identifier") {
        writer.writeLine(`${printPlace(param)},`);
      } else {
        writer.writeLine(`...${printPlace(param.place)},`);
      }
    }
  });
  writer.writeLine(") {");
  writeReactiveInstructions(writer, fn.body);
  writer.writeLine("}");
  return writer.complete();
}
function printReactiveScopeSummary(scope) {
  const items = [];
  items.push("scope");
  items.push(`@${scope.id}`);
  items.push(`[${scope.range.start}:${scope.range.end}]`);
  items.push(
    `dependencies=[${Array.from(scope.dependencies)
      .map((dep) => printDependency(dep))
      .join(", ")}]`
  );
  items.push(
    `declarations=[${Array.from(scope.declarations)
      .map(([, decl]) =>
        printIdentifier(
          Object.assign(Object.assign({}, decl.identifier), {
            scope: decl.scope,
          })
        )
      )
      .join(", ")}]`
  );
  items.push(
    `reassignments=[${Array.from(scope.reassignments).map((reassign) => printIdentifier(reassign))}]`
  );
  if (scope.earlyReturnValue !== null) {
    items.push(
      `earlyReturn={id: ${printIdentifier(scope.earlyReturnValue.value)}, label: ${scope.earlyReturnValue.label}}}`
    );
  }
  return items.join(" ");
}
function writeReactiveBlock(writer, block) {
  writer.writeLine(`${printReactiveScopeSummary(block.scope)} {`);
  writeReactiveInstructions(writer, block.instructions);
  writer.writeLine("}");
}
function writePrunedScope(writer, block) {
  writer.writeLine(`<pruned> ${printReactiveScopeSummary(block.scope)} {`);
  writeReactiveInstructions(writer, block.instructions);
  writer.writeLine("}");
}
function printDependency(dependency) {
  const identifier =
    printIdentifier(dependency.identifier) +
    printType(dependency.identifier.type);
  return `${identifier}${dependency.path.map((prop) => `.${prop}`).join("")}`;
}
function writeReactiveInstructions(writer, instructions) {
  writer.indented(() => {
    for (const instr of instructions) {
      writeReactiveInstruction(writer, instr);
    }
  });
}
function writeReactiveInstruction(writer, instr) {
  switch (instr.kind) {
    case "instruction": {
      const { instruction: instruction } = instr;
      const id = `[${instruction.id}]`;
      if (instruction.lvalue !== null) {
        writer.write(`${id} ${printPlace(instruction.lvalue)} = `);
        writeReactiveValue(writer, instruction.value);
        writer.newline();
      } else {
        writer.write(`${id} `);
        writeReactiveValue(writer, instruction.value);
        writer.newline();
      }
      break;
    }
    case "scope": {
      writeReactiveBlock(writer, instr);
      break;
    }
    case "pruned-scope": {
      writePrunedScope(writer, instr);
      break;
    }
    case "terminal": {
      if (instr.label !== null) {
        writer.write(`bb${instr.label.id}: `);
      }
      writeTerminal(writer, instr.terminal);
      break;
    }
    default: {
      assertExhaustive$1(instr, `Unexpected terminal kind \`${instr.kind}\``);
    }
  }
}
function writeReactiveValue(writer, value) {
  switch (value.kind) {
    case "ConditionalExpression": {
      writer.writeLine(`Ternary `);
      writer.indented(() => {
        writeReactiveValue(writer, value.test);
        writer.writeLine(`? `);
        writer.indented(() => {
          writeReactiveValue(writer, value.consequent);
        });
        writer.writeLine(`: `);
        writer.indented(() => {
          writeReactiveValue(writer, value.alternate);
        });
      });
      writer.newline();
      break;
    }
    case "LogicalExpression": {
      writer.writeLine(`Logical`);
      writer.indented(() => {
        writeReactiveValue(writer, value.left);
        writer.write(`${value.operator} `);
        writeReactiveValue(writer, value.right);
      });
      writer.newline();
      break;
    }
    case "SequenceExpression": {
      writer.writeLine(`Sequence`);
      writer.indented(() => {
        writer.indented(() => {
          value.instructions.forEach((instr) =>
            writeReactiveInstruction(writer, {
              kind: "instruction",
              instruction: instr,
            })
          );
          writer.write(`[${value.id}] `);
          writeReactiveValue(writer, value.value);
        });
      });
      writer.newline();
      break;
    }
    case "OptionalExpression": {
      writer.append(`OptionalExpression optional=${value.optional}`);
      writer.newline();
      writer.indented(() => {
        writeReactiveValue(writer, value.value);
      });
      writer.newline();
      break;
    }
    default: {
      const printed = printInstructionValue(value);
      const lines = printed.split("\n");
      if (lines.length === 1) {
        writer.writeLine(printed);
      } else {
        writer.indented(() => {
          for (const line of lines) {
            writer.writeLine(line);
          }
        });
      }
    }
  }
}
function writeTerminal(writer, terminal) {
  switch (terminal.kind) {
    case "break": {
      const id = terminal.id !== null ? `[${terminal.id}]` : [];
      writer.writeLine(
        `${id} break bb${terminal.target} (${terminal.targetKind})`
      );
      break;
    }
    case "continue": {
      const id = `[${terminal.id}]`;
      writer.writeLine(
        `${id} continue bb${terminal.target} (${terminal.targetKind})`
      );
      break;
    }
    case "do-while": {
      writer.writeLine(`[${terminal.id}] do-while {`);
      writeReactiveInstructions(writer, terminal.loop);
      writer.writeLine("} (");
      writer.indented(() => {
        writeReactiveValue(writer, terminal.test);
      });
      writer.writeLine(")");
      break;
    }
    case "while": {
      writer.writeLine(`[${terminal.id}] while (`);
      writer.indented(() => {
        writeReactiveValue(writer, terminal.test);
      });
      writer.writeLine(") {");
      writeReactiveInstructions(writer, terminal.loop);
      writer.writeLine("}");
      break;
    }
    case "if": {
      const {
        test: test,
        consequent: consequent,
        alternate: alternate,
      } = terminal;
      writer.writeLine(`[${terminal.id}] if (${printPlace(test)}) {`);
      writeReactiveInstructions(writer, consequent);
      if (alternate !== null) {
        writer.writeLine("} else {");
        writeReactiveInstructions(writer, alternate);
      }
      writer.writeLine("}");
      break;
    }
    case "switch": {
      writer.writeLine(
        `[${terminal.id}] switch (${printPlace(terminal.test)}) {`
      );
      writer.indented(() => {
        for (const case_ of terminal.cases) {
          let prefix =
            case_.test !== null ? `case ${printPlace(case_.test)}` : "default";
          writer.writeLine(`${prefix}: {`);
          writer.indented(() => {
            var _a, _b;
            const block = case_.block;
            CompilerError.invariant(block != null, {
              reason: "Expected case to have a block",
              description: null,
              loc:
                (_b =
                  (_a = case_.test) === null || _a === void 0
                    ? void 0
                    : _a.loc) !== null && _b !== void 0
                  ? _b
                  : null,
              suggestions: null,
            });
            writeReactiveInstructions(writer, block);
          });
          writer.writeLine("}");
        }
      });
      writer.writeLine("}");
      break;
    }
    case "for": {
      writer.writeLine(`[${terminal.id}] for (`);
      writer.indented(() => {
        writeReactiveValue(writer, terminal.init);
        writer.writeLine(";");
        writeReactiveValue(writer, terminal.test);
        writer.writeLine(";");
        if (terminal.update !== null) {
          writeReactiveValue(writer, terminal.update);
        }
      });
      writer.writeLine(") {");
      writeReactiveInstructions(writer, terminal.loop);
      writer.writeLine("}");
      break;
    }
    case "for-of": {
      writer.writeLine(`[${terminal.id}] for-of (`);
      writer.indented(() => {
        writeReactiveValue(writer, terminal.init);
        writer.writeLine(";");
        writeReactiveValue(writer, terminal.test);
      });
      writer.writeLine(") {");
      writeReactiveInstructions(writer, terminal.loop);
      writer.writeLine("}");
      break;
    }
    case "for-in": {
      writer.writeLine(`[${terminal.id}] for-in (`);
      writer.indented(() => {
        writeReactiveValue(writer, terminal.init);
      });
      writer.writeLine(") {");
      writeReactiveInstructions(writer, terminal.loop);
      writer.writeLine("}");
      break;
    }
    case "throw": {
      writer.writeLine(`[${terminal.id}] throw ${printPlace(terminal.value)}`);
      break;
    }
    case "return": {
      writer.writeLine(`[${terminal.id}] return ${printPlace(terminal.value)}`);
      break;
    }
    case "label": {
      writer.writeLine("{");
      writeReactiveInstructions(writer, terminal.block);
      writer.writeLine("}");
      break;
    }
    case "try": {
      writer.writeLine(`[${terminal.id}] try {`);
      writeReactiveInstructions(writer, terminal.block);
      writer.write(`} catch `);
      if (terminal.handlerBinding !== null) {
        writer.writeLine(`(${printPlace(terminal.handlerBinding)}) {`);
      } else {
        writer.writeLine(`{`);
      }
      writeReactiveInstructions(writer, terminal.handler);
      writer.writeLine("}");
      break;
    }
    default:
      assertExhaustive$1(terminal, `Unhandled terminal ${terminal}`);
  }
}
class Writer {
  constructor({ depth: depth } = { depth: 0 }) {
    _Writer_out.set(this, []);
    _Writer_line.set(this, void 0);
    _Writer_depth.set(this, void 0);
    __classPrivateFieldSet(this, _Writer_depth, Math.max(depth, 0), "f");
    __classPrivateFieldSet(this, _Writer_line, "", "f");
  }
  complete() {
    const line = __classPrivateFieldGet(this, _Writer_line, "f").trimEnd();
    if (line.length > 0) {
      __classPrivateFieldGet(this, _Writer_out, "f").push(line);
    }
    return __classPrivateFieldGet(this, _Writer_out, "f").join("\n");
  }
  append(s) {
    this.write(s);
  }
  newline() {
    const line = __classPrivateFieldGet(this, _Writer_line, "f").trimEnd();
    if (line.length > 0) {
      __classPrivateFieldGet(this, _Writer_out, "f").push(line);
    }
    __classPrivateFieldSet(this, _Writer_line, "", "f");
  }
  write(s) {
    if (
      __classPrivateFieldGet(this, _Writer_line, "f").length === 0 &&
      __classPrivateFieldGet(this, _Writer_depth, "f") > 0
    ) {
      __classPrivateFieldSet(
        this,
        _Writer_line,
        "  ".repeat(__classPrivateFieldGet(this, _Writer_depth, "f")),
        "f"
      );
    }
    __classPrivateFieldSet(
      this,
      _Writer_line,
      __classPrivateFieldGet(this, _Writer_line, "f") + s,
      "f"
    );
  }
  writeLine(s) {
    this.write(s);
    this.newline();
  }
  indented(f) {
    var _a, _b;
    __classPrivateFieldSet(
      this,
      _Writer_depth,
      ((_a = __classPrivateFieldGet(this, _Writer_depth, "f")), _a++, _a),
      "f"
    );
    f();
    __classPrivateFieldSet(
      this,
      _Writer_depth,
      ((_b = __classPrivateFieldGet(this, _Writer_depth, "f")), _b--, _b),
      "f"
    );
  }
}
(_Writer_out = new WeakMap()),
  (_Writer_line = new WeakMap()),
  (_Writer_depth = new WeakMap());
function printFunction$1(fn) {
  const output = [];
  let definition = "";
  if (fn.id !== null) {
    definition += fn.id;
  }
  if (fn.params.length !== 0) {
    definition +=
      "(" +
      fn.params
        .map((param) => {
          if (param.kind === "Identifier") {
            return printPlace(param);
          } else {
            return `...${printPlace(param.place)}`;
          }
        })
        .join(", ") +
      ")";
  }
  if (definition.length !== 0) {
    output.push(definition);
  }
  output.push(printHIR(fn.body));
  output.push(...fn.directives);
  return output.join("\n");
}
function printHIR(ir, options = null) {
  var _a;
  let output = [];
  let indent = " ".repeat(
    (_a = options === null || options === void 0 ? void 0 : options.indent) !==
      null && _a !== void 0
      ? _a
      : 0
  );
  const push = (text, indent = "  ") => {
    output.push(`${indent}${text}`);
  };
  for (const [blockId, block] of ir.blocks) {
    output.push(`bb${blockId} (${block.kind}):`);
    if (block.preds.size > 0) {
      const preds = ["predecessor blocks:"];
      for (const pred of block.preds) {
        preds.push(`bb${pred}`);
      }
      push(preds.join(" "));
    }
    for (const phi of block.phis) {
      push(printPhi(phi));
    }
    for (const instr of block.instructions) {
      push(printInstruction(instr));
    }
    const terminal = printTerminal(block.terminal);
    if (Array.isArray(terminal)) {
      terminal.forEach((line) => push(line));
    } else {
      push(terminal);
    }
  }
  return output.map((line) => indent + line).join("\n");
}
function printMixedHIR(value) {
  if (!("kind" in value)) {
    return printInstruction(value);
  }
  switch (value.kind) {
    case "try":
    case "maybe-throw":
    case "sequence":
    case "label":
    case "optional":
    case "branch":
    case "if":
    case "logical":
    case "ternary":
    case "return":
    case "switch":
    case "throw":
    case "while":
    case "for":
    case "unreachable":
    case "unsupported":
    case "goto":
    case "do-while":
    case "for-in":
    case "for-of":
    case "scope":
    case "pruned-scope": {
      const terminal = printTerminal(value);
      if (Array.isArray(terminal)) {
        return terminal.join("; ");
      }
      return terminal;
    }
    default: {
      return printInstructionValue(value);
    }
  }
}
function printInstruction(instr) {
  const id = `[${instr.id}]`;
  const value = printInstructionValue(instr.value);
  if (instr.lvalue !== null) {
    return `${id} ${printPlace(instr.lvalue)} = ${value}`;
  } else {
    return `${id} ${value}`;
  }
}
function printPhi(phi) {
  const items = [];
  items.push(printIdentifier(phi.id));
  items.push(printMutableRange(phi.id));
  items.push(printType(phi.type));
  items.push(": phi(");
  const phis = [];
  for (const [blockId, id] of phi.operands) {
    phis.push(`bb${blockId}: ${printIdentifier(id)}`);
  }
  items.push(phis.join(", "));
  items.push(")");
  return items.join("");
}
function printTerminal(terminal) {
  let value;
  switch (terminal.kind) {
    case "if": {
      value = `[${terminal.id}] If (${printPlace(terminal.test)}) then:bb${terminal.consequent} else:bb${terminal.alternate}${terminal.fallthrough ? ` fallthrough=bb${terminal.fallthrough}` : ""}`;
      break;
    }
    case "branch": {
      value = `[${terminal.id}] Branch (${printPlace(terminal.test)}) then:bb${terminal.consequent} else:bb${terminal.alternate}`;
      break;
    }
    case "logical": {
      value = `[${terminal.id}] Logical ${terminal.operator} test:bb${terminal.test} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "ternary": {
      value = `[${terminal.id}] Ternary test:bb${terminal.test} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "optional": {
      value = `[${terminal.id}] Optional test:bb${terminal.test} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "throw": {
      value = `[${terminal.id}] Throw ${printPlace(terminal.value)}`;
      break;
    }
    case "return": {
      value = `[${terminal.id}] Return${terminal.value != null ? " " + printPlace(terminal.value) : ""}`;
      break;
    }
    case "goto": {
      value = `[${terminal.id}] Goto${terminal.variant === GotoVariant.Continue ? "(Continue)" : ""} bb${terminal.block}`;
      break;
    }
    case "switch": {
      const output = [];
      output.push(`[${terminal.id}] Switch (${printPlace(terminal.test)})`);
      terminal.cases.forEach((case_) => {
        if (case_.test !== null) {
          output.push(`  Case ${printPlace(case_.test)}: bb${case_.block}`);
        } else {
          output.push(`  Default: bb${case_.block}`);
        }
      });
      if (terminal.fallthrough) {
        output.push(`  Fallthrough: bb${terminal.fallthrough}`);
      }
      value = output;
      break;
    }
    case "do-while": {
      value = `[${terminal.id}] DoWhile loop=${`bb${terminal.loop}`} test=bb${terminal.test} fallthrough=${`bb${terminal.fallthrough}`}`;
      break;
    }
    case "while": {
      value = `[${terminal.id}] While test=bb${terminal.test} loop=${terminal.loop !== null ? `bb${terminal.loop}` : ""} fallthrough=${terminal.fallthrough ? `bb${terminal.fallthrough}` : ""}`;
      break;
    }
    case "for": {
      value = `[${terminal.id}] For init=bb${terminal.init} test=bb${terminal.test} loop=bb${terminal.loop} update=bb${terminal.update} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "for-of": {
      value = `[${terminal.id}] ForOf init=bb${terminal.init} test=bb${terminal.test} loop=bb${terminal.loop} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "for-in": {
      value = `[${terminal.id}] ForIn init=bb${terminal.init} loop=bb${terminal.loop} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "label": {
      value = `[${terminal.id}] Label block=bb${terminal.block} fallthrough=${terminal.fallthrough ? `bb${terminal.fallthrough}` : ""}`;
      break;
    }
    case "sequence": {
      value = `[${terminal.id}] Sequence block=bb${terminal.block} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "unreachable": {
      value = `[${terminal.id}] Unreachable`;
      break;
    }
    case "unsupported": {
      value = `Unsupported`;
      break;
    }
    case "maybe-throw": {
      value = `MaybeThrow continuation=bb${terminal.continuation} handler=bb${terminal.handler}`;
      break;
    }
    case "scope": {
      value = `Scope ${printReactiveScopeSummary(terminal.scope)} block=bb${terminal.block} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "pruned-scope": {
      value = `<pruned> Scope ${printReactiveScopeSummary(terminal.scope)} block=bb${terminal.block} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "try": {
      value = `Try block=bb${terminal.block} handler=bb${terminal.handler}${terminal.handlerBinding !== null ? ` handlerBinding=(${printPlace(terminal.handlerBinding)})` : ""} fallthrough=${terminal.fallthrough != null ? `bb${terminal.fallthrough}` : ""}`;
      break;
    }
    default: {
      assertExhaustive$1(terminal, `Unexpected terminal kind \`${terminal}\``);
    }
  }
  return value;
}
function printHole() {
  return "<hole>";
}
function printObjectPropertyKey(key) {
  switch (key.kind) {
    case "identifier":
      return key.name;
    case "string":
      return `"${key.name}"`;
    case "computed": {
      return `[${printPlace(key.name)}]`;
    }
  }
}
function printInstructionValue(instrValue) {
  var _a, _b, _c, _d;
  let value = "";
  switch (instrValue.kind) {
    case "ArrayExpression": {
      value = `Array [${instrValue.elements
        .map((element) => {
          if (element.kind === "Identifier") {
            return printPlace(element);
          } else if (element.kind === "Hole") {
            return printHole();
          } else {
            return `...${printPlace(element.place)}`;
          }
        })
        .join(", ")}]`;
      break;
    }
    case "ObjectExpression": {
      const properties = [];
      if (instrValue.properties !== null) {
        for (const property of instrValue.properties) {
          if (property.kind === "ObjectProperty") {
            properties.push(
              `${printObjectPropertyKey(property.key)}: ${printPlace(property.place)}`
            );
          } else {
            properties.push(`...${printPlace(property.place)}`);
          }
        }
      }
      value = `Object { ${properties.join(", ")} }`;
      break;
    }
    case "UnaryExpression": {
      value = `Unary ${printPlace(instrValue.value)}`;
      break;
    }
    case "BinaryExpression": {
      value = `Binary ${printPlace(instrValue.left)} ${instrValue.operator} ${printPlace(instrValue.right)}`;
      break;
    }
    case "NewExpression": {
      value = `New ${printPlace(instrValue.callee)}(${instrValue.args.map((arg) => printPattern(arg)).join(", ")})`;
      break;
    }
    case "CallExpression": {
      value = `Call ${printPlace(instrValue.callee)}(${instrValue.args.map((arg) => printPattern(arg)).join(", ")})`;
      break;
    }
    case "MethodCall": {
      value = `MethodCall ${printPlace(instrValue.receiver)}.${printPlace(instrValue.property)}(${instrValue.args.map((arg) => printPattern(arg)).join(", ")})`;
      break;
    }
    case "JSXText": {
      value = `JSXText ${JSON.stringify(instrValue.value)}`;
      break;
    }
    case "Primitive": {
      if (instrValue.value === undefined) {
        value = "<undefined>";
      } else {
        value = JSON.stringify(instrValue.value);
      }
      break;
    }
    case "TypeCastExpression": {
      value = `TypeCast ${printPlace(instrValue.value)}: ${printType(instrValue.type)}`;
      break;
    }
    case "JsxExpression": {
      const propItems = [];
      for (const attribute of instrValue.props) {
        if (attribute.kind === "JsxAttribute") {
          propItems.push(
            `${attribute.name}={${attribute.place !== null ? printPlace(attribute.place) : "<empty>"}}`
          );
        } else {
          propItems.push(`...${printPlace(attribute.argument)}`);
        }
      }
      const tag =
        instrValue.tag.kind === "Identifier"
          ? printPlace(instrValue.tag)
          : instrValue.tag.name;
      const props = propItems.length !== 0 ? " " + propItems.join(" ") : "";
      if (instrValue.children !== null) {
        const children = instrValue.children.map(
          (child) => `{${printPlace(child)}}`
        );
        value = `JSX <${tag}${props}${props.length > 0 ? " " : ""}>${children.join("")}</${tag}>`;
      } else {
        value = `JSX <${tag}${props}${props.length > 0 ? " " : ""}/>`;
      }
      break;
    }
    case "JsxFragment": {
      value = `JsxFragment [${instrValue.children.map((child) => printPlace(child)).join(", ")}]`;
      break;
    }
    case "UnsupportedNode": {
      value = `UnsupportedNode(${default_1(instrValue.node).code})`;
      break;
    }
    case "LoadLocal": {
      value = `LoadLocal ${printPlace(instrValue.place)}`;
      break;
    }
    case "DeclareLocal": {
      value = `DeclareLocal ${instrValue.lvalue.kind} ${printPlace(instrValue.lvalue.place)}`;
      break;
    }
    case "DeclareContext": {
      value = `DeclareContext ${instrValue.lvalue.kind} ${printPlace(instrValue.lvalue.place)}`;
      break;
    }
    case "StoreLocal": {
      value = `StoreLocal ${instrValue.lvalue.kind} ${printPlace(instrValue.lvalue.place)} = ${printPlace(instrValue.value)}`;
      break;
    }
    case "LoadContext": {
      value = `LoadContext ${printPlace(instrValue.place)}`;
      break;
    }
    case "StoreContext": {
      value = `StoreContext ${instrValue.lvalue.kind} ${printPlace(instrValue.lvalue.place)} = ${printPlace(instrValue.value)}`;
      break;
    }
    case "Destructure": {
      value = `Destructure ${instrValue.lvalue.kind} ${printPattern(instrValue.lvalue.pattern)} = ${printPlace(instrValue.value)}`;
      break;
    }
    case "PropertyLoad": {
      value = `PropertyLoad ${printPlace(instrValue.object)}.${instrValue.property}`;
      break;
    }
    case "PropertyStore": {
      value = `PropertyStore ${printPlace(instrValue.object)}.${instrValue.property} = ${printPlace(instrValue.value)}`;
      break;
    }
    case "PropertyDelete": {
      value = `PropertyDelete ${printPlace(instrValue.object)}.${instrValue.property}`;
      break;
    }
    case "ComputedLoad": {
      value = `ComputedLoad ${printPlace(instrValue.object)}[${printPlace(instrValue.property)}]`;
      break;
    }
    case "ComputedStore": {
      value = `ComputedStore ${printPlace(instrValue.object)}[${printPlace(instrValue.property)}] = ${printPlace(instrValue.value)}`;
      break;
    }
    case "ComputedDelete": {
      value = `ComputedDelete ${printPlace(instrValue.object)}[${printPlace(instrValue.property)}]`;
      break;
    }
    case "ObjectMethod":
    case "FunctionExpression": {
      const kind =
        instrValue.kind === "FunctionExpression" ? "Function" : "ObjectMethod";
      const name = getFunctionName$1(instrValue, "");
      const fn = printFunction$1(instrValue.loweredFunc.func)
        .split("\n")
        .map((line) => `      ${line}`)
        .join("\n");
      const deps = instrValue.loweredFunc.dependencies
        .map((dep) => printPlace(dep))
        .join(",");
      const context = instrValue.loweredFunc.func.context
        .map((dep) => printPlace(dep))
        .join(",");
      const effects =
        (_b =
          (_a = instrValue.loweredFunc.func.effects) === null || _a === void 0
            ? void 0
            : _a
                .map((effect) => {
                  if (effect.kind === "ContextMutation") {
                    return `ContextMutation places=[${[...effect.places].map((place) => printPlace(place)).join(", ")}] effect=${effect.effect}`;
                  } else {
                    return `GlobalMutation`;
                  }
                })
                .join(", ")) !== null && _b !== void 0
          ? _b
          : "";
      value = `${kind} ${name} @deps[${deps}] @context[${context}] @effects[${effects}]:\n${fn}`;
      break;
    }
    case "TaggedTemplateExpression": {
      value = `${printPlace(instrValue.tag)}\`${instrValue.value.raw}\``;
      break;
    }
    case "LogicalExpression": {
      value = `Logical ${printInstructionValue(instrValue.left)} ${instrValue.operator} ${printInstructionValue(instrValue.right)}`;
      break;
    }
    case "SequenceExpression": {
      value = [
        `Sequence`,
        ...instrValue.instructions.map(
          (instr) => `    ${printInstruction(instr)}`
        ),
        `    ${printInstructionValue(instrValue.value)}`,
      ].join("\n");
      break;
    }
    case "ConditionalExpression": {
      value = `Ternary ${printInstructionValue(instrValue.test)} ? ${printInstructionValue(instrValue.consequent)} : ${printInstructionValue(instrValue.alternate)}`;
      break;
    }
    case "TemplateLiteral": {
      value = "`";
      CompilerError.invariant(
        instrValue.subexprs.length === instrValue.quasis.length - 1,
        {
          reason: "Bad assumption about quasi length.",
          description: null,
          loc: instrValue.loc,
          suggestions: null,
        }
      );
      for (let i = 0; i < instrValue.subexprs.length; i++) {
        value += instrValue.quasis[i].raw;
        value += `\${${printPlace(instrValue.subexprs[i])}}`;
      }
      value += instrValue.quasis.at(-1).raw + "`";
      break;
    }
    case "LoadGlobal": {
      switch (instrValue.binding.kind) {
        case "Global": {
          value = `LoadGlobal(global) ${instrValue.binding.name}`;
          break;
        }
        case "ModuleLocal": {
          value = `LoadGlobal(module) ${instrValue.binding.name}`;
          break;
        }
        case "ImportDefault": {
          value = `LoadGlobal import ${instrValue.binding.name} from '${instrValue.binding.module}'`;
          break;
        }
        case "ImportNamespace": {
          value = `LoadGlobal import * as ${instrValue.binding.name} from '${instrValue.binding.module}'`;
          break;
        }
        case "ImportSpecifier": {
          if (instrValue.binding.imported !== instrValue.binding.name) {
            value = `LoadGlobal import { ${instrValue.binding.imported} as ${instrValue.binding.name} } from '${instrValue.binding.module}'`;
          } else {
            value = `LoadGlobal import { ${instrValue.binding.name} } from '${instrValue.binding.module}'`;
          }
          break;
        }
        default: {
          assertExhaustive$1(
            instrValue.binding,
            `Unexpected binding kind \`${instrValue.binding.kind}\``
          );
        }
      }
      break;
    }
    case "StoreGlobal": {
      value = `StoreGlobal ${instrValue.name} = ${printPlace(instrValue.value)}`;
      break;
    }
    case "OptionalExpression": {
      value = `OptionalExpression ${printInstructionValue(instrValue.value)}`;
      break;
    }
    case "RegExpLiteral": {
      value = `RegExp /${instrValue.pattern}/${instrValue.flags}`;
      break;
    }
    case "MetaProperty": {
      value = `MetaProperty ${instrValue.meta}.${instrValue.property}`;
      break;
    }
    case "Await": {
      value = `Await ${printPlace(instrValue.value)}`;
      break;
    }
    case "GetIterator": {
      value = `GetIterator collection=${printPlace(instrValue.collection)}`;
      break;
    }
    case "IteratorNext": {
      value = `IteratorNext iterator=${printPlace(instrValue.iterator)} collection=${printPlace(instrValue.collection)}`;
      break;
    }
    case "NextPropertyOf": {
      value = `NextPropertyOf ${printPlace(instrValue.value)}`;
      break;
    }
    case "Debugger": {
      value = `Debugger`;
      break;
    }
    case "PostfixUpdate": {
      value = `PostfixUpdate ${printPlace(instrValue.lvalue)} = ${printPlace(instrValue.value)} ${instrValue.operation}`;
      break;
    }
    case "PrefixUpdate": {
      value = `PrefixUpdate ${printPlace(instrValue.lvalue)} = ${instrValue.operation} ${printPlace(instrValue.value)}`;
      break;
    }
    case "StartMemoize": {
      value = `StartMemoize deps=${(_d = (_c = instrValue.deps) === null || _c === void 0 ? void 0 : _c.map((dep) => printManualMemoDependency(dep, false))) !== null && _d !== void 0 ? _d : "(none)"}`;
      break;
    }
    case "FinishMemoize": {
      value = `FinishMemoize decl=${printPlace(instrValue.decl)}`;
      break;
    }
    case "ReactiveFunctionValue": {
      value = `FunctionValue ${printReactiveFunction(instrValue.fn)}`;
      break;
    }
    default: {
      assertExhaustive$1(
        instrValue,
        `Unexpected instruction kind '${instrValue.kind}'`
      );
    }
  }
  return value;
}
function isMutable$1(range) {
  return range.end > range.start + 1;
}
function printMutableRange(identifier) {
  var _b, _c;
  const range =
    (_c =
      (_b = identifier.scope) === null || _b === void 0 ? void 0 : _b.range) !==
      null && _c !== void 0
      ? _c
      : identifier.mutableRange;
  return isMutable$1(range) ? `[${range.start}:${range.end}]` : "";
}
function printPattern(pattern) {
  switch (pattern.kind) {
    case "ArrayPattern": {
      return (
        "[ " +
        pattern.items
          .map((item) => {
            if (item.kind === "Hole") {
              return "<hole>";
            }
            return printPattern(item);
          })
          .join(", ") +
        " ]"
      );
    }
    case "ObjectPattern": {
      return (
        "{ " +
        pattern.properties
          .map((item) => {
            switch (item.kind) {
              case "ObjectProperty": {
                return `${printObjectPropertyKey(item.key)}: ${printPattern(item.place)}`;
              }
              case "Spread": {
                return printPattern(item);
              }
              default: {
                assertExhaustive$1(item, "Unexpected object property kind");
              }
            }
          })
          .join(", ") +
        " }"
      );
    }
    case "Spread": {
      return `...${printPlace(pattern.place)}`;
    }
    case "Identifier": {
      return printPlace(pattern);
    }
    default: {
      assertExhaustive$1(
        pattern,
        `Unexpected pattern kind \`${pattern.kind}\``
      );
    }
  }
}
function printPlace(place) {
  const items = [
    place.effect,
    " ",
    printIdentifier(place.identifier),
    printMutableRange(place.identifier),
    printType(place.identifier.type),
    place.reactive ? "{reactive}" : null,
  ];
  return items.filter((x) => x != null).join("");
}
function printIdentifier(id) {
  return `${printName(id.name)}$${id.id}${printScope(id.scope)}`;
}
function printName(name) {
  if (name === null) {
    return "";
  }
  return name.value;
}
function printScope(scope) {
  return `${scope !== null ? `_@${scope.id}` : ""}`;
}
function printManualMemoDependency(val, nameOnly) {
  var _a;
  let rootStr;
  if (val.root.kind === "Global") {
    rootStr = val.root.identifierName;
  } else {
    CompilerError.invariant(
      ((_a = val.root.value.identifier.name) === null || _a === void 0
        ? void 0
        : _a.kind) === "named",
      {
        reason: "DepsValidation: expected named local variable in depslist",
        suggestions: null,
        loc: val.root.value.loc,
      }
    );
    rootStr = nameOnly
      ? val.root.value.identifier.name.value
      : printIdentifier(val.root.value.identifier);
  }
  return `${rootStr}${val.path.length > 0 ? "." : ""}${val.path.join(".")}`;
}
function printType(type) {
  if (type.kind === "Type") return "";
  if (type.kind === "Object" && type.shapeId != null) {
    return `:T${type.kind}<${type.shapeId}>`;
  } else if (type.kind === "Function" && type.shapeId != null) {
    return `:T${type.kind}<${type.shapeId}>`;
  } else {
    return `:T${type.kind}`;
  }
}
function printSourceLocation(loc) {
  if (typeof loc === "symbol") {
    return "generated";
  } else {
    return `${loc.start.line}:${loc.start.column}:${loc.end.line}:${loc.end.column}`;
  }
}
function getFunctionName$1(instrValue, defaultValue) {
  var _a;
  switch (instrValue.kind) {
    case "FunctionExpression":
      return (_a = instrValue.name) !== null && _a !== void 0
        ? _a
        : defaultValue;
    case "ObjectMethod":
      return defaultValue;
  }
}
function* eachInstructionLValue(instr) {
  if (instr.lvalue !== null) {
    yield instr.lvalue;
  }
  yield* eachInstructionValueLValue(instr.value);
}
function* eachInstructionValueLValue(value) {
  switch (value.kind) {
    case "DeclareContext":
    case "StoreContext":
    case "DeclareLocal":
    case "StoreLocal": {
      yield value.lvalue.place;
      break;
    }
    case "Destructure": {
      yield* eachPatternOperand(value.lvalue.pattern);
      break;
    }
    case "PostfixUpdate":
    case "PrefixUpdate": {
      yield value.lvalue;
      break;
    }
  }
}
function* eachInstructionOperand(instr) {
  yield* eachInstructionValueOperand(instr.value);
}
function* eachInstructionValueOperand(instrValue) {
  switch (instrValue.kind) {
    case "NewExpression":
    case "CallExpression": {
      yield instrValue.callee;
      yield* eachCallArgument(instrValue.args);
      break;
    }
    case "BinaryExpression": {
      yield instrValue.left;
      yield instrValue.right;
      break;
    }
    case "MethodCall": {
      yield instrValue.receiver;
      yield instrValue.property;
      yield* eachCallArgument(instrValue.args);
      break;
    }
    case "DeclareContext":
    case "DeclareLocal": {
      break;
    }
    case "LoadLocal":
    case "LoadContext": {
      yield instrValue.place;
      break;
    }
    case "StoreLocal": {
      yield instrValue.value;
      break;
    }
    case "StoreContext": {
      yield instrValue.lvalue.place;
      yield instrValue.value;
      break;
    }
    case "StoreGlobal": {
      yield instrValue.value;
      break;
    }
    case "Destructure": {
      yield instrValue.value;
      break;
    }
    case "PropertyLoad": {
      yield instrValue.object;
      break;
    }
    case "PropertyDelete": {
      yield instrValue.object;
      break;
    }
    case "PropertyStore": {
      yield instrValue.object;
      yield instrValue.value;
      break;
    }
    case "ComputedLoad": {
      yield instrValue.object;
      yield instrValue.property;
      break;
    }
    case "ComputedDelete": {
      yield instrValue.object;
      yield instrValue.property;
      break;
    }
    case "ComputedStore": {
      yield instrValue.object;
      yield instrValue.property;
      yield instrValue.value;
      break;
    }
    case "UnaryExpression": {
      yield instrValue.value;
      break;
    }
    case "JsxExpression": {
      if (instrValue.tag.kind === "Identifier") {
        yield instrValue.tag;
      }
      for (const attribute of instrValue.props) {
        switch (attribute.kind) {
          case "JsxAttribute": {
            yield attribute.place;
            break;
          }
          case "JsxSpreadAttribute": {
            yield attribute.argument;
            break;
          }
          default: {
            assertExhaustive$1(
              attribute,
              `Unexpected attribute kind \`${attribute.kind}\``
            );
          }
        }
      }
      if (instrValue.children) {
        yield* instrValue.children;
      }
      break;
    }
    case "JsxFragment": {
      yield* instrValue.children;
      break;
    }
    case "ObjectExpression": {
      for (const property of instrValue.properties) {
        if (
          property.kind === "ObjectProperty" &&
          property.key.kind === "computed"
        ) {
          yield property.key.name;
        }
        yield property.place;
      }
      break;
    }
    case "ArrayExpression": {
      for (const element of instrValue.elements) {
        if (element.kind === "Identifier") {
          yield element;
        } else if (element.kind === "Spread") {
          yield element.place;
        }
      }
      break;
    }
    case "ObjectMethod":
    case "FunctionExpression": {
      yield* instrValue.loweredFunc.dependencies;
      break;
    }
    case "TaggedTemplateExpression": {
      yield instrValue.tag;
      break;
    }
    case "TypeCastExpression": {
      yield instrValue.value;
      break;
    }
    case "TemplateLiteral": {
      yield* instrValue.subexprs;
      break;
    }
    case "Await": {
      yield instrValue.value;
      break;
    }
    case "GetIterator": {
      yield instrValue.collection;
      break;
    }
    case "IteratorNext": {
      yield instrValue.iterator;
      yield instrValue.collection;
      break;
    }
    case "NextPropertyOf": {
      yield instrValue.value;
      break;
    }
    case "PostfixUpdate":
    case "PrefixUpdate": {
      yield instrValue.value;
      break;
    }
    case "StartMemoize": {
      if (instrValue.deps != null) {
        for (const dep of instrValue.deps) {
          if (dep.root.kind === "NamedLocal") {
            yield dep.root.value;
          }
        }
      }
      break;
    }
    case "FinishMemoize": {
      yield instrValue.decl;
      break;
    }
    case "Debugger":
    case "RegExpLiteral":
    case "MetaProperty":
    case "LoadGlobal":
    case "UnsupportedNode":
    case "Primitive":
    case "JSXText": {
      break;
    }
    default: {
      assertExhaustive$1(
        instrValue,
        `Unexpected instruction kind \`${instrValue.kind}\``
      );
    }
  }
}
function* eachCallArgument(args) {
  for (const arg of args) {
    if (arg.kind === "Identifier") {
      yield arg;
    } else {
      yield arg.place;
    }
  }
}
function doesPatternContainSpreadElement(pattern) {
  switch (pattern.kind) {
    case "ArrayPattern": {
      for (const item of pattern.items) {
        if (item.kind === "Spread") {
          return true;
        }
      }
      break;
    }
    case "ObjectPattern": {
      for (const property of pattern.properties) {
        if (property.kind === "Spread") {
          return true;
        }
      }
      break;
    }
    default: {
      assertExhaustive$1(
        pattern,
        `Unexpected pattern kind \`${pattern.kind}\``
      );
    }
  }
  return false;
}
function* eachPatternOperand(pattern) {
  switch (pattern.kind) {
    case "ArrayPattern": {
      for (const item of pattern.items) {
        if (item.kind === "Identifier") {
          yield item;
        } else if (item.kind === "Spread") {
          yield item.place;
        } else if (item.kind === "Hole") {
          continue;
        } else {
          assertExhaustive$1(item, `Unexpected item kind \`${item.kind}\``);
        }
      }
      break;
    }
    case "ObjectPattern": {
      for (const property of pattern.properties) {
        if (property.kind === "ObjectProperty") {
          yield property.place;
        } else if (property.kind === "Spread") {
          yield property.place;
        } else {
          assertExhaustive$1(
            property,
            `Unexpected item kind \`${property.kind}\``
          );
        }
      }
      break;
    }
    default: {
      assertExhaustive$1(
        pattern,
        `Unexpected pattern kind \`${pattern.kind}\``
      );
    }
  }
}
function mapInstructionLValues(instr, fn) {
  switch (instr.value.kind) {
    case "DeclareLocal":
    case "StoreLocal": {
      const lvalue = instr.value.lvalue;
      lvalue.place = fn(lvalue.place);
      break;
    }
    case "Destructure": {
      mapPatternOperands(instr.value.lvalue.pattern, fn);
      break;
    }
    case "PostfixUpdate":
    case "PrefixUpdate": {
      instr.value.lvalue = fn(instr.value.lvalue);
      break;
    }
  }
  if (instr.lvalue !== null) {
    instr.lvalue = fn(instr.lvalue);
  }
}
function mapInstructionOperands(instr, fn) {
  mapInstructionValueOperands(instr.value, fn);
}
function mapInstructionValueOperands(instrValue, fn) {
  switch (instrValue.kind) {
    case "BinaryExpression": {
      instrValue.left = fn(instrValue.left);
      instrValue.right = fn(instrValue.right);
      break;
    }
    case "PropertyLoad": {
      instrValue.object = fn(instrValue.object);
      break;
    }
    case "PropertyDelete": {
      instrValue.object = fn(instrValue.object);
      break;
    }
    case "PropertyStore": {
      instrValue.object = fn(instrValue.object);
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "ComputedLoad": {
      instrValue.object = fn(instrValue.object);
      instrValue.property = fn(instrValue.property);
      break;
    }
    case "ComputedDelete": {
      instrValue.object = fn(instrValue.object);
      instrValue.property = fn(instrValue.property);
      break;
    }
    case "ComputedStore": {
      instrValue.object = fn(instrValue.object);
      instrValue.property = fn(instrValue.property);
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "DeclareContext":
    case "DeclareLocal": {
      break;
    }
    case "LoadLocal":
    case "LoadContext": {
      instrValue.place = fn(instrValue.place);
      break;
    }
    case "StoreLocal": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "StoreContext": {
      instrValue.lvalue.place = fn(instrValue.lvalue.place);
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "StoreGlobal": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "Destructure": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "NewExpression":
    case "CallExpression": {
      instrValue.callee = fn(instrValue.callee);
      instrValue.args = mapCallArguments(instrValue.args, fn);
      break;
    }
    case "MethodCall": {
      instrValue.receiver = fn(instrValue.receiver);
      instrValue.property = fn(instrValue.property);
      instrValue.args = mapCallArguments(instrValue.args, fn);
      break;
    }
    case "UnaryExpression": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "JsxExpression": {
      if (instrValue.tag.kind === "Identifier") {
        instrValue.tag = fn(instrValue.tag);
      }
      for (const attribute of instrValue.props) {
        switch (attribute.kind) {
          case "JsxAttribute": {
            attribute.place = fn(attribute.place);
            break;
          }
          case "JsxSpreadAttribute": {
            attribute.argument = fn(attribute.argument);
            break;
          }
          default: {
            assertExhaustive$1(
              attribute,
              `Unexpected attribute kind \`${attribute.kind}\``
            );
          }
        }
      }
      if (instrValue.children) {
        instrValue.children = instrValue.children.map((p) => fn(p));
      }
      break;
    }
    case "ObjectExpression": {
      for (const property of instrValue.properties) {
        if (
          property.kind === "ObjectProperty" &&
          property.key.kind === "computed"
        ) {
          property.key.name = fn(property.key.name);
        }
        property.place = fn(property.place);
      }
      break;
    }
    case "ArrayExpression": {
      instrValue.elements = instrValue.elements.map((element) => {
        if (element.kind === "Identifier") {
          return fn(element);
        } else if (element.kind === "Spread") {
          element.place = fn(element.place);
          return element;
        } else {
          return element;
        }
      });
      break;
    }
    case "JsxFragment": {
      instrValue.children = instrValue.children.map((e) => fn(e));
      break;
    }
    case "ObjectMethod":
    case "FunctionExpression": {
      instrValue.loweredFunc.dependencies =
        instrValue.loweredFunc.dependencies.map((d) => fn(d));
      break;
    }
    case "TaggedTemplateExpression": {
      instrValue.tag = fn(instrValue.tag);
      break;
    }
    case "TypeCastExpression": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "TemplateLiteral": {
      instrValue.subexprs = instrValue.subexprs.map(fn);
      break;
    }
    case "Await": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "GetIterator": {
      instrValue.collection = fn(instrValue.collection);
      break;
    }
    case "IteratorNext": {
      instrValue.iterator = fn(instrValue.iterator);
      instrValue.collection = fn(instrValue.collection);
      break;
    }
    case "NextPropertyOf": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "PostfixUpdate":
    case "PrefixUpdate": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "StartMemoize": {
      if (instrValue.deps != null) {
        for (const dep of instrValue.deps) {
          if (dep.root.kind === "NamedLocal") {
            dep.root.value = fn(dep.root.value);
          }
        }
      }
      break;
    }
    case "FinishMemoize": {
      instrValue.decl = fn(instrValue.decl);
      break;
    }
    case "Debugger":
    case "RegExpLiteral":
    case "MetaProperty":
    case "LoadGlobal":
    case "UnsupportedNode":
    case "Primitive":
    case "JSXText": {
      break;
    }
    default: {
      assertExhaustive$1(instrValue, "Unexpected instruction kind");
    }
  }
}
function mapCallArguments(args, fn) {
  return args.map((arg) => {
    if (arg.kind === "Identifier") {
      return fn(arg);
    } else {
      arg.place = fn(arg.place);
      return arg;
    }
  });
}
function mapPatternOperands(pattern, fn) {
  switch (pattern.kind) {
    case "ArrayPattern": {
      pattern.items = pattern.items.map((item) => {
        if (item.kind === "Identifier") {
          return fn(item);
        } else if (item.kind === "Spread") {
          item.place = fn(item.place);
          return item;
        } else {
          return item;
        }
      });
      break;
    }
    case "ObjectPattern": {
      for (const property of pattern.properties) {
        property.place = fn(property.place);
      }
      break;
    }
    default: {
      assertExhaustive$1(
        pattern,
        `Unexpected pattern kind \`${pattern.kind}\``
      );
    }
  }
}
function mapTerminalSuccessors(terminal, fn) {
  switch (terminal.kind) {
    case "goto": {
      const target = fn(terminal.block);
      return {
        kind: "goto",
        block: target,
        variant: terminal.variant,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "if": {
      const consequent = fn(terminal.consequent);
      const alternate = fn(terminal.alternate);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "if",
        test: terminal.test,
        consequent: consequent,
        alternate: alternate,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "branch": {
      const consequent = fn(terminal.consequent);
      const alternate = fn(terminal.alternate);
      return {
        kind: "branch",
        test: terminal.test,
        consequent: consequent,
        alternate: alternate,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "switch": {
      const cases = terminal.cases.map((case_) => {
        const target = fn(case_.block);
        return { test: case_.test, block: target };
      });
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "switch",
        test: terminal.test,
        cases: cases,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "logical": {
      const test = fn(terminal.test);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "logical",
        test: test,
        fallthrough: fallthrough,
        operator: terminal.operator,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "ternary": {
      const test = fn(terminal.test);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "ternary",
        test: test,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "optional": {
      const test = fn(terminal.test);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "optional",
        optional: terminal.optional,
        test: test,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "return": {
      return {
        kind: "return",
        loc: terminal.loc,
        value: terminal.value,
        id: makeInstructionId(0),
      };
    }
    case "throw": {
      return terminal;
    }
    case "do-while": {
      const loop = fn(terminal.loop);
      const test = fn(terminal.test);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "do-while",
        loc: terminal.loc,
        test: test,
        loop: loop,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
      };
    }
    case "while": {
      const test = fn(terminal.test);
      const loop = fn(terminal.loop);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "while",
        loc: terminal.loc,
        test: test,
        loop: loop,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
      };
    }
    case "for": {
      const init = fn(terminal.init);
      const test = fn(terminal.test);
      const update = terminal.update !== null ? fn(terminal.update) : null;
      const loop = fn(terminal.loop);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "for",
        loc: terminal.loc,
        init: init,
        test: test,
        update: update,
        loop: loop,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
      };
    }
    case "for-of": {
      const init = fn(terminal.init);
      const loop = fn(terminal.loop);
      const test = fn(terminal.test);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "for-of",
        loc: terminal.loc,
        init: init,
        test: test,
        loop: loop,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
      };
    }
    case "for-in": {
      const init = fn(terminal.init);
      const loop = fn(terminal.loop);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "for-in",
        loc: terminal.loc,
        init: init,
        loop: loop,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
      };
    }
    case "label": {
      const block = fn(terminal.block);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "label",
        block: block,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "sequence": {
      const block = fn(terminal.block);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "sequence",
        block: block,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "maybe-throw": {
      const continuation = fn(terminal.continuation);
      const handler = fn(terminal.handler);
      return {
        kind: "maybe-throw",
        continuation: continuation,
        handler: handler,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "try": {
      const block = fn(terminal.block);
      const handler = fn(terminal.handler);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "try",
        block: block,
        handlerBinding: terminal.handlerBinding,
        handler: handler,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "scope":
    case "pruned-scope": {
      const block = fn(terminal.block);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: terminal.kind,
        scope: terminal.scope,
        block: block,
        fallthrough: fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc,
      };
    }
    case "unreachable":
    case "unsupported": {
      return terminal;
    }
    default: {
      assertExhaustive$1(
        terminal,
        `Unexpected terminal kind \`${terminal.kind}\``
      );
    }
  }
}
function terminalHasFallthrough(terminal) {
  switch (terminal.kind) {
    case "maybe-throw":
    case "branch":
    case "goto":
    case "return":
    case "throw":
    case "unreachable":
    case "unsupported": {
      terminal.fallthrough;
      return false;
    }
    case "try":
    case "do-while":
    case "for-of":
    case "for-in":
    case "for":
    case "if":
    case "label":
    case "logical":
    case "optional":
    case "sequence":
    case "switch":
    case "ternary":
    case "while":
    case "scope":
    case "pruned-scope": {
      terminal.fallthrough;
      return true;
    }
    default: {
      assertExhaustive$1(
        terminal,
        `Unexpected terminal kind \`${terminal.kind}\``
      );
    }
  }
}
function terminalFallthrough(terminal) {
  if (terminalHasFallthrough(terminal)) {
    return terminal.fallthrough;
  } else {
    return null;
  }
}
function* eachTerminalSuccessor(terminal) {
  switch (terminal.kind) {
    case "goto": {
      yield terminal.block;
      break;
    }
    case "if": {
      yield terminal.consequent;
      yield terminal.alternate;
      break;
    }
    case "branch": {
      yield terminal.consequent;
      yield terminal.alternate;
      break;
    }
    case "switch": {
      for (const case_ of terminal.cases) {
        yield case_.block;
      }
      break;
    }
    case "optional":
    case "ternary":
    case "logical": {
      yield terminal.test;
      break;
    }
    case "return": {
      break;
    }
    case "throw": {
      break;
    }
    case "do-while": {
      yield terminal.loop;
      break;
    }
    case "while": {
      yield terminal.test;
      break;
    }
    case "for": {
      yield terminal.init;
      break;
    }
    case "for-of": {
      yield terminal.init;
      break;
    }
    case "for-in": {
      yield terminal.init;
      break;
    }
    case "label": {
      yield terminal.block;
      break;
    }
    case "sequence": {
      yield terminal.block;
      break;
    }
    case "maybe-throw": {
      yield terminal.continuation;
      yield terminal.handler;
      break;
    }
    case "try": {
      yield terminal.block;
      break;
    }
    case "scope":
    case "pruned-scope": {
      yield terminal.block;
      break;
    }
    case "unreachable":
    case "unsupported":
      break;
    default: {
      assertExhaustive$1(
        terminal,
        `Unexpected terminal kind \`${terminal.kind}\``
      );
    }
  }
}
function mapTerminalOperands(terminal, fn) {
  switch (terminal.kind) {
    case "if": {
      terminal.test = fn(terminal.test);
      break;
    }
    case "branch": {
      terminal.test = fn(terminal.test);
      break;
    }
    case "switch": {
      terminal.test = fn(terminal.test);
      for (const case_ of terminal.cases) {
        if (case_.test === null) {
          continue;
        }
        case_.test = fn(case_.test);
      }
      break;
    }
    case "return":
    case "throw": {
      terminal.value = fn(terminal.value);
      break;
    }
    case "try": {
      if (terminal.handlerBinding !== null) {
        terminal.handlerBinding = fn(terminal.handlerBinding);
      } else {
        terminal.handlerBinding = null;
      }
      break;
    }
    case "maybe-throw":
    case "sequence":
    case "label":
    case "optional":
    case "ternary":
    case "logical":
    case "do-while":
    case "while":
    case "for":
    case "for-of":
    case "for-in":
    case "goto":
    case "unreachable":
    case "unsupported":
    case "scope":
    case "pruned-scope": {
      break;
    }
    default: {
      assertExhaustive$1(
        terminal,
        `Unexpected terminal kind \`${terminal.kind}\``
      );
    }
  }
}
function* eachTerminalOperand(terminal) {
  switch (terminal.kind) {
    case "if": {
      yield terminal.test;
      break;
    }
    case "branch": {
      yield terminal.test;
      break;
    }
    case "switch": {
      yield terminal.test;
      for (const case_ of terminal.cases) {
        if (case_.test === null) {
          continue;
        }
        yield case_.test;
      }
      break;
    }
    case "return":
    case "throw": {
      yield terminal.value;
      break;
    }
    case "try": {
      if (terminal.handlerBinding !== null) {
        yield terminal.handlerBinding;
      }
      break;
    }
    case "maybe-throw":
    case "sequence":
    case "label":
    case "optional":
    case "ternary":
    case "logical":
    case "do-while":
    case "while":
    case "for":
    case "for-of":
    case "for-in":
    case "goto":
    case "unreachable":
    case "unsupported":
    case "scope":
    case "pruned-scope": {
      break;
    }
    default: {
      assertExhaustive$1(
        terminal,
        `Unexpected terminal kind \`${terminal.kind}\``
      );
    }
  }
}
function assertConsistentIdentifiers(fn) {
  const identifiers = new Map();
  const assignments = new Set();
  for (const [, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      validate(identifiers, phi.id);
      for (const [, operand] of phi.operands) {
        validate(identifiers, operand);
      }
    }
    for (const instr of block.instructions) {
      CompilerError.invariant(instr.lvalue.identifier.name === null, {
        reason: `Expected all lvalues to be temporaries`,
        description: `Found named lvalue \`${instr.lvalue.identifier.name}\``,
        loc: instr.lvalue.loc,
        suggestions: null,
      });
      CompilerError.invariant(!assignments.has(instr.lvalue.identifier.id), {
        reason: `Expected lvalues to be assigned exactly once`,
        description: `Found duplicate assignment of '${printPlace(instr.lvalue)}'`,
        loc: instr.lvalue.loc,
        suggestions: null,
      });
      assignments.add(instr.lvalue.identifier.id);
      for (const operand of eachInstructionLValue(instr)) {
        validate(identifiers, operand.identifier, operand.loc);
      }
      for (const operand of eachInstructionValueOperand(instr.value)) {
        validate(identifiers, operand.identifier, operand.loc);
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      validate(identifiers, operand.identifier, operand.loc);
    }
  }
}
function validate(identifiers, identifier, loc = null) {
  const previous = identifiers.get(identifier.id);
  if (previous === undefined) {
    identifiers.set(identifier.id, identifier);
  } else {
    CompilerError.invariant(identifier === previous, {
      reason: `Duplicate identifier object`,
      description: `Found duplicate identifier object for id ${identifier.id}`,
      loc: loc !== null && loc !== void 0 ? loc : GeneratedSource,
      suggestions: null,
    });
  }
}
function assertTerminalSuccessorsExist(fn) {
  for (const [, block] of fn.body.blocks) {
    mapTerminalSuccessors(block.terminal, (successor) => {
      var _a;
      CompilerError.invariant(fn.body.blocks.has(successor), {
        reason: `Terminal successor references unknown block`,
        description: `Block bb${successor} does not exist for terminal '${printTerminal(block.terminal)}'`,
        loc:
          (_a = block.terminal.loc) !== null && _a !== void 0
            ? _a
            : GeneratedSource,
        suggestions: null,
      });
      return successor;
    });
  }
}
function getScopes(fn) {
  const scopes = new Set();
  function visitPlace(place) {
    const scope = place.identifier.scope;
    if (scope != null) {
      if (scope.range.start !== scope.range.end) {
        scopes.add(scope);
      }
    }
  }
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      for (const operand of eachInstructionLValue(instr)) {
        visitPlace(operand);
      }
      for (const operand of eachInstructionOperand(instr)) {
        visitPlace(operand);
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      visitPlace(operand);
    }
  }
  return scopes;
}
function rangePreOrderComparator(a, b) {
  const startDiff = a.start - b.start;
  if (startDiff !== 0) return startDiff;
  return b.end - a.end;
}
function recursivelyTraverseItems(items, getRange, context, enter, exit) {
  items.sort((a, b) => rangePreOrderComparator(getRange(a), getRange(b)));
  let activeItems = [];
  const ranges = items.map(getRange);
  for (let i = 0; i < items.length; i++) {
    const curr = items[i];
    const currRange = ranges[i];
    for (let i = activeItems.length - 1; i >= 0; i--) {
      const maybeParent = activeItems[i];
      const maybeParentRange = getRange(maybeParent);
      const disjoint = currRange.start >= maybeParentRange.end;
      const nested = currRange.end <= maybeParentRange.end;
      CompilerError.invariant(disjoint || nested, {
        reason: "Invalid nesting in program blocks or scopes",
        description: `Items overlap but are not nested: ${maybeParentRange.start}:${maybeParentRange.end}(${currRange.start}:${currRange.end})`,
        loc: GeneratedSource,
      });
      if (disjoint) {
        exit(maybeParent, context);
        activeItems.length = i;
      } else {
        break;
      }
    }
    enter(curr, context);
    activeItems.push(curr);
  }
  let curr = activeItems.pop();
  while (curr != null) {
    exit(curr, context);
    curr = activeItems.pop();
  }
}
const no_op = () => {};
function assertValidBlockNesting(fn) {
  var _a, _b;
  const scopes = getScopes(fn);
  const blocks = [...scopes].map((scope) =>
    Object.assign({ kind: "Scope", id: scope.id }, scope.range)
  );
  for (const [, block] of fn.body.blocks) {
    const fallthroughId = terminalFallthrough(block.terminal);
    if (fallthroughId != null) {
      const fallthrough = fn.body.blocks.get(fallthroughId);
      const end =
        (_b =
          (_a = fallthrough.instructions[0]) === null || _a === void 0
            ? void 0
            : _a.id) !== null && _b !== void 0
          ? _b
          : fallthrough.terminal.id;
      blocks.push({
        kind: "ProgramBlockSubtree",
        id: block.id,
        start: block.terminal.id,
        end: end,
      });
    }
  }
  recursivelyTraverseItems(blocks, (block) => block, null, no_op, no_op);
}
function assertValidMutableRanges(fn) {
  for (const [, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      for (const [, operand] of phi.operands) {
        visitIdentifier(operand);
      }
    }
    for (const instr of block.instructions) {
      for (const operand of eachInstructionLValue(instr)) {
        visitIdentifier(operand.identifier);
      }
      for (const operand of eachInstructionOperand(instr)) {
        visitIdentifier(operand.identifier);
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      visitIdentifier(operand.identifier);
    }
  }
}
function visitIdentifier(identifier) {
  validateMutableRange(identifier.mutableRange);
  if (identifier.scope !== null) {
    validateMutableRange(identifier.scope.range);
  }
}
function validateMutableRange(mutableRange) {
  invariant$1(
    (mutableRange.start === 0 && mutableRange.end === 0) ||
      mutableRange.end > mutableRange.start,
    "Identifier scope mutableRange was invalid: [%s:%s]",
    mutableRange.start,
    mutableRange.end
  );
}
function Ok(val) {
  return new OkImpl(val);
}
class OkImpl {
  constructor(val) {
    this.val = val;
  }
  map(fn) {
    return new OkImpl(fn(this.val));
  }
  mapErr(_fn) {
    return this;
  }
  mapOr(_fallback, fn) {
    return fn(this.val);
  }
  mapOrElse(_fallback, fn) {
    return fn(this.val);
  }
  andThen(fn) {
    return fn(this.val);
  }
  and(res) {
    return res;
  }
  or(_res) {
    return this;
  }
  orElse(_fn) {
    return this;
  }
  isOk() {
    return true;
  }
  isErr() {
    return false;
  }
  expect(_msg) {
    return this.val;
  }
  expectErr(msg) {
    throw new Error(`${msg}: ${this.val}`);
  }
  unwrap() {
    return this.val;
  }
  unwrapOr(_fallback) {
    return this.val;
  }
  unwrapOrElse(_fallback) {
    return this.val;
  }
  unwrapErr() {
    if (this.val instanceof Error) {
      throw this.val;
    }
    throw new Error(`Can't unwrap \`Ok\` to \`Err\`: ${this.val}`);
  }
}
function Err(val) {
  return new ErrImpl(val);
}
class ErrImpl {
  constructor(val) {
    this.val = val;
  }
  map(_fn) {
    return this;
  }
  mapErr(fn) {
    return new ErrImpl(fn(this.val));
  }
  mapOr(fallback, _fn) {
    return fallback;
  }
  mapOrElse(fallback, _fn) {
    return fallback();
  }
  andThen(_fn) {
    return this;
  }
  and(_res) {
    return this;
  }
  or(res) {
    return res;
  }
  orElse(fn) {
    return fn(this.val);
  }
  isOk() {
    return false;
  }
  isErr() {
    return true;
  }
  expect(msg) {
    throw new Error(`${msg}: ${this.val}`);
  }
  expectErr(_msg) {
    return this.val;
  }
  unwrap() {
    if (this.val instanceof Error) {
      throw this.val;
    }
    throw new Error(`Can't unwrap \`Err\` to \`Ok\`: ${this.val}`);
  }
  unwrapOr(fallback) {
    return fallback;
  }
  unwrapOrElse(fallback) {
    return fallback(this.val);
  }
  unwrapErr() {
    return this.val;
  }
}
var _HIRBuilder_instances,
  _HIRBuilder_completed,
  _HIRBuilder_current,
  _HIRBuilder_entry,
  _HIRBuilder_scopes,
  _HIRBuilder_context,
  _HIRBuilder_bindings,
  _HIRBuilder_env,
  _HIRBuilder_exceptionHandlerStack,
  _HIRBuilder_resolveBabelBinding;
function newBlock(id, kind) {
  return { id: id, kind: kind, instructions: [] };
}
class HIRBuilder {
  get nextIdentifierId() {
    return __classPrivateFieldGet(this, _HIRBuilder_env, "f").nextIdentifierId;
  }
  get context() {
    return __classPrivateFieldGet(this, _HIRBuilder_context, "f");
  }
  get bindings() {
    return __classPrivateFieldGet(this, _HIRBuilder_bindings, "f");
  }
  get environment() {
    return __classPrivateFieldGet(this, _HIRBuilder_env, "f");
  }
  constructor(env, parentFunction, bindings = null, context = null) {
    _HIRBuilder_instances.add(this);
    _HIRBuilder_completed.set(this, new Map());
    _HIRBuilder_current.set(this, void 0);
    _HIRBuilder_entry.set(this, void 0);
    _HIRBuilder_scopes.set(this, []);
    _HIRBuilder_context.set(this, void 0);
    _HIRBuilder_bindings.set(this, void 0);
    _HIRBuilder_env.set(this, void 0);
    _HIRBuilder_exceptionHandlerStack.set(this, []);
    this.errors = new CompilerError();
    __classPrivateFieldSet(this, _HIRBuilder_env, env, "f");
    __classPrivateFieldSet(
      this,
      _HIRBuilder_bindings,
      bindings !== null && bindings !== void 0 ? bindings : new Map(),
      "f"
    );
    this.parentFunction = parentFunction;
    __classPrivateFieldSet(
      this,
      _HIRBuilder_context,
      context !== null && context !== void 0 ? context : [],
      "f"
    );
    __classPrivateFieldSet(
      this,
      _HIRBuilder_entry,
      makeBlockId(env.nextBlockId),
      "f"
    );
    __classPrivateFieldSet(
      this,
      _HIRBuilder_current,
      newBlock(__classPrivateFieldGet(this, _HIRBuilder_entry, "f"), "block"),
      "f"
    );
  }
  currentBlockKind() {
    return __classPrivateFieldGet(this, _HIRBuilder_current, "f").kind;
  }
  push(instruction) {
    __classPrivateFieldGet(this, _HIRBuilder_current, "f").instructions.push(
      instruction
    );
    const exceptionHandler = __classPrivateFieldGet(
      this,
      _HIRBuilder_exceptionHandlerStack,
      "f"
    ).at(-1);
    if (exceptionHandler !== undefined) {
      const continuationBlock = this.reserve(this.currentBlockKind());
      this.terminateWithContinuation(
        {
          kind: "maybe-throw",
          continuation: continuationBlock.id,
          handler: exceptionHandler,
          id: makeInstructionId(0),
          loc: instruction.loc,
        },
        continuationBlock
      );
    }
  }
  enterTryCatch(handler, fn) {
    __classPrivateFieldGet(this, _HIRBuilder_exceptionHandlerStack, "f").push(
      handler
    );
    fn();
    __classPrivateFieldGet(this, _HIRBuilder_exceptionHandlerStack, "f").pop();
  }
  resolveThrowHandler() {
    const handler = __classPrivateFieldGet(
      this,
      _HIRBuilder_exceptionHandlerStack,
      "f"
    ).at(-1);
    return handler !== null && handler !== void 0 ? handler : null;
  }
  makeTemporary(loc) {
    const id = this.nextIdentifierId;
    return {
      id: id,
      name: null,
      mutableRange: { start: makeInstructionId(0), end: makeInstructionId(0) },
      scope: null,
      type: makeType(),
      loc: loc,
    };
  }
  resolveIdentifier(path) {
    const originalName = path.node.name;
    const babelBinding = __classPrivateFieldGet(
      this,
      _HIRBuilder_instances,
      "m",
      _HIRBuilder_resolveBabelBinding
    ).call(this, path);
    if (babelBinding == null) {
      return { kind: "Global", name: originalName };
    }
    const outerBinding =
      this.parentFunction.scope.parent.getBinding(originalName);
    if (babelBinding === outerBinding) {
      const path = babelBinding.path;
      if (path.isImportDefaultSpecifier()) {
        const importDeclaration = path.parentPath;
        return {
          kind: "ImportDefault",
          name: originalName,
          module: importDeclaration.node.source.value,
        };
      } else if (path.isImportSpecifier()) {
        const importDeclaration = path.parentPath;
        return {
          kind: "ImportSpecifier",
          name: originalName,
          module: importDeclaration.node.source.value,
          imported:
            path.node.imported.type === "Identifier"
              ? path.node.imported.name
              : path.node.imported.value,
        };
      } else if (path.isImportNamespaceSpecifier()) {
        const importDeclaration = path.parentPath;
        return {
          kind: "ImportNamespace",
          name: originalName,
          module: importDeclaration.node.source.value,
        };
      } else {
        return { kind: "ModuleLocal", name: originalName };
      }
    }
    const resolvedBinding = this.resolveBinding(babelBinding.identifier);
    if (resolvedBinding.name && resolvedBinding.name.value !== originalName) {
      babelBinding.scope.rename(originalName, resolvedBinding.name.value);
    }
    return {
      kind: "Identifier",
      identifier: resolvedBinding,
      bindingKind: babelBinding.kind,
    };
  }
  isContextIdentifier(path) {
    const binding = __classPrivateFieldGet(
      this,
      _HIRBuilder_instances,
      "m",
      _HIRBuilder_resolveBabelBinding
    ).call(this, path);
    if (binding) {
      const outerBinding = this.parentFunction.scope.parent.getBinding(
        path.node.name
      );
      if (binding === outerBinding) {
        return false;
      }
      return __classPrivateFieldGet(
        this,
        _HIRBuilder_env,
        "f"
      ).isContextIdentifier(binding.identifier);
    } else {
      return false;
    }
  }
  resolveBinding(node) {
    var _a;
    const originalName = node.name;
    let name = originalName;
    let index = 0;
    while (true) {
      const mapping = __classPrivateFieldGet(
        this,
        _HIRBuilder_bindings,
        "f"
      ).get(name);
      if (mapping === undefined) {
        const id = this.nextIdentifierId;
        const identifier = {
          id: id,
          name: makeIdentifierName(name),
          mutableRange: {
            start: makeInstructionId(0),
            end: makeInstructionId(0),
          },
          scope: null,
          type: makeType(),
          loc: (_a = node.loc) !== null && _a !== void 0 ? _a : GeneratedSource,
        };
        __classPrivateFieldGet(this, _HIRBuilder_bindings, "f").set(name, {
          node: node,
          identifier: identifier,
        });
        return identifier;
      } else if (mapping.node === node) {
        return mapping.identifier;
      } else {
        name = `${originalName}_${index++}`;
      }
    }
  }
  build() {
    var _a, _b;
    let ir = {
      blocks: __classPrivateFieldGet(this, _HIRBuilder_completed, "f"),
      entry: __classPrivateFieldGet(this, _HIRBuilder_entry, "f"),
    };
    const rpoBlocks = getReversePostorderedBlocks(ir);
    for (const [id, block] of ir.blocks) {
      if (
        !rpoBlocks.has(id) &&
        block.instructions.some(
          (instr) => instr.value.kind === "FunctionExpression"
        )
      ) {
        CompilerError.throwTodo({
          reason: `Support functions with unreachable code that may contain hoisted declarations`,
          loc:
            (_b =
              (_a = block.instructions[0]) === null || _a === void 0
                ? void 0
                : _a.loc) !== null && _b !== void 0
              ? _b
              : block.terminal.loc,
          description: null,
          suggestions: null,
        });
      }
    }
    ir.blocks = rpoBlocks;
    removeUnreachableForUpdates(ir);
    removeDeadDoWhileStatements(ir);
    removeUnnecessaryTryCatch(ir);
    markInstructionIds(ir);
    markPredecessors(ir);
    return ir;
  }
  terminate(terminal, nextBlockKind) {
    const {
      id: blockId,
      kind: kind,
      instructions: instructions,
    } = __classPrivateFieldGet(this, _HIRBuilder_current, "f");
    __classPrivateFieldGet(this, _HIRBuilder_completed, "f").set(blockId, {
      kind: kind,
      id: blockId,
      instructions: instructions,
      terminal: terminal,
      preds: new Set(),
      phis: new Set(),
    });
    if (nextBlockKind) {
      const nextId = __classPrivateFieldGet(
        this,
        _HIRBuilder_env,
        "f"
      ).nextBlockId;
      __classPrivateFieldSet(
        this,
        _HIRBuilder_current,
        newBlock(nextId, nextBlockKind),
        "f"
      );
    }
  }
  terminateWithContinuation(terminal, continuation) {
    const {
      id: blockId,
      kind: kind,
      instructions: instructions,
    } = __classPrivateFieldGet(this, _HIRBuilder_current, "f");
    __classPrivateFieldGet(this, _HIRBuilder_completed, "f").set(blockId, {
      kind: kind,
      id: blockId,
      instructions: instructions,
      terminal: terminal,
      preds: new Set(),
      phis: new Set(),
    });
    __classPrivateFieldSet(this, _HIRBuilder_current, continuation, "f");
  }
  reserve(kind) {
    return newBlock(
      makeBlockId(
        __classPrivateFieldGet(this, _HIRBuilder_env, "f").nextBlockId
      ),
      kind
    );
  }
  complete(block, terminal) {
    const { id: blockId, kind: kind, instructions: instructions } = block;
    __classPrivateFieldGet(this, _HIRBuilder_completed, "f").set(blockId, {
      kind: kind,
      id: blockId,
      instructions: instructions,
      terminal: terminal,
      preds: new Set(),
      phis: new Set(),
    });
  }
  enterReserved(wip, fn) {
    const current = __classPrivateFieldGet(this, _HIRBuilder_current, "f");
    __classPrivateFieldSet(this, _HIRBuilder_current, wip, "f");
    const terminal = fn();
    const {
      id: blockId,
      kind: kind,
      instructions: instructions,
    } = __classPrivateFieldGet(this, _HIRBuilder_current, "f");
    __classPrivateFieldGet(this, _HIRBuilder_completed, "f").set(blockId, {
      kind: kind,
      id: blockId,
      instructions: instructions,
      terminal: terminal,
      preds: new Set(),
      phis: new Set(),
    });
    __classPrivateFieldSet(this, _HIRBuilder_current, current, "f");
  }
  enter(nextBlockKind, fn) {
    const wip = this.reserve(nextBlockKind);
    this.enterReserved(wip, () => fn(wip.id));
    return wip.id;
  }
  label(label, breakBlock, fn) {
    __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").push({
      kind: "label",
      breakBlock: breakBlock,
      label: label,
    });
    const value = fn();
    const last = __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").pop();
    CompilerError.invariant(
      last != null &&
        last.kind === "label" &&
        last.label === label &&
        last.breakBlock === breakBlock,
      {
        reason: "Mismatched label",
        description: null,
        loc: null,
        suggestions: null,
      }
    );
    return value;
  }
  switch(label, breakBlock, fn) {
    __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").push({
      kind: "switch",
      breakBlock: breakBlock,
      label: label,
    });
    const value = fn();
    const last = __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").pop();
    CompilerError.invariant(
      last != null &&
        last.kind === "switch" &&
        last.label === label &&
        last.breakBlock === breakBlock,
      {
        reason: "Mismatched label",
        description: null,
        loc: null,
        suggestions: null,
      }
    );
    return value;
  }
  loop(label, continueBlock, breakBlock, fn) {
    __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").push({
      kind: "loop",
      label: label,
      continueBlock: continueBlock,
      breakBlock: breakBlock,
    });
    const value = fn();
    const last = __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").pop();
    CompilerError.invariant(
      last != null &&
        last.kind === "loop" &&
        last.label === label &&
        last.continueBlock === continueBlock &&
        last.breakBlock === breakBlock,
      {
        reason: "Mismatched loops",
        description: null,
        loc: null,
        suggestions: null,
      }
    );
    return value;
  }
  lookupBreak(label) {
    for (
      let ii = __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").length - 1;
      ii >= 0;
      ii--
    ) {
      const scope = __classPrivateFieldGet(this, _HIRBuilder_scopes, "f")[ii];
      if (
        (label === null &&
          (scope.kind === "loop" || scope.kind === "switch")) ||
        label === scope.label
      ) {
        return scope.breakBlock;
      }
    }
    CompilerError.invariant(false, {
      reason: "Expected a loop or switch to be in scope",
      description: null,
      loc: null,
      suggestions: null,
    });
  }
  lookupContinue(label) {
    for (
      let ii = __classPrivateFieldGet(this, _HIRBuilder_scopes, "f").length - 1;
      ii >= 0;
      ii--
    ) {
      const scope = __classPrivateFieldGet(this, _HIRBuilder_scopes, "f")[ii];
      if (scope.kind === "loop") {
        if (label === null || label === scope.label) {
          return scope.continueBlock;
        }
      } else if (label !== null && scope.label === label) {
        CompilerError.invariant(false, {
          reason: "Continue may only refer to a labeled loop",
          description: null,
          loc: null,
          suggestions: null,
        });
      }
    }
    CompilerError.invariant(false, {
      reason: "Expected a loop to be in scope",
      description: null,
      loc: null,
      suggestions: null,
    });
  }
}
(_HIRBuilder_completed = new WeakMap()),
  (_HIRBuilder_current = new WeakMap()),
  (_HIRBuilder_entry = new WeakMap()),
  (_HIRBuilder_scopes = new WeakMap()),
  (_HIRBuilder_context = new WeakMap()),
  (_HIRBuilder_bindings = new WeakMap()),
  (_HIRBuilder_env = new WeakMap()),
  (_HIRBuilder_exceptionHandlerStack = new WeakMap()),
  (_HIRBuilder_instances = new WeakSet()),
  (_HIRBuilder_resolveBabelBinding = function _HIRBuilder_resolveBabelBinding(
    path
  ) {
    const originalName = path.node.name;
    const binding = path.scope.getBinding(originalName);
    if (binding == null) {
      return null;
    }
    return binding;
  });
function removeUnreachableForUpdates(fn) {
  for (const [, block] of fn.blocks) {
    if (
      block.terminal.kind === "for" &&
      block.terminal.update !== null &&
      !fn.blocks.has(block.terminal.update)
    ) {
      block.terminal.update = null;
    }
  }
}
function removeDeadDoWhileStatements(func) {
  const visited = new Set();
  for (const [_, block] of func.blocks) {
    visited.add(block.id);
  }
  for (const [_, block] of func.blocks) {
    if (block.terminal.kind === "do-while") {
      if (!visited.has(block.terminal.test)) {
        block.terminal = {
          kind: "goto",
          block: block.terminal.loop,
          variant: GotoVariant.Break,
          id: block.terminal.id,
          loc: block.terminal.loc,
        };
      }
    }
  }
}
function reversePostorderBlocks(func) {
  const rpoBlocks = getReversePostorderedBlocks(func);
  func.blocks = rpoBlocks;
}
function getReversePostorderedBlocks(func) {
  const visited = new Set();
  const used = new Set();
  const usedFallthroughs = new Set();
  const postorder = [];
  function visit(blockId, isUsed) {
    const wasUsed = used.has(blockId);
    const wasVisited = visited.has(blockId);
    visited.add(blockId);
    if (isUsed) {
      used.add(blockId);
    }
    if (wasVisited && (wasUsed || !isUsed)) {
      return;
    }
    const block = func.blocks.get(blockId);
    const successors = [...eachTerminalSuccessor(block.terminal)].reverse();
    const fallthrough = terminalFallthrough(block.terminal);
    if (fallthrough != null) {
      if (isUsed) {
        usedFallthroughs.add(fallthrough);
      }
      visit(fallthrough, false);
    }
    for (const successor of successors) {
      visit(successor, isUsed);
    }
    if (!wasVisited) {
      postorder.push(blockId);
    }
  }
  visit(func.entry, true);
  const blocks = new Map();
  for (const blockId of postorder.reverse()) {
    const block = func.blocks.get(blockId);
    if (used.has(blockId)) {
      blocks.set(blockId, func.blocks.get(blockId));
    } else if (usedFallthroughs.has(blockId)) {
      blocks.set(
        blockId,
        Object.assign(Object.assign({}, block), {
          instructions: [],
          terminal: {
            kind: "unreachable",
            id: block.terminal.id,
            loc: block.terminal.loc,
          },
        })
      );
    }
  }
  return blocks;
}
function markInstructionIds(func) {
  let id = 0;
  const visited = new Set();
  for (const [_, block] of func.blocks) {
    for (const instr of block.instructions) {
      CompilerError.invariant(!visited.has(instr), {
        reason: `${printInstruction(instr)} already visited!`,
        description: null,
        loc: instr.loc,
        suggestions: null,
      });
      visited.add(instr);
      instr.id = makeInstructionId(++id);
    }
    block.terminal.id = makeInstructionId(++id);
  }
}
function markPredecessors(func) {
  for (const [, block] of func.blocks) {
    block.preds.clear();
  }
  const visited = new Set();
  function visit(blockId, prevBlock) {
    const block = func.blocks.get(blockId);
    if (block == null) {
      return;
    }
    CompilerError.invariant(block != null, {
      reason: "unexpected missing block",
      description: `block ${blockId}`,
      loc: GeneratedSource,
    });
    if (prevBlock) {
      block.preds.add(prevBlock.id);
    }
    if (visited.has(blockId)) {
      return;
    }
    visited.add(blockId);
    const { terminal: terminal } = block;
    for (const successor of eachTerminalSuccessor(terminal)) {
      visit(successor, block);
    }
  }
  visit(func.entry, null);
}
function removeUnnecessaryTryCatch(fn) {
  for (const [, block] of fn.blocks) {
    if (
      block.terminal.kind === "try" &&
      !fn.blocks.has(block.terminal.handler)
    ) {
      const handlerId = block.terminal.handler;
      const fallthroughId = block.terminal.fallthrough;
      const fallthrough = fn.blocks.get(fallthroughId);
      block.terminal = {
        kind: "goto",
        block: block.terminal.block,
        id: makeInstructionId(0),
        loc: block.terminal.loc,
        variant: GotoVariant.Break,
      };
      if (fallthrough != null) {
        if (fallthrough.preds.size === 1 && fallthrough.preds.has(handlerId)) {
          fn.blocks.delete(fallthroughId);
        } else {
          fallthrough.preds.delete(handlerId);
        }
      }
    }
  }
}
function createTemporaryPlace(env, loc) {
  return {
    kind: "Identifier",
    identifier: {
      id: env.nextIdentifierId,
      mutableRange: { start: makeInstructionId(0), end: makeInstructionId(0) },
      name: null,
      scope: null,
      type: makeType(),
      loc: loc,
    },
    reactive: false,
    effect: Effect.Unknown,
    loc: GeneratedSource,
  };
}
const PRIMITIVE_TYPE = { kind: "Primitive" };
let nextAnonId = 0;
function createAnonId() {
  return `<generated_${nextAnonId++}>`;
}
function addFunction(registry, properties, fn, id = null) {
  const shapeId = id !== null && id !== void 0 ? id : createAnonId();
  addShape(
    registry,
    shapeId,
    properties,
    Object.assign(Object.assign({}, fn), { hookKind: null })
  );
  return { kind: "Function", return: fn.returnType, shapeId: shapeId };
}
function addHook(registry, fn, id = null) {
  const shapeId = id !== null && id !== void 0 ? id : createAnonId();
  addShape(registry, shapeId, [], fn);
  return { kind: "Function", return: fn.returnType, shapeId: shapeId };
}
function addObject(registry, id, properties) {
  const shapeId = id !== null && id !== void 0 ? id : createAnonId();
  addShape(registry, shapeId, properties, null);
  return { kind: "Object", shapeId: shapeId };
}
function addShape(registry, id, properties, functionType) {
  const shape = { properties: new Map(properties), functionType: functionType };
  CompilerError.invariant(!registry.has(id), {
    reason: `[ObjectShape] Could not add shape to registry: name ${id} already exists.`,
    description: null,
    loc: null,
    suggestions: null,
  });
  registry.set(id, shape);
  return shape;
}
const BuiltInPropsId = "BuiltInProps";
const BuiltInArrayId = "BuiltInArray";
const BuiltInFunctionId = "BuiltInFunction";
const BuiltInJsxId = "BuiltInJsx";
const BuiltInObjectId = "BuiltInObject";
const BuiltInUseStateId = "BuiltInUseState";
const BuiltInSetStateId = "BuiltInSetState";
const BuiltInUseActionStateId = "BuiltInUseActionState";
const BuiltInSetActionStateId = "BuiltInSetActionState";
const BuiltInUseRefId = "BuiltInUseRefId";
const BuiltInRefValueId = "BuiltInRefValue";
const BuiltInMixedReadonlyId = "BuiltInMixedReadonly";
const BuiltInUseEffectHookId = "BuiltInUseEffectHook";
const BuiltInUseLayoutEffectHookId = "BuiltInUseLayoutEffectHook";
const BuiltInUseInsertionEffectHookId = "BuiltInUseInsertionEffectHook";
const BuiltInUseOperatorId = "BuiltInUseOperator";
const BuiltInUseReducerId = "BuiltInUseReducer";
const BuiltInDispatchId = "BuiltInDispatch";
const BUILTIN_SHAPES = new Map();
addObject(BUILTIN_SHAPES, BuiltInPropsId, [
  ["ref", { kind: "Object", shapeId: BuiltInUseRefId }],
]);
addObject(BUILTIN_SHAPES, BuiltInArrayId, [
  [
    "at",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [Effect.Read],
      restParam: null,
      returnType: { kind: "Poly" },
      calleeEffect: Effect.Capture,
      returnValueKind: ValueKind.Mutable,
    }),
  ],
  [
    "concat",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: Effect.Capture,
      returnType: { kind: "Object", shapeId: BuiltInArrayId },
      calleeEffect: Effect.Read,
      returnValueKind: ValueKind.Mutable,
    }),
  ],
  ["length", PRIMITIVE_TYPE],
  [
    "push",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: Effect.Capture,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: Effect.Store,
      returnValueKind: ValueKind.Primitive,
    }),
  ],
  [
    "map",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: Effect.ConditionallyMutate,
      returnType: { kind: "Object", shapeId: BuiltInArrayId },
      calleeEffect: Effect.ConditionallyMutate,
      returnValueKind: ValueKind.Mutable,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true,
    }),
  ],
  [
    "filter",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: Effect.ConditionallyMutate,
      returnType: { kind: "Object", shapeId: BuiltInArrayId },
      calleeEffect: Effect.ConditionallyMutate,
      returnValueKind: ValueKind.Mutable,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true,
    }),
  ],
  [
    "every",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: Effect.ConditionallyMutate,
      returnType: { kind: "Primitive" },
      calleeEffect: Effect.ConditionallyMutate,
      returnValueKind: ValueKind.Primitive,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true,
    }),
  ],
  [
    "some",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: Effect.ConditionallyMutate,
      returnType: { kind: "Primitive" },
      calleeEffect: Effect.ConditionallyMutate,
      returnValueKind: ValueKind.Primitive,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true,
    }),
  ],
  [
    "find",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: Effect.ConditionallyMutate,
      returnType: { kind: "Poly" },
      calleeEffect: Effect.ConditionallyMutate,
      returnValueKind: ValueKind.Mutable,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true,
    }),
  ],
  [
    "findIndex",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: Effect.ConditionallyMutate,
      returnType: { kind: "Primitive" },
      calleeEffect: Effect.ConditionallyMutate,
      returnValueKind: ValueKind.Primitive,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true,
    }),
  ],
  [
    "join",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: Effect.ConditionallyMutate,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: Effect.Read,
      returnValueKind: ValueKind.Primitive,
    }),
  ],
]);
addObject(BUILTIN_SHAPES, BuiltInObjectId, [
  [
    "toString",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: null,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: Effect.Read,
      returnValueKind: ValueKind.Primitive,
    }),
  ],
]);
addObject(BUILTIN_SHAPES, BuiltInUseStateId, [
  ["0", { kind: "Poly" }],
  [
    "1",
    addFunction(
      BUILTIN_SHAPES,
      [],
      {
        positionalParams: [],
        restParam: Effect.Freeze,
        returnType: PRIMITIVE_TYPE,
        calleeEffect: Effect.Read,
        returnValueKind: ValueKind.Primitive,
      },
      BuiltInSetStateId
    ),
  ],
]);
addObject(BUILTIN_SHAPES, BuiltInUseActionStateId, [
  ["0", { kind: "Poly" }],
  [
    "1",
    addFunction(
      BUILTIN_SHAPES,
      [],
      {
        positionalParams: [],
        restParam: Effect.Freeze,
        returnType: PRIMITIVE_TYPE,
        calleeEffect: Effect.Read,
        returnValueKind: ValueKind.Primitive,
      },
      BuiltInSetActionStateId
    ),
  ],
]);
addObject(BUILTIN_SHAPES, BuiltInUseReducerId, [
  ["0", { kind: "Poly" }],
  [
    "1",
    addFunction(
      BUILTIN_SHAPES,
      [],
      {
        positionalParams: [],
        restParam: Effect.Freeze,
        returnType: PRIMITIVE_TYPE,
        calleeEffect: Effect.Read,
        returnValueKind: ValueKind.Primitive,
      },
      BuiltInDispatchId
    ),
  ],
]);
addObject(BUILTIN_SHAPES, BuiltInUseRefId, [
  ["current", { kind: "Object", shapeId: BuiltInRefValueId }],
]);
addObject(BUILTIN_SHAPES, BuiltInRefValueId, [
  ["*", { kind: "Object", shapeId: BuiltInRefValueId }],
]);
addObject(BUILTIN_SHAPES, BuiltInMixedReadonlyId, [
  [
    "toString",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: Effect.Read,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: Effect.Read,
      returnValueKind: ValueKind.Primitive,
    }),
  ],
  [
    "map",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: Effect.Read,
      returnType: { kind: "Object", shapeId: BuiltInArrayId },
      calleeEffect: Effect.ConditionallyMutate,
      returnValueKind: ValueKind.Mutable,
      noAlias: true,
    }),
  ],
  [
    "filter",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: Effect.Read,
      returnType: { kind: "Object", shapeId: BuiltInArrayId },
      calleeEffect: Effect.ConditionallyMutate,
      returnValueKind: ValueKind.Mutable,
      noAlias: true,
    }),
  ],
  ["*", { kind: "Object", shapeId: BuiltInMixedReadonlyId }],
]);
addObject(BUILTIN_SHAPES, BuiltInJsxId, []);
addObject(BUILTIN_SHAPES, BuiltInFunctionId, []);
const DefaultMutatingHook = addHook(
  BUILTIN_SHAPES,
  {
    positionalParams: [],
    restParam: Effect.ConditionallyMutate,
    returnType: { kind: "Poly" },
    calleeEffect: Effect.Read,
    hookKind: "Custom",
    returnValueKind: ValueKind.Mutable,
  },
  "DefaultMutatingHook"
);
const DefaultNonmutatingHook = addHook(
  BUILTIN_SHAPES,
  {
    positionalParams: [],
    restParam: Effect.Freeze,
    returnType: { kind: "Poly" },
    calleeEffect: Effect.Read,
    hookKind: "Custom",
    returnValueKind: ValueKind.Frozen,
  },
  "DefaultNonmutatingHook"
);
function lower$1(func, env, bindings = null, capturedRefs = [], parent = null) {
  var _a, _b, _c;
  const builder = new HIRBuilder(
    env,
    parent !== null && parent !== void 0 ? parent : func,
    bindings,
    capturedRefs
  );
  const context = [];
  for (const ref of capturedRefs !== null && capturedRefs !== void 0
    ? capturedRefs
    : []) {
    context.push({
      kind: "Identifier",
      identifier: builder.resolveBinding(ref),
      effect: Effect.Unknown,
      reactive: false,
      loc: (_a = ref.loc) !== null && _a !== void 0 ? _a : GeneratedSource,
    });
  }
  let id = null;
  if (func.isFunctionDeclaration() || func.isFunctionExpression()) {
    const idNode = func.get("id");
    if (hasNode(idNode)) {
      id = idNode.node.name;
    }
  }
  const params = [];
  func.get("params").forEach((param) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (param.isIdentifier()) {
      const binding = builder.resolveIdentifier(param);
      if (binding.kind !== "Identifier") {
        builder.errors.push({
          reason: `(BuildHIR::lower) Could not find binding for param \`${param.node.name}\``,
          severity: ErrorSeverity.Invariant,
          loc: (_a = param.node.loc) !== null && _a !== void 0 ? _a : null,
          suggestions: null,
        });
        return;
      }
      const place = {
        kind: "Identifier",
        identifier: binding.identifier,
        effect: Effect.Unknown,
        reactive: false,
        loc:
          (_b = param.node.loc) !== null && _b !== void 0
            ? _b
            : GeneratedSource,
      };
      params.push(place);
    } else if (
      param.isObjectPattern() ||
      param.isArrayPattern() ||
      param.isAssignmentPattern()
    ) {
      const place = {
        kind: "Identifier",
        identifier: builder.makeTemporary(
          (_c = param.node.loc) !== null && _c !== void 0 ? _c : GeneratedSource
        ),
        effect: Effect.Unknown,
        reactive: false,
        loc:
          (_d = param.node.loc) !== null && _d !== void 0
            ? _d
            : GeneratedSource,
      };
      params.push(place);
      lowerAssignment(
        builder,
        (_e = param.node.loc) !== null && _e !== void 0 ? _e : GeneratedSource,
        InstructionKind.Let,
        param,
        place,
        "Assignment"
      );
    } else if (param.isRestElement()) {
      const place = {
        kind: "Identifier",
        identifier: builder.makeTemporary(
          (_f = param.node.loc) !== null && _f !== void 0 ? _f : GeneratedSource
        ),
        effect: Effect.Unknown,
        reactive: false,
        loc:
          (_g = param.node.loc) !== null && _g !== void 0
            ? _g
            : GeneratedSource,
      };
      params.push({ kind: "Spread", place: place });
      lowerAssignment(
        builder,
        (_h = param.node.loc) !== null && _h !== void 0 ? _h : GeneratedSource,
        InstructionKind.Let,
        param.get("argument"),
        place,
        "Assignment"
      );
    } else {
      builder.errors.push({
        reason: `(BuildHIR::lower) Handle ${param.node.type} params`,
        severity: ErrorSeverity.Todo,
        loc: (_j = param.node.loc) !== null && _j !== void 0 ? _j : null,
        suggestions: null,
      });
    }
  });
  let directives = [];
  const body = func.get("body");
  if (body.isExpression()) {
    const fallthrough = builder.reserve("block");
    const terminal = {
      kind: "return",
      loc: GeneratedSource,
      value: lowerExpressionToTemporary(builder, body),
      id: makeInstructionId(0),
    };
    builder.terminateWithContinuation(terminal, fallthrough);
  } else if (body.isBlockStatement()) {
    lowerStatement(builder, body);
    directives = body.get("directives").map((d) => d.node.value.value);
  } else {
    builder.errors.push({
      severity: ErrorSeverity.InvalidJS,
      reason: `Unexpected function body kind`,
      description: `Expected function body to be an expression or a block statement, got \`${body.type}\``,
      loc: (_b = body.node.loc) !== null && _b !== void 0 ? _b : null,
      suggestions: null,
    });
  }
  if (builder.errors.hasErrors()) {
    return Err(builder.errors);
  }
  builder.terminate(
    {
      kind: "return",
      loc: GeneratedSource,
      value: lowerValueToTemporary(builder, {
        kind: "Primitive",
        value: undefined,
        loc: GeneratedSource,
      }),
      id: makeInstructionId(0),
    },
    null
  );
  return Ok({
    id: id,
    params: params,
    fnType: parent == null ? env.fnType : "Other",
    returnType: null,
    body: builder.build(),
    context: context,
    generator: func.node.generator === true,
    async: func.node.async === true,
    loc: (_c = func.node.loc) !== null && _c !== void 0 ? _c : GeneratedSource,
    env: env,
    effects: null,
    directives: directives,
  });
}
function lowerStatement(builder, stmtPath, label = null) {
  var _a,
    _b,
    _c,
    _d,
    _e,
    _f,
    _g,
    _h,
    _j,
    _k,
    _l,
    _m,
    _o,
    _p,
    _q,
    _r,
    _s,
    _t,
    _u,
    _v,
    _w,
    _x,
    _y,
    _z,
    _0,
    _1,
    _2,
    _3,
    _4,
    _5,
    _6,
    _7,
    _8,
    _9,
    _10,
    _11,
    _12,
    _13,
    _14,
    _15,
    _16,
    _17,
    _18,
    _19,
    _20,
    _21,
    _22,
    _23,
    _24,
    _25,
    _26,
    _27,
    _28,
    _29,
    _30,
    _31,
    _32;
  const stmtNode = stmtPath.node;
  switch (stmtNode.type) {
    case "ThrowStatement": {
      const stmt = stmtPath;
      const value = lowerExpressionToTemporary(builder, stmt.get("argument"));
      const handler = builder.resolveThrowHandler();
      if (handler != null) {
        builder.errors.push({
          reason:
            "(BuildHIR::lowerStatement) Support ThrowStatement inside of try/catch",
          severity: ErrorSeverity.Todo,
          loc: (_a = stmt.node.loc) !== null && _a !== void 0 ? _a : null,
          suggestions: null,
        });
      }
      const terminal = {
        kind: "throw",
        value: value,
        id: makeInstructionId(0),
        loc:
          (_b = stmt.node.loc) !== null && _b !== void 0 ? _b : GeneratedSource,
      };
      builder.terminate(terminal, "block");
      return;
    }
    case "ReturnStatement": {
      const stmt = stmtPath;
      const argument = stmt.get("argument");
      let value;
      if (argument.node === null) {
        value = lowerValueToTemporary(builder, {
          kind: "Primitive",
          value: undefined,
          loc: GeneratedSource,
        });
      } else {
        value = lowerExpressionToTemporary(builder, argument);
      }
      const terminal = {
        kind: "return",
        loc:
          (_c = stmt.node.loc) !== null && _c !== void 0 ? _c : GeneratedSource,
        value: value,
        id: makeInstructionId(0),
      };
      builder.terminate(terminal, "block");
      return;
    }
    case "IfStatement": {
      const stmt = stmtPath;
      const continuationBlock = builder.reserve("block");
      const consequentBlock = builder.enter("block", (_blockId) => {
        var _a;
        const consequent = stmt.get("consequent");
        lowerStatement(builder, consequent);
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: GotoVariant.Break,
          id: makeInstructionId(0),
          loc:
            (_a = consequent.node.loc) !== null && _a !== void 0
              ? _a
              : GeneratedSource,
        };
      });
      let alternateBlock;
      const alternate = stmt.get("alternate");
      if (hasNode(alternate)) {
        alternateBlock = builder.enter("block", (_blockId) => {
          var _a, _b;
          lowerStatement(builder, alternate);
          return {
            kind: "goto",
            block: continuationBlock.id,
            variant: GotoVariant.Break,
            id: makeInstructionId(0),
            loc:
              (_b =
                (_a = alternate.node) === null || _a === void 0
                  ? void 0
                  : _a.loc) !== null && _b !== void 0
                ? _b
                : GeneratedSource,
          };
        });
      } else {
        alternateBlock = continuationBlock.id;
      }
      const test = lowerExpressionToTemporary(builder, stmt.get("test"));
      const terminal = {
        kind: "if",
        test: test,
        consequent: consequentBlock,
        alternate: alternateBlock,
        fallthrough: continuationBlock.id,
        id: makeInstructionId(0),
        loc:
          (_d = stmt.node.loc) !== null && _d !== void 0 ? _d : GeneratedSource,
      };
      builder.terminateWithContinuation(terminal, continuationBlock);
      return;
    }
    case "BlockStatement": {
      const stmt = stmtPath;
      const statements = stmt.get("body");
      const hoistableIdentifiers = new Set();
      for (const [, binding] of Object.entries(stmt.scope.bindings)) {
        if (binding.kind !== "param") {
          hoistableIdentifiers.add(binding.identifier);
        }
      }
      for (const s of statements) {
        const willHoist = new Set();
        let fnDepth = s.isFunctionDeclaration() ? 1 : 0;
        const withFunctionContext = {
          enter: () => {
            fnDepth++;
          },
          exit: () => {
            fnDepth--;
          },
        };
        s.traverse({
          FunctionExpression: withFunctionContext,
          FunctionDeclaration: withFunctionContext,
          ArrowFunctionExpression: withFunctionContext,
          ObjectMethod: withFunctionContext,
          Identifier(id) {
            const id2 = id;
            if (
              !id2.isReferencedIdentifier() &&
              id.parent.type !== "AssignmentExpression"
            ) {
              return;
            }
            const binding = id.scope.getBinding(id.node.name);
            if (
              binding != null &&
              hoistableIdentifiers.has(binding.identifier) &&
              (fnDepth > 0 || binding.kind === "hoisted")
            ) {
              willHoist.add(id);
            }
          },
        });
        s.traverse({
          Identifier(path) {
            if (hoistableIdentifiers.has(path.node)) {
              hoistableIdentifiers.delete(path.node);
            }
          },
        });
        for (const id of willHoist) {
          const binding = stmt.scope.getBinding(id.node.name);
          CompilerError.invariant(binding != null, {
            reason: "Expected to find binding for hoisted identifier",
            description: `Could not find a binding for ${id.node.name}`,
            suggestions: null,
            loc:
              (_e = id.node.loc) !== null && _e !== void 0
                ? _e
                : GeneratedSource,
          });
          if (builder.environment.isHoistedIdentifier(binding.identifier)) {
            continue;
          }
          if (!binding.path.isVariableDeclarator()) {
            builder.errors.push({
              severity: ErrorSeverity.Todo,
              reason: "Unsupported declaration type for hoisting",
              description: `variable "${binding.identifier.name}" declared with ${binding.path.type}`,
              suggestions: null,
              loc:
                (_f = id.parentPath.node.loc) !== null && _f !== void 0
                  ? _f
                  : GeneratedSource,
            });
            continue;
          } else if (!binding.path.get("id").isIdentifier()) {
            builder.errors.push({
              severity: ErrorSeverity.Todo,
              reason: "Unsupported variable declaration type for hoisting",
              description: `variable "${binding.identifier.name}" declared with ${binding.path.get("id").type}`,
              suggestions: null,
              loc:
                (_g = id.parentPath.node.loc) !== null && _g !== void 0
                  ? _g
                  : GeneratedSource,
            });
            continue;
          } else if (binding.kind !== "const" && binding.kind !== "var") {
            builder.errors.push({
              severity: ErrorSeverity.Todo,
              reason: "Handle non-const declarations for hoisting",
              description: `variable "${binding.identifier.name}" declared with ${binding.kind}`,
              suggestions: null,
              loc:
                (_h = id.parentPath.node.loc) !== null && _h !== void 0
                  ? _h
                  : GeneratedSource,
            });
            continue;
          }
          const identifier = builder.resolveIdentifier(id);
          CompilerError.invariant(identifier.kind === "Identifier", {
            reason:
              "Expected hoisted binding to be a local identifier, not a global",
            loc:
              (_j = id.node.loc) !== null && _j !== void 0
                ? _j
                : GeneratedSource,
          });
          const place = {
            effect: Effect.Unknown,
            identifier: identifier.identifier,
            kind: "Identifier",
            reactive: false,
            loc:
              (_k = id.node.loc) !== null && _k !== void 0
                ? _k
                : GeneratedSource,
          };
          lowerValueToTemporary(builder, {
            kind: "DeclareContext",
            lvalue: { kind: InstructionKind.HoistedConst, place: place },
            loc:
              (_l = id.node.loc) !== null && _l !== void 0
                ? _l
                : GeneratedSource,
          });
          builder.environment.addHoistedIdentifier(binding.identifier);
        }
        lowerStatement(builder, s);
      }
      return;
    }
    case "BreakStatement": {
      const stmt = stmtPath;
      const block = builder.lookupBreak(
        (_o =
          (_m = stmt.node.label) === null || _m === void 0
            ? void 0
            : _m.name) !== null && _o !== void 0
          ? _o
          : null
      );
      builder.terminate(
        {
          kind: "goto",
          block: block,
          variant: GotoVariant.Break,
          id: makeInstructionId(0),
          loc:
            (_p = stmt.node.loc) !== null && _p !== void 0
              ? _p
              : GeneratedSource,
        },
        "block"
      );
      return;
    }
    case "ContinueStatement": {
      const stmt = stmtPath;
      const block = builder.lookupContinue(
        (_r =
          (_q = stmt.node.label) === null || _q === void 0
            ? void 0
            : _q.name) !== null && _r !== void 0
          ? _r
          : null
      );
      builder.terminate(
        {
          kind: "goto",
          block: block,
          variant: GotoVariant.Continue,
          id: makeInstructionId(0),
          loc:
            (_s = stmt.node.loc) !== null && _s !== void 0
              ? _s
              : GeneratedSource,
        },
        "block"
      );
      return;
    }
    case "ForStatement": {
      const stmt = stmtPath;
      const testBlock = builder.reserve("loop");
      const continuationBlock = builder.reserve("block");
      const initBlock = builder.enter("loop", (_blockId) => {
        var _a, _b, _c, _d;
        const init = stmt.get("init");
        if (!init.isVariableDeclaration()) {
          builder.errors.push({
            reason:
              "(BuildHIR::lowerStatement) Handle non-variable initialization in ForStatement",
            severity: ErrorSeverity.Todo,
            loc: (_a = stmt.node.loc) !== null && _a !== void 0 ? _a : null,
            suggestions: null,
          });
          return {
            kind: "unsupported",
            id: makeInstructionId(0),
            loc:
              (_c =
                (_b = init.node) === null || _b === void 0
                  ? void 0
                  : _b.loc) !== null && _c !== void 0
                ? _c
                : GeneratedSource,
          };
        }
        lowerStatement(builder, init);
        return {
          kind: "goto",
          block: testBlock.id,
          variant: GotoVariant.Break,
          id: makeInstructionId(0),
          loc:
            (_d = init.node.loc) !== null && _d !== void 0
              ? _d
              : GeneratedSource,
        };
      });
      let updateBlock = null;
      const update = stmt.get("update");
      if (hasNode(update)) {
        updateBlock = builder.enter("loop", (_blockId) => {
          var _a, _b;
          lowerExpressionToTemporary(builder, update);
          return {
            kind: "goto",
            block: testBlock.id,
            variant: GotoVariant.Break,
            id: makeInstructionId(0),
            loc:
              (_b =
                (_a = update.node) === null || _a === void 0
                  ? void 0
                  : _a.loc) !== null && _b !== void 0
                ? _b
                : GeneratedSource,
          };
        });
      }
      const bodyBlock = builder.enter("block", (_blockId) =>
        builder.loop(
          label,
          updateBlock !== null && updateBlock !== void 0
            ? updateBlock
            : testBlock.id,
          continuationBlock.id,
          () => {
            var _a;
            const body = stmt.get("body");
            lowerStatement(builder, body);
            return {
              kind: "goto",
              block:
                updateBlock !== null && updateBlock !== void 0
                  ? updateBlock
                  : testBlock.id,
              variant: GotoVariant.Continue,
              id: makeInstructionId(0),
              loc:
                (_a = body.node.loc) !== null && _a !== void 0
                  ? _a
                  : GeneratedSource,
            };
          }
        )
      );
      builder.terminateWithContinuation(
        {
          kind: "for",
          loc:
            (_t = stmtNode.loc) !== null && _t !== void 0
              ? _t
              : GeneratedSource,
          init: initBlock,
          test: testBlock.id,
          update: updateBlock,
          loop: bodyBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
        },
        testBlock
      );
      const test = stmt.get("test");
      if (test.node == null) {
        builder.errors.push({
          reason: `(BuildHIR::lowerStatement) Handle empty test in ForStatement`,
          severity: ErrorSeverity.Todo,
          loc: (_u = stmt.node.loc) !== null && _u !== void 0 ? _u : null,
          suggestions: null,
        });
      } else {
        builder.terminateWithContinuation(
          {
            kind: "branch",
            test: lowerExpressionToTemporary(builder, test),
            consequent: bodyBlock,
            alternate: continuationBlock.id,
            id: makeInstructionId(0),
            loc:
              (_v = stmt.node.loc) !== null && _v !== void 0
                ? _v
                : GeneratedSource,
          },
          continuationBlock
        );
      }
      return;
    }
    case "WhileStatement": {
      const stmt = stmtPath;
      const conditionalBlock = builder.reserve("loop");
      const continuationBlock = builder.reserve("block");
      const loopBlock = builder.enter("block", (_blockId) =>
        builder.loop(label, conditionalBlock.id, continuationBlock.id, () => {
          var _a;
          const body = stmt.get("body");
          lowerStatement(builder, body);
          return {
            kind: "goto",
            block: conditionalBlock.id,
            variant: GotoVariant.Continue,
            id: makeInstructionId(0),
            loc:
              (_a = body.node.loc) !== null && _a !== void 0
                ? _a
                : GeneratedSource,
          };
        })
      );
      const loc =
        (_w = stmt.node.loc) !== null && _w !== void 0 ? _w : GeneratedSource;
      builder.terminateWithContinuation(
        {
          kind: "while",
          loc: loc,
          test: conditionalBlock.id,
          loop: loopBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
        },
        conditionalBlock
      );
      const test = lowerExpressionToTemporary(builder, stmt.get("test"));
      const terminal = {
        kind: "branch",
        test: test,
        consequent: loopBlock,
        alternate: continuationBlock.id,
        id: makeInstructionId(0),
        loc:
          (_x = stmt.node.loc) !== null && _x !== void 0 ? _x : GeneratedSource,
      };
      builder.terminateWithContinuation(terminal, continuationBlock);
      return;
    }
    case "LabeledStatement": {
      const stmt = stmtPath;
      const label = stmt.node.label.name;
      const body = stmt.get("body");
      switch (body.node.type) {
        case "ForInStatement":
        case "ForOfStatement":
        case "ForStatement":
        case "WhileStatement":
        case "DoWhileStatement": {
          lowerStatement(builder, stmt.get("body"), label);
          break;
        }
        default: {
          const continuationBlock = builder.reserve("block");
          const block = builder.enter("block", () => {
            var _a;
            const body = stmt.get("body");
            builder.label(label, continuationBlock.id, () => {
              lowerStatement(builder, body);
            });
            return {
              kind: "goto",
              block: continuationBlock.id,
              variant: GotoVariant.Break,
              id: makeInstructionId(0),
              loc:
                (_a = body.node.loc) !== null && _a !== void 0
                  ? _a
                  : GeneratedSource,
            };
          });
          builder.terminateWithContinuation(
            {
              kind: "label",
              block: block,
              fallthrough: continuationBlock.id,
              id: makeInstructionId(0),
              loc:
                (_y = stmt.node.loc) !== null && _y !== void 0
                  ? _y
                  : GeneratedSource,
            },
            continuationBlock
          );
        }
      }
      return;
    }
    case "SwitchStatement": {
      const stmt = stmtPath;
      const continuationBlock = builder.reserve("block");
      let fallthrough = continuationBlock.id;
      const cases = [];
      let hasDefault = false;
      for (let ii = stmt.get("cases").length - 1; ii >= 0; ii--) {
        const case_ = stmt.get("cases")[ii];
        const testExpr = case_.get("test");
        if (testExpr.node == null) {
          if (hasDefault) {
            builder.errors.push({
              reason: `Expected at most one \`default\` branch in a switch statement, this code should have failed to parse`,
              severity: ErrorSeverity.InvalidJS,
              loc: (_z = case_.node.loc) !== null && _z !== void 0 ? _z : null,
              suggestions: null,
            });
            break;
          }
          hasDefault = true;
        }
        const block = builder.enter("block", (_blockId) =>
          builder.switch(label, continuationBlock.id, () => {
            var _a;
            case_
              .get("consequent")
              .forEach((consequent) => lowerStatement(builder, consequent));
            return {
              kind: "goto",
              block: fallthrough,
              variant: GotoVariant.Break,
              id: makeInstructionId(0),
              loc:
                (_a = case_.node.loc) !== null && _a !== void 0
                  ? _a
                  : GeneratedSource,
            };
          })
        );
        let test = null;
        if (hasNode(testExpr)) {
          test = lowerReorderableExpression(builder, testExpr);
        }
        cases.push({ test: test, block: block });
        fallthrough = block;
      }
      cases.reverse();
      if (!hasDefault) {
        cases.push({ test: null, block: continuationBlock.id });
      }
      const test = lowerExpressionToTemporary(
        builder,
        stmt.get("discriminant")
      );
      builder.terminateWithContinuation(
        {
          kind: "switch",
          test: test,
          cases: cases,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          loc:
            (_0 = stmt.node.loc) !== null && _0 !== void 0
              ? _0
              : GeneratedSource,
        },
        continuationBlock
      );
      return;
    }
    case "VariableDeclaration": {
      const stmt = stmtPath;
      const nodeKind = stmt.node.kind;
      if (nodeKind === "var") {
        builder.errors.push({
          reason: `(BuildHIR::lowerStatement) Handle ${nodeKind} kinds in VariableDeclaration`,
          severity: ErrorSeverity.Todo,
          loc: (_1 = stmt.node.loc) !== null && _1 !== void 0 ? _1 : null,
          suggestions: null,
        });
        return;
      }
      const kind =
        nodeKind === "let" ? InstructionKind.Let : InstructionKind.Const;
      for (const declaration of stmt.get("declarations")) {
        const id = declaration.get("id");
        const init = declaration.get("init");
        if (hasNode(init)) {
          const value = lowerExpressionToTemporary(builder, init);
          lowerAssignment(
            builder,
            (_2 = stmt.node.loc) !== null && _2 !== void 0
              ? _2
              : GeneratedSource,
            kind,
            id,
            value,
            id.isObjectPattern() || id.isArrayPattern()
              ? "Destructure"
              : "Assignment"
          );
        } else if (id.isIdentifier()) {
          const binding = builder.resolveIdentifier(id);
          if (binding.kind !== "Identifier") {
            builder.errors.push({
              reason: `(BuildHIR::lowerAssignment) Could not find binding for declaration.`,
              severity: ErrorSeverity.Invariant,
              loc: (_3 = id.node.loc) !== null && _3 !== void 0 ? _3 : null,
              suggestions: null,
            });
          } else {
            const place = {
              effect: Effect.Unknown,
              identifier: binding.identifier,
              kind: "Identifier",
              reactive: false,
              loc:
                (_4 = id.node.loc) !== null && _4 !== void 0
                  ? _4
                  : GeneratedSource,
            };
            if (builder.isContextIdentifier(id)) {
              if (kind === InstructionKind.Const) {
                const declRangeStart = declaration.parentPath.node.start;
                builder.errors.push({
                  reason: `Expect \`const\` declaration not to be reassigned`,
                  severity: ErrorSeverity.InvalidJS,
                  loc: (_5 = id.node.loc) !== null && _5 !== void 0 ? _5 : null,
                  suggestions: [
                    {
                      description: "Change to a `let` declaration",
                      op: CompilerSuggestionOperation.Replace,
                      range: [declRangeStart, declRangeStart + 5],
                      text: "let",
                    },
                  ],
                });
              }
              lowerValueToTemporary(builder, {
                kind: "DeclareContext",
                lvalue: { kind: InstructionKind.Let, place: place },
                loc:
                  (_6 = id.node.loc) !== null && _6 !== void 0
                    ? _6
                    : GeneratedSource,
              });
            } else {
              const typeAnnotation = id.get("typeAnnotation");
              let type;
              if (typeAnnotation.isTSTypeAnnotation()) {
                const typePath = typeAnnotation.get("typeAnnotation");
                type = typePath.node;
              } else if (typeAnnotation.isTypeAnnotation()) {
                const typePath = typeAnnotation.get("typeAnnotation");
                type = typePath.node;
              } else {
                type = null;
              }
              lowerValueToTemporary(builder, {
                kind: "DeclareLocal",
                lvalue: { kind: kind, place: place },
                type: type,
                loc:
                  (_7 = id.node.loc) !== null && _7 !== void 0
                    ? _7
                    : GeneratedSource,
              });
            }
          }
        } else {
          builder.errors.push({
            reason: `Expected variable declaration to be an identifier if no initializer was provided`,
            description: `Got a \`${id.type}\``,
            severity: ErrorSeverity.InvalidJS,
            loc: (_8 = stmt.node.loc) !== null && _8 !== void 0 ? _8 : null,
            suggestions: null,
          });
        }
      }
      return;
    }
    case "ExpressionStatement": {
      const stmt = stmtPath;
      const expression = stmt.get("expression");
      lowerExpressionToTemporary(builder, expression);
      return;
    }
    case "DoWhileStatement": {
      const stmt = stmtPath;
      const conditionalBlock = builder.reserve("loop");
      const continuationBlock = builder.reserve("block");
      const loopBlock = builder.enter("block", (_loopBlockId) =>
        builder.loop(label, conditionalBlock.id, continuationBlock.id, () => {
          var _a;
          const body = stmt.get("body");
          lowerStatement(builder, body);
          return {
            kind: "goto",
            block: conditionalBlock.id,
            variant: GotoVariant.Continue,
            id: makeInstructionId(0),
            loc:
              (_a = body.node.loc) !== null && _a !== void 0
                ? _a
                : GeneratedSource,
          };
        })
      );
      const loc =
        (_9 = stmt.node.loc) !== null && _9 !== void 0 ? _9 : GeneratedSource;
      builder.terminateWithContinuation(
        {
          kind: "do-while",
          loc: loc,
          test: conditionalBlock.id,
          loop: loopBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
        },
        conditionalBlock
      );
      const test = lowerExpressionToTemporary(builder, stmt.get("test"));
      const terminal = {
        kind: "branch",
        test: test,
        consequent: loopBlock,
        alternate: continuationBlock.id,
        id: makeInstructionId(0),
        loc: loc,
      };
      builder.terminateWithContinuation(terminal, continuationBlock);
      return;
    }
    case "FunctionDeclaration": {
      const stmt = stmtPath;
      stmt.skip();
      CompilerError.invariant(stmt.get("id").type === "Identifier", {
        reason: "function declarations must have a name",
        description: null,
        loc: (_10 = stmt.node.loc) !== null && _10 !== void 0 ? _10 : null,
        suggestions: null,
      });
      const id = stmt.get("id");
      const fn = lowerValueToTemporary(
        builder,
        lowerFunctionToValue(builder, stmt)
      );
      lowerAssignment(
        builder,
        (_11 = stmt.node.loc) !== null && _11 !== void 0
          ? _11
          : GeneratedSource,
        InstructionKind.Let,
        id,
        fn,
        "Assignment"
      );
      return;
    }
    case "ForOfStatement": {
      const stmt = stmtPath;
      const continuationBlock = builder.reserve("block");
      const initBlock = builder.reserve("loop");
      const testBlock = builder.reserve("loop");
      if (stmt.node.await) {
        builder.errors.push({
          reason: `(BuildHIR::lowerStatement) Handle for-await loops`,
          severity: ErrorSeverity.Todo,
          loc: (_12 = stmt.node.loc) !== null && _12 !== void 0 ? _12 : null,
          suggestions: null,
        });
        return;
      }
      const loopBlock = builder.enter("block", (_blockId) =>
        builder.loop(label, initBlock.id, continuationBlock.id, () => {
          var _a;
          const body = stmt.get("body");
          lowerStatement(builder, body);
          return {
            kind: "goto",
            block: initBlock.id,
            variant: GotoVariant.Continue,
            id: makeInstructionId(0),
            loc:
              (_a = body.node.loc) !== null && _a !== void 0
                ? _a
                : GeneratedSource,
          };
        })
      );
      const loc =
        (_13 = stmt.node.loc) !== null && _13 !== void 0
          ? _13
          : GeneratedSource;
      const value = lowerExpressionToTemporary(builder, stmt.get("right"));
      builder.terminateWithContinuation(
        {
          kind: "for-of",
          loc: loc,
          init: initBlock.id,
          test: testBlock.id,
          loop: loopBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
        },
        initBlock
      );
      const iterator = lowerValueToTemporary(builder, {
        kind: "GetIterator",
        loc: value.loc,
        collection: Object.assign({}, value),
      });
      builder.terminateWithContinuation(
        {
          id: makeInstructionId(0),
          kind: "goto",
          block: testBlock.id,
          variant: GotoVariant.Break,
          loc:
            (_14 = stmt.node.loc) !== null && _14 !== void 0
              ? _14
              : GeneratedSource,
        },
        testBlock
      );
      const left = stmt.get("left");
      const leftLoc =
        (_15 = left.node.loc) !== null && _15 !== void 0
          ? _15
          : GeneratedSource;
      let test;
      if (left.isVariableDeclaration()) {
        const declarations = left.get("declarations");
        CompilerError.invariant(declarations.length === 1, {
          reason: `Expected only one declaration in the init of a ForOfStatement, got ${declarations.length}`,
          description: null,
          loc: (_16 = left.node.loc) !== null && _16 !== void 0 ? _16 : null,
          suggestions: null,
        });
        const id = declarations[0].get("id");
        const advanceIterator = lowerValueToTemporary(builder, {
          kind: "IteratorNext",
          loc: leftLoc,
          iterator: Object.assign({}, iterator),
          collection: Object.assign({}, value),
        });
        const assign = lowerAssignment(
          builder,
          leftLoc,
          InstructionKind.Let,
          id,
          advanceIterator,
          "Assignment"
        );
        test = lowerValueToTemporary(builder, assign);
      } else {
        builder.errors.push({
          reason: `(BuildHIR::lowerStatement) Handle ${left.type} inits in ForOfStatement`,
          severity: ErrorSeverity.Todo,
          loc: (_17 = left.node.loc) !== null && _17 !== void 0 ? _17 : null,
          suggestions: null,
        });
        return;
      }
      builder.terminateWithContinuation(
        {
          id: makeInstructionId(0),
          kind: "branch",
          test: test,
          consequent: loopBlock,
          alternate: continuationBlock.id,
          loc:
            (_18 = stmt.node.loc) !== null && _18 !== void 0
              ? _18
              : GeneratedSource,
        },
        continuationBlock
      );
      return;
    }
    case "ForInStatement": {
      const stmt = stmtPath;
      const continuationBlock = builder.reserve("block");
      const initBlock = builder.reserve("loop");
      const loopBlock = builder.enter("block", (_blockId) =>
        builder.loop(label, initBlock.id, continuationBlock.id, () => {
          var _a;
          const body = stmt.get("body");
          lowerStatement(builder, body);
          return {
            kind: "goto",
            block: initBlock.id,
            variant: GotoVariant.Continue,
            id: makeInstructionId(0),
            loc:
              (_a = body.node.loc) !== null && _a !== void 0
                ? _a
                : GeneratedSource,
          };
        })
      );
      const loc =
        (_19 = stmt.node.loc) !== null && _19 !== void 0
          ? _19
          : GeneratedSource;
      const value = lowerExpressionToTemporary(builder, stmt.get("right"));
      builder.terminateWithContinuation(
        {
          kind: "for-in",
          loc: loc,
          init: initBlock.id,
          loop: loopBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
        },
        initBlock
      );
      const left = stmt.get("left");
      const leftLoc =
        (_20 = left.node.loc) !== null && _20 !== void 0
          ? _20
          : GeneratedSource;
      let test;
      if (left.isVariableDeclaration()) {
        const declarations = left.get("declarations");
        CompilerError.invariant(declarations.length === 1, {
          reason: `Expected only one declaration in the init of a ForInStatement, got ${declarations.length}`,
          description: null,
          loc: (_21 = left.node.loc) !== null && _21 !== void 0 ? _21 : null,
          suggestions: null,
        });
        const id = declarations[0].get("id");
        const nextPropertyTemp = lowerValueToTemporary(builder, {
          kind: "NextPropertyOf",
          loc: leftLoc,
          value: value,
        });
        const assign = lowerAssignment(
          builder,
          leftLoc,
          InstructionKind.Let,
          id,
          nextPropertyTemp,
          "Assignment"
        );
        test = lowerValueToTemporary(builder, assign);
      } else {
        builder.errors.push({
          reason: `(BuildHIR::lowerStatement) Handle ${left.type} inits in ForInStatement`,
          severity: ErrorSeverity.Todo,
          loc: (_22 = left.node.loc) !== null && _22 !== void 0 ? _22 : null,
          suggestions: null,
        });
        return;
      }
      builder.terminateWithContinuation(
        {
          id: makeInstructionId(0),
          kind: "branch",
          test: test,
          consequent: loopBlock,
          alternate: continuationBlock.id,
          loc:
            (_23 = stmt.node.loc) !== null && _23 !== void 0
              ? _23
              : GeneratedSource,
        },
        continuationBlock
      );
      return;
    }
    case "DebuggerStatement": {
      const stmt = stmtPath;
      const loc =
        (_24 = stmt.node.loc) !== null && _24 !== void 0
          ? _24
          : GeneratedSource;
      builder.push({
        id: makeInstructionId(0),
        lvalue: buildTemporaryPlace(builder, loc),
        value: { kind: "Debugger", loc: loc },
        loc: loc,
      });
      return;
    }
    case "EmptyStatement": {
      return;
    }
    case "TryStatement": {
      const stmt = stmtPath;
      const continuationBlock = builder.reserve("block");
      const handlerPath = stmt.get("handler");
      if (!hasNode(handlerPath)) {
        builder.errors.push({
          reason: `(BuildHIR::lowerStatement) Handle TryStatement without a catch clause`,
          severity: ErrorSeverity.Todo,
          loc: (_25 = stmt.node.loc) !== null && _25 !== void 0 ? _25 : null,
          suggestions: null,
        });
        return;
      }
      if (hasNode(stmt.get("finalizer"))) {
        builder.errors.push({
          reason: `(BuildHIR::lowerStatement) Handle TryStatement with a finalizer ('finally') clause`,
          severity: ErrorSeverity.Todo,
          loc: (_26 = stmt.node.loc) !== null && _26 !== void 0 ? _26 : null,
          suggestions: null,
        });
      }
      const handlerBindingPath = handlerPath.get("param");
      let handlerBinding = null;
      if (hasNode(handlerBindingPath)) {
        const place = {
          kind: "Identifier",
          identifier: builder.makeTemporary(
            (_27 = handlerBindingPath.node.loc) !== null && _27 !== void 0
              ? _27
              : GeneratedSource
          ),
          effect: Effect.Unknown,
          reactive: false,
          loc:
            (_28 = handlerBindingPath.node.loc) !== null && _28 !== void 0
              ? _28
              : GeneratedSource,
        };
        promoteTemporary(place.identifier);
        lowerValueToTemporary(builder, {
          kind: "DeclareLocal",
          lvalue: {
            kind: InstructionKind.Catch,
            place: Object.assign({}, place),
          },
          type: null,
          loc:
            (_29 = handlerBindingPath.node.loc) !== null && _29 !== void 0
              ? _29
              : GeneratedSource,
        });
        handlerBinding = { path: handlerBindingPath, place: place };
      }
      const handler = builder.enter("catch", (_blockId) => {
        var _a, _b;
        if (handlerBinding !== null) {
          lowerAssignment(
            builder,
            (_a = handlerBinding.path.node.loc) !== null && _a !== void 0
              ? _a
              : GeneratedSource,
            InstructionKind.Catch,
            handlerBinding.path,
            Object.assign({}, handlerBinding.place),
            "Assignment"
          );
        }
        lowerStatement(builder, handlerPath.get("body"));
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: GotoVariant.Break,
          id: makeInstructionId(0),
          loc:
            (_b = handlerPath.node.loc) !== null && _b !== void 0
              ? _b
              : GeneratedSource,
        };
      });
      const block = builder.enter("block", (_blockId) => {
        var _a;
        const block = stmt.get("block");
        builder.enterTryCatch(handler, () => {
          lowerStatement(builder, block);
        });
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: GotoVariant.Try,
          id: makeInstructionId(0),
          loc:
            (_a = block.node.loc) !== null && _a !== void 0
              ? _a
              : GeneratedSource,
        };
      });
      builder.terminateWithContinuation(
        {
          kind: "try",
          block: block,
          handlerBinding:
            handlerBinding !== null
              ? Object.assign({}, handlerBinding.place)
              : null,
          handler: handler,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          loc:
            (_30 = stmt.node.loc) !== null && _30 !== void 0
              ? _30
              : GeneratedSource,
        },
        continuationBlock
      );
      return;
    }
    case "TypeAlias":
    case "TSTypeAliasDeclaration": {
      return;
    }
    case "ClassDeclaration":
    case "DeclareClass":
    case "DeclareExportAllDeclaration":
    case "DeclareExportDeclaration":
    case "DeclareFunction":
    case "DeclareInterface":
    case "DeclareModule":
    case "DeclareModuleExports":
    case "DeclareOpaqueType":
    case "DeclareTypeAlias":
    case "DeclareVariable":
    case "EnumDeclaration":
    case "ExportAllDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ImportDeclaration":
    case "InterfaceDeclaration":
    case "OpaqueType":
    case "TSDeclareFunction":
    case "TSEnumDeclaration":
    case "TSExportAssignment":
    case "TSImportEqualsDeclaration":
    case "TSInterfaceDeclaration":
    case "TSModuleDeclaration":
    case "TSNamespaceExportDeclaration":
    case "WithStatement": {
      builder.errors.push({
        reason: `(BuildHIR::lowerStatement) Handle ${stmtPath.type} statements`,
        severity: ErrorSeverity.Todo,
        loc: (_31 = stmtPath.node.loc) !== null && _31 !== void 0 ? _31 : null,
        suggestions: null,
      });
      lowerValueToTemporary(builder, {
        kind: "UnsupportedNode",
        loc:
          (_32 = stmtPath.node.loc) !== null && _32 !== void 0
            ? _32
            : GeneratedSource,
        node: stmtPath.node,
      });
      return;
    }
    default: {
      return assertExhaustive$1(
        stmtNode,
        `Unsupported statement kind '${stmtNode.type}'`
      );
    }
  }
}
function lowerObjectMethod(builder, property) {
  var _a;
  const loc =
    (_a = property.node.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
  const loweredFunc = lowerFunction(builder, property);
  if (!loweredFunc) {
    return { kind: "UnsupportedNode", node: property.node, loc: loc };
  }
  return { kind: "ObjectMethod", loc: loc, loweredFunc: loweredFunc };
}
function lowerObjectPropertyKey(builder, property) {
  var _a, _b;
  const key = property.get("key");
  if (key.isStringLiteral()) {
    return { kind: "string", name: key.node.value };
  } else if (property.node.computed && key.isExpression()) {
    if (!key.isIdentifier()) {
      builder.errors.push({
        reason: `(BuildHIR::lowerExpression) Expected Identifier, got ${key.type} key in ObjectExpression`,
        severity: ErrorSeverity.Todo,
        loc: (_a = key.node.loc) !== null && _a !== void 0 ? _a : null,
        suggestions: null,
      });
      return null;
    }
    const place = lowerExpressionToTemporary(builder, key);
    return { kind: "computed", name: place };
  } else if (key.isIdentifier()) {
    return { kind: "identifier", name: key.node.name };
  }
  builder.errors.push({
    reason: `(BuildHIR::lowerExpression) Expected Identifier, got ${key.type} key in ObjectExpression`,
    severity: ErrorSeverity.Todo,
    loc: (_b = key.node.loc) !== null && _b !== void 0 ? _b : null,
    suggestions: null,
  });
  return null;
}
function lowerExpression(builder, exprPath) {
  var _a,
    _b,
    _c,
    _d,
    _e,
    _f,
    _g,
    _h,
    _j,
    _k,
    _l,
    _m,
    _o,
    _p,
    _q,
    _r,
    _s,
    _t,
    _u,
    _v,
    _w,
    _x,
    _y,
    _z,
    _0,
    _1,
    _2,
    _3,
    _4,
    _5,
    _6,
    _7,
    _8,
    _9,
    _10,
    _11,
    _12,
    _13,
    _14,
    _15,
    _16,
    _17,
    _18,
    _19,
    _20;
  const exprNode = exprPath.node;
  const exprLoc =
    (_a = exprNode.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
  switch (exprNode.type) {
    case "Identifier": {
      const expr = exprPath;
      const place = lowerIdentifier(builder, expr);
      return { kind: getLoadKind(builder, expr), place: place, loc: exprLoc };
    }
    case "NullLiteral": {
      return { kind: "Primitive", value: null, loc: exprLoc };
    }
    case "BooleanLiteral":
    case "NumericLiteral":
    case "StringLiteral": {
      const expr = exprPath;
      const value = expr.node.value;
      return { kind: "Primitive", value: value, loc: exprLoc };
    }
    case "ObjectExpression": {
      const expr = exprPath;
      const propertyPaths = expr.get("properties");
      const properties = [];
      for (const propertyPath of propertyPaths) {
        if (propertyPath.isObjectProperty()) {
          const loweredKey = lowerObjectPropertyKey(builder, propertyPath);
          if (!loweredKey) {
            continue;
          }
          const valuePath = propertyPath.get("value");
          if (!valuePath.isExpression()) {
            builder.errors.push({
              reason: `(BuildHIR::lowerExpression) Handle ${valuePath.type} values in ObjectExpression`,
              severity: ErrorSeverity.Todo,
              loc:
                (_b = valuePath.node.loc) !== null && _b !== void 0 ? _b : null,
              suggestions: null,
            });
            continue;
          }
          const value = lowerExpressionToTemporary(builder, valuePath);
          properties.push({
            kind: "ObjectProperty",
            type: "property",
            place: value,
            key: loweredKey,
          });
        } else if (propertyPath.isSpreadElement()) {
          const place = lowerExpressionToTemporary(
            builder,
            propertyPath.get("argument")
          );
          properties.push({ kind: "Spread", place: place });
        } else if (propertyPath.isObjectMethod()) {
          if (propertyPath.node.kind !== "method") {
            builder.errors.push({
              reason: `(BuildHIR::lowerExpression) Handle ${propertyPath.node.kind} functions in ObjectExpression`,
              severity: ErrorSeverity.Todo,
              loc:
                (_c = propertyPath.node.loc) !== null && _c !== void 0
                  ? _c
                  : null,
              suggestions: null,
            });
            continue;
          }
          const method = lowerObjectMethod(builder, propertyPath);
          const place = lowerValueToTemporary(builder, method);
          const loweredKey = lowerObjectPropertyKey(builder, propertyPath);
          if (!loweredKey) {
            continue;
          }
          properties.push({
            kind: "ObjectProperty",
            type: "method",
            place: place,
            key: loweredKey,
          });
        } else {
          builder.errors.push({
            reason: `(BuildHIR::lowerExpression) Handle ${propertyPath.type} properties in ObjectExpression`,
            severity: ErrorSeverity.Todo,
            loc:
              (_d = propertyPath.node.loc) !== null && _d !== void 0
                ? _d
                : null,
            suggestions: null,
          });
          continue;
        }
      }
      return { kind: "ObjectExpression", properties: properties, loc: exprLoc };
    }
    case "ArrayExpression": {
      const expr = exprPath;
      let elements = [];
      for (const element of expr.get("elements")) {
        if (element.node == null) {
          elements.push({ kind: "Hole" });
          continue;
        } else if (element.isExpression()) {
          elements.push(lowerExpressionToTemporary(builder, element));
        } else if (element.isSpreadElement()) {
          const place = lowerExpressionToTemporary(
            builder,
            element.get("argument")
          );
          elements.push({ kind: "Spread", place: place });
        } else {
          builder.errors.push({
            reason: `(BuildHIR::lowerExpression) Handle ${element.type} elements in ArrayExpression`,
            severity: ErrorSeverity.Todo,
            loc: (_e = element.node.loc) !== null && _e !== void 0 ? _e : null,
            suggestions: null,
          });
          continue;
        }
      }
      return { kind: "ArrayExpression", elements: elements, loc: exprLoc };
    }
    case "NewExpression": {
      const expr = exprPath;
      const calleePath = expr.get("callee");
      if (!calleePath.isExpression()) {
        builder.errors.push({
          reason: `Expected an expression as the \`new\` expression receiver (v8 intrinsics are not supported)`,
          description: `Got a \`${calleePath.node.type}\``,
          severity: ErrorSeverity.InvalidJS,
          loc: (_f = calleePath.node.loc) !== null && _f !== void 0 ? _f : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      const callee = lowerExpressionToTemporary(builder, calleePath);
      const args = lowerArguments(builder, expr.get("arguments"));
      return {
        kind: "NewExpression",
        callee: callee,
        args: args,
        loc: exprLoc,
      };
    }
    case "OptionalCallExpression": {
      const expr = exprPath;
      return lowerOptionalCallExpression(builder, expr, null);
    }
    case "CallExpression": {
      const expr = exprPath;
      const calleePath = expr.get("callee");
      if (!calleePath.isExpression()) {
        builder.errors.push({
          reason: `Expected Expression, got ${calleePath.type} in CallExpression (v8 intrinsics not supported). This error is likely caused by a bug in React Compiler. Please file an issue`,
          severity: ErrorSeverity.Todo,
          loc: (_g = calleePath.node.loc) !== null && _g !== void 0 ? _g : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      if (calleePath.isMemberExpression()) {
        const memberExpr = lowerMemberExpression(builder, calleePath);
        const propertyPlace = lowerValueToTemporary(builder, memberExpr.value);
        const args = lowerArguments(builder, expr.get("arguments"));
        return {
          kind: "MethodCall",
          receiver: memberExpr.object,
          property: Object.assign({}, propertyPlace),
          args: args,
          loc: exprLoc,
        };
      } else {
        const callee = lowerExpressionToTemporary(builder, calleePath);
        const args = lowerArguments(builder, expr.get("arguments"));
        return {
          kind: "CallExpression",
          callee: callee,
          args: args,
          loc: exprLoc,
        };
      }
    }
    case "BinaryExpression": {
      const expr = exprPath;
      const leftPath = expr.get("left");
      if (!leftPath.isExpression()) {
        builder.errors.push({
          reason: `(BuildHIR::lowerExpression) Expected Expression, got ${leftPath.type} lval in BinaryExpression`,
          severity: ErrorSeverity.Todo,
          loc: (_h = leftPath.node.loc) !== null && _h !== void 0 ? _h : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      const left = lowerExpressionToTemporary(builder, leftPath);
      const right = lowerExpressionToTemporary(builder, expr.get("right"));
      const operator = expr.node.operator;
      if (operator === "|>") {
        builder.errors.push({
          reason: `(BuildHIR::lowerExpression) Pipe operator not supported`,
          severity: ErrorSeverity.Todo,
          loc: (_j = leftPath.node.loc) !== null && _j !== void 0 ? _j : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      return {
        kind: "BinaryExpression",
        operator: operator,
        left: left,
        right: right,
        loc: exprLoc,
      };
    }
    case "SequenceExpression": {
      const expr = exprPath;
      const exprLoc =
        (_k = expr.node.loc) !== null && _k !== void 0 ? _k : GeneratedSource;
      const continuationBlock = builder.reserve(builder.currentBlockKind());
      const place = buildTemporaryPlace(builder, exprLoc);
      const sequenceBlock = builder.enter("sequence", (_) => {
        var _a;
        let last = null;
        for (const item of expr.get("expressions")) {
          last = lowerExpressionToTemporary(builder, item);
        }
        if (last === null) {
          builder.errors.push({
            reason: `Expected sequence expression to have at least one expression`,
            severity: ErrorSeverity.InvalidJS,
            loc: (_a = expr.node.loc) !== null && _a !== void 0 ? _a : null,
            suggestions: null,
          });
        } else {
          lowerValueToTemporary(builder, {
            kind: "StoreLocal",
            lvalue: {
              kind: InstructionKind.Const,
              place: Object.assign({}, place),
            },
            value: last,
            type: null,
            loc: exprLoc,
          });
        }
        return {
          kind: "goto",
          id: makeInstructionId(0),
          block: continuationBlock.id,
          loc: exprLoc,
          variant: GotoVariant.Break,
        };
      });
      builder.terminateWithContinuation(
        {
          kind: "sequence",
          block: sequenceBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          loc: exprLoc,
        },
        continuationBlock
      );
      return { kind: "LoadLocal", place: place, loc: place.loc };
    }
    case "ConditionalExpression": {
      const expr = exprPath;
      const exprLoc =
        (_l = expr.node.loc) !== null && _l !== void 0 ? _l : GeneratedSource;
      const continuationBlock = builder.reserve(builder.currentBlockKind());
      const testBlock = builder.reserve("value");
      const place = buildTemporaryPlace(builder, exprLoc);
      const consequentBlock = builder.enter("value", (_blockId) => {
        var _a;
        const consequentPath = expr.get("consequent");
        const consequent = lowerExpressionToTemporary(builder, consequentPath);
        lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: {
            kind: InstructionKind.Const,
            place: Object.assign({}, place),
          },
          value: consequent,
          type: null,
          loc: exprLoc,
        });
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: GotoVariant.Break,
          id: makeInstructionId(0),
          loc:
            (_a = consequentPath.node.loc) !== null && _a !== void 0
              ? _a
              : GeneratedSource,
        };
      });
      const alternateBlock = builder.enter("value", (_blockId) => {
        var _a;
        const alternatePath = expr.get("alternate");
        const alternate = lowerExpressionToTemporary(builder, alternatePath);
        lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: {
            kind: InstructionKind.Const,
            place: Object.assign({}, place),
          },
          value: alternate,
          type: null,
          loc: exprLoc,
        });
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: GotoVariant.Break,
          id: makeInstructionId(0),
          loc:
            (_a = alternatePath.node.loc) !== null && _a !== void 0
              ? _a
              : GeneratedSource,
        };
      });
      builder.terminateWithContinuation(
        {
          kind: "ternary",
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          test: testBlock.id,
          loc: exprLoc,
        },
        testBlock
      );
      const testPlace = lowerExpressionToTemporary(builder, expr.get("test"));
      builder.terminateWithContinuation(
        {
          kind: "branch",
          test: Object.assign({}, testPlace),
          consequent: consequentBlock,
          alternate: alternateBlock,
          id: makeInstructionId(0),
          loc: exprLoc,
        },
        continuationBlock
      );
      return { kind: "LoadLocal", place: place, loc: place.loc };
    }
    case "LogicalExpression": {
      const expr = exprPath;
      const exprLoc =
        (_m = expr.node.loc) !== null && _m !== void 0 ? _m : GeneratedSource;
      const continuationBlock = builder.reserve(builder.currentBlockKind());
      const testBlock = builder.reserve("value");
      const place = buildTemporaryPlace(builder, exprLoc);
      const leftPlace = buildTemporaryPlace(
        builder,
        (_o = expr.get("left").node.loc) !== null && _o !== void 0
          ? _o
          : GeneratedSource
      );
      const consequent = builder.enter("value", () => {
        lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: {
            kind: InstructionKind.Const,
            place: Object.assign({}, place),
          },
          value: Object.assign({}, leftPlace),
          type: null,
          loc: leftPlace.loc,
        });
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: GotoVariant.Break,
          id: makeInstructionId(0),
          loc: leftPlace.loc,
        };
      });
      const alternate = builder.enter("value", () => {
        const right = lowerExpressionToTemporary(builder, expr.get("right"));
        lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: {
            kind: InstructionKind.Const,
            place: Object.assign({}, place),
          },
          value: Object.assign({}, right),
          type: null,
          loc: right.loc,
        });
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: GotoVariant.Break,
          id: makeInstructionId(0),
          loc: right.loc,
        };
      });
      builder.terminateWithContinuation(
        {
          kind: "logical",
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          test: testBlock.id,
          operator: expr.node.operator,
          loc: exprLoc,
        },
        testBlock
      );
      const leftValue = lowerExpressionToTemporary(builder, expr.get("left"));
      builder.push({
        id: makeInstructionId(0),
        lvalue: Object.assign({}, leftPlace),
        value: { kind: "LoadLocal", place: leftValue, loc: exprLoc },
        loc: exprLoc,
      });
      builder.terminateWithContinuation(
        {
          kind: "branch",
          test: Object.assign({}, leftPlace),
          consequent: consequent,
          alternate: alternate,
          id: makeInstructionId(0),
          loc: exprLoc,
        },
        continuationBlock
      );
      return { kind: "LoadLocal", place: place, loc: place.loc };
    }
    case "AssignmentExpression": {
      const expr = exprPath;
      const operator = expr.node.operator;
      if (operator === "=") {
        const left = expr.get("left");
        return lowerAssignment(
          builder,
          (_p = left.node.loc) !== null && _p !== void 0 ? _p : GeneratedSource,
          InstructionKind.Reassign,
          left,
          lowerExpressionToTemporary(builder, expr.get("right")),
          left.isArrayPattern() || left.isObjectPattern()
            ? "Destructure"
            : "Assignment"
        );
      }
      const operators = {
        "+=": "+",
        "-=": "-",
        "/=": "/",
        "%=": "%",
        "*=": "*",
        "**=": "**",
        "&=": "&",
        "|=": "|",
        ">>=": ">>",
        ">>>=": ">>>",
        "<<=": "<<",
        "^=": "^",
      };
      const binaryOperator = operators[operator];
      if (binaryOperator == null) {
        builder.errors.push({
          reason: `(BuildHIR::lowerExpression) Handle ${operator} operators in AssignmentExpression`,
          severity: ErrorSeverity.Todo,
          loc: (_q = expr.node.loc) !== null && _q !== void 0 ? _q : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      const left = expr.get("left");
      const leftNode = left.node;
      switch (leftNode.type) {
        case "Identifier": {
          const leftExpr = left;
          const identifier = lowerIdentifier(builder, leftExpr);
          const leftPlace = lowerExpressionToTemporary(builder, leftExpr);
          const right = lowerExpressionToTemporary(builder, expr.get("right"));
          const binaryPlace = lowerValueToTemporary(builder, {
            kind: "BinaryExpression",
            operator: binaryOperator,
            left: leftPlace,
            right: right,
            loc: exprLoc,
          });
          const kind = getStoreKind(builder, leftExpr);
          if (kind === "StoreLocal") {
            lowerValueToTemporary(builder, {
              kind: "StoreLocal",
              lvalue: {
                place: Object.assign({}, identifier),
                kind: InstructionKind.Reassign,
              },
              value: Object.assign({}, binaryPlace),
              type: null,
              loc: exprLoc,
            });
            return { kind: "LoadLocal", place: identifier, loc: exprLoc };
          } else {
            lowerValueToTemporary(builder, {
              kind: "StoreContext",
              lvalue: {
                place: Object.assign({}, identifier),
                kind: InstructionKind.Reassign,
              },
              value: Object.assign({}, binaryPlace),
              loc: exprLoc,
            });
            return { kind: "LoadContext", place: identifier, loc: exprLoc };
          }
        }
        case "MemberExpression": {
          const leftExpr = left;
          const {
            object: object,
            property: property,
            value: value,
          } = lowerMemberExpression(builder, leftExpr);
          const previousValuePlace = lowerValueToTemporary(builder, value);
          const newValuePlace = lowerValueToTemporary(builder, {
            kind: "BinaryExpression",
            operator: binaryOperator,
            left: Object.assign({}, previousValuePlace),
            right: lowerExpressionToTemporary(builder, expr.get("right")),
            loc:
              (_r = leftExpr.node.loc) !== null && _r !== void 0
                ? _r
                : GeneratedSource,
          });
          if (typeof property === "string") {
            return {
              kind: "PropertyStore",
              object: Object.assign({}, object),
              property: property,
              value: Object.assign({}, newValuePlace),
              loc:
                (_s = leftExpr.node.loc) !== null && _s !== void 0
                  ? _s
                  : GeneratedSource,
            };
          } else {
            return {
              kind: "ComputedStore",
              object: Object.assign({}, object),
              property: Object.assign({}, property),
              value: Object.assign({}, newValuePlace),
              loc:
                (_t = leftExpr.node.loc) !== null && _t !== void 0
                  ? _t
                  : GeneratedSource,
            };
          }
        }
        default: {
          builder.errors.push({
            reason: `(BuildHIR::lowerExpression) Expected Identifier or MemberExpression, got ${expr.type} lval in AssignmentExpression`,
            severity: ErrorSeverity.Todo,
            loc: (_u = expr.node.loc) !== null && _u !== void 0 ? _u : null,
            suggestions: null,
          });
          return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
        }
      }
    }
    case "OptionalMemberExpression": {
      const expr = exprPath;
      const { value: value } = lowerOptionalMemberExpression(
        builder,
        expr,
        null
      );
      return { kind: "LoadLocal", place: value, loc: value.loc };
    }
    case "MemberExpression": {
      const expr = exprPath;
      const { value: value } = lowerMemberExpression(builder, expr);
      const place = lowerValueToTemporary(builder, value);
      return { kind: "LoadLocal", place: place, loc: place.loc };
    }
    case "JSXElement": {
      const expr = exprPath;
      const opening = expr.get("openingElement");
      const openingLoc =
        (_v = opening.node.loc) !== null && _v !== void 0
          ? _v
          : GeneratedSource;
      const tag = lowerJsxElementName(builder, opening.get("name"));
      const props = [];
      for (const attribute of opening.get("attributes")) {
        if (attribute.isJSXSpreadAttribute()) {
          const argument = lowerExpressionToTemporary(
            builder,
            attribute.get("argument")
          );
          props.push({ kind: "JsxSpreadAttribute", argument: argument });
          continue;
        }
        if (!attribute.isJSXAttribute()) {
          builder.errors.push({
            reason: `(BuildHIR::lowerExpression) Handle ${attribute.type} attributes in JSXElement`,
            severity: ErrorSeverity.Todo,
            loc:
              (_w = attribute.node.loc) !== null && _w !== void 0 ? _w : null,
            suggestions: null,
          });
          continue;
        }
        const namePath = attribute.get("name");
        let propName;
        if (namePath.isJSXIdentifier()) {
          propName = namePath.node.name;
          if (propName.indexOf(":") !== -1) {
            builder.errors.push({
              reason: `(BuildHIR::lowerExpression) Unexpected colon in attribute name \`${name}\``,
              severity: ErrorSeverity.Todo,
              loc:
                (_x = namePath.node.loc) !== null && _x !== void 0 ? _x : null,
              suggestions: null,
            });
          }
        } else {
          CompilerError.invariant(namePath.isJSXNamespacedName(), {
            reason: "Refinement",
            description: null,
            loc: (_y = namePath.node.loc) !== null && _y !== void 0 ? _y : null,
            suggestions: null,
          });
          const namespace = namePath.node.namespace.name;
          const name = namePath.node.name.name;
          propName = `${namespace}:${name}`;
        }
        const valueExpr = attribute.get("value");
        let value;
        if (valueExpr.isJSXElement() || valueExpr.isStringLiteral()) {
          value = lowerExpressionToTemporary(builder, valueExpr);
        } else if (valueExpr.type == null) {
          value = lowerValueToTemporary(builder, {
            kind: "Primitive",
            value: true,
            loc:
              (_z = attribute.node.loc) !== null && _z !== void 0
                ? _z
                : GeneratedSource,
          });
        } else {
          if (!valueExpr.isJSXExpressionContainer()) {
            builder.errors.push({
              reason: `(BuildHIR::lowerExpression) Handle ${valueExpr.type} attribute values in JSXElement`,
              severity: ErrorSeverity.Todo,
              loc:
                (_1 =
                  (_0 = valueExpr.node) === null || _0 === void 0
                    ? void 0
                    : _0.loc) !== null && _1 !== void 0
                  ? _1
                  : null,
              suggestions: null,
            });
            continue;
          }
          const expression = valueExpr.get("expression");
          if (!expression.isExpression()) {
            builder.errors.push({
              reason: `(BuildHIR::lowerExpression) Handle ${expression.type} expressions in JSXExpressionContainer within JSXElement`,
              severity: ErrorSeverity.Todo,
              loc:
                (_2 = valueExpr.node.loc) !== null && _2 !== void 0 ? _2 : null,
              suggestions: null,
            });
            continue;
          }
          value = lowerExpressionToTemporary(builder, expression);
        }
        props.push({ kind: "JsxAttribute", name: propName, place: value });
      }
      if (
        tag.kind === "BuiltinTag" &&
        (tag.name === "fbt" || tag.name === "fbs")
      ) {
        const tagName = tag.name;
        const openingIdentifier = opening.get("name");
        const tagIdentifier = openingIdentifier.isJSXIdentifier()
          ? builder.resolveIdentifier(openingIdentifier)
          : null;
        if (tagIdentifier != null && tagIdentifier.kind === "Identifier") {
          CompilerError.throwTodo({
            reason: `Support <${tagName}> tags where '${tagName}' is a local variable instead of a global`,
            loc:
              (_3 = openingIdentifier.node.loc) !== null && _3 !== void 0
                ? _3
                : GeneratedSource,
            description: null,
            suggestions: null,
          });
        }
        const fbtEnumLocations = [];
        expr.traverse({
          JSXNamespacedName(path) {
            var _a;
            if (
              path.node.namespace.name === tagName &&
              path.node.name.name === "enum"
            ) {
              fbtEnumLocations.push(
                (_a = path.node.loc) !== null && _a !== void 0
                  ? _a
                  : GeneratedSource
              );
            }
          },
        });
        if (fbtEnumLocations.length > 1) {
          CompilerError.throwTodo({
            reason: `Support <${tagName}> tags with multiple <${tagName}:enum> values`,
            loc:
              (_4 = fbtEnumLocations.at(-1)) !== null && _4 !== void 0
                ? _4
                : GeneratedSource,
            description: null,
            suggestions: null,
          });
        }
      }
      let children;
      if (
        tag.kind === "BuiltinTag" &&
        (tag.name === "fbt" || tag.name === "fbs")
      ) {
        children = expr
          .get("children")
          .map((child) => {
            var _a;
            if (child.isJSXText()) {
              const text = child.node.value.replace(/[^\S\u00A0]+/g, " ");
              return lowerValueToTemporary(builder, {
                kind: "JSXText",
                value: text,
                loc:
                  (_a = child.node.loc) !== null && _a !== void 0
                    ? _a
                    : GeneratedSource,
              });
            }
            return lowerJsxElement(builder, child);
          })
          .filter(notNull);
      } else {
        children = expr
          .get("children")
          .map((child) => lowerJsxElement(builder, child))
          .filter(notNull);
      }
      return {
        kind: "JsxExpression",
        tag: tag,
        props: props,
        children: children.length === 0 ? null : children,
        loc: exprLoc,
        openingLoc: openingLoc,
        closingLoc:
          (_6 =
            (_5 = expr.get("closingElement").node) === null || _5 === void 0
              ? void 0
              : _5.loc) !== null && _6 !== void 0
            ? _6
            : GeneratedSource,
      };
    }
    case "JSXFragment": {
      const expr = exprPath;
      const children = expr
        .get("children")
        .map((child) => lowerJsxElement(builder, child))
        .filter(notNull);
      return { kind: "JsxFragment", children: children, loc: exprLoc };
    }
    case "ArrowFunctionExpression":
    case "FunctionExpression": {
      const expr = exprPath;
      return lowerFunctionToValue(builder, expr);
    }
    case "TaggedTemplateExpression": {
      const expr = exprPath;
      if (expr.get("quasi").get("expressions").length !== 0) {
        builder.errors.push({
          reason:
            "(BuildHIR::lowerExpression) Handle tagged template with interpolations",
          severity: ErrorSeverity.Todo,
          loc: (_7 = exprPath.node.loc) !== null && _7 !== void 0 ? _7 : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      CompilerError.invariant(expr.get("quasi").get("quasis").length == 1, {
        reason:
          "there should be only one quasi as we don't support interpolations yet",
        description: null,
        loc: (_8 = expr.node.loc) !== null && _8 !== void 0 ? _8 : null,
        suggestions: null,
      });
      const value = expr.get("quasi").get("quasis").at(0).node.value;
      if (value.raw !== value.cooked) {
        builder.errors.push({
          reason:
            "(BuildHIR::lowerExpression) Handle tagged template where cooked value is different from raw value",
          severity: ErrorSeverity.Todo,
          loc: (_9 = exprPath.node.loc) !== null && _9 !== void 0 ? _9 : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      return {
        kind: "TaggedTemplateExpression",
        tag: lowerExpressionToTemporary(builder, expr.get("tag")),
        value: value,
        loc: exprLoc,
      };
    }
    case "TemplateLiteral": {
      const expr = exprPath;
      const subexprs = expr.get("expressions");
      const quasis = expr.get("quasis");
      if (subexprs.length !== quasis.length - 1) {
        builder.errors.push({
          reason: `Unexpected quasi and subexpression lengths in template literal`,
          severity: ErrorSeverity.InvalidJS,
          loc:
            (_10 = exprPath.node.loc) !== null && _10 !== void 0 ? _10 : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      if (subexprs.some((e) => !e.isExpression())) {
        builder.errors.push({
          reason: `(BuildHIR::lowerAssignment) Handle TSType in TemplateLiteral.`,
          severity: ErrorSeverity.Todo,
          loc:
            (_11 = exprPath.node.loc) !== null && _11 !== void 0 ? _11 : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      const subexprPlaces = subexprs.map((e) =>
        lowerExpressionToTemporary(builder, e)
      );
      return {
        kind: "TemplateLiteral",
        subexprs: subexprPlaces,
        quasis: expr.get("quasis").map((q) => q.node.value),
        loc: exprLoc,
      };
    }
    case "UnaryExpression": {
      let expr = exprPath;
      if (expr.node.operator === "delete") {
        const argument = expr.get("argument");
        if (argument.isMemberExpression()) {
          const { object: object, property: property } = lowerMemberExpression(
            builder,
            argument
          );
          if (typeof property === "string") {
            return {
              kind: "PropertyDelete",
              object: object,
              property: property,
              loc: exprLoc,
            };
          } else {
            return {
              kind: "ComputedDelete",
              object: object,
              property: property,
              loc: exprLoc,
            };
          }
        } else {
          builder.errors.push({
            reason: `Only object properties can be deleted`,
            severity: ErrorSeverity.InvalidJS,
            loc: (_12 = expr.node.loc) !== null && _12 !== void 0 ? _12 : null,
            suggestions: [
              {
                description: "Remove this line",
                range: [expr.node.start, expr.node.end],
                op: CompilerSuggestionOperation.Remove,
              },
            ],
          });
          return { kind: "UnsupportedNode", node: expr.node, loc: exprLoc };
        }
      } else if (expr.node.operator === "throw") {
        builder.errors.push({
          reason: `Throw expressions are not supported`,
          severity: ErrorSeverity.InvalidJS,
          loc: (_13 = expr.node.loc) !== null && _13 !== void 0 ? _13 : null,
          suggestions: [
            {
              description: "Remove this line",
              range: [expr.node.start, expr.node.end],
              op: CompilerSuggestionOperation.Remove,
            },
          ],
        });
        return { kind: "UnsupportedNode", node: expr.node, loc: exprLoc };
      } else {
        return {
          kind: "UnaryExpression",
          operator: expr.node.operator,
          value: lowerExpressionToTemporary(builder, expr.get("argument")),
          loc: exprLoc,
        };
      }
    }
    case "AwaitExpression": {
      let expr = exprPath;
      return {
        kind: "Await",
        value: lowerExpressionToTemporary(builder, expr.get("argument")),
        loc: exprLoc,
      };
    }
    case "TypeCastExpression": {
      let expr = exprPath;
      const typeAnnotation = expr.get("typeAnnotation").get("typeAnnotation");
      return {
        kind: "TypeCastExpression",
        value: lowerExpressionToTemporary(builder, expr.get("expression")),
        typeAnnotation: typeAnnotation.node,
        type: lowerType(typeAnnotation.node),
        loc: exprLoc,
      };
    }
    case "TSAsExpression": {
      let expr = exprPath;
      const typeAnnotation = expr.get("typeAnnotation");
      return {
        kind: "TypeCastExpression",
        value: lowerExpressionToTemporary(builder, expr.get("expression")),
        typeAnnotation: typeAnnotation.node,
        type: lowerType(typeAnnotation.node),
        loc: exprLoc,
      };
    }
    case "UpdateExpression": {
      let expr = exprPath;
      const argument = expr.get("argument");
      if (!argument.isIdentifier()) {
        builder.errors.push({
          reason: `(BuildHIR::lowerExpression) Handle UpdateExpression with ${argument.type} argument`,
          severity: ErrorSeverity.Todo,
          loc:
            (_14 = exprPath.node.loc) !== null && _14 !== void 0 ? _14 : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      } else if (builder.isContextIdentifier(argument)) {
        builder.errors.push({
          reason: `(BuildHIR::lowerExpression) Handle UpdateExpression to variables captured within lambdas.`,
          severity: ErrorSeverity.Todo,
          loc:
            (_15 = exprPath.node.loc) !== null && _15 !== void 0 ? _15 : null,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      const lvalue = lowerIdentifierForAssignment(
        builder,
        (_16 = argument.node.loc) !== null && _16 !== void 0
          ? _16
          : GeneratedSource,
        InstructionKind.Reassign,
        argument
      );
      if (lvalue === null) {
        if (!builder.errors.hasErrors()) {
          builder.errors.push({
            reason: `(BuildHIR::lowerExpression) Found an invalid UpdateExpression without a previously reported error`,
            severity: ErrorSeverity.Invariant,
            loc: exprLoc,
            suggestions: null,
          });
        }
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      } else if (lvalue.kind === "Global") {
        builder.errors.push({
          reason: `(BuildHIR::lowerExpression) Support UpdateExpression where argument is a global`,
          severity: ErrorSeverity.Todo,
          loc: exprLoc,
          suggestions: null,
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      const value = lowerIdentifier(builder, argument);
      if (expr.node.prefix) {
        return {
          kind: "PrefixUpdate",
          lvalue: lvalue,
          operation: expr.node.operator,
          value: value,
          loc: exprLoc,
        };
      } else {
        return {
          kind: "PostfixUpdate",
          lvalue: lvalue,
          operation: expr.node.operator,
          value: value,
          loc: exprLoc,
        };
      }
    }
    case "RegExpLiteral": {
      let expr = exprPath;
      return {
        kind: "RegExpLiteral",
        pattern: expr.node.pattern,
        flags: expr.node.flags,
        loc:
          (_17 = expr.node.loc) !== null && _17 !== void 0
            ? _17
            : GeneratedSource,
      };
    }
    case "TSNonNullExpression": {
      let expr = exprPath;
      return lowerExpression(builder, expr.get("expression"));
    }
    case "MetaProperty": {
      let expr = exprPath;
      if (
        expr.node.meta.name === "import" &&
        expr.node.property.name === "meta"
      ) {
        return {
          kind: "MetaProperty",
          meta: expr.node.meta.name,
          property: expr.node.property.name,
          loc:
            (_18 = expr.node.loc) !== null && _18 !== void 0
              ? _18
              : GeneratedSource,
        };
      }
      builder.errors.push({
        reason: `(BuildHIR::lowerExpression) Handle MetaProperty expressions other than import.meta`,
        severity: ErrorSeverity.Todo,
        loc: (_19 = exprPath.node.loc) !== null && _19 !== void 0 ? _19 : null,
        suggestions: null,
      });
      return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
    }
    default: {
      builder.errors.push({
        reason: `(BuildHIR::lowerExpression) Handle ${exprPath.type} expressions`,
        severity: ErrorSeverity.Todo,
        loc: (_20 = exprPath.node.loc) !== null && _20 !== void 0 ? _20 : null,
        suggestions: null,
      });
      return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
    }
  }
}
function lowerOptionalMemberExpression(builder, expr, parentAlternate) {
  var _a;
  const optional = expr.node.optional;
  const loc =
    (_a = expr.node.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
  const place = buildTemporaryPlace(builder, loc);
  const continuationBlock = builder.reserve(builder.currentBlockKind());
  const consequent = builder.reserve("value");
  const alternate =
    parentAlternate !== null
      ? parentAlternate
      : builder.enter("value", () => {
          const temp = lowerValueToTemporary(builder, {
            kind: "Primitive",
            value: undefined,
            loc: loc,
          });
          lowerValueToTemporary(builder, {
            kind: "StoreLocal",
            lvalue: {
              kind: InstructionKind.Const,
              place: Object.assign({}, place),
            },
            value: Object.assign({}, temp),
            type: null,
            loc: loc,
          });
          return {
            kind: "goto",
            variant: GotoVariant.Break,
            block: continuationBlock.id,
            id: makeInstructionId(0),
            loc: loc,
          };
        });
  let object = null;
  const testBlock = builder.enter("value", () => {
    const objectPath = expr.get("object");
    if (objectPath.isOptionalMemberExpression()) {
      const { value: value } = lowerOptionalMemberExpression(
        builder,
        objectPath,
        alternate
      );
      object = value;
    } else if (objectPath.isOptionalCallExpression()) {
      const value = lowerOptionalCallExpression(builder, objectPath, alternate);
      object = lowerValueToTemporary(builder, value);
    } else {
      object = lowerExpressionToTemporary(builder, objectPath);
    }
    return {
      kind: "branch",
      test: Object.assign({}, object),
      consequent: consequent.id,
      alternate: alternate,
      id: makeInstructionId(0),
      loc: loc,
    };
  });
  CompilerError.invariant(object !== null, {
    reason: "Satisfy type checker",
    description: null,
    loc: null,
    suggestions: null,
  });
  builder.enterReserved(consequent, () => {
    const { value: value } = lowerMemberExpression(builder, expr, object);
    const temp = lowerValueToTemporary(builder, value);
    lowerValueToTemporary(builder, {
      kind: "StoreLocal",
      lvalue: { kind: InstructionKind.Const, place: Object.assign({}, place) },
      value: Object.assign({}, temp),
      type: null,
      loc: loc,
    });
    return {
      kind: "goto",
      variant: GotoVariant.Break,
      block: continuationBlock.id,
      id: makeInstructionId(0),
      loc: loc,
    };
  });
  builder.terminateWithContinuation(
    {
      kind: "optional",
      optional: optional,
      test: testBlock,
      fallthrough: continuationBlock.id,
      id: makeInstructionId(0),
      loc: loc,
    },
    continuationBlock
  );
  return { object: object, value: place };
}
function lowerOptionalCallExpression(builder, expr, parentAlternate) {
  var _a;
  const optional = expr.node.optional;
  const calleePath = expr.get("callee");
  const loc =
    (_a = expr.node.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
  const place = buildTemporaryPlace(builder, loc);
  const continuationBlock = builder.reserve(builder.currentBlockKind());
  const consequent = builder.reserve("value");
  const alternate =
    parentAlternate !== null
      ? parentAlternate
      : builder.enter("value", () => {
          const temp = lowerValueToTemporary(builder, {
            kind: "Primitive",
            value: undefined,
            loc: loc,
          });
          lowerValueToTemporary(builder, {
            kind: "StoreLocal",
            lvalue: {
              kind: InstructionKind.Const,
              place: Object.assign({}, place),
            },
            value: Object.assign({}, temp),
            type: null,
            loc: loc,
          });
          return {
            kind: "goto",
            variant: GotoVariant.Break,
            block: continuationBlock.id,
            id: makeInstructionId(0),
            loc: loc,
          };
        });
  let callee;
  const testBlock = builder.enter("value", () => {
    if (calleePath.isOptionalCallExpression()) {
      const value = lowerOptionalCallExpression(builder, calleePath, alternate);
      const valuePlace = lowerValueToTemporary(builder, value);
      callee = { kind: "CallExpression", callee: valuePlace };
    } else if (calleePath.isOptionalMemberExpression()) {
      const { object: object, value: value } = lowerOptionalMemberExpression(
        builder,
        calleePath,
        alternate
      );
      callee = { kind: "MethodCall", receiver: object, property: value };
    } else if (calleePath.isMemberExpression()) {
      const memberExpr = lowerMemberExpression(builder, calleePath);
      const propertyPlace = lowerValueToTemporary(builder, memberExpr.value);
      callee = {
        kind: "MethodCall",
        receiver: memberExpr.object,
        property: propertyPlace,
      };
    } else {
      callee = {
        kind: "CallExpression",
        callee: lowerExpressionToTemporary(builder, calleePath),
      };
    }
    const testPlace =
      callee.kind === "CallExpression" ? callee.callee : callee.property;
    return {
      kind: "branch",
      test: Object.assign({}, testPlace),
      consequent: consequent.id,
      alternate: alternate,
      id: makeInstructionId(0),
      loc: loc,
    };
  });
  builder.enterReserved(consequent, () => {
    const args = lowerArguments(builder, expr.get("arguments"));
    const temp = buildTemporaryPlace(builder, loc);
    if (callee.kind === "CallExpression") {
      builder.push({
        id: makeInstructionId(0),
        lvalue: Object.assign({}, temp),
        value: {
          kind: "CallExpression",
          callee: Object.assign({}, callee.callee),
          args: args,
          loc: loc,
        },
        loc: loc,
      });
    } else {
      builder.push({
        id: makeInstructionId(0),
        lvalue: Object.assign({}, temp),
        value: {
          kind: "MethodCall",
          receiver: Object.assign({}, callee.receiver),
          property: Object.assign({}, callee.property),
          args: args,
          loc: loc,
        },
        loc: loc,
      });
    }
    lowerValueToTemporary(builder, {
      kind: "StoreLocal",
      lvalue: { kind: InstructionKind.Const, place: Object.assign({}, place) },
      value: Object.assign({}, temp),
      type: null,
      loc: loc,
    });
    return {
      kind: "goto",
      variant: GotoVariant.Break,
      block: continuationBlock.id,
      id: makeInstructionId(0),
      loc: loc,
    };
  });
  builder.terminateWithContinuation(
    {
      kind: "optional",
      optional: optional,
      test: testBlock,
      fallthrough: continuationBlock.id,
      id: makeInstructionId(0),
      loc: loc,
    },
    continuationBlock
  );
  return { kind: "LoadLocal", place: place, loc: place.loc };
}
function lowerReorderableExpression(builder, expr) {
  var _a;
  if (!isReorderableExpression(builder, expr, true)) {
    builder.errors.push({
      reason: `(BuildHIR::node.lowerReorderableExpression) Expression type \`${expr.type}\` cannot be safely reordered`,
      severity: ErrorSeverity.Todo,
      loc: (_a = expr.node.loc) !== null && _a !== void 0 ? _a : null,
      suggestions: null,
    });
  }
  return lowerExpressionToTemporary(builder, expr);
}
function isReorderableExpression(builder, expr, allowLocalIdentifiers) {
  switch (expr.node.type) {
    case "Identifier": {
      const binding = builder.resolveIdentifier(expr);
      if (binding.kind === "Identifier") {
        return allowLocalIdentifiers;
      } else {
        return true;
      }
    }
    case "RegExpLiteral":
    case "StringLiteral":
    case "NumericLiteral":
    case "NullLiteral":
    case "BooleanLiteral":
    case "BigIntLiteral": {
      return true;
    }
    case "UnaryExpression": {
      const unary = expr;
      switch (expr.node.operator) {
        case "!":
        case "+":
        case "-": {
          return isReorderableExpression(
            builder,
            unary.get("argument"),
            allowLocalIdentifiers
          );
        }
        default: {
          return false;
        }
      }
    }
    case "TypeCastExpression": {
      return isReorderableExpression(
        builder,
        expr.get("expression"),
        allowLocalIdentifiers
      );
    }
    case "ConditionalExpression": {
      const conditional = expr;
      return (
        isReorderableExpression(
          builder,
          conditional.get("test"),
          allowLocalIdentifiers
        ) &&
        isReorderableExpression(
          builder,
          conditional.get("consequent"),
          allowLocalIdentifiers
        ) &&
        isReorderableExpression(
          builder,
          conditional.get("alternate"),
          allowLocalIdentifiers
        )
      );
    }
    case "ArrayExpression": {
      return expr
        .get("elements")
        .every(
          (element) =>
            element.isExpression() &&
            isReorderableExpression(builder, element, allowLocalIdentifiers)
        );
    }
    case "ObjectExpression": {
      return expr.get("properties").every((property) => {
        if (!property.isObjectProperty() || property.node.computed) {
          return false;
        }
        const value = property.get("value");
        return (
          value.isExpression() &&
          isReorderableExpression(builder, value, allowLocalIdentifiers)
        );
      });
    }
    case "MemberExpression": {
      const test = expr;
      let innerObject = test;
      while (innerObject.isMemberExpression()) {
        innerObject = innerObject.get("object");
      }
      if (
        innerObject.isIdentifier() &&
        builder.resolveIdentifier(innerObject).kind !== "Identifier"
      ) {
        return true;
      } else {
        return false;
      }
    }
    case "ArrowFunctionExpression": {
      const fn = expr;
      const body = fn.get("body");
      if (body.node.type === "BlockStatement") {
        return body.node.body.length === 0;
      } else {
        invariant$1(body.isExpression(), "Expected an expression");
        return isReorderableExpression(builder, body, false);
      }
    }
    case "CallExpression": {
      const call = expr;
      const callee = call.get("callee");
      return (
        callee.isExpression() &&
        isReorderableExpression(builder, callee, allowLocalIdentifiers) &&
        call
          .get("arguments")
          .every(
            (arg) =>
              arg.isExpression() &&
              isReorderableExpression(builder, arg, allowLocalIdentifiers)
          )
      );
    }
    default: {
      return false;
    }
  }
}
function lowerArguments(builder, expr) {
  var _a;
  let args = [];
  for (const argPath of expr) {
    if (argPath.isSpreadElement()) {
      args.push({
        kind: "Spread",
        place: lowerExpressionToTemporary(builder, argPath.get("argument")),
      });
    } else if (argPath.isExpression()) {
      args.push(lowerExpressionToTemporary(builder, argPath));
    } else {
      builder.errors.push({
        reason: `(BuildHIR::lowerExpression) Handle ${argPath.type} arguments in CallExpression`,
        severity: ErrorSeverity.Todo,
        loc: (_a = argPath.node.loc) !== null && _a !== void 0 ? _a : null,
        suggestions: null,
      });
    }
  }
  return args;
}
function lowerMemberExpression(builder, expr, loweredObject = null) {
  var _a, _b, _c;
  const exprNode = expr.node;
  const exprLoc =
    (_a = exprNode.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
  const objectNode = expr.get("object");
  const propertyNode = expr.get("property");
  const object =
    loweredObject !== null && loweredObject !== void 0
      ? loweredObject
      : lowerExpressionToTemporary(builder, objectNode);
  if (!expr.node.computed) {
    if (!propertyNode.isIdentifier()) {
      builder.errors.push({
        reason: `(BuildHIR::lowerMemberExpression) Handle ${propertyNode.type} property`,
        severity: ErrorSeverity.Todo,
        loc: (_b = propertyNode.node.loc) !== null && _b !== void 0 ? _b : null,
        suggestions: null,
      });
      return {
        object: object,
        property: propertyNode.toString(),
        value: { kind: "UnsupportedNode", node: exprNode, loc: exprLoc },
      };
    }
    const value = {
      kind: "PropertyLoad",
      object: Object.assign({}, object),
      property: propertyNode.node.name,
      loc: exprLoc,
    };
    return { object: object, property: propertyNode.node.name, value: value };
  } else {
    if (!propertyNode.isExpression()) {
      builder.errors.push({
        reason: `(BuildHIR::lowerMemberExpression) Expected Expression, got ${propertyNode.type} property`,
        severity: ErrorSeverity.Todo,
        loc: (_c = propertyNode.node.loc) !== null && _c !== void 0 ? _c : null,
        suggestions: null,
      });
      return {
        object: object,
        property: propertyNode.toString(),
        value: { kind: "UnsupportedNode", node: exprNode, loc: exprLoc },
      };
    }
    const property = lowerExpressionToTemporary(builder, propertyNode);
    const value = {
      kind: "ComputedLoad",
      object: Object.assign({}, object),
      property: Object.assign({}, property),
      loc: exprLoc,
    };
    return { object: object, property: property, value: value };
  }
}
function lowerJsxElementName(builder, exprPath) {
  var _a, _b, _c;
  const exprNode = exprPath.node;
  const exprLoc =
    (_a = exprNode.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
  if (exprPath.isJSXIdentifier()) {
    const tag = exprPath.node.name;
    if (tag.match(/^[A-Z]/)) {
      const kind = getLoadKind(builder, exprPath);
      return lowerValueToTemporary(builder, {
        kind: kind,
        place: lowerIdentifier(builder, exprPath),
        loc: exprLoc,
      });
    } else {
      return { kind: "BuiltinTag", name: tag, loc: exprLoc };
    }
  } else if (exprPath.isJSXMemberExpression()) {
    return lowerJsxMemberExpression(builder, exprPath);
  } else if (exprPath.isJSXNamespacedName()) {
    const namespace = exprPath.node.namespace.name;
    const name = exprPath.node.name.name;
    const tag = `${namespace}:${name}`;
    if (namespace.indexOf(":") !== -1 || name.indexOf(":") !== -1) {
      builder.errors.push({
        reason: `Expected JSXNamespacedName to have no colons in the namespace or name`,
        description: `Got \`${namespace}\` : \`${name}\``,
        severity: ErrorSeverity.InvalidJS,
        loc: (_b = exprPath.node.loc) !== null && _b !== void 0 ? _b : null,
        suggestions: null,
      });
    }
    const place = lowerValueToTemporary(builder, {
      kind: "Primitive",
      value: tag,
      loc: exprLoc,
    });
    return place;
  } else {
    builder.errors.push({
      reason: `(BuildHIR::lowerJsxElementName) Handle ${exprPath.type} tags`,
      severity: ErrorSeverity.Todo,
      loc: (_c = exprPath.node.loc) !== null && _c !== void 0 ? _c : null,
      suggestions: null,
    });
    return lowerValueToTemporary(builder, {
      kind: "UnsupportedNode",
      node: exprNode,
      loc: exprLoc,
    });
  }
}
function lowerJsxMemberExpression(builder, exprPath) {
  var _a, _b;
  const loc =
    (_a = exprPath.node.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
  const object = exprPath.get("object");
  let objectPlace;
  if (object.isJSXMemberExpression()) {
    objectPlace = lowerJsxMemberExpression(builder, object);
  } else {
    CompilerError.invariant(object.isJSXIdentifier(), {
      reason: `TypeScript refinement fail: expected 'JsxIdentifier', got \`${object.node.type}\``,
      description: null,
      loc: (_b = object.node.loc) !== null && _b !== void 0 ? _b : null,
      suggestions: null,
    });
    objectPlace = lowerIdentifier(builder, object);
  }
  const property = exprPath.get("property").node.name;
  return lowerValueToTemporary(builder, {
    kind: "PropertyLoad",
    object: objectPlace,
    property: property,
    loc: loc,
  });
}
function lowerJsxElement(builder, exprPath) {
  var _a, _b, _c;
  const exprNode = exprPath.node;
  const exprLoc =
    (_a = exprNode.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
  if (exprPath.isJSXElement() || exprPath.isJSXFragment()) {
    return lowerExpressionToTemporary(builder, exprPath);
  } else if (exprPath.isJSXExpressionContainer()) {
    const expression = exprPath.get("expression");
    if (expression.isJSXEmptyExpression()) {
      return null;
    } else {
      CompilerError.invariant(expression.isExpression(), {
        reason: `(BuildHIR::lowerJsxElement) Expected Expression but found ${expression.type}!`,
        description: null,
        loc: (_b = expression.node.loc) !== null && _b !== void 0 ? _b : null,
        suggestions: null,
      });
      return lowerExpressionToTemporary(builder, expression);
    }
  } else if (exprPath.isJSXText()) {
    const text = trimJsxText(exprPath.node.value);
    if (text === null) {
      return null;
    }
    const place = lowerValueToTemporary(builder, {
      kind: "JSXText",
      value: text,
      loc: exprLoc,
    });
    return place;
  } else {
    builder.errors.push({
      reason: `(BuildHIR::lowerJsxElement) Unhandled JsxElement, got: ${exprPath.type}`,
      severity: ErrorSeverity.Todo,
      loc: (_c = exprPath.node.loc) !== null && _c !== void 0 ? _c : null,
      suggestions: null,
    });
    const place = lowerValueToTemporary(builder, {
      kind: "UnsupportedNode",
      node: exprNode,
      loc: exprLoc,
    });
    return place;
  }
}
function trimJsxText(original) {
  const lines = original.split(/\r\n|\n|\r/);
  let lastNonEmptyLine = 0;
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].match(/[^ \t]/)) {
      lastNonEmptyLine = i;
    }
  }
  let str = "";
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const isFirstLine = i === 0;
    const isLastLine = i === lines.length - 1;
    const isLastNonEmptyLine = i === lastNonEmptyLine;
    let trimmedLine = line.replace(/\t/g, " ");
    if (!isFirstLine) {
      trimmedLine = trimmedLine.replace(/^[ ]+/, "");
    }
    if (!isLastLine) {
      trimmedLine = trimmedLine.replace(/[ ]+$/, "");
    }
    if (trimmedLine) {
      if (!isLastNonEmptyLine) {
        trimmedLine += " ";
      }
      str += trimmedLine;
    }
  }
  if (str.length !== 0) {
    return str;
  } else {
    return null;
  }
}
function lowerFunctionToValue(builder, expr) {
  var _a, _b, _c, _d;
  const exprNode = expr.node;
  const exprLoc =
    (_a = exprNode.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
  let name = null;
  if (expr.isFunctionExpression()) {
    name =
      (_d =
        (_c =
          (_b = expr.get("id")) === null || _b === void 0
            ? void 0
            : _b.node) === null || _c === void 0
          ? void 0
          : _c.name) !== null && _d !== void 0
        ? _d
        : null;
  }
  const loweredFunc = lowerFunction(builder, expr);
  if (!loweredFunc) {
    return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
  }
  return {
    kind: "FunctionExpression",
    name: name,
    expr: expr.node,
    loc: exprLoc,
    loweredFunc: loweredFunc,
  };
}
function lowerFunction(builder, expr) {
  const componentScope = builder.parentFunction.scope;
  const captured = gatherCapturedDeps(builder, expr, componentScope);
  const lowering = lower$1(
    expr,
    builder.environment,
    builder.bindings,
    [...builder.context, ...captured.identifiers],
    builder.parentFunction
  );
  let loweredFunc;
  if (lowering.isErr()) {
    lowering
      .unwrapErr()
      .details.forEach((detail) => builder.errors.pushErrorDetail(detail));
    return null;
  }
  loweredFunc = lowering.unwrap();
  return { func: loweredFunc, dependencies: captured.refs };
}
function lowerExpressionToTemporary(builder, exprPath) {
  const value = lowerExpression(builder, exprPath);
  return lowerValueToTemporary(builder, value);
}
function lowerValueToTemporary(builder, value) {
  if (value.kind === "LoadLocal" && value.place.identifier.name === null) {
    return value.place;
  }
  const place = buildTemporaryPlace(builder, value.loc);
  builder.push({
    id: makeInstructionId(0),
    value: value,
    loc: value.loc,
    lvalue: Object.assign({}, place),
  });
  return place;
}
function lowerIdentifier(builder, exprPath) {
  var _a;
  const exprNode = exprPath.node;
  const exprLoc =
    (_a = exprNode.loc) !== null && _a !== void 0 ? _a : GeneratedSource;
  const binding = builder.resolveIdentifier(exprPath);
  switch (binding.kind) {
    case "Identifier": {
      const place = {
        kind: "Identifier",
        identifier: binding.identifier,
        effect: Effect.Unknown,
        reactive: false,
        loc: exprLoc,
      };
      return place;
    }
    default: {
      return lowerValueToTemporary(builder, {
        kind: "LoadGlobal",
        binding: binding,
        loc: exprLoc,
      });
    }
  }
}
function buildTemporaryPlace(builder, loc) {
  const place = {
    kind: "Identifier",
    identifier: builder.makeTemporary(loc),
    effect: Effect.Unknown,
    reactive: false,
    loc: loc,
  };
  return place;
}
function getStoreKind(builder, identifier) {
  const isContext = builder.isContextIdentifier(identifier);
  return isContext ? "StoreContext" : "StoreLocal";
}
function getLoadKind(builder, identifier) {
  const isContext = builder.isContextIdentifier(identifier);
  return isContext ? "LoadContext" : "LoadLocal";
}
function lowerIdentifierForAssignment(builder, loc, kind, path) {
  var _a, _b;
  const binding = builder.resolveIdentifier(path);
  if (binding.kind !== "Identifier") {
    if (kind === InstructionKind.Reassign) {
      return { kind: "Global", name: path.node.name };
    } else {
      builder.errors.push({
        reason: `(BuildHIR::lowerAssignment) Could not find binding for declaration.`,
        severity: ErrorSeverity.Invariant,
        loc: (_a = path.node.loc) !== null && _a !== void 0 ? _a : null,
        suggestions: null,
      });
      return null;
    }
  } else if (
    binding.bindingKind === "const" &&
    kind === InstructionKind.Reassign
  ) {
    builder.errors.push({
      reason: `Cannot reassign a \`const\` variable`,
      severity: ErrorSeverity.InvalidJS,
      loc: (_b = path.node.loc) !== null && _b !== void 0 ? _b : null,
      description:
        binding.identifier.name != null
          ? `\`${binding.identifier.name.value}\` is declared as const`
          : null,
    });
    return null;
  }
  const place = {
    kind: "Identifier",
    identifier: binding.identifier,
    effect: Effect.Unknown,
    reactive: false,
    loc: loc,
  };
  return place;
}
function lowerAssignment(
  builder,
  loc,
  kind,
  lvaluePath,
  value,
  assignmentKind
) {
  var _a,
    _b,
    _c,
    _d,
    _e,
    _f,
    _g,
    _h,
    _j,
    _k,
    _l,
    _m,
    _o,
    _p,
    _q,
    _r,
    _s,
    _t,
    _u,
    _v,
    _w,
    _x,
    _y,
    _z,
    _0;
  const lvalueNode = lvaluePath.node;
  switch (lvalueNode.type) {
    case "Identifier": {
      const lvalue = lvaluePath;
      const place = lowerIdentifierForAssignment(builder, loc, kind, lvalue);
      if (place === null) {
        return {
          kind: "UnsupportedNode",
          loc:
            (_a = lvalue.node.loc) !== null && _a !== void 0
              ? _a
              : GeneratedSource,
          node: lvalue.node,
        };
      } else if (place.kind === "Global") {
        const temporary = lowerValueToTemporary(builder, {
          kind: "StoreGlobal",
          name: place.name,
          value: value,
          loc: loc,
        });
        return { kind: "LoadLocal", place: temporary, loc: temporary.loc };
      }
      const isHoistedIdentifier = builder.environment.isHoistedIdentifier(
        lvalue.node
      );
      let temporary;
      if (builder.isContextIdentifier(lvalue)) {
        if (kind !== InstructionKind.Reassign && !isHoistedIdentifier) {
          if (kind === InstructionKind.Const) {
            builder.errors.push({
              reason: `Expected \`const\` declaration not to be reassigned`,
              severity: ErrorSeverity.InvalidJS,
              loc: (_b = lvalue.node.loc) !== null && _b !== void 0 ? _b : null,
              suggestions: null,
            });
          }
          lowerValueToTemporary(builder, {
            kind: "DeclareContext",
            lvalue: {
              kind: InstructionKind.Let,
              place: Object.assign({}, place),
            },
            loc: place.loc,
          });
        }
        temporary = lowerValueToTemporary(builder, {
          kind: "StoreContext",
          lvalue: {
            place: Object.assign({}, place),
            kind: InstructionKind.Reassign,
          },
          value: value,
          loc: loc,
        });
      } else {
        const typeAnnotation = lvalue.get("typeAnnotation");
        let type;
        if (typeAnnotation.isTSTypeAnnotation()) {
          const typePath = typeAnnotation.get("typeAnnotation");
          type = typePath.node;
        } else if (typeAnnotation.isTypeAnnotation()) {
          const typePath = typeAnnotation.get("typeAnnotation");
          type = typePath.node;
        } else {
          type = null;
        }
        temporary = lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: { place: Object.assign({}, place), kind: kind },
          value: value,
          type: type,
          loc: loc,
        });
      }
      return { kind: "LoadLocal", place: temporary, loc: temporary.loc };
    }
    case "MemberExpression": {
      CompilerError.invariant(kind === InstructionKind.Reassign, {
        reason: "MemberExpression may only appear in an assignment expression",
        description: null,
        loc: (_c = lvaluePath.node.loc) !== null && _c !== void 0 ? _c : null,
        suggestions: null,
      });
      const lvalue = lvaluePath;
      const property = lvalue.get("property");
      const object = lowerExpressionToTemporary(builder, lvalue.get("object"));
      if (!lvalue.node.computed) {
        if (!property.isIdentifier()) {
          builder.errors.push({
            reason: `(BuildHIR::lowerAssignment) Handle ${property.type} properties in MemberExpression`,
            severity: ErrorSeverity.Todo,
            loc: (_d = property.node.loc) !== null && _d !== void 0 ? _d : null,
            suggestions: null,
          });
          return { kind: "UnsupportedNode", node: lvalueNode, loc: loc };
        }
        const temporary = lowerValueToTemporary(builder, {
          kind: "PropertyStore",
          object: object,
          property: property.node.name,
          value: value,
          loc: loc,
        });
        return { kind: "LoadLocal", place: temporary, loc: temporary.loc };
      } else {
        if (!property.isExpression()) {
          builder.errors.push({
            reason:
              "(BuildHIR::lowerAssignment) Expected private name to appear as a non-computed property",
            severity: ErrorSeverity.Todo,
            loc: (_e = property.node.loc) !== null && _e !== void 0 ? _e : null,
            suggestions: null,
          });
          return { kind: "UnsupportedNode", node: lvalueNode, loc: loc };
        }
        const propertyPlace = lowerExpressionToTemporary(builder, property);
        const temporary = lowerValueToTemporary(builder, {
          kind: "ComputedStore",
          object: object,
          property: propertyPlace,
          value: value,
          loc: loc,
        });
        return { kind: "LoadLocal", place: temporary, loc: temporary.loc };
      }
    }
    case "ArrayPattern": {
      const lvalue = lvaluePath;
      const elements = lvalue.get("elements");
      const items = [];
      const followups = [];
      const forceTemporaries =
        kind === InstructionKind.Reassign &&
        (elements.some((element) => !element.isIdentifier()) ||
          elements.some(
            (element) =>
              element.isIdentifier() &&
              (getStoreKind(builder, element) !== "StoreLocal" ||
                builder.resolveIdentifier(element).kind !== "Identifier")
          ));
      for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        if (element.node == null) {
          items.push({ kind: "Hole" });
          continue;
        }
        if (element.isRestElement()) {
          const argument = element.get("argument");
          if (
            argument.isIdentifier() &&
            !forceTemporaries &&
            (assignmentKind === "Assignment" ||
              getStoreKind(builder, argument) === "StoreLocal")
          ) {
            const identifier = lowerIdentifierForAssignment(
              builder,
              (_f = element.node.loc) !== null && _f !== void 0
                ? _f
                : GeneratedSource,
              kind,
              argument
            );
            if (identifier === null) {
              continue;
            } else if (identifier.kind === "Global") {
              builder.errors.push({
                severity: ErrorSeverity.Todo,
                reason:
                  "Expected reassignment of globals to enable forceTemporaries",
                loc:
                  (_g = element.node.loc) !== null && _g !== void 0
                    ? _g
                    : GeneratedSource,
              });
              continue;
            }
            items.push({ kind: "Spread", place: identifier });
          } else {
            const temp = buildTemporaryPlace(
              builder,
              (_h = element.node.loc) !== null && _h !== void 0
                ? _h
                : GeneratedSource
            );
            promoteTemporary(temp.identifier);
            items.push({ kind: "Spread", place: Object.assign({}, temp) });
            followups.push({ place: temp, path: argument });
          }
        } else if (
          element.isIdentifier() &&
          !forceTemporaries &&
          (assignmentKind === "Assignment" ||
            getStoreKind(builder, element) === "StoreLocal")
        ) {
          const identifier = lowerIdentifierForAssignment(
            builder,
            (_j = element.node.loc) !== null && _j !== void 0
              ? _j
              : GeneratedSource,
            kind,
            element
          );
          if (identifier === null) {
            continue;
          } else if (identifier.kind === "Global") {
            builder.errors.push({
              severity: ErrorSeverity.Todo,
              reason:
                "Expected reassignment of globals to enable forceTemporaries",
              loc:
                (_k = element.node.loc) !== null && _k !== void 0
                  ? _k
                  : GeneratedSource,
            });
            continue;
          }
          items.push(identifier);
        } else {
          const temp = buildTemporaryPlace(
            builder,
            (_l = element.node.loc) !== null && _l !== void 0
              ? _l
              : GeneratedSource
          );
          promoteTemporary(temp.identifier);
          items.push(Object.assign({}, temp));
          followups.push({ place: temp, path: element });
        }
      }
      const temporary = lowerValueToTemporary(builder, {
        kind: "Destructure",
        lvalue: { kind: kind, pattern: { kind: "ArrayPattern", items: items } },
        value: value,
        loc: loc,
      });
      for (const { place: place, path: path } of followups) {
        lowerAssignment(
          builder,
          (_m = path.node.loc) !== null && _m !== void 0 ? _m : loc,
          kind,
          path,
          place,
          assignmentKind
        );
      }
      return { kind: "LoadLocal", place: temporary, loc: value.loc };
    }
    case "ObjectPattern": {
      const lvalue = lvaluePath;
      const propertiesPaths = lvalue.get("properties");
      const properties = [];
      const followups = [];
      const forceTemporaries =
        kind === InstructionKind.Reassign &&
        propertiesPaths.some(
          (property) =>
            property.isRestElement() ||
            (property.isObjectProperty() &&
              (!property.get("value").isIdentifier() ||
                builder.resolveIdentifier(property.get("value")).kind !==
                  "Identifier"))
        );
      for (let i = 0; i < propertiesPaths.length; i++) {
        const property = propertiesPaths[i];
        if (property.isRestElement()) {
          const argument = property.get("argument");
          if (!argument.isIdentifier()) {
            builder.errors.push({
              reason: `(BuildHIR::lowerAssignment) Handle ${argument.node.type} rest element in ObjectPattern`,
              severity: ErrorSeverity.Todo,
              loc:
                (_o = argument.node.loc) !== null && _o !== void 0 ? _o : null,
              suggestions: null,
            });
            continue;
          }
          if (
            forceTemporaries ||
            getStoreKind(builder, argument) === "StoreContext"
          ) {
            const temp = buildTemporaryPlace(
              builder,
              (_p = property.node.loc) !== null && _p !== void 0
                ? _p
                : GeneratedSource
            );
            promoteTemporary(temp.identifier);
            properties.push({ kind: "Spread", place: Object.assign({}, temp) });
            followups.push({ place: temp, path: argument });
          } else {
            const identifier = lowerIdentifierForAssignment(
              builder,
              (_q = property.node.loc) !== null && _q !== void 0
                ? _q
                : GeneratedSource,
              kind,
              argument
            );
            if (identifier === null) {
              continue;
            } else if (identifier.kind === "Global") {
              builder.errors.push({
                severity: ErrorSeverity.Todo,
                reason:
                  "Expected reassignment of globals to enable forceTemporaries",
                loc:
                  (_r = property.node.loc) !== null && _r !== void 0
                    ? _r
                    : GeneratedSource,
              });
              continue;
            }
            properties.push({ kind: "Spread", place: identifier });
          }
        } else {
          if (!property.isObjectProperty()) {
            builder.errors.push({
              reason: `(BuildHIR::lowerAssignment) Handle ${property.type} properties in ObjectPattern`,
              severity: ErrorSeverity.Todo,
              loc:
                (_s = property.node.loc) !== null && _s !== void 0 ? _s : null,
              suggestions: null,
            });
            continue;
          }
          if (property.node.computed) {
            builder.errors.push({
              reason: `(BuildHIR::lowerAssignment) Handle computed properties in ObjectPattern`,
              severity: ErrorSeverity.Todo,
              loc:
                (_t = property.node.loc) !== null && _t !== void 0 ? _t : null,
              suggestions: null,
            });
            continue;
          }
          const loweredKey = lowerObjectPropertyKey(builder, property);
          if (!loweredKey) {
            continue;
          }
          const element = property.get("value");
          if (!element.isLVal()) {
            builder.errors.push({
              reason: `(BuildHIR::lowerAssignment) Expected object property value to be an LVal, got: ${element.type}`,
              severity: ErrorSeverity.Todo,
              loc:
                (_u = element.node.loc) !== null && _u !== void 0 ? _u : null,
              suggestions: null,
            });
            continue;
          }
          if (
            element.isIdentifier() &&
            !forceTemporaries &&
            (assignmentKind === "Assignment" ||
              getStoreKind(builder, element) === "StoreLocal")
          ) {
            const identifier = lowerIdentifierForAssignment(
              builder,
              (_v = element.node.loc) !== null && _v !== void 0
                ? _v
                : GeneratedSource,
              kind,
              element
            );
            if (identifier === null) {
              continue;
            } else if (identifier.kind === "Global") {
              builder.errors.push({
                severity: ErrorSeverity.Todo,
                reason:
                  "Expected reassignment of globals to enable forceTemporaries",
                loc:
                  (_w = element.node.loc) !== null && _w !== void 0
                    ? _w
                    : GeneratedSource,
              });
              continue;
            }
            properties.push({
              kind: "ObjectProperty",
              type: "property",
              place: identifier,
              key: loweredKey,
            });
          } else {
            const temp = buildTemporaryPlace(
              builder,
              (_x = element.node.loc) !== null && _x !== void 0
                ? _x
                : GeneratedSource
            );
            promoteTemporary(temp.identifier);
            properties.push({
              kind: "ObjectProperty",
              type: "property",
              place: Object.assign({}, temp),
              key: loweredKey,
            });
            followups.push({ place: temp, path: element });
          }
        }
      }
      const temporary = lowerValueToTemporary(builder, {
        kind: "Destructure",
        lvalue: {
          kind: kind,
          pattern: { kind: "ObjectPattern", properties: properties },
        },
        value: value,
        loc: loc,
      });
      for (const { place: place, path: path } of followups) {
        lowerAssignment(
          builder,
          (_y = path.node.loc) !== null && _y !== void 0 ? _y : loc,
          kind,
          path,
          place,
          assignmentKind
        );
      }
      return { kind: "LoadLocal", place: temporary, loc: value.loc };
    }
    case "AssignmentPattern": {
      const lvalue = lvaluePath;
      const loc =
        (_z = lvalue.node.loc) !== null && _z !== void 0 ? _z : GeneratedSource;
      const temp = buildTemporaryPlace(builder, loc);
      const testBlock = builder.reserve("value");
      const continuationBlock = builder.reserve(builder.currentBlockKind());
      const consequent = builder.enter("value", () => {
        const defaultValue = lowerReorderableExpression(
          builder,
          lvalue.get("right")
        );
        lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: {
            kind: InstructionKind.Const,
            place: Object.assign({}, temp),
          },
          value: Object.assign({}, defaultValue),
          type: null,
          loc: loc,
        });
        return {
          kind: "goto",
          variant: GotoVariant.Break,
          block: continuationBlock.id,
          id: makeInstructionId(0),
          loc: loc,
        };
      });
      const alternate = builder.enter("value", () => {
        lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: {
            kind: InstructionKind.Const,
            place: Object.assign({}, temp),
          },
          value: Object.assign({}, value),
          type: null,
          loc: loc,
        });
        return {
          kind: "goto",
          variant: GotoVariant.Break,
          block: continuationBlock.id,
          id: makeInstructionId(0),
          loc: loc,
        };
      });
      builder.terminateWithContinuation(
        {
          kind: "ternary",
          test: testBlock.id,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          loc: loc,
        },
        testBlock
      );
      const undef = lowerValueToTemporary(builder, {
        kind: "Primitive",
        value: undefined,
        loc: loc,
      });
      const test = lowerValueToTemporary(builder, {
        kind: "BinaryExpression",
        left: Object.assign({}, value),
        operator: "===",
        right: Object.assign({}, undef),
        loc: loc,
      });
      builder.terminateWithContinuation(
        {
          kind: "branch",
          test: Object.assign({}, test),
          consequent: consequent,
          alternate: alternate,
          id: makeInstructionId(0),
          loc: loc,
        },
        continuationBlock
      );
      return lowerAssignment(
        builder,
        loc,
        kind,
        lvalue.get("left"),
        temp,
        assignmentKind
      );
    }
    default: {
      builder.errors.push({
        reason: `(BuildHIR::lowerAssignment) Handle ${lvaluePath.type} assignments`,
        severity: ErrorSeverity.Todo,
        loc: (_0 = lvaluePath.node.loc) !== null && _0 !== void 0 ? _0 : null,
        suggestions: null,
      });
      return { kind: "UnsupportedNode", node: lvalueNode, loc: loc };
    }
  }
}
function isValidDependency(path) {
  const parent = path.parentPath;
  return (
    !path.node.computed &&
    !(parent.isCallExpression() && parent.get("callee") === path)
  );
}
function captureScopes({ from: from, to: to }) {
  let scopes = new Set();
  while (from) {
    scopes.add(from);
    if (from === to) {
      break;
    }
    from = from.parent;
  }
  return scopes;
}
function gatherCapturedDeps(builder, fn, componentScope) {
  const capturedIds = new Map();
  const capturedRefs = new Set();
  const seenPaths = new Set();
  const pureScopes = captureScopes({
    from: fn.scope.parent,
    to: componentScope,
  });
  function addCapturedId(bindingIdentifier) {
    if (!capturedIds.has(bindingIdentifier)) {
      const index = capturedIds.size;
      capturedIds.set(bindingIdentifier, index);
      return index;
    } else {
      return capturedIds.get(bindingIdentifier);
    }
  }
  function handleMaybeDependency(path) {
    var _a;
    let baseIdentifier;
    let dependency;
    if (path.isJSXOpeningElement()) {
      const name = path.get("name");
      if (!(name.isJSXMemberExpression() || name.isJSXIdentifier())) {
        return;
      }
      let current = name;
      while (current.isJSXMemberExpression()) {
        current = current.get("object");
      }
      invariant$1(
        current.isJSXIdentifier(),
        "Invalid logic in gatherCapturedDeps"
      );
      baseIdentifier = current;
      let currentDep = baseIdentifier;
      while (true) {
        const nextDep = currentDep.parentPath;
        if (nextDep && nextDep.isJSXMemberExpression()) {
          currentDep = nextDep;
        } else {
          break;
        }
      }
      dependency = currentDep;
    } else if (path.isMemberExpression()) {
      let currentId = path;
      while (currentId.isMemberExpression()) {
        currentId = currentId.get("object");
      }
      if (!currentId.isIdentifier()) {
        return;
      }
      baseIdentifier = currentId;
      let currentDep = baseIdentifier;
      while (true) {
        const nextDep = currentDep.parentPath;
        if (
          nextDep &&
          nextDep.isMemberExpression() &&
          isValidDependency(nextDep)
        ) {
          currentDep = nextDep;
        } else {
          break;
        }
      }
      dependency = currentDep;
    } else {
      baseIdentifier = path;
      dependency = path;
    }
    dependency.skip();
    const binding = baseIdentifier.scope.getBinding(baseIdentifier.node.name);
    if (binding === undefined || !pureScopes.has(binding.scope)) {
      return;
    }
    const idKey = String(addCapturedId(binding.identifier));
    let exprKey = idKey;
    if (dependency.isMemberExpression()) {
      let pathTokens = [];
      let current = dependency;
      while (current.isMemberExpression()) {
        const property = current.get("property");
        pathTokens.push(property.node.name);
        current = current.get("object");
      }
      exprKey += "." + pathTokens.reverse().join(".");
    } else if (dependency.isJSXMemberExpression()) {
      let pathTokens = [];
      let current = dependency;
      while (current.isJSXMemberExpression()) {
        const property = current.get("property");
        pathTokens.push(property.node.name);
        current = current.get("object");
      }
    }
    if (!seenPaths.has(exprKey)) {
      let loweredDep;
      if (dependency.isJSXIdentifier()) {
        loweredDep = lowerValueToTemporary(builder, {
          kind: "LoadLocal",
          place: lowerIdentifier(builder, dependency),
          loc:
            (_a = path.node.loc) !== null && _a !== void 0
              ? _a
              : GeneratedSource,
        });
      } else if (dependency.isJSXMemberExpression()) {
        loweredDep = lowerJsxMemberExpression(builder, dependency);
      } else {
        loweredDep = lowerExpressionToTemporary(builder, dependency);
      }
      capturedRefs.add(loweredDep);
      seenPaths.add(exprKey);
    }
  }
  fn.traverse({
    TypeAnnotation(path) {
      path.skip();
    },
    TSTypeAnnotation(path) {
      path.skip();
    },
    TypeAlias(path) {
      path.skip();
    },
    TSTypeAliasDeclaration(path) {
      path.skip();
    },
    Expression(path) {
      if (path.isAssignmentExpression()) {
        const left = path.get("left");
        if (left.isIdentifier()) {
          handleMaybeDependency(left);
        }
        return;
      } else if (path.isJSXElement()) {
        handleMaybeDependency(path.get("openingElement"));
      } else if (path.isMemberExpression() || path.isIdentifier()) {
        handleMaybeDependency(path);
      }
    },
  });
  return { identifiers: [...capturedIds.keys()], refs: [...capturedRefs] };
}
function notNull(value) {
  return value !== null;
}
function lowerType(node) {
  switch (node.type) {
    case "GenericTypeAnnotation": {
      const id = node.id;
      if (id.type === "Identifier" && id.name === "Array") {
        return { kind: "Object", shapeId: BuiltInArrayId };
      }
      return makeType();
    }
    case "TSTypeReference": {
      const typeName = node.typeName;
      if (typeName.type === "Identifier" && typeName.name === "Array") {
        return { kind: "Object", shapeId: BuiltInArrayId };
      }
      return makeType();
    }
    case "ArrayTypeAnnotation":
    case "TSArrayType": {
      return { kind: "Object", shapeId: BuiltInArrayId };
    }
    case "BooleanLiteralTypeAnnotation":
    case "BooleanTypeAnnotation":
    case "NullLiteralTypeAnnotation":
    case "NumberLiteralTypeAnnotation":
    case "NumberTypeAnnotation":
    case "StringLiteralTypeAnnotation":
    case "StringTypeAnnotation":
    case "TSBooleanKeyword":
    case "TSNullKeyword":
    case "TSNumberKeyword":
    case "TSStringKeyword":
    case "TSSymbolKeyword":
    case "TSUndefinedKeyword":
    case "TSVoidKeyword":
    case "VoidTypeAnnotation": {
      return { kind: "Primitive" };
    }
    default: {
      return makeType();
    }
  }
}
function buildReactiveScopeTerminalsHIR(fn) {
  const queuedRewrites = [];
  recursivelyTraverseItems(
    [...getScopes(fn)],
    (scope) => scope.range,
    { fallthroughs: new Map(), rewrites: queuedRewrites, env: fn.env },
    pushStartScopeTerminal,
    pushEndScopeTerminal
  );
  const rewrittenFinalBlocks = new Map();
  const nextBlocks = new Map();
  queuedRewrites.reverse();
  for (const [, block] of fn.body.blocks) {
    const context = {
      nextBlockId: block.id,
      rewrites: [],
      nextPreds: block.preds,
      instrSliceIdx: 0,
      source: block,
    };
    for (let i = 0; i < block.instructions.length + 1; i++) {
      const instrId =
        i < block.instructions.length
          ? block.instructions[i].id
          : block.terminal.id;
      let rewrite = queuedRewrites.at(-1);
      while (rewrite != null && rewrite.instrId <= instrId) {
        handleRewrite(rewrite, i, context);
        queuedRewrites.pop();
        rewrite = queuedRewrites.at(-1);
      }
    }
    if (context.rewrites.length > 0) {
      const finalBlock = {
        id: context.nextBlockId,
        kind: block.kind,
        preds: context.nextPreds,
        terminal: block.terminal,
        instructions: block.instructions.slice(context.instrSliceIdx),
        phis: new Set(),
      };
      context.rewrites.push(finalBlock);
      for (const b of context.rewrites) {
        nextBlocks.set(b.id, b);
      }
      rewrittenFinalBlocks.set(block.id, finalBlock.id);
    } else {
      nextBlocks.set(block.id, block);
    }
  }
  const originalBlocks = fn.body.blocks;
  fn.body.blocks = nextBlocks;
  for (const [, block] of originalBlocks) {
    for (const pred of block.preds) {
      const newId = rewrittenFinalBlocks.get(pred);
      if (newId != null) {
        block.preds.delete(pred);
        block.preds.add(newId);
      }
    }
    for (const phi of block.phis) {
      for (const [originalId, value] of phi.operands) {
        const newId = rewrittenFinalBlocks.get(originalId);
        if (newId != null) {
          phi.operands.delete(originalId);
          phi.operands.set(newId, value);
        }
      }
    }
  }
}
function pushStartScopeTerminal(scope, context) {
  const blockId = context.env.nextBlockId;
  const fallthroughId = context.env.nextBlockId;
  context.rewrites.push({
    kind: "StartScope",
    blockId: blockId,
    fallthroughId: fallthroughId,
    instrId: scope.range.start,
    scope: scope,
  });
  context.fallthroughs.set(scope.id, fallthroughId);
}
function pushEndScopeTerminal(scope, context) {
  const fallthroughId = context.fallthroughs.get(scope.id);
  CompilerError.invariant(fallthroughId != null, {
    reason: "Expected scope to exist",
    loc: GeneratedSource,
  });
  context.rewrites.push({
    kind: "EndScope",
    fallthroughId: fallthroughId,
    instrId: scope.range.end,
  });
}
function handleRewrite(terminalInfo, idx, context) {
  const terminal =
    terminalInfo.kind === "StartScope"
      ? {
          kind: "scope",
          fallthrough: terminalInfo.fallthroughId,
          block: terminalInfo.blockId,
          scope: terminalInfo.scope,
          id: terminalInfo.instrId,
          loc: GeneratedSource,
        }
      : {
          kind: "goto",
          variant: GotoVariant.Break,
          block: terminalInfo.fallthroughId,
          id: terminalInfo.instrId,
          loc: GeneratedSource,
        };
  const currBlockId = context.nextBlockId;
  context.rewrites.push({
    kind: context.source.kind,
    id: currBlockId,
    instructions: context.source.instructions.slice(context.instrSliceIdx, idx),
    preds: context.nextPreds,
    phis: context.rewrites.length === 0 ? context.source.phis : new Set(),
    terminal: terminal,
  });
  context.nextPreds = new Set([currBlockId]);
  context.nextBlockId =
    terminalInfo.kind === "StartScope"
      ? terminalInfo.blockId
      : terminalInfo.fallthroughId;
  context.instrSliceIdx = idx;
}
var ansiStyles = { exports: {} };
var conversions$2 = { exports: {} };
var colorName = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50],
};
var cssKeywords = colorName;
var reverseKeywords = {};
for (var key in cssKeywords) {
  if (cssKeywords.hasOwnProperty(key)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
}
var convert$1 = (conversions$2.exports = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] },
});
for (var model in convert$1) {
  if (convert$1.hasOwnProperty(model)) {
    if (!("channels" in convert$1[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert$1[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert$1[model].labels.length !== convert$1[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    var channels = convert$1[model].channels;
    var labels = convert$1[model].labels;
    delete convert$1[model].channels;
    delete convert$1[model].labels;
    Object.defineProperty(convert$1[model], "channels", { value: channels });
    Object.defineProperty(convert$1[model], "labels", { value: labels });
  }
}
convert$1.rgb.hsl = function (rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var min = Math.min(r, g, b);
  var max = Math.max(r, g, b);
  var delta = max - min;
  var h;
  var s;
  var l;
  if (max === min) {
    h = 0;
  } else if (r === max) {
    h = (g - b) / delta;
  } else if (g === max) {
    h = 2 + (b - r) / delta;
  } else if (b === max) {
    h = 4 + (r - g) / delta;
  }
  h = Math.min(h * 60, 360);
  if (h < 0) {
    h += 360;
  }
  l = (min + max) / 2;
  if (max === min) {
    s = 0;
  } else if (l <= 0.5) {
    s = delta / (max + min);
  } else {
    s = delta / (2 - max - min);
  }
  return [h, s * 100, l * 100];
};
convert$1.rgb.hsv = function (rgb) {
  var rdif;
  var gdif;
  var bdif;
  var h;
  var s;
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var v = Math.max(r, g, b);
  var diff = v - Math.min(r, g, b);
  var diffc = function (c) {
    return (v - c) / 6 / diff + 1 / 2;
  };
  if (diff === 0) {
    h = s = 0;
  } else {
    s = diff / v;
    rdif = diffc(r);
    gdif = diffc(g);
    bdif = diffc(b);
    if (r === v) {
      h = bdif - gdif;
    } else if (g === v) {
      h = 1 / 3 + rdif - bdif;
    } else if (b === v) {
      h = 2 / 3 + gdif - rdif;
    }
    if (h < 0) {
      h += 1;
    } else if (h > 1) {
      h -= 1;
    }
  }
  return [h * 360, s * 100, v * 100];
};
convert$1.rgb.hwb = function (rgb) {
  var r = rgb[0];
  var g = rgb[1];
  var b = rgb[2];
  var h = convert$1.rgb.hsl(rgb)[0];
  var w = (1 / 255) * Math.min(r, Math.min(g, b));
  b = 1 - (1 / 255) * Math.max(r, Math.max(g, b));
  return [h, w * 100, b * 100];
};
convert$1.rgb.cmyk = function (rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var c;
  var m;
  var y;
  var k;
  k = Math.min(1 - r, 1 - g, 1 - b);
  c = (1 - r - k) / (1 - k) || 0;
  m = (1 - g - k) / (1 - k) || 0;
  y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
};
function comparativeDistance(x, y) {
  return (
    Math.pow(x[0] - y[0], 2) +
    Math.pow(x[1] - y[1], 2) +
    Math.pow(x[2] - y[2], 2)
  );
}
convert$1.rgb.keyword = function (rgb) {
  var reversed = reverseKeywords[rgb];
  if (reversed) {
    return reversed;
  }
  var currentClosestDistance = Infinity;
  var currentClosestKeyword;
  for (var keyword in cssKeywords) {
    if (cssKeywords.hasOwnProperty(keyword)) {
      var value = cssKeywords[keyword];
      var distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
  }
  return currentClosestKeyword;
};
convert$1.keyword.rgb = function (keyword) {
  return cssKeywords[keyword];
};
convert$1.rgb.xyz = function (rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
  var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
  var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
  var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
  return [x * 100, y * 100, z * 100];
};
convert$1.rgb.lab = function (rgb) {
  var xyz = convert$1.rgb.xyz(rgb);
  var x = xyz[0];
  var y = xyz[1];
  var z = xyz[2];
  var l;
  var a;
  var b;
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
  l = 116 * y - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);
  return [l, a, b];
};
convert$1.hsl.rgb = function (hsl) {
  var h = hsl[0] / 360;
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var t1;
  var t2;
  var t3;
  var rgb;
  var val;
  if (s === 0) {
    val = l * 255;
    return [val, val, val];
  }
  if (l < 0.5) {
    t2 = l * (1 + s);
  } else {
    t2 = l + s - l * s;
  }
  t1 = 2 * l - t2;
  rgb = [0, 0, 0];
  for (var i = 0; i < 3; i++) {
    t3 = h + (1 / 3) * -(i - 1);
    if (t3 < 0) {
      t3++;
    }
    if (t3 > 1) {
      t3--;
    }
    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      val = t2;
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      val = t1;
    }
    rgb[i] = val * 255;
  }
  return rgb;
};
convert$1.hsl.hsv = function (hsl) {
  var h = hsl[0];
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var smin = s;
  var lmin = Math.max(l, 0.01);
  var sv;
  var v;
  l *= 2;
  s *= l <= 1 ? l : 2 - l;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  v = (l + s) / 2;
  sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);
  return [h, sv * 100, v * 100];
};
convert$1.hsv.rgb = function (hsv) {
  var h = hsv[0] / 60;
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var hi = Math.floor(h) % 6;
  var f = h - Math.floor(h);
  var p = 255 * v * (1 - s);
  var q = 255 * v * (1 - s * f);
  var t = 255 * v * (1 - s * (1 - f));
  v *= 255;
  switch (hi) {
    case 0:
      return [v, t, p];
    case 1:
      return [q, v, p];
    case 2:
      return [p, v, t];
    case 3:
      return [p, q, v];
    case 4:
      return [t, p, v];
    case 5:
      return [v, p, q];
  }
};
convert$1.hsv.hsl = function (hsv) {
  var h = hsv[0];
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var vmin = Math.max(v, 0.01);
  var lmin;
  var sl;
  var l;
  l = (2 - s) * v;
  lmin = (2 - s) * vmin;
  sl = s * vmin;
  sl /= lmin <= 1 ? lmin : 2 - lmin;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
};
convert$1.hwb.rgb = function (hwb) {
  var h = hwb[0] / 360;
  var wh = hwb[1] / 100;
  var bl = hwb[2] / 100;
  var ratio = wh + bl;
  var i;
  var v;
  var f;
  var n;
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }
  i = Math.floor(6 * h);
  v = 1 - bl;
  f = 6 * h - i;
  if ((i & 1) !== 0) {
    f = 1 - f;
  }
  n = wh + f * (v - wh);
  var r;
  var g;
  var b;
  switch (i) {
    default:
    case 6:
    case 0:
      r = v;
      g = n;
      b = wh;
      break;
    case 1:
      r = n;
      g = v;
      b = wh;
      break;
    case 2:
      r = wh;
      g = v;
      b = n;
      break;
    case 3:
      r = wh;
      g = n;
      b = v;
      break;
    case 4:
      r = n;
      g = wh;
      b = v;
      break;
    case 5:
      r = v;
      g = wh;
      b = n;
      break;
  }
  return [r * 255, g * 255, b * 255];
};
convert$1.cmyk.rgb = function (cmyk) {
  var c = cmyk[0] / 100;
  var m = cmyk[1] / 100;
  var y = cmyk[2] / 100;
  var k = cmyk[3] / 100;
  var r;
  var g;
  var b;
  r = 1 - Math.min(1, c * (1 - k) + k);
  g = 1 - Math.min(1, m * (1 - k) + k);
  b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
};
convert$1.xyz.rgb = function (xyz) {
  var x = xyz[0] / 100;
  var y = xyz[1] / 100;
  var z = xyz[2] / 100;
  var r;
  var g;
  var b;
  r = x * 3.2406 + y * -1.5372 + z * -0.4986;
  g = x * -0.9689 + y * 1.8758 + z * 0.0415;
  b = x * 0.0557 + y * -0.204 + z * 1.057;
  r = r > 0.0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
  g = g > 0.0031308 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
  b = b > 0.0031308 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);
  return [r * 255, g * 255, b * 255];
};
convert$1.xyz.lab = function (xyz) {
  var x = xyz[0];
  var y = xyz[1];
  var z = xyz[2];
  var l;
  var a;
  var b;
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
  l = 116 * y - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);
  return [l, a, b];
};
convert$1.lab.xyz = function (lab) {
  var l = lab[0];
  var a = lab[1];
  var b = lab[2];
  var x;
  var y;
  var z;
  y = (l + 16) / 116;
  x = a / 500 + y;
  z = y - b / 200;
  var y2 = Math.pow(y, 3);
  var x2 = Math.pow(x, 3);
  var z2 = Math.pow(z, 3);
  y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
  x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
  z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
  x *= 95.047;
  y *= 100;
  z *= 108.883;
  return [x, y, z];
};
convert$1.lab.lch = function (lab) {
  var l = lab[0];
  var a = lab[1];
  var b = lab[2];
  var hr;
  var h;
  var c;
  hr = Math.atan2(b, a);
  h = (hr * 360) / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  c = Math.sqrt(a * a + b * b);
  return [l, c, h];
};
convert$1.lch.lab = function (lch) {
  var l = lch[0];
  var c = lch[1];
  var h = lch[2];
  var a;
  var b;
  var hr;
  hr = (h / 360) * 2 * Math.PI;
  a = c * Math.cos(hr);
  b = c * Math.sin(hr);
  return [l, a, b];
};
convert$1.rgb.ansi16 = function (args) {
  var r = args[0];
  var g = args[1];
  var b = args[2];
  var value = 1 in arguments ? arguments[1] : convert$1.rgb.hsv(args)[2];
  value = Math.round(value / 50);
  if (value === 0) {
    return 30;
  }
  var ansi =
    30 +
    ((Math.round(b / 255) << 2) |
      (Math.round(g / 255) << 1) |
      Math.round(r / 255));
  if (value === 2) {
    ansi += 60;
  }
  return ansi;
};
convert$1.hsv.ansi16 = function (args) {
  return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);
};
convert$1.rgb.ansi256 = function (args) {
  var r = args[0];
  var g = args[1];
  var b = args[2];
  if (r === g && g === b) {
    if (r < 8) {
      return 16;
    }
    if (r > 248) {
      return 231;
    }
    return Math.round(((r - 8) / 247) * 24) + 232;
  }
  var ansi =
    16 +
    36 * Math.round((r / 255) * 5) +
    6 * Math.round((g / 255) * 5) +
    Math.round((b / 255) * 5);
  return ansi;
};
convert$1.ansi16.rgb = function (args) {
  var color = args % 10;
  if (color === 0 || color === 7) {
    if (args > 50) {
      color += 3.5;
    }
    color = (color / 10.5) * 255;
    return [color, color, color];
  }
  var mult = (~~(args > 50) + 1) * 0.5;
  var r = (color & 1) * mult * 255;
  var g = ((color >> 1) & 1) * mult * 255;
  var b = ((color >> 2) & 1) * mult * 255;
  return [r, g, b];
};
convert$1.ansi256.rgb = function (args) {
  if (args >= 232) {
    var c = (args - 232) * 10 + 8;
    return [c, c, c];
  }
  args -= 16;
  var rem;
  var r = (Math.floor(args / 36) / 5) * 255;
  var g = (Math.floor((rem = args % 36) / 6) / 5) * 255;
  var b = ((rem % 6) / 5) * 255;
  return [r, g, b];
};
convert$1.rgb.hex = function (args) {
  var integer =
    ((Math.round(args[0]) & 255) << 16) +
    ((Math.round(args[1]) & 255) << 8) +
    (Math.round(args[2]) & 255);
  var string = integer.toString(16).toUpperCase();
  return "000000".substring(string.length) + string;
};
convert$1.hex.rgb = function (args) {
  var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!match) {
    return [0, 0, 0];
  }
  var colorString = match[0];
  if (match[0].length === 3) {
    colorString = colorString
      .split("")
      .map(function (char) {
        return char + char;
      })
      .join("");
  }
  var integer = parseInt(colorString, 16);
  var r = (integer >> 16) & 255;
  var g = (integer >> 8) & 255;
  var b = integer & 255;
  return [r, g, b];
};
convert$1.rgb.hcg = function (rgb) {
  var r = rgb[0] / 255;
  var g = rgb[1] / 255;
  var b = rgb[2] / 255;
  var max = Math.max(Math.max(r, g), b);
  var min = Math.min(Math.min(r, g), b);
  var chroma = max - min;
  var grayscale;
  var hue;
  if (chroma < 1) {
    grayscale = min / (1 - chroma);
  } else {
    grayscale = 0;
  }
  if (chroma <= 0) {
    hue = 0;
  } else if (max === r) {
    hue = ((g - b) / chroma) % 6;
  } else if (max === g) {
    hue = 2 + (b - r) / chroma;
  } else {
    hue = 4 + (r - g) / chroma + 4;
  }
  hue /= 6;
  hue %= 1;
  return [hue * 360, chroma * 100, grayscale * 100];
};
convert$1.hsl.hcg = function (hsl) {
  var s = hsl[1] / 100;
  var l = hsl[2] / 100;
  var c = 1;
  var f = 0;
  if (l < 0.5) {
    c = 2 * s * l;
  } else {
    c = 2 * s * (1 - l);
  }
  if (c < 1) {
    f = (l - 0.5 * c) / (1 - c);
  }
  return [hsl[0], c * 100, f * 100];
};
convert$1.hsv.hcg = function (hsv) {
  var s = hsv[1] / 100;
  var v = hsv[2] / 100;
  var c = s * v;
  var f = 0;
  if (c < 1) {
    f = (v - c) / (1 - c);
  }
  return [hsv[0], c * 100, f * 100];
};
convert$1.hcg.rgb = function (hcg) {
  var h = hcg[0] / 360;
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  if (c === 0) {
    return [g * 255, g * 255, g * 255];
  }
  var pure = [0, 0, 0];
  var hi = (h % 1) * 6;
  var v = hi % 1;
  var w = 1 - v;
  var mg = 0;
  switch (Math.floor(hi)) {
    case 0:
      pure[0] = 1;
      pure[1] = v;
      pure[2] = 0;
      break;
    case 1:
      pure[0] = w;
      pure[1] = 1;
      pure[2] = 0;
      break;
    case 2:
      pure[0] = 0;
      pure[1] = 1;
      pure[2] = v;
      break;
    case 3:
      pure[0] = 0;
      pure[1] = w;
      pure[2] = 1;
      break;
    case 4:
      pure[0] = v;
      pure[1] = 0;
      pure[2] = 1;
      break;
    default:
      pure[0] = 1;
      pure[1] = 0;
      pure[2] = w;
  }
  mg = (1 - c) * g;
  return [
    (c * pure[0] + mg) * 255,
    (c * pure[1] + mg) * 255,
    (c * pure[2] + mg) * 255,
  ];
};
convert$1.hcg.hsv = function (hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var v = c + g * (1 - c);
  var f = 0;
  if (v > 0) {
    f = c / v;
  }
  return [hcg[0], f * 100, v * 100];
};
convert$1.hcg.hsl = function (hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var l = g * (1 - c) + 0.5 * c;
  var s = 0;
  if (l > 0 && l < 0.5) {
    s = c / (2 * l);
  } else if (l >= 0.5 && l < 1) {
    s = c / (2 * (1 - l));
  }
  return [hcg[0], s * 100, l * 100];
};
convert$1.hcg.hwb = function (hcg) {
  var c = hcg[1] / 100;
  var g = hcg[2] / 100;
  var v = c + g * (1 - c);
  return [hcg[0], (v - c) * 100, (1 - v) * 100];
};
convert$1.hwb.hcg = function (hwb) {
  var w = hwb[1] / 100;
  var b = hwb[2] / 100;
  var v = 1 - b;
  var c = v - w;
  var g = 0;
  if (c < 1) {
    g = (v - c) / (1 - c);
  }
  return [hwb[0], c * 100, g * 100];
};
convert$1.apple.rgb = function (apple) {
  return [
    (apple[0] / 65535) * 255,
    (apple[1] / 65535) * 255,
    (apple[2] / 65535) * 255,
  ];
};
convert$1.rgb.apple = function (rgb) {
  return [
    (rgb[0] / 255) * 65535,
    (rgb[1] / 255) * 65535,
    (rgb[2] / 255) * 65535,
  ];
};
convert$1.gray.rgb = function (args) {
  return [(args[0] / 100) * 255, (args[0] / 100) * 255, (args[0] / 100) * 255];
};
convert$1.gray.hsl = convert$1.gray.hsv = function (args) {
  return [0, 0, args[0]];
};
convert$1.gray.hwb = function (gray) {
  return [0, 100, gray[0]];
};
convert$1.gray.cmyk = function (gray) {
  return [0, 0, 0, gray[0]];
};
convert$1.gray.lab = function (gray) {
  return [gray[0], 0, 0];
};
convert$1.gray.hex = function (gray) {
  var val = Math.round((gray[0] / 100) * 255) & 255;
  var integer = (val << 16) + (val << 8) + val;
  var string = integer.toString(16).toUpperCase();
  return "000000".substring(string.length) + string;
};
convert$1.rgb.gray = function (rgb) {
  var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
  return [(val / 255) * 100];
};
var conversionsExports = conversions$2.exports;
var conversions$1 = conversionsExports;
function buildGraph() {
  var graph = {};
  var models = Object.keys(conversions$1);
  for (var len = models.length, i = 0; i < len; i++) {
    graph[models[i]] = { distance: -1, parent: null };
  }
  return graph;
}
function deriveBFS(fromModel) {
  var graph = buildGraph();
  var queue = [fromModel];
  graph[fromModel].distance = 0;
  while (queue.length) {
    var current = queue.pop();
    var adjacents = Object.keys(conversions$1[current]);
    for (var len = adjacents.length, i = 0; i < len; i++) {
      var adjacent = adjacents[i];
      var node = graph[adjacent];
      if (node.distance === -1) {
        node.distance = graph[current].distance + 1;
        node.parent = current;
        queue.unshift(adjacent);
      }
    }
  }
  return graph;
}
function link(from, to) {
  return function (args) {
    return to(from(args));
  };
}
function wrapConversion(toModel, graph) {
  var path = [graph[toModel].parent, toModel];
  var fn = conversions$1[graph[toModel].parent][toModel];
  var cur = graph[toModel].parent;
  while (graph[cur].parent) {
    path.unshift(graph[cur].parent);
    fn = link(conversions$1[graph[cur].parent][cur], fn);
    cur = graph[cur].parent;
  }
  fn.conversion = path;
  return fn;
}
var route$1 = function (fromModel) {
  var graph = deriveBFS(fromModel);
  var conversion = {};
  var models = Object.keys(graph);
  for (var len = models.length, i = 0; i < len; i++) {
    var toModel = models[i];
    var node = graph[toModel];
    if (node.parent === null) {
      continue;
    }
    conversion[toModel] = wrapConversion(toModel, graph);
  }
  return conversion;
};
var conversions = conversionsExports;
var route = route$1;
var convert = {};
var models = Object.keys(conversions);
function wrapRaw(fn) {
  var wrappedFn = function (args) {
    if (args === undefined || args === null) {
      return args;
    }
    if (arguments.length > 1) {
      args = Array.prototype.slice.call(arguments);
    }
    return fn(args);
  };
  if ("conversion" in fn) {
    wrappedFn.conversion = fn.conversion;
  }
  return wrappedFn;
}
function wrapRounded(fn) {
  var wrappedFn = function (args) {
    if (args === undefined || args === null) {
      return args;
    }
    if (arguments.length > 1) {
      args = Array.prototype.slice.call(arguments);
    }
    var result = fn(args);
    if (typeof result === "object") {
      for (var len = result.length, i = 0; i < len; i++) {
        result[i] = Math.round(result[i]);
      }
    }
    return result;
  };
  if ("conversion" in fn) {
    wrappedFn.conversion = fn.conversion;
  }
  return wrappedFn;
}
models.forEach(function (fromModel) {
  convert[fromModel] = {};
  Object.defineProperty(convert[fromModel], "channels", {
    value: conversions[fromModel].channels,
  });
  Object.defineProperty(convert[fromModel], "labels", {
    value: conversions[fromModel].labels,
  });
  var routes = route(fromModel);
  var routeModels = Object.keys(routes);
  routeModels.forEach(function (toModel) {
    var fn = routes[toModel];
    convert[fromModel][toModel] = wrapRounded(fn);
    convert[fromModel][toModel].raw = wrapRaw(fn);
  });
});
var colorConvert = convert;
ansiStyles.exports;
(function (module) {
  const colorConvert$1 = colorConvert;
  const wrapAnsi16 = (fn, offset) =>
    function () {
      const code = fn.apply(colorConvert$1, arguments);
      return `[${code + offset}m`;
    };
  const wrapAnsi256 = (fn, offset) =>
    function () {
      const code = fn.apply(colorConvert$1, arguments);
      return `[${38 + offset};5;${code}m`;
    };
  const wrapAnsi16m = (fn, offset) =>
    function () {
      const rgb = fn.apply(colorConvert$1, arguments);
      return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
  function assembleStyles() {
    const codes = new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29],
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39],
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49],
      },
    };
    styles.color.grey = styles.color.gray;
    for (const groupName of Object.keys(styles)) {
      const group = styles[groupName];
      for (const styleName of Object.keys(group)) {
        const style = group[styleName];
        styles[styleName] = { open: `[${style[0]}m`, close: `[${style[1]}m` };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false,
      });
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false,
      });
    }
    const ansi2ansi = (n) => n;
    const rgb2rgb = (r, g, b) => [r, g, b];
    styles.color.close = "[39m";
    styles.bgColor.close = "[49m";
    styles.color.ansi = { ansi: wrapAnsi16(ansi2ansi, 0) };
    styles.color.ansi256 = { ansi256: wrapAnsi256(ansi2ansi, 0) };
    styles.color.ansi16m = { rgb: wrapAnsi16m(rgb2rgb, 0) };
    styles.bgColor.ansi = { ansi: wrapAnsi16(ansi2ansi, 10) };
    styles.bgColor.ansi256 = { ansi256: wrapAnsi256(ansi2ansi, 10) };
    styles.bgColor.ansi16m = { rgb: wrapAnsi16m(rgb2rgb, 10) };
    for (let key of Object.keys(colorConvert$1)) {
      if (typeof colorConvert$1[key] !== "object") {
        continue;
      }
      const suite = colorConvert$1[key];
      if (key === "ansi16") {
        key = "ansi";
      }
      if ("ansi16" in suite) {
        styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
        styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
      }
      if ("ansi256" in suite) {
        styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
        styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
      }
      if ("rgb" in suite) {
        styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
        styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
      }
    }
    return styles;
  }
  Object.defineProperty(module, "exports", {
    enumerable: true,
    get: assembleStyles,
  });
})(ansiStyles);
var ansiStylesExports = ansiStyles.exports;
var collections = {};
Object.defineProperty(collections, "__esModule", { value: true });
collections.printIteratorEntries = printIteratorEntries;
collections.printIteratorValues = printIteratorValues;
collections.printListItems = printListItems;
collections.printObjectProperties = printObjectProperties;
const getKeysOfEnumerableProperties = (object) => {
  const keys = Object.keys(object).sort();
  if (Object.getOwnPropertySymbols) {
    Object.getOwnPropertySymbols(object).forEach((symbol) => {
      if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) {
        keys.push(symbol);
      }
    });
  }
  return keys;
};
function printIteratorEntries(
  iterator,
  config,
  indentation,
  depth,
  refs,
  printer,
  separator = ": "
) {
  let result = "";
  let current = iterator.next();
  if (!current.done) {
    result += config.spacingOuter;
    const indentationNext = indentation + config.indent;
    while (!current.done) {
      const name = printer(
        current.value[0],
        config,
        indentationNext,
        depth,
        refs
      );
      const value = printer(
        current.value[1],
        config,
        indentationNext,
        depth,
        refs
      );
      result += indentationNext + name + separator + value;
      current = iterator.next();
      if (!current.done) {
        result += "," + config.spacingInner;
      } else if (!config.min) {
        result += ",";
      }
    }
    result += config.spacingOuter + indentation;
  }
  return result;
}
function printIteratorValues(
  iterator,
  config,
  indentation,
  depth,
  refs,
  printer
) {
  let result = "";
  let current = iterator.next();
  if (!current.done) {
    result += config.spacingOuter;
    const indentationNext = indentation + config.indent;
    while (!current.done) {
      result +=
        indentationNext +
        printer(current.value, config, indentationNext, depth, refs);
      current = iterator.next();
      if (!current.done) {
        result += "," + config.spacingInner;
      } else if (!config.min) {
        result += ",";
      }
    }
    result += config.spacingOuter + indentation;
  }
  return result;
}
function printListItems(list, config, indentation, depth, refs, printer) {
  let result = "";
  if (list.length) {
    result += config.spacingOuter;
    const indentationNext = indentation + config.indent;
    for (let i = 0; i < list.length; i++) {
      result +=
        indentationNext +
        printer(list[i], config, indentationNext, depth, refs);
      if (i < list.length - 1) {
        result += "," + config.spacingInner;
      } else if (!config.min) {
        result += ",";
      }
    }
    result += config.spacingOuter + indentation;
  }
  return result;
}
function printObjectProperties(val, config, indentation, depth, refs, printer) {
  let result = "";
  const keys = getKeysOfEnumerableProperties(val);
  if (keys.length) {
    result += config.spacingOuter;
    const indentationNext = indentation + config.indent;
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const name = printer(key, config, indentationNext, depth, refs);
      const value = printer(val[key], config, indentationNext, depth, refs);
      result += indentationNext + name + ": " + value;
      if (i < keys.length - 1) {
        result += "," + config.spacingInner;
      } else if (!config.min) {
        result += ",";
      }
    }
    result += config.spacingOuter + indentation;
  }
  return result;
}
var AsymmetricMatcher = {};
Object.defineProperty(AsymmetricMatcher, "__esModule", { value: true });
AsymmetricMatcher.default =
  AsymmetricMatcher.test =
  AsymmetricMatcher.serialize =
    void 0;
var _collections$3 = collections;
var Symbol$3 =
  commonjsGlobal["jest-symbol-do-not-touch"] || commonjsGlobal.Symbol;
const asymmetricMatcher = Symbol$3.for("jest.asymmetricMatcher");
const SPACE$2 = " ";
const serialize$6 = (val, config, indentation, depth, refs, printer) => {
  const stringedValue = val.toString();
  if (
    stringedValue === "ArrayContaining" ||
    stringedValue === "ArrayNotContaining"
  ) {
    if (++depth > config.maxDepth) {
      return "[" + stringedValue + "]";
    }
    return (
      stringedValue +
      SPACE$2 +
      "[" +
      (0, _collections$3.printListItems)(
        val.sample,
        config,
        indentation,
        depth,
        refs,
        printer
      ) +
      "]"
    );
  }
  if (
    stringedValue === "ObjectContaining" ||
    stringedValue === "ObjectNotContaining"
  ) {
    if (++depth > config.maxDepth) {
      return "[" + stringedValue + "]";
    }
    return (
      stringedValue +
      SPACE$2 +
      "{" +
      (0, _collections$3.printObjectProperties)(
        val.sample,
        config,
        indentation,
        depth,
        refs,
        printer
      ) +
      "}"
    );
  }
  if (
    stringedValue === "StringMatching" ||
    stringedValue === "StringNotMatching"
  ) {
    return (
      stringedValue +
      SPACE$2 +
      printer(val.sample, config, indentation, depth, refs)
    );
  }
  if (
    stringedValue === "StringContaining" ||
    stringedValue === "StringNotContaining"
  ) {
    return (
      stringedValue +
      SPACE$2 +
      printer(val.sample, config, indentation, depth, refs)
    );
  }
  return val.toAsymmetricMatcher();
};
AsymmetricMatcher.serialize = serialize$6;
const test$6 = (val) => val && val.$$typeof === asymmetricMatcher;
AsymmetricMatcher.test = test$6;
const plugin$6 = { serialize: serialize$6, test: test$6 };
var _default$6 = plugin$6;
AsymmetricMatcher.default = _default$6;
var ConvertAnsi = {};
var ansiRegex = (options) => {
  options = Object.assign({ onlyFirst: false }, options);
  const pattern = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))",
  ].join("|");
  return new RegExp(pattern, options.onlyFirst ? undefined : "g");
};
Object.defineProperty(ConvertAnsi, "__esModule", { value: true });
ConvertAnsi.default = ConvertAnsi.serialize = ConvertAnsi.test = void 0;
var _ansiRegex = _interopRequireDefault$2(ansiRegex);
var _ansiStyles$1 = _interopRequireDefault$2(ansiStylesExports);
function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const toHumanReadableAnsi = (text) =>
  text.replace((0, _ansiRegex.default)(), (match) => {
    switch (match) {
      case _ansiStyles$1.default.red.close:
      case _ansiStyles$1.default.green.close:
      case _ansiStyles$1.default.cyan.close:
      case _ansiStyles$1.default.gray.close:
      case _ansiStyles$1.default.white.close:
      case _ansiStyles$1.default.yellow.close:
      case _ansiStyles$1.default.bgRed.close:
      case _ansiStyles$1.default.bgGreen.close:
      case _ansiStyles$1.default.bgYellow.close:
      case _ansiStyles$1.default.inverse.close:
      case _ansiStyles$1.default.dim.close:
      case _ansiStyles$1.default.bold.close:
      case _ansiStyles$1.default.reset.open:
      case _ansiStyles$1.default.reset.close:
        return "</>";
      case _ansiStyles$1.default.red.open:
        return "<red>";
      case _ansiStyles$1.default.green.open:
        return "<green>";
      case _ansiStyles$1.default.cyan.open:
        return "<cyan>";
      case _ansiStyles$1.default.gray.open:
        return "<gray>";
      case _ansiStyles$1.default.white.open:
        return "<white>";
      case _ansiStyles$1.default.yellow.open:
        return "<yellow>";
      case _ansiStyles$1.default.bgRed.open:
        return "<bgRed>";
      case _ansiStyles$1.default.bgGreen.open:
        return "<bgGreen>";
      case _ansiStyles$1.default.bgYellow.open:
        return "<bgYellow>";
      case _ansiStyles$1.default.inverse.open:
        return "<inverse>";
      case _ansiStyles$1.default.dim.open:
        return "<dim>";
      case _ansiStyles$1.default.bold.open:
        return "<bold>";
      default:
        return "";
    }
  });
const test$5 = (val) =>
  typeof val === "string" && !!val.match((0, _ansiRegex.default)());
ConvertAnsi.test = test$5;
const serialize$5 = (val, config, indentation, depth, refs, printer) =>
  printer(toHumanReadableAnsi(val), config, indentation, depth, refs);
ConvertAnsi.serialize = serialize$5;
const plugin$5 = { serialize: serialize$5, test: test$5 };
var _default$5 = plugin$5;
ConvertAnsi.default = _default$5;
var DOMCollection = {};
Object.defineProperty(DOMCollection, "__esModule", { value: true });
DOMCollection.default = DOMCollection.serialize = DOMCollection.test = void 0;
var _collections$2 = collections;
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys = ownKeys.concat(
        Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        })
      );
    }
    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true,
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
const SPACE$1 = " ";
const OBJECT_NAMES = ["DOMStringMap", "NamedNodeMap"];
const ARRAY_REGEXP = /^(HTML\w*Collection|NodeList)$/;
const testName = (name) =>
  OBJECT_NAMES.indexOf(name) !== -1 || ARRAY_REGEXP.test(name);
const test$4 = (val) =>
  val &&
  val.constructor &&
  val.constructor.name &&
  testName(val.constructor.name);
DOMCollection.test = test$4;
const propsReducer = (props, attribute) => {
  props[attribute.name] = attribute.value;
  return props;
};
const serialize$4 = (collection, config, indentation, depth, refs, printer) => {
  const name = collection.constructor.name;
  if (++depth > config.maxDepth) {
    return "[" + name + "]";
  }
  return (
    (config.min ? "" : name + SPACE$1) +
    (OBJECT_NAMES.indexOf(name) !== -1
      ? "{" +
        (0, _collections$2.printObjectProperties)(
          name === "NamedNodeMap"
            ? Array.prototype.reduce.call(collection, propsReducer, {})
            : _objectSpread({}, collection),
          config,
          indentation,
          depth,
          refs,
          printer
        ) +
        "}"
      : "[" +
        (0, _collections$2.printListItems)(
          Array.from(collection),
          config,
          indentation,
          depth,
          refs,
          printer
        ) +
        "]")
  );
};
DOMCollection.serialize = serialize$4;
const plugin$4 = { serialize: serialize$4, test: test$4 };
var _default$4 = plugin$4;
DOMCollection.default = _default$4;
var DOMElement = {};
var markup = {};
var escapeHTML$1 = {};
Object.defineProperty(escapeHTML$1, "__esModule", { value: true });
escapeHTML$1.default = escapeHTML;
function escapeHTML(str) {
  return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
Object.defineProperty(markup, "__esModule", { value: true });
markup.printElementAsLeaf =
  markup.printElement =
  markup.printComment =
  markup.printText =
  markup.printChildren =
  markup.printProps =
    void 0;
var _escapeHTML = _interopRequireDefault$1(escapeHTML$1);
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const printProps = (keys, props, config, indentation, depth, refs, printer) => {
  const indentationNext = indentation + config.indent;
  const colors = config.colors;
  return keys
    .map((key) => {
      const value = props[key];
      let printed = printer(value, config, indentationNext, depth, refs);
      if (typeof value !== "string") {
        if (printed.indexOf("\n") !== -1) {
          printed =
            config.spacingOuter +
            indentationNext +
            printed +
            config.spacingOuter +
            indentation;
        }
        printed = "{" + printed + "}";
      }
      return (
        config.spacingInner +
        indentation +
        colors.prop.open +
        key +
        colors.prop.close +
        "=" +
        colors.value.open +
        printed +
        colors.value.close
      );
    })
    .join("");
};
markup.printProps = printProps;
const printChildren = (children, config, indentation, depth, refs, printer) =>
  children
    .map(
      (child) =>
        config.spacingOuter +
        indentation +
        (typeof child === "string"
          ? printText(child, config)
          : printer(child, config, indentation, depth, refs))
    )
    .join("");
markup.printChildren = printChildren;
const printText = (text, config) => {
  const contentColor = config.colors.content;
  return (
    contentColor.open + (0, _escapeHTML.default)(text) + contentColor.close
  );
};
markup.printText = printText;
const printComment = (comment, config) => {
  const commentColor = config.colors.comment;
  return (
    commentColor.open +
    "\x3c!--" +
    (0, _escapeHTML.default)(comment) +
    "--\x3e" +
    commentColor.close
  );
};
markup.printComment = printComment;
const printElement = (
  type,
  printedProps,
  printedChildren,
  config,
  indentation
) => {
  const tagColor = config.colors.tag;
  return (
    tagColor.open +
    "<" +
    type +
    (printedProps &&
      tagColor.close +
        printedProps +
        config.spacingOuter +
        indentation +
        tagColor.open) +
    (printedChildren
      ? ">" +
        tagColor.close +
        printedChildren +
        config.spacingOuter +
        indentation +
        tagColor.open +
        "</" +
        type
      : (printedProps && !config.min ? "" : " ") + "/") +
    ">" +
    tagColor.close
  );
};
markup.printElement = printElement;
const printElementAsLeaf = (type, config) => {
  const tagColor = config.colors.tag;
  return (
    tagColor.open +
    "<" +
    type +
    tagColor.close +
    " " +
    tagColor.open +
    " />" +
    tagColor.close
  );
};
markup.printElementAsLeaf = printElementAsLeaf;
Object.defineProperty(DOMElement, "__esModule", { value: true });
DOMElement.default = DOMElement.serialize = DOMElement.test = void 0;
var _markup$2 = markup;
const ELEMENT_NODE = 1;
const TEXT_NODE = 3;
const COMMENT_NODE = 8;
const FRAGMENT_NODE = 11;
const ELEMENT_REGEXP = /^((HTML|SVG)\w*)?Element$/;
const testNode = (nodeType, name) =>
  (nodeType === ELEMENT_NODE && ELEMENT_REGEXP.test(name)) ||
  (nodeType === TEXT_NODE && name === "Text") ||
  (nodeType === COMMENT_NODE && name === "Comment") ||
  (nodeType === FRAGMENT_NODE && name === "DocumentFragment");
const test$3 = (val) =>
  val &&
  val.constructor &&
  val.constructor.name &&
  testNode(val.nodeType, val.constructor.name);
DOMElement.test = test$3;
function nodeIsText(node) {
  return node.nodeType === TEXT_NODE;
}
function nodeIsComment(node) {
  return node.nodeType === COMMENT_NODE;
}
function nodeIsFragment(node) {
  return node.nodeType === FRAGMENT_NODE;
}
const serialize$3 = (node, config, indentation, depth, refs, printer) => {
  if (nodeIsText(node)) {
    return (0, _markup$2.printText)(node.data, config);
  }
  if (nodeIsComment(node)) {
    return (0, _markup$2.printComment)(node.data, config);
  }
  const type = nodeIsFragment(node)
    ? `DocumentFragment`
    : node.tagName.toLowerCase();
  if (++depth > config.maxDepth) {
    return (0, _markup$2.printElementAsLeaf)(type, config);
  }
  return (0, _markup$2.printElement)(
    type,
    (0, _markup$2.printProps)(
      nodeIsFragment(node)
        ? []
        : Array.from(node.attributes)
            .map((attr) => attr.name)
            .sort(),
      nodeIsFragment(node)
        ? []
        : Array.from(node.attributes).reduce((props, attribute) => {
            props[attribute.name] = attribute.value;
            return props;
          }, {}),
      config,
      indentation + config.indent,
      depth,
      refs,
      printer
    ),
    (0, _markup$2.printChildren)(
      Array.prototype.slice.call(node.childNodes || node.children),
      config,
      indentation + config.indent,
      depth,
      refs,
      printer
    ),
    config,
    indentation
  );
};
DOMElement.serialize = serialize$3;
const plugin$3 = { serialize: serialize$3, test: test$3 };
var _default$3 = plugin$3;
DOMElement.default = _default$3;
var Immutable = {};
Object.defineProperty(Immutable, "__esModule", { value: true });
Immutable.default = Immutable.test = Immutable.serialize = void 0;
var _collections$1 = collections;
const IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
const IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
const IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
const IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
const IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
const IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@";
const IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
const IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
const IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
const getImmutableName = (name) => "Immutable." + name;
const printAsLeaf = (name) => "[" + name + "]";
const SPACE = " ";
const LAZY = "";
const printImmutableEntries = (
  val,
  config,
  indentation,
  depth,
  refs,
  printer,
  type
) =>
  ++depth > config.maxDepth
    ? printAsLeaf(getImmutableName(type))
    : getImmutableName(type) +
      SPACE +
      "{" +
      (0, _collections$1.printIteratorEntries)(
        val.entries(),
        config,
        indentation,
        depth,
        refs,
        printer
      ) +
      "}";
const getRecordEntries = (val) => {
  let i = 0;
  return {
    next() {
      if (i < val._keys.length) {
        const key = val._keys[i++];
        return { done: false, value: [key, val.get(key)] };
      }
      return { done: true };
    },
  };
};
const printImmutableRecord = (
  val,
  config,
  indentation,
  depth,
  refs,
  printer
) => {
  const name = getImmutableName(val._name || "Record");
  return ++depth > config.maxDepth
    ? printAsLeaf(name)
    : name +
        SPACE +
        "{" +
        (0, _collections$1.printIteratorEntries)(
          getRecordEntries(val),
          config,
          indentation,
          depth,
          refs,
          printer
        ) +
        "}";
};
const printImmutableSeq = (val, config, indentation, depth, refs, printer) => {
  const name = getImmutableName("Seq");
  if (++depth > config.maxDepth) {
    return printAsLeaf(name);
  }
  if (val[IS_KEYED_SENTINEL]) {
    return (
      name +
      SPACE +
      "{" +
      (val._iter || val._object
        ? (0, _collections$1.printIteratorEntries)(
            val.entries(),
            config,
            indentation,
            depth,
            refs,
            printer
          )
        : LAZY) +
      "}"
    );
  }
  return (
    name +
    SPACE +
    "[" +
    (val._iter || val._array || val._collection || val._iterable
      ? (0, _collections$1.printIteratorValues)(
          val.values(),
          config,
          indentation,
          depth,
          refs,
          printer
        )
      : LAZY) +
    "]"
  );
};
const printImmutableValues = (
  val,
  config,
  indentation,
  depth,
  refs,
  printer,
  type
) =>
  ++depth > config.maxDepth
    ? printAsLeaf(getImmutableName(type))
    : getImmutableName(type) +
      SPACE +
      "[" +
      (0, _collections$1.printIteratorValues)(
        val.values(),
        config,
        indentation,
        depth,
        refs,
        printer
      ) +
      "]";
const serialize$2 = (val, config, indentation, depth, refs, printer) => {
  if (val[IS_MAP_SENTINEL]) {
    return printImmutableEntries(
      val,
      config,
      indentation,
      depth,
      refs,
      printer,
      val[IS_ORDERED_SENTINEL] ? "OrderedMap" : "Map"
    );
  }
  if (val[IS_LIST_SENTINEL]) {
    return printImmutableValues(
      val,
      config,
      indentation,
      depth,
      refs,
      printer,
      "List"
    );
  }
  if (val[IS_SET_SENTINEL]) {
    return printImmutableValues(
      val,
      config,
      indentation,
      depth,
      refs,
      printer,
      val[IS_ORDERED_SENTINEL] ? "OrderedSet" : "Set"
    );
  }
  if (val[IS_STACK_SENTINEL]) {
    return printImmutableValues(
      val,
      config,
      indentation,
      depth,
      refs,
      printer,
      "Stack"
    );
  }
  if (val[IS_SEQ_SENTINEL]) {
    return printImmutableSeq(val, config, indentation, depth, refs, printer);
  }
  return printImmutableRecord(val, config, indentation, depth, refs, printer);
};
Immutable.serialize = serialize$2;
const test$2 = (val) =>
  val &&
  (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true);
Immutable.test = test$2;
const plugin$2 = { serialize: serialize$2, test: test$2 };
var _default$2 = plugin$2;
Immutable.default = _default$2;
var ReactElement = {};
var reactIs = { exports: {} };
var reactIs_production = {};
var hasRequiredReactIs_production;
function requireReactIs_production() {
  if (hasRequiredReactIs_production) return reactIs_production;
  hasRequiredReactIs_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
    REACT_PORTAL_TYPE = Symbol.for("react.portal"),
    REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
    REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
    REACT_PROFILER_TYPE = Symbol.for("react.profiler");
  var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
    REACT_CONTEXT_TYPE = Symbol.for("react.context"),
    REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
    REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
    REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
    REACT_MEMO_TYPE = Symbol.for("react.memo"),
    REACT_LAZY_TYPE = Symbol.for("react.lazy"),
    REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
    REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  function typeOf(object) {
    if ("object" === typeof object && null !== object) {
      var $$typeof = object.$$typeof;
      switch ($$typeof) {
        case REACT_ELEMENT_TYPE:
          switch (((object = object.type), object)) {
            case REACT_FRAGMENT_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_SUSPENSE_TYPE:
            case REACT_SUSPENSE_LIST_TYPE:
              return object;
            default:
              switch (((object = object && object.$$typeof), object)) {
                case REACT_CONTEXT_TYPE:
                case REACT_FORWARD_REF_TYPE:
                case REACT_LAZY_TYPE:
                case REACT_MEMO_TYPE:
                  return object;
                case REACT_CONSUMER_TYPE:
                  return object;
                default:
                  return $$typeof;
              }
          }
        case REACT_PORTAL_TYPE:
          return $$typeof;
      }
    }
  }
  reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;
  reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;
  reactIs_production.Element = REACT_ELEMENT_TYPE;
  reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;
  reactIs_production.Fragment = REACT_FRAGMENT_TYPE;
  reactIs_production.Lazy = REACT_LAZY_TYPE;
  reactIs_production.Memo = REACT_MEMO_TYPE;
  reactIs_production.Portal = REACT_PORTAL_TYPE;
  reactIs_production.Profiler = REACT_PROFILER_TYPE;
  reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;
  reactIs_production.Suspense = REACT_SUSPENSE_TYPE;
  reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
  reactIs_production.isContextConsumer = function (object) {
    return typeOf(object) === REACT_CONSUMER_TYPE;
  };
  reactIs_production.isContextProvider = function (object) {
    return typeOf(object) === REACT_CONTEXT_TYPE;
  };
  reactIs_production.isElement = function (object) {
    return (
      "object" === typeof object &&
      null !== object &&
      object.$$typeof === REACT_ELEMENT_TYPE
    );
  };
  reactIs_production.isForwardRef = function (object) {
    return typeOf(object) === REACT_FORWARD_REF_TYPE;
  };
  reactIs_production.isFragment = function (object) {
    return typeOf(object) === REACT_FRAGMENT_TYPE;
  };
  reactIs_production.isLazy = function (object) {
    return typeOf(object) === REACT_LAZY_TYPE;
  };
  reactIs_production.isMemo = function (object) {
    return typeOf(object) === REACT_MEMO_TYPE;
  };
  reactIs_production.isPortal = function (object) {
    return typeOf(object) === REACT_PORTAL_TYPE;
  };
  reactIs_production.isProfiler = function (object) {
    return typeOf(object) === REACT_PROFILER_TYPE;
  };
  reactIs_production.isStrictMode = function (object) {
    return typeOf(object) === REACT_STRICT_MODE_TYPE;
  };
  reactIs_production.isSuspense = function (object) {
    return typeOf(object) === REACT_SUSPENSE_TYPE;
  };
  reactIs_production.isSuspenseList = function (object) {
    return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
  };
  reactIs_production.isValidElementType = function (type) {
    return "string" === typeof type ||
      "function" === typeof type ||
      type === REACT_FRAGMENT_TYPE ||
      type === REACT_PROFILER_TYPE ||
      type === REACT_STRICT_MODE_TYPE ||
      type === REACT_SUSPENSE_TYPE ||
      type === REACT_SUSPENSE_LIST_TYPE ||
      type === REACT_OFFSCREEN_TYPE ||
      ("object" === typeof type &&
        null !== type &&
        (type.$$typeof === REACT_LAZY_TYPE ||
          type.$$typeof === REACT_MEMO_TYPE ||
          type.$$typeof === REACT_CONTEXT_TYPE ||
          type.$$typeof === REACT_CONSUMER_TYPE ||
          type.$$typeof === REACT_FORWARD_REF_TYPE ||
          type.$$typeof === REACT_CLIENT_REFERENCE ||
          void 0 !== type.getModuleId))
      ? !0
      : !1;
  };
  reactIs_production.typeOf = typeOf;
  return reactIs_production;
}
var reactIs_development = {};
var hasRequiredReactIs_development;
function requireReactIs_development() {
  if (hasRequiredReactIs_development) return reactIs_development;
  hasRequiredReactIs_development = 1;
  if (process.env.NODE_ENV !== "production") {
    (function () {
      var enableScopeAPI = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableRenderableContext = true;
      var enableDebugTracing = false;
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (
          type === REACT_FRAGMENT_TYPE ||
          type === REACT_PROFILER_TYPE ||
          enableDebugTracing ||
          type === REACT_STRICT_MODE_TYPE ||
          type === REACT_SUSPENSE_TYPE ||
          type === REACT_SUSPENSE_LIST_TYPE ||
          enableLegacyHidden ||
          type === REACT_OFFSCREEN_TYPE ||
          enableScopeAPI ||
          enableTransitionTracing
        ) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (
            type.$$typeof === REACT_LAZY_TYPE ||
            type.$$typeof === REACT_MEMO_TYPE ||
            type.$$typeof === REACT_CONTEXT_TYPE ||
            !enableRenderableContext ||
            type.$$typeof === REACT_CONSUMER_TYPE ||
            type.$$typeof === REACT_FORWARD_REF_TYPE ||
            type.$$typeof === REACT_CLIENT_REFERENCE ||
            type.getModuleId !== undefined
          ) {
            return true;
          }
        }
        return false;
      }
      function typeOf(object) {
        if (typeof object === "object" && object !== null) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;
              switch (type) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                  return type;
                default:
                  var $$typeofType = type && type.$$typeof;
                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                      return $$typeofType;
                    case REACT_CONSUMER_TYPE: {
                      return $$typeofType;
                    }
                    case REACT_PROVIDER_TYPE:
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
        return undefined;
      }
      var ContextConsumer = REACT_CONSUMER_TYPE;
      var ContextProvider = REACT_CONTEXT_TYPE;
      var Element = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense = REACT_SUSPENSE_TYPE;
      var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
      function isContextConsumer(object) {
        {
          return typeOf(object) === REACT_CONSUMER_TYPE;
        }
      }
      function isContextProvider(object) {
        {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
      }
      function isElement(object) {
        return (
          typeof object === "object" &&
          object !== null &&
          object.$$typeof === REACT_ELEMENT_TYPE
        );
      }
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      function isSuspenseList(object) {
        return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
      }
      reactIs_development.ContextConsumer = ContextConsumer;
      reactIs_development.ContextProvider = ContextProvider;
      reactIs_development.Element = Element;
      reactIs_development.ForwardRef = ForwardRef;
      reactIs_development.Fragment = Fragment;
      reactIs_development.Lazy = Lazy;
      reactIs_development.Memo = Memo;
      reactIs_development.Portal = Portal;
      reactIs_development.Profiler = Profiler;
      reactIs_development.StrictMode = StrictMode;
      reactIs_development.Suspense = Suspense;
      reactIs_development.SuspenseList = SuspenseList;
      reactIs_development.isContextConsumer = isContextConsumer;
      reactIs_development.isContextProvider = isContextProvider;
      reactIs_development.isElement = isElement;
      reactIs_development.isForwardRef = isForwardRef;
      reactIs_development.isFragment = isFragment;
      reactIs_development.isLazy = isLazy;
      reactIs_development.isMemo = isMemo;
      reactIs_development.isPortal = isPortal;
      reactIs_development.isProfiler = isProfiler;
      reactIs_development.isStrictMode = isStrictMode;
      reactIs_development.isSuspense = isSuspense;
      reactIs_development.isSuspenseList = isSuspenseList;
      reactIs_development.isValidElementType = isValidElementType;
      reactIs_development.typeOf = typeOf;
    })();
  }
  return reactIs_development;
}
if (process.env.NODE_ENV === "production") {
  reactIs.exports = requireReactIs_production();
} else {
  reactIs.exports = requireReactIs_development();
}
var reactIsExports = reactIs.exports;
Object.defineProperty(ReactElement, "__esModule", { value: true });
ReactElement.default = ReactElement.test = ReactElement.serialize = void 0;
var ReactIs = _interopRequireWildcard(reactIsExports);
var _markup$1 = markup;
function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
const getChildren = (arg, children = []) => {
  if (Array.isArray(arg)) {
    arg.forEach((item) => {
      getChildren(item, children);
    });
  } else if (arg != null && arg !== false) {
    children.push(arg);
  }
  return children;
};
const getType = (element) => {
  const type = element.type;
  if (typeof type === "string") {
    return type;
  }
  if (typeof type === "function") {
    return type.displayName || type.name || "Unknown";
  }
  if (ReactIs.isFragment(element)) {
    return "React.Fragment";
  }
  if (ReactIs.isSuspense(element)) {
    return "React.Suspense";
  }
  if (typeof type === "object" && type !== null) {
    if (ReactIs.isContextProvider(element)) {
      return "Context.Provider";
    }
    if (ReactIs.isContextConsumer(element)) {
      return "Context.Consumer";
    }
    if (ReactIs.isForwardRef(element)) {
      const functionName = type.render.displayName || type.render.name || "";
      return functionName !== ""
        ? "ForwardRef(" + functionName + ")"
        : "ForwardRef";
    }
    if (ReactIs.isMemo(type)) {
      const functionName =
        type.displayName || type.type.displayName || type.type.name || "";
      return functionName !== "" ? "Memo(" + functionName + ")" : "Memo";
    }
  }
  return "UNDEFINED";
};
const getPropKeys$1 = (element) => {
  const props = element.props;
  return Object.keys(props)
    .filter((key) => key !== "children" && props[key] !== undefined)
    .sort();
};
const serialize$1 = (element, config, indentation, depth, refs, printer) =>
  ++depth > config.maxDepth
    ? (0, _markup$1.printElementAsLeaf)(getType(element), config)
    : (0, _markup$1.printElement)(
        getType(element),
        (0, _markup$1.printProps)(
          getPropKeys$1(element),
          element.props,
          config,
          indentation + config.indent,
          depth,
          refs,
          printer
        ),
        (0, _markup$1.printChildren)(
          getChildren(element.props.children),
          config,
          indentation + config.indent,
          depth,
          refs,
          printer
        ),
        config,
        indentation
      );
ReactElement.serialize = serialize$1;
const test$1 = (val) => val && ReactIs.isElement(val);
ReactElement.test = test$1;
const plugin$1 = { serialize: serialize$1, test: test$1 };
var _default$1 = plugin$1;
ReactElement.default = _default$1;
var ReactTestComponent = {};
Object.defineProperty(ReactTestComponent, "__esModule", { value: true });
ReactTestComponent.default =
  ReactTestComponent.test =
  ReactTestComponent.serialize =
    void 0;
var _markup = markup;
var Symbol$2 =
  commonjsGlobal["jest-symbol-do-not-touch"] || commonjsGlobal.Symbol;
const testSymbol = Symbol$2.for("react.test.json");
const getPropKeys = (object) => {
  const props = object.props;
  return props
    ? Object.keys(props)
        .filter((key) => props[key] !== undefined)
        .sort()
    : [];
};
const serialize = (object, config, indentation, depth, refs, printer) =>
  ++depth > config.maxDepth
    ? (0, _markup.printElementAsLeaf)(object.type, config)
    : (0, _markup.printElement)(
        object.type,
        object.props
          ? (0, _markup.printProps)(
              getPropKeys(object),
              object.props,
              config,
              indentation + config.indent,
              depth,
              refs,
              printer
            )
          : "",
        object.children
          ? (0, _markup.printChildren)(
              object.children,
              config,
              indentation + config.indent,
              depth,
              refs,
              printer
            )
          : "",
        config,
        indentation
      );
ReactTestComponent.serialize = serialize;
const test = (val) => val && val.$$typeof === testSymbol;
ReactTestComponent.test = test;
const plugin = { serialize: serialize, test: test };
var _default = plugin;
ReactTestComponent.default = _default;
var _ansiStyles = _interopRequireDefault(ansiStylesExports);
var _collections = collections;
var _AsymmetricMatcher = _interopRequireDefault(AsymmetricMatcher);
var _ConvertAnsi = _interopRequireDefault(ConvertAnsi);
var _DOMCollection = _interopRequireDefault(DOMCollection);
var _DOMElement = _interopRequireDefault(DOMElement);
var _Immutable = _interopRequireDefault(Immutable);
var _ReactElement = _interopRequireDefault(ReactElement);
var _ReactTestComponent = _interopRequireDefault(ReactTestComponent);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var Symbol$1 =
  commonjsGlobal["jest-symbol-do-not-touch"] || commonjsGlobal.Symbol;
const toString = Object.prototype.toString;
const toISOString = Date.prototype.toISOString;
const errorToString = Error.prototype.toString;
const regExpToString = RegExp.prototype.toString;
const symbolToString = Symbol$1.prototype.toString;
const getConstructorName = (val) =>
  (typeof val.constructor === "function" && val.constructor.name) || "Object";
const isWindow = (val) => typeof window !== "undefined" && val === window;
const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
const NEWLINE_REGEXP = /\n/gi;
class PrettyFormatPluginError extends Error {
  constructor(message, stack) {
    super(message);
    this.stack = stack;
    this.name = this.constructor.name;
  }
}
function isToStringedArrayType(toStringed) {
  return (
    toStringed === "[object Array]" ||
    toStringed === "[object ArrayBuffer]" ||
    toStringed === "[object DataView]" ||
    toStringed === "[object Float32Array]" ||
    toStringed === "[object Float64Array]" ||
    toStringed === "[object Int8Array]" ||
    toStringed === "[object Int16Array]" ||
    toStringed === "[object Int32Array]" ||
    toStringed === "[object Uint8Array]" ||
    toStringed === "[object Uint8ClampedArray]" ||
    toStringed === "[object Uint16Array]" ||
    toStringed === "[object Uint32Array]"
  );
}
function printNumber(val) {
  return Object.is(val, -0) ? "-0" : String(val);
}
function printBigInt(val) {
  return String(`${val}n`);
}
function printFunction(val, printFunctionName) {
  if (!printFunctionName) {
    return "[Function]";
  }
  return "[Function " + (val.name || "anonymous") + "]";
}
function printSymbol(val) {
  return symbolToString.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
}
function printError(val) {
  return "[" + errorToString.call(val) + "]";
}
function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
  if (val === true || val === false) {
    return "" + val;
  }
  if (val === undefined) {
    return "undefined";
  }
  if (val === null) {
    return "null";
  }
  const typeOf = typeof val;
  if (typeOf === "number") {
    return printNumber(val);
  }
  if (typeOf === "bigint") {
    return printBigInt(val);
  }
  if (typeOf === "string") {
    if (escapeString) {
      return '"' + val.replace(/"|\\/g, "\\$&") + '"';
    }
    return '"' + val + '"';
  }
  if (typeOf === "function") {
    return printFunction(val, printFunctionName);
  }
  if (typeOf === "symbol") {
    return printSymbol(val);
  }
  const toStringed = toString.call(val);
  if (toStringed === "[object WeakMap]") {
    return "WeakMap {}";
  }
  if (toStringed === "[object WeakSet]") {
    return "WeakSet {}";
  }
  if (
    toStringed === "[object Function]" ||
    toStringed === "[object GeneratorFunction]"
  ) {
    return printFunction(val, printFunctionName);
  }
  if (toStringed === "[object Symbol]") {
    return printSymbol(val);
  }
  if (toStringed === "[object Date]") {
    return isNaN(+val) ? "Date { NaN }" : toISOString.call(val);
  }
  if (toStringed === "[object Error]") {
    return printError(val);
  }
  if (toStringed === "[object RegExp]") {
    if (escapeRegex) {
      return regExpToString.call(val).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    return regExpToString.call(val);
  }
  if (val instanceof Error) {
    return printError(val);
  }
  return null;
}
function printComplexValue(
  val,
  config,
  indentation,
  depth,
  refs,
  hasCalledToJSON
) {
  if (refs.indexOf(val) !== -1) {
    return "[Circular]";
  }
  refs = refs.slice();
  refs.push(val);
  const hitMaxDepth = ++depth > config.maxDepth;
  const min = config.min;
  if (
    config.callToJSON &&
    !hitMaxDepth &&
    val.toJSON &&
    typeof val.toJSON === "function" &&
    !hasCalledToJSON
  ) {
    return printer(val.toJSON(), config, indentation, depth, refs, true);
  }
  const toStringed = toString.call(val);
  if (toStringed === "[object Arguments]") {
    return hitMaxDepth
      ? "[Arguments]"
      : (min ? "" : "Arguments ") +
          "[" +
          (0, _collections.printListItems)(
            val,
            config,
            indentation,
            depth,
            refs,
            printer
          ) +
          "]";
  }
  if (isToStringedArrayType(toStringed)) {
    return hitMaxDepth
      ? "[" + val.constructor.name + "]"
      : (min ? "" : val.constructor.name + " ") +
          "[" +
          (0, _collections.printListItems)(
            val,
            config,
            indentation,
            depth,
            refs,
            printer
          ) +
          "]";
  }
  if (toStringed === "[object Map]") {
    return hitMaxDepth
      ? "[Map]"
      : "Map {" +
          (0, _collections.printIteratorEntries)(
            val.entries(),
            config,
            indentation,
            depth,
            refs,
            printer,
            " => "
          ) +
          "}";
  }
  if (toStringed === "[object Set]") {
    return hitMaxDepth
      ? "[Set]"
      : "Set {" +
          (0, _collections.printIteratorValues)(
            val.values(),
            config,
            indentation,
            depth,
            refs,
            printer
          ) +
          "}";
  }
  return hitMaxDepth || isWindow(val)
    ? "[" + getConstructorName(val) + "]"
    : (min ? "" : getConstructorName(val) + " ") +
        "{" +
        (0, _collections.printObjectProperties)(
          val,
          config,
          indentation,
          depth,
          refs,
          printer
        ) +
        "}";
}
function isNewPlugin(plugin) {
  return plugin.serialize != null;
}
function printPlugin(plugin, val, config, indentation, depth, refs) {
  let printed;
  try {
    printed = isNewPlugin(plugin)
      ? plugin.serialize(val, config, indentation, depth, refs, printer)
      : plugin.print(
          val,
          (valChild) => printer(valChild, config, indentation, depth, refs),
          (str) => {
            const indentationNext = indentation + config.indent;
            return (
              indentationNext +
              str.replace(NEWLINE_REGEXP, "\n" + indentationNext)
            );
          },
          {
            edgeSpacing: config.spacingOuter,
            min: config.min,
            spacing: config.spacingInner,
          },
          config.colors
        );
  } catch (error) {
    throw new PrettyFormatPluginError(error.message, error.stack);
  }
  if (typeof printed !== "string") {
    throw new Error(
      `pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`
    );
  }
  return printed;
}
function findPlugin(plugins, val) {
  for (let p = 0; p < plugins.length; p++) {
    try {
      if (plugins[p].test(val)) {
        return plugins[p];
      }
    } catch (error) {
      throw new PrettyFormatPluginError(error.message, error.stack);
    }
  }
  return null;
}
function printer(val, config, indentation, depth, refs, hasCalledToJSON) {
  const plugin = findPlugin(config.plugins, val);
  if (plugin !== null) {
    return printPlugin(plugin, val, config, indentation, depth, refs);
  }
  const basicResult = printBasicValue(
    val,
    config.printFunctionName,
    config.escapeRegex,
    config.escapeString
  );
  if (basicResult !== null) {
    return basicResult;
  }
  return printComplexValue(
    val,
    config,
    indentation,
    depth,
    refs,
    hasCalledToJSON
  );
}
const DEFAULT_THEME = {
  comment: "gray",
  content: "reset",
  prop: "yellow",
  tag: "cyan",
  value: "green",
};
const DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);
const DEFAULT_OPTIONS = {
  callToJSON: true,
  escapeRegex: false,
  escapeString: true,
  highlight: false,
  indent: 2,
  maxDepth: Infinity,
  min: false,
  plugins: [],
  printFunctionName: true,
  theme: DEFAULT_THEME,
};
function validateOptions(options) {
  Object.keys(options).forEach((key) => {
    if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
      throw new Error(`pretty-format: Unknown option "${key}".`);
    }
  });
  if (options.min && options.indent !== undefined && options.indent !== 0) {
    throw new Error(
      'pretty-format: Options "min" and "indent" cannot be used together.'
    );
  }
  if (options.theme !== undefined) {
    if (options.theme === null) {
      throw new Error(`pretty-format: Option "theme" must not be null.`);
    }
    if (typeof options.theme !== "object") {
      throw new Error(
        `pretty-format: Option "theme" must be of type "object" but instead received "${typeof options.theme}".`
      );
    }
  }
}
const getColorsHighlight = (options) =>
  DEFAULT_THEME_KEYS.reduce((colors, key) => {
    const value =
      options.theme && options.theme[key] !== undefined
        ? options.theme[key]
        : DEFAULT_THEME[key];
    const color = value && _ansiStyles.default[value];
    if (
      color &&
      typeof color.close === "string" &&
      typeof color.open === "string"
    ) {
      colors[key] = color;
    } else {
      throw new Error(
        `pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`
      );
    }
    return colors;
  }, Object.create(null));
const getColorsEmpty = () =>
  DEFAULT_THEME_KEYS.reduce((colors, key) => {
    colors[key] = { close: "", open: "" };
    return colors;
  }, Object.create(null));
const getPrintFunctionName = (options) =>
  options && options.printFunctionName !== undefined
    ? options.printFunctionName
    : DEFAULT_OPTIONS.printFunctionName;
const getEscapeRegex = (options) =>
  options && options.escapeRegex !== undefined
    ? options.escapeRegex
    : DEFAULT_OPTIONS.escapeRegex;
const getEscapeString = (options) =>
  options && options.escapeString !== undefined
    ? options.escapeString
    : DEFAULT_OPTIONS.escapeString;
const getConfig = (options) => ({
  callToJSON:
    options && options.callToJSON !== undefined
      ? options.callToJSON
      : DEFAULT_OPTIONS.callToJSON,
  colors:
    options && options.highlight
      ? getColorsHighlight(options)
      : getColorsEmpty(),
  escapeRegex: getEscapeRegex(options),
  escapeString: getEscapeString(options),
  indent:
    options && options.min
      ? ""
      : createIndent(
          options && options.indent !== undefined
            ? options.indent
            : DEFAULT_OPTIONS.indent
        ),
  maxDepth:
    options && options.maxDepth !== undefined
      ? options.maxDepth
      : DEFAULT_OPTIONS.maxDepth,
  min: options && options.min !== undefined ? options.min : DEFAULT_OPTIONS.min,
  plugins:
    options && options.plugins !== undefined
      ? options.plugins
      : DEFAULT_OPTIONS.plugins,
  printFunctionName: getPrintFunctionName(options),
  spacingInner: options && options.min ? " " : "\n",
  spacingOuter: options && options.min ? "" : "\n",
});
function createIndent(indent) {
  return new Array(indent + 1).join(" ");
}
function prettyFormat(val, options) {
  if (options) {
    validateOptions(options);
    if (options.plugins) {
      const plugin = findPlugin(options.plugins, val);
      if (plugin !== null) {
        return printPlugin(plugin, val, getConfig(options), "", 0, []);
      }
    }
  }
  const basicResult = printBasicValue(
    val,
    getPrintFunctionName(options),
    getEscapeRegex(options),
    getEscapeString(options)
  );
  if (basicResult !== null) {
    return basicResult;
  }
  return printComplexValue(val, getConfig(options), "", 0, []);
}
prettyFormat.plugins = {
  AsymmetricMatcher: _AsymmetricMatcher.default,
  ConvertAnsi: _ConvertAnsi.default,
  DOMCollection: _DOMCollection.default,
  DOMElement: _DOMElement.default,
  Immutable: _Immutable.default,
  ReactElement: _ReactElement.default,
  ReactTestComponent: _ReactTestComponent.default,
};
var build = prettyFormat;
var prettyFormat$1 = getDefaultExportFromCjs(build);
var _PostDominator_exit, _PostDominator_nodes;
function computePostDominatorTree(fn, options) {
  const graph = buildReverseGraph(fn, options.includeThrowsAsExitNode);
  const nodes = computeImmediateDominators(graph);
  if (!options.includeThrowsAsExitNode) {
    for (const [id] of fn.body.blocks) {
      if (!nodes.has(id)) {
        nodes.set(id, id);
      }
    }
  }
  return new PostDominator(graph.entry, nodes);
}
class PostDominator {
  constructor(exit, nodes) {
    _PostDominator_exit.set(this, void 0);
    _PostDominator_nodes.set(this, void 0);
    __classPrivateFieldSet(this, _PostDominator_exit, exit, "f");
    __classPrivateFieldSet(this, _PostDominator_nodes, nodes, "f");
  }
  get exit() {
    return __classPrivateFieldGet(this, _PostDominator_exit, "f");
  }
  get(id) {
    const dominator = __classPrivateFieldGet(
      this,
      _PostDominator_nodes,
      "f"
    ).get(id);
    CompilerError.invariant(dominator !== undefined, {
      reason: "Unknown node",
      description: null,
      loc: null,
      suggestions: null,
    });
    return dominator === id ? null : dominator;
  }
  debug() {
    const postDominators = new Map();
    for (const [key, value] of __classPrivateFieldGet(
      this,
      _PostDominator_nodes,
      "f"
    )) {
      postDominators.set(`bb${key}`, `bb${value}`);
    }
    return prettyFormat$1({
      exit: `bb${this.exit}`,
      postDominators: postDominators,
    });
  }
}
(_PostDominator_exit = new WeakMap()), (_PostDominator_nodes = new WeakMap());
function computeImmediateDominators(graph) {
  const nodes = new Map();
  nodes.set(graph.entry, graph.entry);
  let changed = true;
  while (changed) {
    changed = false;
    for (const [id, node] of graph.nodes) {
      if (node.id === graph.entry) {
        continue;
      }
      let newIdom = null;
      for (const pred of node.preds) {
        if (nodes.has(pred)) {
          newIdom = pred;
          break;
        }
      }
      CompilerError.invariant(newIdom !== null, {
        reason: `At least one predecessor must have been visited for block ${id}`,
        description: null,
        loc: null,
        suggestions: null,
      });
      for (const pred of node.preds) {
        if (pred === newIdom) {
          continue;
        }
        const predDom = nodes.get(pred);
        if (predDom !== undefined) {
          newIdom = intersect(pred, newIdom, graph, nodes);
        }
      }
      if (nodes.get(id) !== newIdom) {
        nodes.set(id, newIdom);
        changed = true;
      }
    }
  }
  return nodes;
}
function intersect(a, b, graph, nodes) {
  let block1 = graph.nodes.get(a);
  let block2 = graph.nodes.get(b);
  while (block1 !== block2) {
    while (block1.index > block2.index) {
      const dom = nodes.get(block1.id);
      block1 = graph.nodes.get(dom);
    }
    while (block2.index > block1.index) {
      const dom = nodes.get(block2.id);
      block2 = graph.nodes.get(dom);
    }
  }
  return block1.id;
}
function buildReverseGraph(fn, includeThrowsAsExitNode) {
  const nodes = new Map();
  const exitId = fn.env.nextBlockId;
  const exit = { id: exitId, index: 0, preds: new Set(), succs: new Set() };
  nodes.set(exitId, exit);
  for (const [id, block] of fn.body.blocks) {
    const node = {
      id: id,
      index: 0,
      preds: new Set(eachTerminalSuccessor(block.terminal)),
      succs: new Set(block.preds),
    };
    if (block.terminal.kind === "return") {
      node.preds.add(exitId);
      exit.succs.add(id);
    } else if (block.terminal.kind === "throw" && includeThrowsAsExitNode) {
      node.preds.add(exitId);
      exit.succs.add(id);
    }
    nodes.set(id, node);
  }
  const visited = new Set();
  const postorder = [];
  function visit(id) {
    if (visited.has(id)) {
      return;
    }
    visited.add(id);
    const node = nodes.get(id);
    for (const successor of node.succs) {
      visit(successor);
    }
    postorder.push(id);
  }
  visit(exitId);
  const rpo = { entry: exitId, nodes: new Map() };
  let index = 0;
  for (const id of postorder.reverse()) {
    const node = nodes.get(id);
    node.index = index++;
    rpo.nodes.set(id, node);
  }
  return rpo;
}
const DEFAULT_SHAPES = new Map(BUILTIN_SHAPES);
const UNTYPED_GLOBALS = new Set([
  "String",
  "Object",
  "Function",
  "Number",
  "RegExp",
  "Date",
  "Error",
  "Function",
  "TypeError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "URIError",
  "EvalError",
  "Boolean",
  "DataView",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Map",
  "Set",
  "WeakMap",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "ArrayBuffer",
  "JSON",
  "parseFloat",
  "parseInt",
  "console",
  "isNaN",
  "eval",
  "isFinite",
  "encodeURI",
  "decodeURI",
  "encodeURIComponent",
  "decodeURIComponent",
]);
const TYPED_GLOBALS = [
  [
    "Array",
    addObject(DEFAULT_SHAPES, "Array", [
      [
        "isArray",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [Effect.Read],
          restParam: null,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Primitive,
        }),
      ],
      [
        "of",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Read,
          returnType: { kind: "Object", shapeId: BuiltInArrayId },
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Mutable,
        }),
      ],
    ]),
  ],
  [
    "Math",
    addObject(DEFAULT_SHAPES, "Math", [
      ["PI", { kind: "Primitive" }],
      [
        "max",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Primitive,
        }),
      ],
    ]),
  ],
  ["Infinity", { kind: "Primitive" }],
  ["NaN", { kind: "Primitive" }],
  [
    "console",
    addObject(DEFAULT_SHAPES, "console", [
      [
        "error",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Primitive,
        }),
      ],
      [
        "info",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Primitive,
        }),
      ],
      [
        "log",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Primitive,
        }),
      ],
      [
        "table",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Primitive,
        }),
      ],
      [
        "trace",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Primitive,
        }),
      ],
      [
        "warn",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Read,
          returnType: { kind: "Primitive" },
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Primitive,
        }),
      ],
    ]),
  ],
  [
    "Boolean",
    addFunction(DEFAULT_SHAPES, [], {
      positionalParams: [],
      restParam: Effect.Read,
      returnType: { kind: "Primitive" },
      calleeEffect: Effect.Read,
      returnValueKind: ValueKind.Primitive,
    }),
  ],
  [
    "Number",
    addFunction(DEFAULT_SHAPES, [], {
      positionalParams: [],
      restParam: Effect.Read,
      returnType: { kind: "Primitive" },
      calleeEffect: Effect.Read,
      returnValueKind: ValueKind.Primitive,
    }),
  ],
  [
    "String",
    addFunction(DEFAULT_SHAPES, [], {
      positionalParams: [],
      restParam: Effect.Read,
      returnType: { kind: "Primitive" },
      calleeEffect: Effect.Read,
      returnValueKind: ValueKind.Primitive,
    }),
  ],
];
const REACT_APIS = [
  [
    "useContext",
    addHook(DEFAULT_SHAPES, {
      positionalParams: [],
      restParam: Effect.Read,
      returnType: { kind: "Poly" },
      calleeEffect: Effect.Read,
      hookKind: "useContext",
      returnValueKind: ValueKind.Frozen,
      returnValueReason: ValueReason.Context,
    }),
  ],
  [
    "useState",
    addHook(DEFAULT_SHAPES, {
      positionalParams: [],
      restParam: Effect.Freeze,
      returnType: { kind: "Object", shapeId: BuiltInUseStateId },
      calleeEffect: Effect.Read,
      hookKind: "useState",
      returnValueKind: ValueKind.Frozen,
      returnValueReason: ValueReason.State,
    }),
  ],
  [
    "useActionState",
    addHook(DEFAULT_SHAPES, {
      positionalParams: [],
      restParam: Effect.Freeze,
      returnType: { kind: "Object", shapeId: BuiltInUseActionStateId },
      calleeEffect: Effect.Read,
      hookKind: "useActionState",
      returnValueKind: ValueKind.Frozen,
      returnValueReason: ValueReason.State,
    }),
  ],
  [
    "useReducer",
    addHook(DEFAULT_SHAPES, {
      positionalParams: [],
      restParam: Effect.Freeze,
      returnType: { kind: "Object", shapeId: BuiltInUseReducerId },
      calleeEffect: Effect.Read,
      hookKind: "useReducer",
      returnValueKind: ValueKind.Frozen,
      returnValueReason: ValueReason.ReducerState,
    }),
  ],
  [
    "useRef",
    addHook(DEFAULT_SHAPES, {
      positionalParams: [],
      restParam: Effect.Capture,
      returnType: { kind: "Object", shapeId: BuiltInUseRefId },
      calleeEffect: Effect.Read,
      hookKind: "useRef",
      returnValueKind: ValueKind.Mutable,
    }),
  ],
  [
    "useMemo",
    addHook(DEFAULT_SHAPES, {
      positionalParams: [],
      restParam: Effect.Freeze,
      returnType: { kind: "Poly" },
      calleeEffect: Effect.Read,
      hookKind: "useMemo",
      returnValueKind: ValueKind.Frozen,
    }),
  ],
  [
    "useCallback",
    addHook(DEFAULT_SHAPES, {
      positionalParams: [],
      restParam: Effect.Freeze,
      returnType: { kind: "Poly" },
      calleeEffect: Effect.Read,
      hookKind: "useCallback",
      returnValueKind: ValueKind.Frozen,
    }),
  ],
  [
    "useEffect",
    addHook(
      DEFAULT_SHAPES,
      {
        positionalParams: [],
        restParam: Effect.Freeze,
        returnType: { kind: "Primitive" },
        calleeEffect: Effect.Read,
        hookKind: "useEffect",
        returnValueKind: ValueKind.Frozen,
      },
      BuiltInUseEffectHookId
    ),
  ],
  [
    "useLayoutEffect",
    addHook(
      DEFAULT_SHAPES,
      {
        positionalParams: [],
        restParam: Effect.Freeze,
        returnType: { kind: "Poly" },
        calleeEffect: Effect.Read,
        hookKind: "useLayoutEffect",
        returnValueKind: ValueKind.Frozen,
      },
      BuiltInUseLayoutEffectHookId
    ),
  ],
  [
    "useInsertionEffect",
    addHook(
      DEFAULT_SHAPES,
      {
        positionalParams: [],
        restParam: Effect.Freeze,
        returnType: { kind: "Poly" },
        calleeEffect: Effect.Read,
        hookKind: "useLayoutEffect",
        returnValueKind: ValueKind.Frozen,
      },
      BuiltInUseInsertionEffectHookId
    ),
  ],
  [
    "use",
    addFunction(
      DEFAULT_SHAPES,
      [],
      {
        positionalParams: [],
        restParam: Effect.Freeze,
        returnType: { kind: "Poly" },
        calleeEffect: Effect.Read,
        returnValueKind: ValueKind.Frozen,
      },
      BuiltInUseOperatorId
    ),
  ],
];
TYPED_GLOBALS.push(
  [
    "React",
    addObject(DEFAULT_SHAPES, null, [
      ...REACT_APIS,
      [
        "createElement",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Freeze,
          returnType: { kind: "Poly" },
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Frozen,
        }),
      ],
      [
        "cloneElement",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Freeze,
          returnType: { kind: "Poly" },
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Frozen,
        }),
      ],
      [
        "createRef",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: Effect.Capture,
          returnType: { kind: "Object", shapeId: BuiltInUseRefId },
          calleeEffect: Effect.Read,
          returnValueKind: ValueKind.Mutable,
        }),
      ],
    ]),
  ],
  [
    "_jsx",
    addFunction(DEFAULT_SHAPES, [], {
      positionalParams: [],
      restParam: Effect.Freeze,
      returnType: { kind: "Poly" },
      calleeEffect: Effect.Read,
      returnValueKind: ValueKind.Frozen,
    }),
  ]
);
const DEFAULT_GLOBALS = new Map(REACT_APIS);
for (const name of UNTYPED_GLOBALS) {
  DEFAULT_GLOBALS.set(name, { kind: "Poly" });
}
for (const [name, type_] of TYPED_GLOBALS) {
  DEFAULT_GLOBALS.set(name, type_);
}
DEFAULT_GLOBALS.set(
  "globalThis",
  addObject(DEFAULT_SHAPES, "globalThis", TYPED_GLOBALS)
);
function installReAnimatedTypes(globals, registry) {
  const frozenHooks = [
    "useFrameCallback",
    "useAnimatedStyle",
    "useAnimatedProps",
    "useAnimatedScrollHandler",
    "useAnimatedReaction",
    "useWorkletCallback",
  ];
  for (const hook of frozenHooks) {
    globals.set(
      hook,
      addHook(registry, {
        positionalParams: [],
        restParam: Effect.Freeze,
        returnType: { kind: "Poly" },
        returnValueKind: ValueKind.Frozen,
        noAlias: true,
        calleeEffect: Effect.Read,
        hookKind: "Custom",
      })
    );
  }
  const mutableHooks = ["useSharedValue", "useDerivedValue"];
  for (const hook of mutableHooks) {
    globals.set(
      hook,
      addHook(registry, {
        positionalParams: [],
        restParam: Effect.Freeze,
        returnType: { kind: "Poly" },
        returnValueKind: ValueKind.Mutable,
        noAlias: true,
        calleeEffect: Effect.Read,
        hookKind: "Custom",
      })
    );
  }
  const funcs = [
    "withTiming",
    "withSpring",
    "createAnimatedPropAdapter",
    "withDecay",
    "withRepeat",
    "runOnUI",
    "executeOnUIRuntimeSync",
  ];
  for (const fn of funcs) {
    globals.set(
      fn,
      addFunction(registry, [], {
        positionalParams: [],
        restParam: Effect.Read,
        returnType: { kind: "Poly" },
        calleeEffect: Effect.Read,
        returnValueKind: ValueKind.Mutable,
        noAlias: true,
      })
    );
  }
}
var _Environment_instances,
  _Environment_globals,
  _Environment_shapes,
  _Environment_nextIdentifer,
  _Environment_nextBlock,
  _Environment_nextScope,
  _Environment_contextIdentifiers,
  _Environment_hoistedIdentifiers,
  _Environment_isKnownReactModule,
  _Environment_getCustomHookType;
const ExternalFunctionSchema = zod.z.object({
  source: zod.z.string(),
  importSpecifierName: zod.z.string(),
});
const InstrumentationSchema = zod.z
  .object({
    fn: ExternalFunctionSchema,
    gating: ExternalFunctionSchema.nullish(),
    globalGating: zod.z.string().nullish(),
  })
  .refine(
    (opts) => opts.gating != null || opts.globalGating != null,
    "Expected at least one of gating or globalGating"
  );
const HookSchema = zod.z.object({
  effectKind: zod.z.nativeEnum(Effect),
  valueKind: zod.z.nativeEnum(ValueKind),
  noAlias: zod.z.boolean().default(false),
  transitiveMixedData: zod.z.boolean().default(false),
});
const EnvironmentConfigSchema = zod.z.object({
  customHooks: zod.z
    .map(zod.z.string(), HookSchema)
    .optional()
    .default(new Map()),
  customMacros: zod.z.nullable(zod.z.array(zod.z.string())).default(null),
  enableResetCacheOnSourceFileChanges: zod.z.boolean().default(false),
  enablePreserveExistingMemoizationGuarantees: zod.z.boolean().default(false),
  validatePreserveExistingMemoizationGuarantees: zod.z.boolean().default(true),
  enablePreserveExistingManualUseMemo: zod.z.boolean().default(false),
  enableForest: zod.z.boolean().default(false),
  enableUseTypeAnnotations: zod.z.boolean().default(false),
  enableReactiveScopesInHIR: zod.z.boolean().default(true),
  validateHooksUsage: zod.z.boolean().default(true),
  validateRefAccessDuringRender: zod.z.boolean().default(false),
  validateNoSetStateInRender: zod.z.boolean().default(true),
  validateMemoizedEffectDependencies: zod.z.boolean().default(false),
  validateNoCapitalizedCalls: zod.z
    .nullable(zod.z.array(zod.z.string()))
    .default(null),
  enableAssumeHooksFollowRulesOfReact: zod.z.boolean().default(true),
  enableTransitivelyFreezeFunctionExpressions: zod.z.boolean().default(true),
  enableEmitFreeze: ExternalFunctionSchema.nullish(),
  enableEmitHookGuards: ExternalFunctionSchema.nullish(),
  enableInstructionReordering: zod.z.boolean().default(false),
  enableEmitInstrumentForget: InstrumentationSchema.nullish(),
  assertValidMutableRanges: zod.z.boolean().default(false),
  enableChangeVariableCodegen: zod.z.boolean().default(false),
  enableMemoizationComments: zod.z.boolean().default(false),
  throwUnknownException__testonly: zod.z.boolean().default(false),
  enableSharedRuntime__testonly: zod.z.boolean().default(false),
  enableTreatFunctionDepsAsConditional: zod.z.boolean().default(false),
  disableMemoizationForDebugging: zod.z.boolean().default(false),
  enableChangeDetectionForDebugging: ExternalFunctionSchema.nullish(),
  enableCustomTypeDefinitionForReanimated: zod.z.boolean().default(false),
  hookPattern: zod.z.string().nullable().default(null),
  enableTreatRefLikeIdentifiersAsRefs: zod.z
    .boolean()
    .nullable()
    .default(false),
});
class Environment {
  constructor(
    fnType,
    config,
    contextIdentifiers,
    logger,
    filename,
    code,
    useMemoCacheIdentifier
  ) {
    _Environment_instances.add(this);
    _Environment_globals.set(this, void 0);
    _Environment_shapes.set(this, void 0);
    _Environment_nextIdentifer.set(this, 0);
    _Environment_nextBlock.set(this, 0);
    _Environment_nextScope.set(this, 0);
    _Environment_contextIdentifiers.set(this, void 0);
    _Environment_hoistedIdentifiers.set(this, void 0);
    this.fnType = fnType;
    this.config = config;
    this.filename = filename;
    this.code = code;
    this.logger = logger;
    this.useMemoCacheIdentifier = useMemoCacheIdentifier;
    __classPrivateFieldSet(
      this,
      _Environment_shapes,
      new Map(DEFAULT_SHAPES),
      "f"
    );
    __classPrivateFieldSet(
      this,
      _Environment_globals,
      new Map(DEFAULT_GLOBALS),
      "f"
    );
    if (
      config.disableMemoizationForDebugging &&
      config.enableChangeDetectionForDebugging != null
    ) {
      CompilerError.throwInvalidConfig({
        reason: `Invalid environment config: the 'disableMemoizationForDebugging' and 'enableChangeDetectionForDebugging' options cannot be used together`,
        description: null,
        loc: null,
        suggestions: null,
      });
    }
    for (const [hookName, hook] of this.config.customHooks) {
      CompilerError.invariant(
        !__classPrivateFieldGet(this, _Environment_globals, "f").has(hookName),
        {
          reason: `[Globals] Found existing definition in global registry for custom hook ${hookName}`,
          description: null,
          loc: null,
          suggestions: null,
        }
      );
      __classPrivateFieldGet(this, _Environment_globals, "f").set(
        hookName,
        addHook(__classPrivateFieldGet(this, _Environment_shapes, "f"), {
          positionalParams: [],
          restParam: hook.effectKind,
          returnType: hook.transitiveMixedData
            ? { kind: "Object", shapeId: BuiltInMixedReadonlyId }
            : { kind: "Poly" },
          returnValueKind: hook.valueKind,
          calleeEffect: Effect.Read,
          hookKind: "Custom",
          noAlias: hook.noAlias,
        })
      );
    }
    if (config.enableCustomTypeDefinitionForReanimated) {
      installReAnimatedTypes(
        __classPrivateFieldGet(this, _Environment_globals, "f"),
        __classPrivateFieldGet(this, _Environment_shapes, "f")
      );
    }
    __classPrivateFieldSet(
      this,
      _Environment_contextIdentifiers,
      contextIdentifiers,
      "f"
    );
    __classPrivateFieldSet(
      this,
      _Environment_hoistedIdentifiers,
      new Set(),
      "f"
    );
  }
  get nextIdentifierId() {
    var _a, _b;
    return makeIdentifierId(
      (__classPrivateFieldSet(
        this,
        _Environment_nextIdentifer,
        ((_b = __classPrivateFieldGet(this, _Environment_nextIdentifer, "f")),
        (_a = _b++),
        _b),
        "f"
      ),
      _a)
    );
  }
  get nextBlockId() {
    var _a, _b;
    return makeBlockId(
      (__classPrivateFieldSet(
        this,
        _Environment_nextBlock,
        ((_b = __classPrivateFieldGet(this, _Environment_nextBlock, "f")),
        (_a = _b++),
        _b),
        "f"
      ),
      _a)
    );
  }
  get nextScopeId() {
    var _a, _b;
    return makeScopeId(
      (__classPrivateFieldSet(
        this,
        _Environment_nextScope,
        ((_b = __classPrivateFieldGet(this, _Environment_nextScope, "f")),
        (_a = _b++),
        _b),
        "f"
      ),
      _a)
    );
  }
  isContextIdentifier(node) {
    return __classPrivateFieldGet(
      this,
      _Environment_contextIdentifiers,
      "f"
    ).has(node);
  }
  isHoistedIdentifier(node) {
    return __classPrivateFieldGet(
      this,
      _Environment_hoistedIdentifiers,
      "f"
    ).has(node);
  }
  getGlobalDeclaration(binding) {
    var _a, _b, _c, _d;
    if (this.config.hookPattern != null) {
      const match = new RegExp(this.config.hookPattern).exec(binding.name);
      if (
        match != null &&
        typeof match[1] === "string" &&
        isHookName$1(match[1])
      ) {
        const resolvedName = match[1];
        return (_a = __classPrivateFieldGet(
          this,
          _Environment_globals,
          "f"
        ).get(resolvedName)) !== null && _a !== void 0
          ? _a
          : __classPrivateFieldGet(
              this,
              _Environment_instances,
              "m",
              _Environment_getCustomHookType
            ).call(this);
      }
    }
    switch (binding.kind) {
      case "ModuleLocal": {
        return isHookName$1(binding.name)
          ? __classPrivateFieldGet(
              this,
              _Environment_instances,
              "m",
              _Environment_getCustomHookType
            ).call(this)
          : null;
      }
      case "Global": {
        return (_b = __classPrivateFieldGet(
          this,
          _Environment_globals,
          "f"
        ).get(binding.name)) !== null && _b !== void 0
          ? _b
          : isHookName$1(binding.name)
            ? __classPrivateFieldGet(
                this,
                _Environment_instances,
                "m",
                _Environment_getCustomHookType
              ).call(this)
            : null;
      }
      case "ImportSpecifier": {
        if (
          __classPrivateFieldGet(
            this,
            _Environment_instances,
            "m",
            _Environment_isKnownReactModule
          ).call(this, binding.module)
        ) {
          return (_c = __classPrivateFieldGet(
            this,
            _Environment_globals,
            "f"
          ).get(binding.imported)) !== null && _c !== void 0
            ? _c
            : isHookName$1(binding.imported)
              ? __classPrivateFieldGet(
                  this,
                  _Environment_instances,
                  "m",
                  _Environment_getCustomHookType
                ).call(this)
              : null;
        } else {
          return isHookName$1(binding.imported) || isHookName$1(binding.name)
            ? __classPrivateFieldGet(
                this,
                _Environment_instances,
                "m",
                _Environment_getCustomHookType
              ).call(this)
            : null;
        }
      }
      case "ImportDefault":
      case "ImportNamespace": {
        if (
          __classPrivateFieldGet(
            this,
            _Environment_instances,
            "m",
            _Environment_isKnownReactModule
          ).call(this, binding.module)
        ) {
          return (_d = __classPrivateFieldGet(
            this,
            _Environment_globals,
            "f"
          ).get(binding.name)) !== null && _d !== void 0
            ? _d
            : isHookName$1(binding.name)
              ? __classPrivateFieldGet(
                  this,
                  _Environment_instances,
                  "m",
                  _Environment_getCustomHookType
                ).call(this)
              : null;
        } else {
          return isHookName$1(binding.name)
            ? __classPrivateFieldGet(
                this,
                _Environment_instances,
                "m",
                _Environment_getCustomHookType
              ).call(this)
            : null;
        }
      }
    }
  }
  getPropertyType(receiver, property) {
    var _a, _b;
    let shapeId = null;
    if (receiver.kind === "Object" || receiver.kind === "Function") {
      shapeId = receiver.shapeId;
    }
    if (shapeId !== null) {
      const shape = __classPrivateFieldGet(this, _Environment_shapes, "f").get(
        shapeId
      );
      CompilerError.invariant(shape !== undefined, {
        reason: `[HIR] Forget internal error: cannot resolve shape ${shapeId}`,
        description: null,
        loc: null,
        suggestions: null,
      });
      let value =
        (_b =
          (_a = shape.properties.get(property)) !== null && _a !== void 0
            ? _a
            : shape.properties.get("*")) !== null && _b !== void 0
          ? _b
          : null;
      if (value === null && isHookName$1(property)) {
        value = __classPrivateFieldGet(
          this,
          _Environment_instances,
          "m",
          _Environment_getCustomHookType
        ).call(this);
      }
      return value;
    } else if (isHookName$1(property)) {
      return __classPrivateFieldGet(
        this,
        _Environment_instances,
        "m",
        _Environment_getCustomHookType
      ).call(this);
    } else {
      return null;
    }
  }
  getFunctionSignature(type) {
    const { shapeId: shapeId } = type;
    if (shapeId !== null) {
      const shape = __classPrivateFieldGet(this, _Environment_shapes, "f").get(
        shapeId
      );
      CompilerError.invariant(shape !== undefined, {
        reason: `[HIR] Forget internal error: cannot resolve shape ${shapeId}`,
        description: null,
        loc: null,
        suggestions: null,
      });
      return shape.functionType;
    }
    return null;
  }
  addHoistedIdentifier(node) {
    __classPrivateFieldGet(this, _Environment_contextIdentifiers, "f").add(
      node
    );
    __classPrivateFieldGet(this, _Environment_hoistedIdentifiers, "f").add(
      node
    );
  }
}
(_Environment_globals = new WeakMap()),
  (_Environment_shapes = new WeakMap()),
  (_Environment_nextIdentifer = new WeakMap()),
  (_Environment_nextBlock = new WeakMap()),
  (_Environment_nextScope = new WeakMap()),
  (_Environment_contextIdentifiers = new WeakMap()),
  (_Environment_hoistedIdentifiers = new WeakMap()),
  (_Environment_instances = new WeakSet()),
  (_Environment_isKnownReactModule = function _Environment_isKnownReactModule(
    moduleName
  ) {
    return (
      moduleName.toLowerCase() === "react" ||
      moduleName.toLowerCase() === "react-dom" ||
      (this.config.enableSharedRuntime__testonly &&
        moduleName === "shared-runtime")
    );
  }),
  (_Environment_getCustomHookType = function _Environment_getCustomHookType() {
    if (this.config.enableAssumeHooksFollowRulesOfReact) {
      return DefaultNonmutatingHook;
    } else {
      return DefaultMutatingHook;
    }
  });
function isHookName$1(name) {
  return /^use[A-Z0-9]/.test(name);
}
function parseEnvironmentConfig(partialConfig) {
  const config = EnvironmentConfigSchema.safeParse(partialConfig);
  if (config.success) {
    return Ok(config.data);
  } else {
    return Err(config.error);
  }
}
function validateEnvironmentConfig(partialConfig) {
  const config = EnvironmentConfigSchema.safeParse(partialConfig);
  if (config.success) {
    return config.data;
  }
  CompilerError.throwInvalidConfig({
    reason:
      "Could not validate environment config. Update React Compiler config to fix the error",
    description: `${zodValidationError.fromZodError(config.error)}`,
    loc: null,
    suggestions: null,
  });
}
function tryParseExternalFunction(maybeExternalFunction) {
  const externalFunction = ExternalFunctionSchema.safeParse(
    maybeExternalFunction
  );
  if (externalFunction.success) {
    return externalFunction.data;
  }
  CompilerError.throwInvalidConfig({
    reason:
      "Could not parse external function. Update React Compiler config to fix the error",
    description: `${zodValidationError.fromZodError(externalFunction.error)}`,
    loc: null,
    suggestions: null,
  });
}
var _MergedBlocks_map;
function mergeConsecutiveBlocks(fn) {
  const merged = new MergedBlocks();
  const fallthroughBlocks = new Set();
  for (const [, block] of fn.body.blocks) {
    const fallthrough = terminalFallthrough(block.terminal);
    if (fallthrough !== null) {
      fallthroughBlocks.add(fallthrough);
    }
    for (const instr of block.instructions) {
      if (
        instr.value.kind === "FunctionExpression" ||
        instr.value.kind === "ObjectMethod"
      ) {
        mergeConsecutiveBlocks(instr.value.loweredFunc.func);
      }
    }
    if (
      block.preds.size !== 1 ||
      block.kind !== "block" ||
      fallthroughBlocks.has(block.id)
    ) {
      continue;
    }
    const originalPredecessorId = Array.from(block.preds)[0];
    const predecessorId = merged.get(originalPredecessorId);
    const predecessor = fn.body.blocks.get(predecessorId);
    CompilerError.invariant(predecessor !== undefined, {
      reason: `Expected predecessor ${predecessorId} to exist`,
      description: null,
      loc: null,
      suggestions: null,
    });
    if (predecessor.terminal.kind !== "goto" || predecessor.kind !== "block") {
      continue;
    }
    for (const phi of block.phis) {
      CompilerError.invariant(phi.operands.size === 1, {
        reason: `Found a block with a single predecessor but where a phi has multiple (${phi.operands.size}) operands`,
        description: null,
        loc: null,
        suggestions: null,
      });
      const operand = Array.from(phi.operands.values())[0];
      const instr = {
        id: predecessor.terminal.id,
        lvalue: {
          kind: "Identifier",
          identifier: phi.id,
          effect: Effect.ConditionallyMutate,
          reactive: false,
          loc: GeneratedSource,
        },
        value: {
          kind: "LoadLocal",
          place: {
            kind: "Identifier",
            identifier: operand,
            effect: Effect.Read,
            reactive: false,
            loc: GeneratedSource,
          },
          loc: GeneratedSource,
        },
        loc: GeneratedSource,
      };
      predecessor.instructions.push(instr);
    }
    predecessor.instructions.push(...block.instructions);
    predecessor.terminal = block.terminal;
    merged.merge(block.id, predecessorId);
    fn.body.blocks.delete(block.id);
  }
  markPredecessors(fn.body);
  for (const [, { terminal: terminal }] of fn.body.blocks) {
    if (terminalHasFallthrough(terminal)) {
      terminal.fallthrough = merged.get(terminal.fallthrough);
    }
  }
}
class MergedBlocks {
  constructor() {
    _MergedBlocks_map.set(this, new Map());
  }
  merge(block, into) {
    const target = this.get(into);
    __classPrivateFieldGet(this, _MergedBlocks_map, "f").set(block, target);
  }
  get(block) {
    var _a;
    let current = block;
    while (__classPrivateFieldGet(this, _MergedBlocks_map, "f").has(current)) {
      current =
        (_a = __classPrivateFieldGet(this, _MergedBlocks_map, "f").get(
          current
        )) !== null && _a !== void 0
          ? _a
          : current;
    }
    return current;
  }
}
_MergedBlocks_map = new WeakMap();
function visitReactiveFunction(fn, visitor, state) {
  visitor.visitBlock(fn.body, state);
}
class ReactiveFunctionVisitor {
  visitID(_id, _state) {}
  visitParam(_place, _state) {}
  visitLValue(_id, _lvalue, _state) {}
  visitPlace(_id, _place, _state) {}
  visitReactiveFunctionValue(_id, _dependencies, _fn, _state) {}
  visitValue(id, value, state) {
    this.traverseValue(id, value, state);
  }
  traverseValue(id, value, state) {
    switch (value.kind) {
      case "OptionalExpression": {
        this.visitValue(id, value.value, state);
        break;
      }
      case "LogicalExpression": {
        this.visitValue(id, value.left, state);
        this.visitValue(id, value.right, state);
        break;
      }
      case "ConditionalExpression": {
        this.visitValue(id, value.test, state);
        this.visitValue(id, value.consequent, state);
        this.visitValue(id, value.alternate, state);
        break;
      }
      case "SequenceExpression": {
        for (const instr of value.instructions) {
          this.visitInstruction(instr, state);
        }
        this.visitValue(value.id, value.value, state);
        break;
      }
      case "ReactiveFunctionValue": {
        this.visitReactiveFunctionValue(
          id,
          value.dependencies,
          value.fn,
          state
        );
        break;
      }
      default: {
        for (const place of eachInstructionValueOperand(value)) {
          this.visitPlace(id, place, state);
        }
      }
    }
  }
  visitInstruction(instruction, state) {
    this.traverseInstruction(instruction, state);
  }
  traverseInstruction(instruction, state) {
    this.visitID(instruction.id, state);
    for (const operand of eachInstructionLValue(instruction)) {
      this.visitLValue(instruction.id, operand, state);
    }
    this.visitValue(instruction.id, instruction.value, state);
  }
  visitTerminal(stmt, state) {
    this.traverseTerminal(stmt, state);
  }
  traverseTerminal(stmt, state) {
    const { terminal: terminal } = stmt;
    if (terminal.id !== null) {
      this.visitID(terminal.id, state);
    }
    switch (terminal.kind) {
      case "break":
      case "continue": {
        break;
      }
      case "return": {
        this.visitPlace(terminal.id, terminal.value, state);
        break;
      }
      case "throw": {
        this.visitPlace(terminal.id, terminal.value, state);
        break;
      }
      case "for": {
        this.visitValue(terminal.id, terminal.init, state);
        this.visitValue(terminal.id, terminal.test, state);
        this.visitBlock(terminal.loop, state);
        if (terminal.update !== null) {
          this.visitValue(terminal.id, terminal.update, state);
        }
        break;
      }
      case "for-of": {
        this.visitValue(terminal.id, terminal.init, state);
        this.visitValue(terminal.id, terminal.test, state);
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "for-in": {
        this.visitValue(terminal.id, terminal.init, state);
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "do-while": {
        this.visitBlock(terminal.loop, state);
        this.visitValue(terminal.id, terminal.test, state);
        break;
      }
      case "while": {
        this.visitValue(terminal.id, terminal.test, state);
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "if": {
        this.visitPlace(terminal.id, terminal.test, state);
        this.visitBlock(terminal.consequent, state);
        if (terminal.alternate !== null) {
          this.visitBlock(terminal.alternate, state);
        }
        break;
      }
      case "switch": {
        this.visitPlace(terminal.id, terminal.test, state);
        for (const case_ of terminal.cases) {
          if (case_.test !== null) {
            this.visitPlace(terminal.id, case_.test, state);
          }
          if (case_.block !== undefined) {
            this.visitBlock(case_.block, state);
          }
        }
        break;
      }
      case "label": {
        this.visitBlock(terminal.block, state);
        break;
      }
      case "try": {
        this.visitBlock(terminal.block, state);
        this.visitBlock(terminal.handler, state);
        break;
      }
      default: {
        assertExhaustive$1(
          terminal,
          `Unexpected terminal kind \`${terminal.kind}\``
        );
      }
    }
  }
  visitScope(scope, state) {
    this.traverseScope(scope, state);
  }
  traverseScope(scope, state) {
    this.visitBlock(scope.instructions, state);
  }
  visitPrunedScope(scopeBlock, state) {
    this.traversePrunedScope(scopeBlock, state);
  }
  traversePrunedScope(scopeBlock, state) {
    this.visitBlock(scopeBlock.instructions, state);
  }
  visitBlock(block, state) {
    this.traverseBlock(block, state);
  }
  traverseBlock(block, state) {
    for (const instr of block) {
      switch (instr.kind) {
        case "instruction": {
          this.visitInstruction(instr.instruction, state);
          break;
        }
        case "scope": {
          this.visitScope(instr, state);
          break;
        }
        case "pruned-scope": {
          this.visitPrunedScope(instr, state);
          break;
        }
        case "terminal": {
          this.visitTerminal(instr, state);
          break;
        }
        default: {
          assertExhaustive$1(
            instr,
            `Unexpected instruction kind \`${instr.kind}\``
          );
        }
      }
    }
  }
  visitHirFunction(fn, state) {
    for (const param of fn.params) {
      const place = param.kind === "Identifier" ? param : param.place;
      this.visitParam(place, state);
    }
    for (const [, block] of fn.body.blocks) {
      for (const instr of block.instructions) {
        this.visitInstruction(instr, state);
        if (
          instr.value.kind === "FunctionExpression" ||
          instr.value.kind === "ObjectMethod"
        ) {
          this.visitHirFunction(instr.value.loweredFunc.func, state);
        }
      }
      for (const operand of eachTerminalOperand(block.terminal)) {
        this.visitPlace(block.terminal.id, operand, state);
      }
    }
  }
}
class ReactiveFunctionTransform extends ReactiveFunctionVisitor {
  traverseBlock(block, state) {
    let nextBlock = null;
    for (let i = 0; i < block.length; i++) {
      const instr = block[i];
      let transformed;
      switch (instr.kind) {
        case "instruction": {
          transformed = this.transformInstruction(instr.instruction, state);
          break;
        }
        case "scope": {
          transformed = this.transformScope(instr, state);
          break;
        }
        case "pruned-scope": {
          transformed = this.transformPrunedScope(instr, state);
          break;
        }
        case "terminal": {
          transformed = this.transformTerminal(instr, state);
          break;
        }
        default: {
          assertExhaustive$1(
            instr,
            `Unexpected instruction kind \`${instr.kind}\``
          );
        }
      }
      switch (transformed.kind) {
        case "keep": {
          if (nextBlock !== null) {
            nextBlock.push(instr);
          }
          break;
        }
        case "remove": {
          if (nextBlock === null) {
            nextBlock = block.slice(0, i);
          }
          break;
        }
        case "replace": {
          nextBlock !== null && nextBlock !== void 0
            ? nextBlock
            : (nextBlock = block.slice(0, i));
          nextBlock.push(transformed.value);
          break;
        }
        case "replace-many": {
          nextBlock !== null && nextBlock !== void 0
            ? nextBlock
            : (nextBlock = block.slice(0, i));
          nextBlock.push(...transformed.value);
          break;
        }
      }
    }
    if (nextBlock !== null) {
      block.length = 0;
      block.push(...nextBlock);
    }
  }
  transformInstruction(instruction, state) {
    this.visitInstruction(instruction, state);
    return { kind: "keep" };
  }
  transformTerminal(stmt, state) {
    this.visitTerminal(stmt, state);
    return { kind: "keep" };
  }
  transformScope(scope, state) {
    this.visitScope(scope, state);
    return { kind: "keep" };
  }
  transformPrunedScope(scope, state) {
    this.visitPrunedScope(scope, state);
    return { kind: "keep" };
  }
  transformValue(id, value, state) {
    this.visitValue(id, value, state);
    return { kind: "keep" };
  }
  transformReactiveFunctionValue(id, dependencies, fn, state) {
    this.visitReactiveFunctionValue(id, dependencies, fn, state);
    return { kind: "keep" };
  }
  traverseValue(id, value, state) {
    switch (value.kind) {
      case "OptionalExpression": {
        const nextValue = this.transformValue(id, value.value, state);
        if (nextValue.kind === "replace") {
          value.value = nextValue.value;
        }
        break;
      }
      case "LogicalExpression": {
        const left = this.transformValue(id, value.left, state);
        if (left.kind === "replace") {
          value.left = left.value;
        }
        const right = this.transformValue(id, value.right, state);
        if (right.kind === "replace") {
          value.right = right.value;
        }
        break;
      }
      case "ConditionalExpression": {
        const test = this.transformValue(id, value.test, state);
        if (test.kind === "replace") {
          value.test = test.value;
        }
        const consequent = this.transformValue(id, value.consequent, state);
        if (consequent.kind === "replace") {
          value.consequent = consequent.value;
        }
        const alternate = this.transformValue(id, value.alternate, state);
        if (alternate.kind === "replace") {
          value.alternate = alternate.value;
        }
        break;
      }
      case "SequenceExpression": {
        for (const instr of value.instructions) {
          this.visitInstruction(instr, state);
        }
        const nextValue = this.transformValue(value.id, value.value, state);
        if (nextValue.kind === "replace") {
          value.value = nextValue.value;
        }
        break;
      }
      case "ReactiveFunctionValue": {
        const nextValue = this.transformReactiveFunctionValue(
          id,
          value.dependencies,
          value.fn,
          state
        );
        if (nextValue.kind === "replace") {
          value.fn = nextValue.value;
        }
        break;
      }
      default: {
        for (const place of eachInstructionValueOperand(value)) {
          this.visitPlace(id, place, state);
        }
      }
    }
  }
  traverseInstruction(instruction, state) {
    this.visitID(instruction.id, state);
    for (const operand of eachInstructionLValue(instruction)) {
      this.visitLValue(instruction.id, operand, state);
    }
    const nextValue = this.transformValue(
      instruction.id,
      instruction.value,
      state
    );
    if (nextValue.kind === "replace") {
      instruction.value = nextValue.value;
    }
  }
  traverseTerminal(stmt, state) {
    const { terminal: terminal } = stmt;
    if (terminal.id !== null) {
      this.visitID(terminal.id, state);
    }
    switch (terminal.kind) {
      case "break":
      case "continue": {
        break;
      }
      case "return": {
        this.visitPlace(terminal.id, terminal.value, state);
        break;
      }
      case "throw": {
        this.visitPlace(terminal.id, terminal.value, state);
        break;
      }
      case "for": {
        const init = this.transformValue(terminal.id, terminal.init, state);
        if (init.kind === "replace") {
          terminal.init = init.value;
        }
        const test = this.transformValue(terminal.id, terminal.test, state);
        if (test.kind === "replace") {
          terminal.test = test.value;
        }
        if (terminal.update !== null) {
          const update = this.transformValue(
            terminal.id,
            terminal.update,
            state
          );
          if (update.kind === "replace") {
            terminal.update = update.value;
          }
        }
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "for-of": {
        const init = this.transformValue(terminal.id, terminal.init, state);
        if (init.kind === "replace") {
          terminal.init = init.value;
        }
        const test = this.transformValue(terminal.id, terminal.test, state);
        if (test.kind === "replace") {
          terminal.test = test.value;
        }
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "for-in": {
        const init = this.transformValue(terminal.id, terminal.init, state);
        if (init.kind === "replace") {
          terminal.init = init.value;
        }
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "do-while": {
        this.visitBlock(terminal.loop, state);
        const test = this.transformValue(terminal.id, terminal.test, state);
        if (test.kind === "replace") {
          terminal.test = test.value;
        }
        break;
      }
      case "while": {
        const test = this.transformValue(terminal.id, terminal.test, state);
        if (test.kind === "replace") {
          terminal.test = test.value;
        }
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "if": {
        this.visitPlace(terminal.id, terminal.test, state);
        this.visitBlock(terminal.consequent, state);
        if (terminal.alternate !== null) {
          this.visitBlock(terminal.alternate, state);
        }
        break;
      }
      case "switch": {
        this.visitPlace(terminal.id, terminal.test, state);
        for (const case_ of terminal.cases) {
          if (case_.test !== null) {
            this.visitPlace(terminal.id, case_.test, state);
          }
          if (case_.block !== undefined) {
            this.visitBlock(case_.block, state);
          }
        }
        break;
      }
      case "label": {
        this.visitBlock(terminal.block, state);
        break;
      }
      case "try": {
        this.visitBlock(terminal.block, state);
        if (terminal.handlerBinding !== null) {
          this.visitPlace(terminal.id, terminal.handlerBinding, state);
        }
        this.visitBlock(terminal.handler, state);
        break;
      }
      default: {
        assertExhaustive$1(
          terminal,
          `Unexpected terminal kind \`${terminal.kind}\``
        );
      }
    }
  }
}
function* eachReactiveValueOperand(instrValue) {
  switch (instrValue.kind) {
    case "OptionalExpression": {
      yield* eachReactiveValueOperand(instrValue.value);
      break;
    }
    case "LogicalExpression": {
      yield* eachReactiveValueOperand(instrValue.left);
      yield* eachReactiveValueOperand(instrValue.right);
      break;
    }
    case "SequenceExpression": {
      for (const instr of instrValue.instructions) {
        yield* eachReactiveValueOperand(instr.value);
      }
      yield* eachReactiveValueOperand(instrValue.value);
      break;
    }
    case "ConditionalExpression": {
      yield* eachReactiveValueOperand(instrValue.test);
      yield* eachReactiveValueOperand(instrValue.consequent);
      yield* eachReactiveValueOperand(instrValue.alternate);
      break;
    }
    case "ReactiveFunctionValue": {
      yield* instrValue.dependencies;
      break;
    }
    default: {
      yield* eachInstructionValueOperand(instrValue);
    }
  }
}
function mapTerminalBlocks(terminal, fn) {
  switch (terminal.kind) {
    case "break":
    case "continue":
    case "return":
    case "throw": {
      break;
    }
    case "for": {
      terminal.loop = fn(terminal.loop);
      break;
    }
    case "for-of": {
      terminal.loop = fn(terminal.loop);
      break;
    }
    case "for-in": {
      terminal.loop = fn(terminal.loop);
      break;
    }
    case "do-while":
    case "while": {
      terminal.loop = fn(terminal.loop);
      break;
    }
    case "if": {
      terminal.consequent = fn(terminal.consequent);
      if (terminal.alternate !== null) {
        terminal.alternate = fn(terminal.alternate);
      }
      break;
    }
    case "switch": {
      for (const case_ of terminal.cases) {
        if (case_.block !== undefined) {
          case_.block = fn(case_.block);
        }
      }
      break;
    }
    case "label": {
      terminal.block = fn(terminal.block);
      break;
    }
    case "try": {
      terminal.block = fn(terminal.block);
      terminal.handler = fn(terminal.handler);
      break;
    }
    default: {
      assertExhaustive$1(
        terminal,
        `Unexpected terminal kind \`${terminal.kind}\``
      );
    }
  }
}
var _Context_builders, _Context_scopes$1, _Builder_instructions, _Builder_stack;
function buildReactiveBlocks(fn) {
  const context = new Context$5();
  fn.body = context.enter(() => {
    visitBlock(context, fn.body);
  });
}
let Context$5 = class Context {
  constructor() {
    _Context_builders.set(this, []);
    _Context_scopes$1.set(this, new Set());
  }
  visitId(id) {
    const builder = __classPrivateFieldGet(this, _Context_builders, "f").at(-1);
    builder.visitId(id);
  }
  visitScope(scope) {
    if (__classPrivateFieldGet(this, _Context_scopes$1, "f").has(scope.id)) {
      return;
    }
    __classPrivateFieldGet(this, _Context_scopes$1, "f").add(scope.id);
    __classPrivateFieldGet(this, _Context_builders, "f")
      .at(-1)
      .startScope(scope);
  }
  append(stmt, label) {
    __classPrivateFieldGet(this, _Context_builders, "f")
      .at(-1)
      .append(stmt, label);
  }
  enter(fn) {
    const builder = new Builder();
    __classPrivateFieldGet(this, _Context_builders, "f").push(builder);
    fn();
    const popped = __classPrivateFieldGet(this, _Context_builders, "f").pop();
    CompilerError.invariant(popped === builder, {
      reason: "Expected push/pop to be called 1:1",
      description: null,
      loc: null,
      suggestions: null,
    });
    return builder.complete();
  }
};
(_Context_builders = new WeakMap()), (_Context_scopes$1 = new WeakMap());
class Builder {
  constructor() {
    _Builder_instructions.set(this, void 0);
    _Builder_stack.set(this, void 0);
    const block = [];
    __classPrivateFieldSet(this, _Builder_instructions, block, "f");
    __classPrivateFieldSet(
      this,
      _Builder_stack,
      [{ kind: "block", block: block }],
      "f"
    );
  }
  append(item, label) {
    if (label !== null) {
      CompilerError.invariant(item.kind === "terminal", {
        reason: "Only terminals may have a label",
        description: null,
        loc: null,
        suggestions: null,
      });
      item.label = label;
    }
    __classPrivateFieldGet(this, _Builder_instructions, "f").push(item);
  }
  startScope(scope) {
    const block = { kind: "scope", scope: scope, instructions: [] };
    this.append(block, null);
    __classPrivateFieldSet(
      this,
      _Builder_instructions,
      block.instructions,
      "f"
    );
    __classPrivateFieldGet(this, _Builder_stack, "f").push({
      kind: "scope",
      block: block,
    });
  }
  visitId(id) {
    for (
      let i = 0;
      i < __classPrivateFieldGet(this, _Builder_stack, "f").length;
      i++
    ) {
      const entry = __classPrivateFieldGet(this, _Builder_stack, "f")[i];
      if (entry.kind === "scope" && id >= entry.block.scope.range.end) {
        __classPrivateFieldGet(this, _Builder_stack, "f").length = i;
        break;
      }
    }
    const last = __classPrivateFieldGet(this, _Builder_stack, "f")[
      __classPrivateFieldGet(this, _Builder_stack, "f").length - 1
    ];
    if (last.kind === "block") {
      __classPrivateFieldSet(this, _Builder_instructions, last.block, "f");
    } else {
      __classPrivateFieldSet(
        this,
        _Builder_instructions,
        last.block.instructions,
        "f"
      );
    }
  }
  complete() {
    const first = __classPrivateFieldGet(this, _Builder_stack, "f")[0];
    CompilerError.invariant(first.kind === "block", {
      reason: "Expected first stack item to be a basic block",
      description: null,
      loc: null,
      suggestions: null,
    });
    return first.block;
  }
}
(_Builder_instructions = new WeakMap()), (_Builder_stack = new WeakMap());
function visitBlock(context, block) {
  for (const stmt of block) {
    switch (stmt.kind) {
      case "instruction": {
        context.visitId(stmt.instruction.id);
        const scope = getInstructionScope(stmt.instruction);
        if (scope !== null) {
          context.visitScope(scope);
        }
        context.append(stmt, null);
        break;
      }
      case "terminal": {
        const id = stmt.terminal.id;
        if (id !== null) {
          context.visitId(id);
        }
        mapTerminalBlocks(stmt.terminal, (block) =>
          context.enter(() => {
            visitBlock(context, block);
          })
        );
        context.append(stmt, stmt.label);
        break;
      }
      case "pruned-scope":
      case "scope": {
        CompilerError.invariant(false, {
          reason: "Expected the function to not have scopes already assigned",
          description: null,
          loc: null,
          suggestions: null,
        });
      }
      default: {
        assertExhaustive$1(stmt, `Unexpected statement kind \`${stmt.kind}\``);
      }
    }
  }
}
function getInstructionScope(instr) {
  CompilerError.invariant(instr.lvalue !== null, {
    reason:
      "Expected lvalues to not be null when assigning scopes. " +
      "Pruning lvalues too early can result in missing scope information.",
    description: null,
    loc: instr.loc,
    suggestions: null,
  });
  for (const operand of eachInstructionLValue(instr)) {
    const operandScope = getPlaceScope(instr.id, operand);
    if (operandScope !== null) {
      return operandScope;
    }
  }
  for (const operand of eachReactiveValueOperand(instr.value)) {
    const operandScope = getPlaceScope(instr.id, operand);
    if (operandScope !== null) {
      return operandScope;
    }
  }
  return null;
}
function getPlaceScope(id, place) {
  const scope = place.identifier.scope;
  if (scope !== null && isScopeActive(scope, id)) {
    return scope;
  }
  return null;
}
function isScopeActive(scope, id) {
  return id >= scope.range.start && id < scope.range.end;
}
var _DisjointSet_entries;
class DisjointSet {
  constructor() {
    _DisjointSet_entries.set(this, new Map());
  }
  union(items) {
    const first = items.shift();
    CompilerError.invariant(first != null, {
      reason: "Expected set to be non-empty",
      description: null,
      loc: null,
      suggestions: null,
    });
    let root = this.find(first);
    if (root == null) {
      root = first;
      __classPrivateFieldGet(this, _DisjointSet_entries, "f").set(first, first);
    }
    for (const item of items) {
      let itemParent = __classPrivateFieldGet(
        this,
        _DisjointSet_entries,
        "f"
      ).get(item);
      if (itemParent == null) {
        __classPrivateFieldGet(this, _DisjointSet_entries, "f").set(item, root);
        continue;
      } else if (itemParent === root) {
        continue;
      } else {
        let current = item;
        while (itemParent !== root) {
          __classPrivateFieldGet(this, _DisjointSet_entries, "f").set(
            current,
            root
          );
          current = itemParent;
          itemParent = __classPrivateFieldGet(
            this,
            _DisjointSet_entries,
            "f"
          ).get(current);
        }
      }
    }
  }
  find(item) {
    if (!__classPrivateFieldGet(this, _DisjointSet_entries, "f").has(item)) {
      return null;
    }
    const parent = __classPrivateFieldGet(this, _DisjointSet_entries, "f").get(
      item
    );
    if (parent === item) {
      return item;
    }
    const root = this.find(parent);
    __classPrivateFieldGet(this, _DisjointSet_entries, "f").set(item, root);
    return root;
  }
  canonicalize() {
    const entries = new Map();
    for (const item of __classPrivateFieldGet(
      this,
      _DisjointSet_entries,
      "f"
    ).keys()) {
      const root = this.find(item);
      entries.set(item, root);
    }
    return entries;
  }
  forEach(fn) {
    for (const item of __classPrivateFieldGet(
      this,
      _DisjointSet_entries,
      "f"
    ).keys()) {
      const group = this.find(item);
      fn(item, group);
    }
  }
  buildSets() {
    const ids = new Map();
    const sets = new Map();
    this.forEach((identifier, groupIdentifier) => {
      let id = ids.get(groupIdentifier);
      if (id == null) {
        id = ids.size;
        ids.set(groupIdentifier, id);
      }
      let set = sets.get(id);
      if (set === undefined) {
        set = new Set();
        sets.set(id, set);
      }
      set.add(identifier);
    });
    return [...sets.values()];
  }
  get size() {
    return __classPrivateFieldGet(this, _DisjointSet_entries, "f").size;
  }
}
_DisjointSet_entries = new WeakMap();
function findScopesToMerge(fn) {
  const objectMethodDecls = new Set();
  const mergeScopesBuilder = new DisjointSet();
  for (const [_, block] of fn.body.blocks) {
    for (const { lvalue: lvalue, value: value } of block.instructions) {
      if (value.kind === "ObjectMethod") {
        objectMethodDecls.add(lvalue.identifier);
      } else if (value.kind === "ObjectExpression") {
        for (const operand of eachInstructionValueOperand(value)) {
          if (objectMethodDecls.has(operand.identifier)) {
            const operandScope = operand.identifier.scope;
            const lvalueScope = lvalue.identifier.scope;
            CompilerError.invariant(
              operandScope != null && lvalueScope != null,
              {
                reason:
                  "Internal error: Expected all ObjectExpressions and ObjectMethods to have non-null scope.",
                suggestions: null,
                loc: GeneratedSource,
              }
            );
            mergeScopesBuilder.union([operandScope, lvalueScope]);
          }
        }
      }
    }
  }
  return mergeScopesBuilder;
}
function alignObjectMethodScopes(fn) {
  for (const [_, block] of fn.body.blocks) {
    for (const { value: value } of block.instructions) {
      if (
        value.kind === "ObjectMethod" ||
        value.kind === "FunctionExpression"
      ) {
        alignObjectMethodScopes(value.loweredFunc.func);
      }
    }
  }
  const scopeGroupsMap = findScopesToMerge(fn).canonicalize();
  for (const [scope, root] of scopeGroupsMap) {
    if (scope !== root) {
      root.range.start = makeInstructionId(
        Math.min(scope.range.start, root.range.start)
      );
      root.range.end = makeInstructionId(
        Math.max(scope.range.end, root.range.end)
      );
    }
  }
  for (const [_, block] of fn.body.blocks) {
    for (const {
      lvalue: { identifier: identifier },
    } of block.instructions) {
      if (identifier.scope != null) {
        const root = scopeGroupsMap.get(identifier.scope);
        if (root != null) {
          identifier.scope = root;
        }
      }
    }
  }
}
var _Context_blockScopes, _Context_unclosedScopes, _Context_seenScopes;
function alignReactiveScopesToBlockScopes(fn) {
  const context = new Context$4();
  visitReactiveFunction(fn, new Visitor$d(), context);
}
let Visitor$d = class Visitor extends ReactiveFunctionVisitor {
  visitID(id, state) {
    state.visitId(id);
  }
  visitPlace(id, place, state) {
    const scope = getPlaceScope(id, place);
    if (scope !== null) {
      state.visitScope(scope);
    }
  }
  visitLValue(id, lvalue, state) {
    const scope = getPlaceScope(id, lvalue);
    if (scope !== null) {
      state.visitScope(scope);
    }
  }
  visitInstruction(instr, state) {
    switch (instr.value.kind) {
      case "OptionalExpression":
      case "SequenceExpression":
      case "ConditionalExpression":
      case "LogicalExpression": {
        const prevScopeCount = state.currentScopes().length;
        this.traverseInstruction(instr, state);
        const scopes = state.currentScopes();
        for (let i = prevScopeCount; i < scopes.length; i++) {
          const scope = scopes[i];
          scope.scope.range.start = makeInstructionId(
            Math.min(instr.id, scope.scope.range.start)
          );
        }
        break;
      }
      default: {
        this.traverseInstruction(instr, state);
      }
    }
  }
  visitBlock(block, state) {
    state.enter(() => {
      this.traverseBlock(block, state);
    });
  }
};
let Context$4 = class Context {
  constructor() {
    _Context_blockScopes.set(this, []);
    _Context_unclosedScopes.set(this, []);
    _Context_seenScopes.set(this, new Set());
  }
  currentScopes() {
    var _a;
    return (_a = __classPrivateFieldGet(this, _Context_blockScopes, "f").at(
      -1
    )) !== null && _a !== void 0
      ? _a
      : [];
  }
  enter(fn) {
    __classPrivateFieldGet(this, _Context_blockScopes, "f").push([]);
    fn();
    const lastScope = __classPrivateFieldGet(
      this,
      _Context_blockScopes,
      "f"
    ).pop();
    for (const scope of lastScope) {
      if (scope.active) {
        __classPrivateFieldGet(this, _Context_unclosedScopes, "f").push(scope);
      }
    }
  }
  visitId(id) {
    const currentScopes = __classPrivateFieldGet(
      this,
      _Context_blockScopes,
      "f"
    ).at(-1);
    const scopes = [
      ...currentScopes,
      ...__classPrivateFieldGet(this, _Context_unclosedScopes, "f"),
    ];
    for (const pending of scopes) {
      if (!pending.active) {
        continue;
      }
      if (id >= pending.scope.range.end) {
        pending.active = false;
        pending.scope.range.end = id;
      }
    }
  }
  visitScope(scope) {
    if (!__classPrivateFieldGet(this, _Context_seenScopes, "f").has(scope.id)) {
      const currentScopes = __classPrivateFieldGet(
        this,
        _Context_blockScopes,
        "f"
      ).at(-1);
      __classPrivateFieldGet(this, _Context_seenScopes, "f").add(scope.id);
      currentScopes.push({ active: true, scope: scope });
    }
  }
};
(_Context_blockScopes = new WeakMap()),
  (_Context_unclosedScopes = new WeakMap()),
  (_Context_seenScopes = new WeakMap());
function assertScopeInstructionsWithinScopes(fn) {
  const existingScopes = new Set();
  visitReactiveFunction(fn, new FindAllScopesVisitor(), existingScopes);
  visitReactiveFunction(
    fn,
    new CheckInstructionsAgainstScopesVisitor(),
    existingScopes
  );
}
class FindAllScopesVisitor extends ReactiveFunctionVisitor {
  visitScope(block, state) {
    this.traverseScope(block, state);
    state.add(block.scope.id);
  }
}
class CheckInstructionsAgainstScopesVisitor extends ReactiveFunctionVisitor {
  constructor() {
    super(...arguments);
    this.activeScopes = new Set();
  }
  visitPlace(id, place, state) {
    const scope = getPlaceScope(id, place);
    if (
      scope !== null &&
      state.has(scope.id) &&
      !this.activeScopes.has(scope.id)
    ) {
      CompilerError.invariant(false, {
        description: `Instruction [${id}] is part of scope @${scope.id}, but that scope has already completed.`,
        loc: place.loc,
        reason:
          "Encountered an instruction that should be part of a scope, but where that scope has already completed",
        suggestions: null,
      });
    }
  }
  visitScope(block, state) {
    this.activeScopes.add(block.scope.id);
    this.traverseScope(block, state);
    this.activeScopes.delete(block.scope.id);
  }
}
function assertWellFormedBreakTargets(fn) {
  visitReactiveFunction(fn, new Visitor$c(), new Set());
}
let Visitor$c = class Visitor extends ReactiveFunctionVisitor {
  visitTerminal(stmt, seenLabels) {
    if (stmt.label != null) {
      seenLabels.add(stmt.label.id);
    }
    const terminal = stmt.terminal;
    if (terminal.kind === "break" || terminal.kind === "continue") {
      CompilerError.invariant(seenLabels.has(terminal.target), {
        reason: "Unexpected break to invalid label",
        loc: stmt.terminal.loc,
      });
    }
  }
};
var _Context_nextScheduleId,
  _Context_scheduled,
  _Context_catchHandlers,
  _Context_controlFlowStack;
function buildReactiveFunction(fn) {
  const cx = new Context$3(fn.body);
  const driver = new Driver(cx);
  const body = driver.traverseBlock(cx.block(fn.body.entry));
  return {
    loc: fn.loc,
    id: fn.id,
    params: fn.params,
    generator: fn.generator,
    async: fn.async,
    body: body,
    env: fn.env,
    directives: fn.directives,
  };
}
class Driver {
  constructor(cx) {
    this.cx = cx;
  }
  traverseBlock(block) {
    const blockValue = [];
    this.visitBlock(block, blockValue);
    return blockValue;
  }
  visitBlock(block, blockValue) {
    var _a;
    CompilerError.invariant(!this.cx.emitted.has(block.id), {
      reason: `Cannot emit the same block twice: bb${block.id}`,
      description: null,
      loc: null,
      suggestions: null,
    });
    this.cx.emitted.add(block.id);
    for (const instruction of block.instructions) {
      blockValue.push({ kind: "instruction", instruction: instruction });
    }
    const terminal = block.terminal;
    const scheduleIds = [];
    switch (terminal.kind) {
      case "return": {
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "return",
            loc: terminal.loc,
            value: terminal.value,
            id: terminal.id,
          },
          label: null,
        });
        break;
      }
      case "throw": {
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "throw",
            loc: terminal.loc,
            value: terminal.value,
            id: terminal.id,
          },
          label: null,
        });
        break;
      }
      case "if": {
        const fallthroughId =
          this.cx.reachable(terminal.fallthrough) &&
          !this.cx.isScheduled(terminal.fallthrough)
            ? terminal.fallthrough
            : null;
        const alternateId =
          terminal.alternate !== terminal.fallthrough
            ? terminal.alternate
            : null;
        if (fallthroughId !== null) {
          const scheduleId = this.cx.schedule(fallthroughId, "if");
          scheduleIds.push(scheduleId);
        }
        let consequent = null;
        if (this.cx.isScheduled(terminal.consequent)) {
          CompilerError.invariant(false, {
            reason: `Unexpected 'if' where the consequent is already scheduled`,
            loc: terminal.loc,
          });
        } else {
          consequent = this.traverseBlock(
            this.cx.ir.blocks.get(terminal.consequent)
          );
        }
        let alternate = null;
        if (alternateId !== null) {
          if (this.cx.isScheduled(alternateId)) {
            CompilerError.invariant(false, {
              reason: `Unexpected 'if' where the alternate is already scheduled`,
              loc: terminal.loc,
            });
          } else {
            alternate = this.traverseBlock(this.cx.ir.blocks.get(alternateId));
          }
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "if",
            loc: terminal.loc,
            test: terminal.test,
            consequent:
              consequent !== null && consequent !== void 0
                ? consequent
                : this.emptyBlock(),
            alternate: alternate,
            id: terminal.id,
          },
          label:
            fallthroughId == null
              ? null
              : { id: fallthroughId, implicit: false },
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "switch": {
        const fallthroughId =
          this.cx.reachable(terminal.fallthrough) &&
          !this.cx.isScheduled(terminal.fallthrough)
            ? terminal.fallthrough
            : null;
        if (fallthroughId !== null) {
          const scheduleId = this.cx.schedule(fallthroughId, "switch");
          scheduleIds.push(scheduleId);
        }
        const cases = [];
        [...terminal.cases].reverse().forEach((case_, _index) => {
          const test = case_.test;
          let consequent;
          if (this.cx.isScheduled(case_.block)) {
            CompilerError.invariant(case_.block === terminal.fallthrough, {
              reason: `Unexpected 'switch' where a case is already scheduled and block is not the fallthrough`,
              loc: terminal.loc,
            });
            return;
          } else {
            consequent = this.traverseBlock(this.cx.ir.blocks.get(case_.block));
            const scheduleId = this.cx.schedule(case_.block, "case");
            scheduleIds.push(scheduleId);
          }
          cases.push({ test: test, block: consequent });
        });
        cases.reverse();
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "switch",
            loc: terminal.loc,
            test: terminal.test,
            cases: cases,
            id: terminal.id,
          },
          label:
            fallthroughId == null
              ? null
              : { id: fallthroughId, implicit: false },
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "do-while": {
        const fallthroughId = !this.cx.isScheduled(terminal.fallthrough)
          ? terminal.fallthrough
          : null;
        const loopId =
          !this.cx.isScheduled(terminal.loop) &&
          terminal.loop !== terminal.fallthrough
            ? terminal.loop
            : null;
        const scheduleId = this.cx.scheduleLoop(
          terminal.fallthrough,
          terminal.test,
          terminal.loop
        );
        scheduleIds.push(scheduleId);
        let loopBody;
        if (loopId) {
          loopBody = this.traverseBlock(this.cx.ir.blocks.get(loopId));
        } else {
          CompilerError.invariant(false, {
            reason: `Unexpected 'do-while' where the loop is already scheduled`,
            loc: terminal.loc,
          });
        }
        const testValue = this.visitValueBlock(
          terminal.test,
          terminal.loc
        ).value;
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "do-while",
            loc: terminal.loc,
            test: testValue,
            loop: loopBody,
            id: terminal.id,
          },
          label:
            fallthroughId == null
              ? null
              : { id: fallthroughId, implicit: false },
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "while": {
        const fallthroughId =
          this.cx.reachable(terminal.fallthrough) &&
          !this.cx.isScheduled(terminal.fallthrough)
            ? terminal.fallthrough
            : null;
        const loopId =
          !this.cx.isScheduled(terminal.loop) &&
          terminal.loop !== terminal.fallthrough
            ? terminal.loop
            : null;
        const scheduleId = this.cx.scheduleLoop(
          terminal.fallthrough,
          terminal.test,
          terminal.loop
        );
        scheduleIds.push(scheduleId);
        const testValue = this.visitValueBlock(
          terminal.test,
          terminal.loc
        ).value;
        let loopBody;
        if (loopId) {
          loopBody = this.traverseBlock(this.cx.ir.blocks.get(loopId));
        } else {
          CompilerError.invariant(false, {
            reason: `Unexpected 'while' where the loop is already scheduled`,
            loc: terminal.loc,
          });
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "while",
            loc: terminal.loc,
            test: testValue,
            loop: loopBody,
            id: terminal.id,
          },
          label:
            fallthroughId == null
              ? null
              : { id: fallthroughId, implicit: false },
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "for": {
        const loopId =
          !this.cx.isScheduled(terminal.loop) &&
          terminal.loop !== terminal.fallthrough
            ? terminal.loop
            : null;
        const fallthroughId = !this.cx.isScheduled(terminal.fallthrough)
          ? terminal.fallthrough
          : null;
        const scheduleId = this.cx.scheduleLoop(
          terminal.fallthrough,
          (_a = terminal.update) !== null && _a !== void 0 ? _a : terminal.test,
          terminal.loop
        );
        scheduleIds.push(scheduleId);
        const init = this.visitValueBlock(terminal.init, terminal.loc);
        const initBlock = this.cx.ir.blocks.get(init.block);
        let initValue = init.value;
        if (initValue.kind === "SequenceExpression") {
          const last = initBlock.instructions.at(-1);
          initValue.instructions.push(last);
          initValue.value = {
            kind: "Primitive",
            value: undefined,
            loc: terminal.loc,
          };
        } else {
          initValue = {
            kind: "SequenceExpression",
            instructions: [initBlock.instructions.at(-1)],
            id: terminal.id,
            loc: terminal.loc,
            value: { kind: "Primitive", value: undefined, loc: terminal.loc },
          };
        }
        const testValue = this.visitValueBlock(
          terminal.test,
          terminal.loc
        ).value;
        const updateValue =
          terminal.update !== null
            ? this.visitValueBlock(terminal.update, terminal.loc).value
            : null;
        let loopBody;
        if (loopId) {
          loopBody = this.traverseBlock(this.cx.ir.blocks.get(loopId));
        } else {
          CompilerError.invariant(false, {
            reason: `Unexpected 'for' where the loop is already scheduled`,
            loc: terminal.loc,
          });
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "for",
            loc: terminal.loc,
            init: initValue,
            test: testValue,
            update: updateValue,
            loop: loopBody,
            id: terminal.id,
          },
          label:
            fallthroughId == null
              ? null
              : { id: fallthroughId, implicit: false },
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "for-of": {
        const loopId =
          !this.cx.isScheduled(terminal.loop) &&
          terminal.loop !== terminal.fallthrough
            ? terminal.loop
            : null;
        const fallthroughId = !this.cx.isScheduled(terminal.fallthrough)
          ? terminal.fallthrough
          : null;
        const scheduleId = this.cx.scheduleLoop(
          terminal.fallthrough,
          terminal.init,
          terminal.loop
        );
        scheduleIds.push(scheduleId);
        const init = this.visitValueBlock(terminal.init, terminal.loc);
        const initBlock = this.cx.ir.blocks.get(init.block);
        let initValue = init.value;
        if (initValue.kind === "SequenceExpression") {
          const last = initBlock.instructions.at(-1);
          initValue.instructions.push(last);
          initValue.value = {
            kind: "Primitive",
            value: undefined,
            loc: terminal.loc,
          };
        } else {
          initValue = {
            kind: "SequenceExpression",
            instructions: [initBlock.instructions.at(-1)],
            id: terminal.id,
            loc: terminal.loc,
            value: { kind: "Primitive", value: undefined, loc: terminal.loc },
          };
        }
        const test = this.visitValueBlock(terminal.test, terminal.loc);
        const testBlock = this.cx.ir.blocks.get(test.block);
        let testValue = test.value;
        if (testValue.kind === "SequenceExpression") {
          const last = testBlock.instructions.at(-1);
          testValue.instructions.push(last);
          testValue.value = {
            kind: "Primitive",
            value: undefined,
            loc: terminal.loc,
          };
        } else {
          testValue = {
            kind: "SequenceExpression",
            instructions: [testBlock.instructions.at(-1)],
            id: terminal.id,
            loc: terminal.loc,
            value: { kind: "Primitive", value: undefined, loc: terminal.loc },
          };
        }
        let loopBody;
        if (loopId) {
          loopBody = this.traverseBlock(this.cx.ir.blocks.get(loopId));
        } else {
          CompilerError.invariant(false, {
            reason: `Unexpected 'for-of' where the loop is already scheduled`,
            loc: terminal.loc,
          });
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "for-of",
            loc: terminal.loc,
            init: initValue,
            test: testValue,
            loop: loopBody,
            id: terminal.id,
          },
          label:
            fallthroughId == null
              ? null
              : { id: fallthroughId, implicit: false },
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "for-in": {
        const loopId =
          !this.cx.isScheduled(terminal.loop) &&
          terminal.loop !== terminal.fallthrough
            ? terminal.loop
            : null;
        const fallthroughId = !this.cx.isScheduled(terminal.fallthrough)
          ? terminal.fallthrough
          : null;
        const scheduleId = this.cx.scheduleLoop(
          terminal.fallthrough,
          terminal.init,
          terminal.loop
        );
        scheduleIds.push(scheduleId);
        const init = this.visitValueBlock(terminal.init, terminal.loc);
        const initBlock = this.cx.ir.blocks.get(init.block);
        let initValue = init.value;
        if (initValue.kind === "SequenceExpression") {
          const last = initBlock.instructions.at(-1);
          initValue.instructions.push(last);
          initValue.value = {
            kind: "Primitive",
            value: undefined,
            loc: terminal.loc,
          };
        } else {
          initValue = {
            kind: "SequenceExpression",
            instructions: [initBlock.instructions.at(-1)],
            id: terminal.id,
            loc: terminal.loc,
            value: { kind: "Primitive", value: undefined, loc: terminal.loc },
          };
        }
        let loopBody;
        if (loopId) {
          loopBody = this.traverseBlock(this.cx.ir.blocks.get(loopId));
        } else {
          CompilerError.invariant(false, {
            reason: `Unexpected 'for-in' where the loop is already scheduled`,
            loc: terminal.loc,
          });
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "for-in",
            loc: terminal.loc,
            init: initValue,
            loop: loopBody,
            id: terminal.id,
          },
          label:
            fallthroughId == null
              ? null
              : { id: fallthroughId, implicit: false },
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "branch": {
        let consequent = null;
        if (this.cx.isScheduled(terminal.consequent)) {
          const break_ = this.visitBreak(
            terminal.consequent,
            terminal.id,
            terminal.loc
          );
          if (break_ !== null) {
            consequent = [break_];
          }
        } else {
          consequent = this.traverseBlock(
            this.cx.ir.blocks.get(terminal.consequent)
          );
        }
        let alternate = null;
        if (this.cx.isScheduled(terminal.alternate)) {
          CompilerError.invariant(false, {
            reason: `Unexpected 'branch' where the alternate is already scheduled`,
            loc: terminal.loc,
          });
        } else {
          alternate = this.traverseBlock(
            this.cx.ir.blocks.get(terminal.alternate)
          );
        }
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "if",
            loc: terminal.loc,
            test: terminal.test,
            consequent:
              consequent !== null && consequent !== void 0
                ? consequent
                : this.emptyBlock(),
            alternate: alternate,
            id: terminal.id,
          },
          label: null,
        });
        break;
      }
      case "label": {
        const fallthroughId =
          this.cx.reachable(terminal.fallthrough) &&
          !this.cx.isScheduled(terminal.fallthrough)
            ? terminal.fallthrough
            : null;
        if (fallthroughId !== null) {
          const scheduleId = this.cx.schedule(fallthroughId, "if");
          scheduleIds.push(scheduleId);
        }
        let block;
        if (this.cx.isScheduled(terminal.block)) {
          CompilerError.invariant(false, {
            reason: `Unexpected 'label' where the block is already scheduled`,
            loc: terminal.loc,
          });
        } else {
          block = this.traverseBlock(this.cx.ir.blocks.get(terminal.block));
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "label",
            loc: terminal.loc,
            block: block,
            id: terminal.id,
          },
          label:
            fallthroughId == null
              ? null
              : { id: fallthroughId, implicit: false },
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "sequence":
      case "optional":
      case "ternary":
      case "logical": {
        const fallthroughId =
          terminal.fallthrough !== null &&
          !this.cx.isScheduled(terminal.fallthrough)
            ? terminal.fallthrough
            : null;
        if (fallthroughId !== null) {
          const scheduleId = this.cx.schedule(fallthroughId, "if");
          scheduleIds.push(scheduleId);
        }
        const { place: place, value: value } =
          this.visitValueBlockTerminal(terminal);
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "instruction",
          instruction: {
            id: terminal.id,
            lvalue: place,
            value: value,
            loc: terminal.loc,
          },
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "goto": {
        switch (terminal.variant) {
          case GotoVariant.Break: {
            const break_ = this.visitBreak(
              terminal.block,
              terminal.id,
              terminal.loc
            );
            if (break_ !== null) {
              blockValue.push(break_);
            }
            break;
          }
          case GotoVariant.Continue: {
            const continue_ = this.visitContinue(
              terminal.block,
              terminal.id,
              terminal.loc
            );
            if (continue_ !== null) {
              blockValue.push(continue_);
            }
            break;
          }
          case GotoVariant.Try: {
            break;
          }
          default: {
            assertExhaustive$1(
              terminal.variant,
              `Unexpected goto variant \`${terminal.variant}\``
            );
          }
        }
        break;
      }
      case "maybe-throw": {
        if (!this.cx.isScheduled(terminal.continuation)) {
          this.visitBlock(
            this.cx.ir.blocks.get(terminal.continuation),
            blockValue
          );
        }
        break;
      }
      case "try": {
        const fallthroughId =
          this.cx.reachable(terminal.fallthrough) &&
          !this.cx.isScheduled(terminal.fallthrough)
            ? terminal.fallthrough
            : null;
        if (fallthroughId !== null) {
          const scheduleId = this.cx.schedule(fallthroughId, "if");
          scheduleIds.push(scheduleId);
        }
        this.cx.scheduleCatchHandler(terminal.handler);
        const block = this.traverseBlock(this.cx.ir.blocks.get(terminal.block));
        const handler = this.traverseBlock(
          this.cx.ir.blocks.get(terminal.handler)
        );
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          label:
            fallthroughId == null
              ? null
              : { id: fallthroughId, implicit: false },
          terminal: {
            kind: "try",
            loc: terminal.loc,
            block: block,
            handlerBinding: terminal.handlerBinding,
            handler: handler,
            id: terminal.id,
          },
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "pruned-scope":
      case "scope": {
        const fallthroughId = !this.cx.isScheduled(terminal.fallthrough)
          ? terminal.fallthrough
          : null;
        if (fallthroughId !== null) {
          const scheduleId = this.cx.schedule(fallthroughId, "if");
          scheduleIds.push(scheduleId);
          this.cx.scopeFallthroughs.add(fallthroughId);
        }
        let block;
        if (this.cx.isScheduled(terminal.block)) {
          CompilerError.invariant(false, {
            reason: `Unexpected 'scope' where the block is already scheduled`,
            loc: terminal.loc,
          });
        } else {
          block = this.traverseBlock(this.cx.ir.blocks.get(terminal.block));
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: terminal.kind,
          instructions: block,
          scope: terminal.scope,
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "unreachable": {
        break;
      }
      case "unsupported": {
        CompilerError.invariant(false, {
          reason: "Unexpected unsupported terminal",
          description: null,
          loc: terminal.loc,
          suggestions: null,
        });
      }
      default: {
        assertExhaustive$1(terminal, "Unexpected terminal");
      }
    }
  }
  visitValueBlock(id, loc) {
    const defaultBlock = this.cx.ir.blocks.get(id);
    if (defaultBlock.terminal.kind === "branch") {
      const instructions = defaultBlock.instructions;
      if (instructions.length === 0) {
        return {
          block: defaultBlock.id,
          place: defaultBlock.terminal.test,
          value: {
            kind: "LoadLocal",
            place: defaultBlock.terminal.test,
            loc: defaultBlock.terminal.test.loc,
          },
          id: defaultBlock.terminal.id,
        };
      } else if (defaultBlock.instructions.length === 1) {
        const instr = defaultBlock.instructions[0];
        CompilerError.invariant(
          instr.lvalue.identifier.id ===
            defaultBlock.terminal.test.identifier.id,
          {
            reason:
              "Expected branch block to end in an instruction that sets the test value",
            description: null,
            loc: instr.lvalue.loc,
            suggestions: null,
          }
        );
        return {
          block: defaultBlock.id,
          place: instr.lvalue,
          value: instr.value,
          id: instr.id,
        };
      } else {
        const instr = defaultBlock.instructions.at(-1);
        const sequence = {
          kind: "SequenceExpression",
          instructions: defaultBlock.instructions.slice(0, -1),
          id: instr.id,
          value: instr.value,
          loc: loc,
        };
        return {
          block: defaultBlock.id,
          place: defaultBlock.terminal.test,
          value: sequence,
          id: defaultBlock.terminal.id,
        };
      }
    } else if (defaultBlock.terminal.kind === "goto") {
      const instructions = defaultBlock.instructions;
      if (instructions.length === 0) {
        CompilerError.invariant(false, {
          reason: "Expected goto value block to have at least one instruction",
          description: null,
          loc: null,
          suggestions: null,
        });
      } else if (defaultBlock.instructions.length === 1) {
        const instr = defaultBlock.instructions[0];
        let place = instr.lvalue;
        let value = instr.value;
        if (
          value.kind === "StoreLocal" &&
          value.lvalue.place.identifier.name === null
        ) {
          place = value.lvalue.place;
          value = {
            kind: "LoadLocal",
            place: value.value,
            loc: value.value.loc,
          };
        }
        return {
          block: defaultBlock.id,
          place: place,
          value: value,
          id: instr.id,
        };
      } else {
        const instr = defaultBlock.instructions.at(-1);
        let place = instr.lvalue;
        let value = instr.value;
        if (
          value.kind === "StoreLocal" &&
          value.lvalue.place.identifier.name === null
        ) {
          place = value.lvalue.place;
          value = {
            kind: "LoadLocal",
            place: value.value,
            loc: value.value.loc,
          };
        }
        const sequence = {
          kind: "SequenceExpression",
          instructions: defaultBlock.instructions.slice(0, -1),
          id: instr.id,
          value: value,
          loc: loc,
        };
        return {
          block: defaultBlock.id,
          place: place,
          value: sequence,
          id: instr.id,
        };
      }
    } else {
      const init = this.visitValueBlockTerminal(defaultBlock.terminal);
      const final = this.visitValueBlock(init.fallthrough, loc);
      const sequence = {
        kind: "SequenceExpression",
        instructions: [
          ...defaultBlock.instructions,
          { id: init.id, loc: loc, lvalue: init.place, value: init.value },
        ],
        id: final.id,
        value: final.value,
        loc: loc,
      };
      return {
        block: init.fallthrough,
        value: sequence,
        place: final.place,
        id: final.id,
      };
    }
  }
  visitValueBlockTerminal(terminal) {
    switch (terminal.kind) {
      case "sequence": {
        const block = this.visitValueBlock(terminal.block, terminal.loc);
        return {
          value: block.value,
          place: block.place,
          fallthrough: terminal.fallthrough,
          id: terminal.id,
        };
      }
      case "optional": {
        const test = this.visitValueBlock(terminal.test, terminal.loc);
        const testBlock = this.cx.ir.blocks.get(test.block);
        if (testBlock.terminal.kind !== "branch") {
          CompilerError.throwTodo({
            reason: `Unexpected terminal kind \`${testBlock.terminal.kind}\` for optional test block`,
            description: null,
            loc: testBlock.terminal.loc,
            suggestions: null,
          });
        }
        const consequent = this.visitValueBlock(
          testBlock.terminal.consequent,
          terminal.loc
        );
        const call = {
          kind: "SequenceExpression",
          instructions: [
            {
              id: test.id,
              loc: testBlock.terminal.loc,
              lvalue: test.place,
              value: test.value,
            },
          ],
          id: consequent.id,
          value: consequent.value,
          loc: terminal.loc,
        };
        return {
          place: Object.assign({}, consequent.place),
          value: {
            kind: "OptionalExpression",
            optional: terminal.optional,
            value: call,
            id: terminal.id,
            loc: terminal.loc,
          },
          fallthrough: terminal.fallthrough,
          id: terminal.id,
        };
      }
      case "logical": {
        const test = this.visitValueBlock(terminal.test, terminal.loc);
        const testBlock = this.cx.ir.blocks.get(test.block);
        if (testBlock.terminal.kind !== "branch") {
          CompilerError.throwTodo({
            reason: `Unexpected terminal kind \`${testBlock.terminal.kind}\` for logical test block`,
            description: null,
            loc: testBlock.terminal.loc,
            suggestions: null,
          });
        }
        const leftFinal = this.visitValueBlock(
          testBlock.terminal.consequent,
          terminal.loc
        );
        const left = {
          kind: "SequenceExpression",
          instructions: [
            {
              id: test.id,
              loc: terminal.loc,
              lvalue: test.place,
              value: test.value,
            },
          ],
          id: leftFinal.id,
          value: leftFinal.value,
          loc: terminal.loc,
        };
        const right = this.visitValueBlock(
          testBlock.terminal.alternate,
          terminal.loc
        );
        const value = {
          kind: "LogicalExpression",
          operator: terminal.operator,
          left: left,
          right: right.value,
          loc: terminal.loc,
        };
        return {
          place: Object.assign({}, leftFinal.place),
          value: value,
          fallthrough: terminal.fallthrough,
          id: terminal.id,
        };
      }
      case "ternary": {
        const test = this.visitValueBlock(terminal.test, terminal.loc);
        const testBlock = this.cx.ir.blocks.get(test.block);
        if (testBlock.terminal.kind !== "branch") {
          CompilerError.throwTodo({
            reason: `Unexpected terminal kind \`${testBlock.terminal.kind}\` for ternary test block`,
            description: null,
            loc: testBlock.terminal.loc,
            suggestions: null,
          });
        }
        const consequent = this.visitValueBlock(
          testBlock.terminal.consequent,
          terminal.loc
        );
        const alternate = this.visitValueBlock(
          testBlock.terminal.alternate,
          terminal.loc
        );
        const value = {
          kind: "ConditionalExpression",
          test: test.value,
          consequent: consequent.value,
          alternate: alternate.value,
          loc: terminal.loc,
        };
        return {
          place: Object.assign({}, consequent.place),
          value: value,
          fallthrough: terminal.fallthrough,
          id: terminal.id,
        };
      }
      case "maybe-throw": {
        CompilerError.throwTodo({
          reason: `Support value blocks (conditional, logical, optional chaining, etc) within a try/catch statement`,
          description: null,
          loc: terminal.loc,
          suggestions: null,
        });
      }
      case "label": {
        CompilerError.throwTodo({
          reason: `Support labeled statements combined with value blocks (conditional, logical, optional chaining, etc)`,
          description: null,
          loc: terminal.loc,
          suggestions: null,
        });
      }
      default: {
        CompilerError.throwTodo({
          reason: `Support \`${terminal.kind}\` as a value block terminal (conditional, logical, optional chaining, etc)`,
          description: null,
          loc: terminal.loc,
          suggestions: null,
        });
      }
    }
  }
  emptyBlock() {
    return [];
  }
  visitBreak(block, id, loc) {
    const target = this.cx.getBreakTarget(block);
    if (target === null) {
      CompilerError.invariant(false, {
        reason: "Expected a break target",
        description: null,
        loc: null,
        suggestions: null,
      });
    }
    if (this.cx.scopeFallthroughs.has(target.block)) {
      CompilerError.invariant(target.type === "implicit", {
        reason: "Expected reactive scope to implicitly break to fallthrough",
        loc: loc,
      });
      return null;
    }
    return {
      kind: "terminal",
      terminal: {
        kind: "break",
        loc: loc,
        target: target.block,
        id: id,
        targetKind: target.type,
      },
      label: null,
    };
  }
  visitContinue(block, id, loc) {
    const target = this.cx.getContinueTarget(block);
    CompilerError.invariant(target !== null, {
      reason: `Expected continue target to be scheduled for bb${block}`,
      description: null,
      loc: null,
      suggestions: null,
    });
    return {
      kind: "terminal",
      terminal: {
        kind: "continue",
        loc: loc,
        target: target.block,
        id: id,
        targetKind: target.type,
      },
      label: null,
    };
  }
}
let Context$3 = class Context {
  constructor(ir) {
    _Context_nextScheduleId.set(this, 0);
    this.emitted = new Set();
    this.scopeFallthroughs = new Set();
    _Context_scheduled.set(this, new Set());
    _Context_catchHandlers.set(this, new Set());
    _Context_controlFlowStack.set(this, []);
    this.ir = ir;
  }
  block(id) {
    return this.ir.blocks.get(id);
  }
  scheduleCatchHandler(block) {
    __classPrivateFieldGet(this, _Context_catchHandlers, "f").add(block);
  }
  reachable(id) {
    const block = this.ir.blocks.get(id);
    return block.terminal.kind !== "unreachable";
  }
  schedule(block, type) {
    var _a, _b;
    const id =
      (__classPrivateFieldSet(
        this,
        _Context_nextScheduleId,
        ((_b = __classPrivateFieldGet(this, _Context_nextScheduleId, "f")),
        (_a = _b++),
        _b),
        "f"
      ),
      _a);
    CompilerError.invariant(
      !__classPrivateFieldGet(this, _Context_scheduled, "f").has(block),
      {
        reason: `Break block is already scheduled: bb${block}`,
        description: null,
        loc: null,
        suggestions: null,
      }
    );
    __classPrivateFieldGet(this, _Context_scheduled, "f").add(block);
    __classPrivateFieldGet(this, _Context_controlFlowStack, "f").push({
      block: block,
      id: id,
      type: type,
    });
    return id;
  }
  scheduleLoop(fallthroughBlock, continueBlock, loopBlock) {
    var _a, _b;
    const id =
      (__classPrivateFieldSet(
        this,
        _Context_nextScheduleId,
        ((_b = __classPrivateFieldGet(this, _Context_nextScheduleId, "f")),
        (_a = _b++),
        _b),
        "f"
      ),
      _a);
    const ownsBlock = !__classPrivateFieldGet(
      this,
      _Context_scheduled,
      "f"
    ).has(fallthroughBlock);
    __classPrivateFieldGet(this, _Context_scheduled, "f").add(fallthroughBlock);
    CompilerError.invariant(
      !__classPrivateFieldGet(this, _Context_scheduled, "f").has(continueBlock),
      {
        reason: `Continue block is already scheduled: bb${continueBlock}`,
        description: null,
        loc: null,
        suggestions: null,
      }
    );
    __classPrivateFieldGet(this, _Context_scheduled, "f").add(continueBlock);
    let ownsLoop = false;
    if (loopBlock !== null) {
      ownsLoop = !__classPrivateFieldGet(this, _Context_scheduled, "f").has(
        loopBlock
      );
      __classPrivateFieldGet(this, _Context_scheduled, "f").add(loopBlock);
    }
    __classPrivateFieldGet(this, _Context_controlFlowStack, "f").push({
      block: fallthroughBlock,
      ownsBlock: ownsBlock,
      id: id,
      type: "loop",
      continueBlock: continueBlock,
      loopBlock: loopBlock,
      ownsLoop: ownsLoop,
    });
    return id;
  }
  unschedule(scheduleId) {
    const last = __classPrivateFieldGet(
      this,
      _Context_controlFlowStack,
      "f"
    ).pop();
    CompilerError.invariant(last !== undefined && last.id === scheduleId, {
      reason: "Can only unschedule the last target",
      description: null,
      loc: null,
      suggestions: null,
    });
    if (last.type !== "loop" || last.ownsBlock !== null) {
      __classPrivateFieldGet(this, _Context_scheduled, "f").delete(last.block);
    }
    if (last.type === "loop") {
      __classPrivateFieldGet(this, _Context_scheduled, "f").delete(
        last.continueBlock
      );
      if (last.ownsLoop && last.loopBlock !== null) {
        __classPrivateFieldGet(this, _Context_scheduled, "f").delete(
          last.loopBlock
        );
      }
    }
  }
  unscheduleAll(scheduleIds) {
    for (let i = scheduleIds.length - 1; i >= 0; i--) {
      this.unschedule(scheduleIds[i]);
    }
  }
  isScheduled(block) {
    return (
      __classPrivateFieldGet(this, _Context_scheduled, "f").has(block) ||
      __classPrivateFieldGet(this, _Context_catchHandlers, "f").has(block)
    );
  }
  getBreakTarget(block) {
    let hasPrecedingLoop = false;
    for (
      let i =
        __classPrivateFieldGet(this, _Context_controlFlowStack, "f").length - 1;
      i >= 0;
      i--
    ) {
      const target = __classPrivateFieldGet(
        this,
        _Context_controlFlowStack,
        "f"
      )[i];
      if (target.block === block) {
        let type;
        if (target.type === "loop") {
          type = hasPrecedingLoop ? "labeled" : "unlabeled";
        } else if (
          i ===
          __classPrivateFieldGet(this, _Context_controlFlowStack, "f").length -
            1
        ) {
          type = "implicit";
        } else {
          type = "labeled";
        }
        return { block: target.block, type: type };
      }
      hasPrecedingLoop || (hasPrecedingLoop = target.type === "loop");
    }
    CompilerError.invariant(false, {
      reason: "Expected a break target",
      description: null,
      loc: null,
      suggestions: null,
    });
  }
  getContinueTarget(block) {
    let hasPrecedingLoop = false;
    for (
      let i =
        __classPrivateFieldGet(this, _Context_controlFlowStack, "f").length - 1;
      i >= 0;
      i--
    ) {
      const target = __classPrivateFieldGet(
        this,
        _Context_controlFlowStack,
        "f"
      )[i];
      if (target.type == "loop" && target.continueBlock === block) {
        let type;
        if (hasPrecedingLoop) {
          type = "labeled";
        } else if (
          i ===
          __classPrivateFieldGet(this, _Context_controlFlowStack, "f").length -
            1
        ) {
          type = "implicit";
        } else {
          type = "unlabeled";
        }
        return { block: target.block, type: type };
      }
      hasPrecedingLoop || (hasPrecedingLoop = target.type === "loop");
    }
    return null;
  }
  debugBreakTargets() {
    return __classPrivateFieldGet(this, _Context_controlFlowStack, "f").map(
      (target) => Object.assign({}, target)
    );
  }
};
(_Context_nextScheduleId = new WeakMap()),
  (_Context_scheduled = new WeakMap()),
  (_Context_catchHandlers = new WeakMap()),
  (_Context_controlFlowStack = new WeakMap());
var GuardKind;
(function (GuardKind) {
  GuardKind[(GuardKind["PushHookGuard"] = 0)] = "PushHookGuard";
  GuardKind[(GuardKind["PopHookGuard"] = 1)] = "PopHookGuard";
  GuardKind[(GuardKind["AllowHook"] = 2)] = "AllowHook";
  GuardKind[(GuardKind["DisallowHook"] = 3)] = "DisallowHook";
})(GuardKind || (GuardKind = {}));
function memoizeFbtAndMacroOperandsInSameScope(fn) {
  var _a;
  const fbtMacroTags = new Set([
    ...FBT_TAGS,
    ...((_a = fn.env.config.customMacros) !== null && _a !== void 0 ? _a : []),
  ]);
  const fbtValues = new Set();
  while (true) {
    let size = fbtValues.size;
    visit$1(fn, fbtMacroTags, fbtValues);
    if (size === fbtValues.size) {
      break;
    }
  }
}
const FBT_TAGS = new Set(["fbt", "fbt:param", "fbs", "fbs:param"]);
const SINGLE_CHILD_FBT_TAGS = new Set(["fbt:param", "fbs:param"]);
function visit$1(fn, fbtMacroTags, fbtValues) {
  for (const [, block] of fn.body.blocks) {
    for (const instruction of block.instructions) {
      const { lvalue: lvalue, value: value } = instruction;
      if (lvalue === null) {
        continue;
      }
      if (
        value.kind === "Primitive" &&
        typeof value.value === "string" &&
        fbtMacroTags.has(value.value)
      ) {
        fbtValues.add(lvalue.identifier.id);
      } else if (
        value.kind === "LoadGlobal" &&
        fbtMacroTags.has(value.binding.name)
      ) {
        fbtValues.add(lvalue.identifier.id);
      } else if (isFbtCallExpression(fbtValues, value)) {
        const fbtScope = lvalue.identifier.scope;
        if (fbtScope === null) {
          continue;
        }
        for (const operand of eachReactiveValueOperand(value)) {
          operand.identifier.scope = fbtScope;
          fbtScope.range.start = makeInstructionId(
            Math.min(
              fbtScope.range.start,
              operand.identifier.mutableRange.start
            )
          );
          fbtValues.add(operand.identifier.id);
        }
      } else if (
        isFbtJsxExpression(fbtMacroTags, fbtValues, value) ||
        isFbtJsxChild(fbtValues, lvalue, value)
      ) {
        const fbtScope = lvalue.identifier.scope;
        if (fbtScope === null) {
          continue;
        }
        for (const operand of eachReactiveValueOperand(value)) {
          operand.identifier.scope = fbtScope;
          fbtScope.range.start = makeInstructionId(
            Math.min(
              fbtScope.range.start,
              operand.identifier.mutableRange.start
            )
          );
          fbtValues.add(operand.identifier.id);
        }
      } else if (fbtValues.has(lvalue.identifier.id)) {
        const fbtScope = lvalue.identifier.scope;
        if (fbtScope === null) {
          return;
        }
        for (const operand of eachReactiveValueOperand(value)) {
          if (
            operand.identifier.name !== null &&
            operand.identifier.name.kind === "named"
          ) {
            continue;
          }
          operand.identifier.scope = fbtScope;
          fbtScope.range.start = makeInstructionId(
            Math.min(
              fbtScope.range.start,
              operand.identifier.mutableRange.start
            )
          );
        }
      }
    }
  }
}
function isFbtCallExpression(fbtValues, value) {
  return (
    value.kind === "CallExpression" && fbtValues.has(value.callee.identifier.id)
  );
}
function isFbtJsxExpression(fbtMacroTags, fbtValues, value) {
  return (
    value.kind === "JsxExpression" &&
    ((value.tag.kind === "Identifier" &&
      fbtValues.has(value.tag.identifier.id)) ||
      (value.tag.kind === "BuiltinTag" && fbtMacroTags.has(value.tag.name)))
  );
}
function isFbtJsxChild(fbtValues, lvalue, value) {
  return (
    (value.kind === "JsxExpression" || value.kind === "JsxFragment") &&
    lvalue !== null &&
    fbtValues.has(lvalue.identifier.id)
  );
}
var _Context_nextCacheIndex, _Context_declarations$1;
const MEMO_CACHE_SENTINEL = "react.memo_cache_sentinel";
const EARLY_RETURN_SENTINEL = "react.early_return_sentinel";
function codegenFunction(fn, uniqueIdentifiers) {
  var _a, _b;
  const cx = new Context$2(
    fn.env,
    (_a = fn.id) !== null && _a !== void 0 ? _a : "[[ anonymous ]]",
    uniqueIdentifiers,
    null
  );
  let fastRefreshState = null;
  if (
    fn.env.config.enableResetCacheOnSourceFileChanges &&
    fn.env.code !== null
  ) {
    const hash = crypto.createHmac("sha256", fn.env.code).digest("hex");
    fastRefreshState = { cacheIndex: cx.nextCacheIndex, hash: hash };
  }
  const compileResult = codegenReactiveFunction(cx, fn);
  if (compileResult.isErr()) {
    return compileResult;
  }
  const compiled = compileResult.unwrap();
  const hookGuard = fn.env.config.enableEmitHookGuards;
  if (hookGuard != null) {
    compiled.body = libExports.blockStatement([
      createHookGuard(
        hookGuard,
        compiled.body.body,
        GuardKind.PushHookGuard,
        GuardKind.PopHookGuard
      ),
    ]);
  }
  const cacheCount = compiled.memoSlotsUsed;
  if (cacheCount !== 0) {
    const preface = [];
    preface.push(
      libExports.variableDeclaration("const", [
        libExports.variableDeclarator(
          libExports.identifier(cx.synthesizeName("$")),
          libExports.callExpression(
            libExports.identifier(fn.env.useMemoCacheIdentifier),
            [libExports.numericLiteral(cacheCount)]
          )
        ),
      ])
    );
    if (fastRefreshState !== null) {
      const index = cx.synthesizeName("$i");
      preface.push(
        libExports.ifStatement(
          libExports.binaryExpression(
            "!==",
            libExports.memberExpression(
              libExports.identifier(cx.synthesizeName("$")),
              libExports.numericLiteral(fastRefreshState.cacheIndex),
              true
            ),
            libExports.stringLiteral(fastRefreshState.hash)
          ),
          libExports.blockStatement([
            libExports.forStatement(
              libExports.variableDeclaration("let", [
                libExports.variableDeclarator(
                  libExports.identifier(index),
                  libExports.numericLiteral(0)
                ),
              ]),
              libExports.binaryExpression(
                "<",
                libExports.identifier(index),
                libExports.numericLiteral(cacheCount)
              ),
              libExports.assignmentExpression(
                "+=",
                libExports.identifier(index),
                libExports.numericLiteral(1)
              ),
              libExports.blockStatement([
                libExports.expressionStatement(
                  libExports.assignmentExpression(
                    "=",
                    libExports.memberExpression(
                      libExports.identifier(cx.synthesizeName("$")),
                      libExports.identifier(index),
                      true
                    ),
                    libExports.callExpression(
                      libExports.memberExpression(
                        libExports.identifier("Symbol"),
                        libExports.identifier("for")
                      ),
                      [libExports.stringLiteral(MEMO_CACHE_SENTINEL)]
                    )
                  )
                ),
              ])
            ),
            libExports.expressionStatement(
              libExports.assignmentExpression(
                "=",
                libExports.memberExpression(
                  libExports.identifier(cx.synthesizeName("$")),
                  libExports.numericLiteral(fastRefreshState.cacheIndex),
                  true
                ),
                libExports.stringLiteral(fastRefreshState.hash)
              )
            ),
          ])
        )
      );
    }
    compiled.body.body.unshift(...preface);
  }
  const emitInstrumentForget = fn.env.config.enableEmitInstrumentForget;
  if (emitInstrumentForget != null && fn.id != null) {
    let gating;
    if (
      emitInstrumentForget.gating != null &&
      emitInstrumentForget.globalGating != null
    ) {
      gating = libExports.logicalExpression(
        "&&",
        libExports.identifier(emitInstrumentForget.globalGating),
        libExports.identifier(emitInstrumentForget.gating.importSpecifierName)
      );
    } else if (emitInstrumentForget.gating != null) {
      gating = libExports.identifier(
        emitInstrumentForget.gating.importSpecifierName
      );
    } else {
      CompilerError.invariant(emitInstrumentForget.globalGating != null, {
        reason:
          "Bad config not caught! Expected at least one of gating or globalGating",
        loc: null,
        suggestions: null,
      });
      gating = libExports.identifier(emitInstrumentForget.globalGating);
    }
    const test = libExports.ifStatement(
      gating,
      libExports.expressionStatement(
        libExports.callExpression(
          libExports.identifier(emitInstrumentForget.fn.importSpecifierName),
          [
            libExports.stringLiteral(fn.id),
            libExports.stringLiteral(
              (_b = fn.env.filename) !== null && _b !== void 0 ? _b : ""
            ),
          ]
        )
      )
    );
    compiled.body.body.unshift(test);
  }
  return compileResult;
}
function codegenReactiveFunction(cx, fn) {
  for (const param of fn.params) {
    if (param.kind === "Identifier") {
      cx.temp.set(param.identifier.id, null);
    } else {
      cx.temp.set(param.place.identifier.id, null);
    }
  }
  const params = fn.params.map((param) => convertParameter(param));
  const body = codegenBlock(cx, fn.body);
  body.directives = fn.directives.map((d) =>
    libExports.directive(libExports.directiveLiteral(d))
  );
  const statements = body.body;
  if (statements.length !== 0) {
    const last = statements[statements.length - 1];
    if (last.type === "ReturnStatement" && last.argument == null) {
      statements.pop();
    }
  }
  if (cx.errors.hasErrors()) {
    return Err(cx.errors);
  }
  const countMemoBlockVisitor = new CountMemoBlockVisitor(fn.env);
  visitReactiveFunction(fn, countMemoBlockVisitor, undefined);
  return Ok({
    type: "CodegenFunction",
    loc: fn.loc,
    id: fn.id !== null ? libExports.identifier(fn.id) : null,
    params: params,
    body: body,
    generator: fn.generator,
    async: fn.async,
    memoSlotsUsed: cx.nextCacheIndex,
    memoBlocks: countMemoBlockVisitor.memoBlocks,
    memoValues: countMemoBlockVisitor.memoValues,
    prunedMemoBlocks: countMemoBlockVisitor.prunedMemoBlocks,
    prunedMemoValues: countMemoBlockVisitor.prunedMemoValues,
  });
}
class CountMemoBlockVisitor extends ReactiveFunctionVisitor {
  constructor(env) {
    super();
    this.memoBlocks = 0;
    this.memoValues = 0;
    this.prunedMemoBlocks = 0;
    this.prunedMemoValues = 0;
    this.env = env;
  }
  visitScope(scopeBlock, state) {
    this.memoBlocks += 1;
    this.memoValues += scopeBlock.scope.declarations.size;
    this.traverseScope(scopeBlock, state);
  }
  visitPrunedScope(scopeBlock, state) {
    this.prunedMemoBlocks += 1;
    this.prunedMemoValues += scopeBlock.scope.declarations.size;
    this.traversePrunedScope(scopeBlock, state);
  }
}
function convertParameter(param) {
  if (param.kind === "Identifier") {
    return convertIdentifier(param.identifier);
  } else {
    return libExports.restElement(convertIdentifier(param.place.identifier));
  }
}
let Context$2 = class Context {
  constructor(env, fnName, uniqueIdentifiers, temporaries = null) {
    _Context_nextCacheIndex.set(this, 0);
    _Context_declarations$1.set(this, new Set());
    this.errors = new CompilerError();
    this.objectMethods = new Map();
    this.synthesizedNames = new Map();
    this.env = env;
    this.fnName = fnName;
    this.uniqueIdentifiers = uniqueIdentifiers;
    this.temp = temporaries !== null ? new Map(temporaries) : new Map();
  }
  get nextCacheIndex() {
    var _a, _b;
    return (
      __classPrivateFieldSet(
        this,
        _Context_nextCacheIndex,
        ((_b = __classPrivateFieldGet(this, _Context_nextCacheIndex, "f")),
        (_a = _b++),
        _b),
        "f"
      ),
      _a
    );
  }
  declare(identifier) {
    __classPrivateFieldGet(this, _Context_declarations$1, "f").add(
      identifier.id
    );
  }
  hasDeclared(identifier) {
    return __classPrivateFieldGet(this, _Context_declarations$1, "f").has(
      identifier.id
    );
  }
  synthesizeName(name) {
    const previous = this.synthesizedNames.get(name);
    if (previous !== undefined) {
      return previous;
    }
    let validated = makeIdentifierName(name).value;
    let index = 0;
    while (this.uniqueIdentifiers.has(validated)) {
      validated = makeIdentifierName(`${name}${index++}`).value;
    }
    this.uniqueIdentifiers.add(validated);
    this.synthesizedNames.set(name, validated);
    return validated;
  }
};
(_Context_nextCacheIndex = new WeakMap()),
  (_Context_declarations$1 = new WeakMap());
function codegenBlock(cx, block) {
  const temp = new Map(cx.temp);
  const result = codegenBlockNoReset(cx, block);
  for (const [key, value] of cx.temp) {
    if (!temp.has(key)) {
      continue;
    }
    CompilerError.invariant(temp.get(key) === value, {
      loc: null,
      reason: "Expected temporary value to be unchanged",
      description: null,
      suggestions: null,
    });
  }
  cx.temp = temp;
  return result;
}
function codegenBlockNoReset(cx, block) {
  const statements = [];
  for (const item of block) {
    switch (item.kind) {
      case "instruction": {
        const statement = codegenInstructionNullable(cx, item.instruction);
        if (statement !== null) {
          statements.push(statement);
        }
        break;
      }
      case "pruned-scope": {
        const scopeBlock = codegenBlockNoReset(cx, item.instructions);
        statements.push(...scopeBlock.body);
        break;
      }
      case "scope": {
        const temp = new Map(cx.temp);
        codegenReactiveScope(cx, statements, item.scope, item.instructions);
        cx.temp = temp;
        break;
      }
      case "terminal": {
        const statement = codegenTerminal(cx, item.terminal);
        if (statement === null) {
          break;
        }
        if (item.label !== null && !item.label.implicit) {
          const block =
            statement.type === "BlockStatement" && statement.body.length === 1
              ? statement.body[0]
              : statement;
          statements.push(
            libExports.labeledStatement(
              libExports.identifier(codegenLabel(item.label.id)),
              block
            )
          );
        } else if (statement.type === "BlockStatement") {
          statements.push(...statement.body);
        } else {
          statements.push(statement);
        }
        break;
      }
      default: {
        assertExhaustive$1(item, `Unexpected item kind \`${item.kind}\``);
      }
    }
  }
  return libExports.blockStatement(statements);
}
function wrapCacheDep(cx, value) {
  if (cx.env.config.enableEmitFreeze != null) {
    return libExports.conditionalExpression(
      libExports.identifier("__DEV__"),
      libExports.callExpression(
        libExports.identifier(
          cx.env.config.enableEmitFreeze.importSpecifierName
        ),
        [value, libExports.stringLiteral(cx.fnName)]
      ),
      value
    );
  } else {
    return value;
  }
}
function codegenReactiveScope(cx, statements, scope, block) {
  const cacheStoreStatements = [];
  const cacheLoadStatements = [];
  const cacheLoads = [];
  const changeExpressions = [];
  const changeExpressionComments = [];
  const outputComments = [];
  for (const dep of scope.dependencies) {
    const index = cx.nextCacheIndex;
    changeExpressionComments.push(printDependencyComment(dep));
    const comparison = libExports.binaryExpression(
      "!==",
      libExports.memberExpression(
        libExports.identifier(cx.synthesizeName("$")),
        libExports.numericLiteral(index),
        true
      ),
      codegenDependency(cx, dep)
    );
    if (cx.env.config.enableChangeVariableCodegen) {
      const changeIdentifier = libExports.identifier(
        cx.synthesizeName(`c_${index}`)
      );
      statements.push(
        libExports.variableDeclaration("const", [
          libExports.variableDeclarator(changeIdentifier, comparison),
        ])
      );
      changeExpressions.push(changeIdentifier);
    } else {
      changeExpressions.push(comparison);
    }
    cacheStoreStatements.push(
      libExports.expressionStatement(
        libExports.assignmentExpression(
          "=",
          libExports.memberExpression(
            libExports.identifier(cx.synthesizeName("$")),
            libExports.numericLiteral(index),
            true
          ),
          codegenDependency(cx, dep)
        )
      )
    );
  }
  let firstOutputIndex = null;
  for (const [, { identifier: identifier }] of scope.declarations) {
    const index = cx.nextCacheIndex;
    if (firstOutputIndex === null) {
      firstOutputIndex = index;
    }
    CompilerError.invariant(identifier.name != null, {
      reason: `Expected scope declaration identifier to be named`,
      description: `Declaration \`${printIdentifier(identifier)}\` is unnamed in scope @${scope.id}`,
      loc: null,
      suggestions: null,
    });
    const name = convertIdentifier(identifier);
    outputComments.push(name.name);
    if (!cx.hasDeclared(identifier)) {
      statements.push(
        libExports.variableDeclaration("let", [
          libExports.variableDeclarator(name),
        ])
      );
    }
    cacheLoads.push({
      name: name,
      index: index,
      value: wrapCacheDep(cx, name),
    });
    cx.declare(identifier);
  }
  for (const reassignment of scope.reassignments) {
    const index = cx.nextCacheIndex;
    if (firstOutputIndex === null) {
      firstOutputIndex = index;
    }
    const name = convertIdentifier(reassignment);
    outputComments.push(name.name);
    cacheLoads.push({
      name: name,
      index: index,
      value: wrapCacheDep(cx, name),
    });
  }
  let testCondition = changeExpressions.reduce((acc, ident) => {
    if (acc == null) {
      return ident;
    }
    return libExports.logicalExpression("||", acc, ident);
  }, null);
  if (testCondition === null) {
    CompilerError.invariant(firstOutputIndex !== null, {
      reason: `Expected scope to have at least one declaration`,
      description: `Scope '@${scope.id}' has no declarations`,
      loc: null,
      suggestions: null,
    });
    testCondition = libExports.binaryExpression(
      "===",
      libExports.memberExpression(
        libExports.identifier(cx.synthesizeName("$")),
        libExports.numericLiteral(firstOutputIndex),
        true
      ),
      libExports.callExpression(
        libExports.memberExpression(
          libExports.identifier("Symbol"),
          libExports.identifier("for")
        ),
        [libExports.stringLiteral(MEMO_CACHE_SENTINEL)]
      )
    );
  }
  if (cx.env.config.disableMemoizationForDebugging) {
    CompilerError.invariant(
      cx.env.config.enableChangeDetectionForDebugging == null,
      {
        reason: `Expected to not have both change detection enabled and memoization disabled`,
        description: `Incompatible config options`,
        loc: null,
      }
    );
    testCondition = libExports.logicalExpression(
      "||",
      testCondition,
      libExports.booleanLiteral(true)
    );
  }
  let computationBlock = codegenBlock(cx, block);
  let memoStatement;
  if (
    cx.env.config.enableChangeDetectionForDebugging != null &&
    changeExpressions.length > 0
  ) {
    const loc =
      typeof scope.loc === "symbol"
        ? "unknown location"
        : `(${scope.loc.start.line}:${scope.loc.end.line})`;
    const detectionFunction =
      cx.env.config.enableChangeDetectionForDebugging.importSpecifierName;
    const cacheLoadOldValueStatements = [];
    const changeDetectionStatements = [];
    const idempotenceDetectionStatements = [];
    for (const { name: name, index: index, value: value } of cacheLoads) {
      const loadName = cx.synthesizeName(`old$${name.name}`);
      const slot = libExports.memberExpression(
        libExports.identifier(cx.synthesizeName("$")),
        libExports.numericLiteral(index),
        true
      );
      cacheStoreStatements.push(
        libExports.expressionStatement(
          libExports.assignmentExpression("=", slot, value)
        )
      );
      cacheLoadOldValueStatements.push(
        libExports.variableDeclaration("let", [
          libExports.variableDeclarator(libExports.identifier(loadName), slot),
        ])
      );
      changeDetectionStatements.push(
        libExports.expressionStatement(
          libExports.callExpression(libExports.identifier(detectionFunction), [
            libExports.identifier(loadName),
            name,
            libExports.stringLiteral(name.name),
            libExports.stringLiteral(cx.fnName),
            libExports.stringLiteral("cached"),
            libExports.stringLiteral(loc),
          ])
        )
      );
      idempotenceDetectionStatements.push(
        libExports.expressionStatement(
          libExports.callExpression(libExports.identifier(detectionFunction), [
            slot,
            name,
            libExports.stringLiteral(name.name),
            libExports.stringLiteral(cx.fnName),
            libExports.stringLiteral("recomputed"),
            libExports.stringLiteral(loc),
          ])
        )
      );
      idempotenceDetectionStatements.push(
        libExports.expressionStatement(
          libExports.assignmentExpression("=", name, slot)
        )
      );
    }
    const condition = cx.synthesizeName("condition");
    memoStatement = libExports.blockStatement([
      ...computationBlock.body,
      libExports.variableDeclaration("let", [
        libExports.variableDeclarator(
          libExports.identifier(condition),
          testCondition
        ),
      ]),
      libExports.ifStatement(
        libExports.unaryExpression("!", libExports.identifier(condition)),
        libExports.blockStatement([
          ...cacheLoadOldValueStatements,
          ...changeDetectionStatements,
        ])
      ),
      ...cacheStoreStatements,
      libExports.ifStatement(
        libExports.identifier(condition),
        libExports.blockStatement([
          ...computationBlock.body,
          ...idempotenceDetectionStatements,
        ])
      ),
    ]);
  } else {
    for (const { name: name, index: index, value: value } of cacheLoads) {
      cacheStoreStatements.push(
        libExports.expressionStatement(
          libExports.assignmentExpression(
            "=",
            libExports.memberExpression(
              libExports.identifier(cx.synthesizeName("$")),
              libExports.numericLiteral(index),
              true
            ),
            value
          )
        )
      );
      cacheLoadStatements.push(
        libExports.expressionStatement(
          libExports.assignmentExpression(
            "=",
            name,
            libExports.memberExpression(
              libExports.identifier(cx.synthesizeName("$")),
              libExports.numericLiteral(index),
              true
            )
          )
        )
      );
    }
    computationBlock.body.push(...cacheStoreStatements);
    memoStatement = libExports.ifStatement(
      testCondition,
      computationBlock,
      libExports.blockStatement(cacheLoadStatements)
    );
  }
  if (cx.env.config.enableMemoizationComments) {
    if (changeExpressionComments.length) {
      libExports.addComment(
        memoStatement,
        "leading",
        ` check if ${printDelimitedCommentList(changeExpressionComments, "or")} changed`,
        true
      );
      libExports.addComment(
        memoStatement,
        "leading",
        ` "useMemo" for ${printDelimitedCommentList(outputComments, "and")}:`,
        true
      );
    } else {
      libExports.addComment(
        memoStatement,
        "leading",
        " cache value with no dependencies",
        true
      );
      libExports.addComment(
        memoStatement,
        "leading",
        ` "useMemo" for ${printDelimitedCommentList(outputComments, "and")}:`,
        true
      );
    }
    if (computationBlock.body.length > 0) {
      libExports.addComment(
        computationBlock.body[0],
        "leading",
        ` Inputs changed, recompute`,
        true
      );
    }
    if (cacheLoadStatements.length > 0) {
      libExports.addComment(
        cacheLoadStatements[0],
        "leading",
        ` Inputs did not change, use cached value`,
        true
      );
    }
  }
  statements.push(memoStatement);
  const earlyReturnValue = scope.earlyReturnValue;
  if (earlyReturnValue !== null) {
    CompilerError.invariant(
      earlyReturnValue.value.name !== null &&
        earlyReturnValue.value.name.kind === "named",
      {
        reason: `Expected early return value to be promoted to a named variable`,
        loc: earlyReturnValue.loc,
        description: null,
        suggestions: null,
      }
    );
    const name = earlyReturnValue.value.name.value;
    statements.push(
      libExports.ifStatement(
        libExports.binaryExpression(
          "!==",
          libExports.identifier(name),
          libExports.callExpression(
            libExports.memberExpression(
              libExports.identifier("Symbol"),
              libExports.identifier("for")
            ),
            [libExports.stringLiteral(EARLY_RETURN_SENTINEL)]
          )
        ),
        libExports.blockStatement([
          libExports.returnStatement(libExports.identifier(name)),
        ])
      )
    );
  }
}
function codegenTerminal(cx, terminal) {
  switch (terminal.kind) {
    case "break": {
      if (terminal.targetKind === "implicit") {
        return null;
      }
      return libExports.breakStatement(
        terminal.targetKind === "labeled"
          ? libExports.identifier(codegenLabel(terminal.target))
          : null
      );
    }
    case "continue": {
      if (terminal.targetKind === "implicit") {
        return null;
      }
      return libExports.continueStatement(
        terminal.targetKind === "labeled"
          ? libExports.identifier(codegenLabel(terminal.target))
          : null
      );
    }
    case "for": {
      return libExports.forStatement(
        codegenForInit(cx, terminal.init),
        codegenInstructionValueToExpression(cx, terminal.test),
        terminal.update !== null
          ? codegenInstructionValueToExpression(cx, terminal.update)
          : null,
        codegenBlock(cx, terminal.loop)
      );
    }
    case "for-in": {
      CompilerError.invariant(terminal.init.kind === "SequenceExpression", {
        reason: `Expected a sequence expression init for for..in`,
        description: `Got \`${terminal.init.kind}\` expression instead`,
        loc: terminal.init.loc,
        suggestions: null,
      });
      if (terminal.init.instructions.length !== 2) {
        CompilerError.throwTodo({
          reason: "Support non-trivial for..in inits",
          description: null,
          loc: terminal.init.loc,
          suggestions: null,
        });
      }
      const iterableCollection = terminal.init.instructions[0];
      const iterableItem = terminal.init.instructions[1];
      let lval;
      switch (iterableItem.value.kind) {
        case "StoreLocal": {
          lval = codegenLValue(cx, iterableItem.value.lvalue.place);
          break;
        }
        case "Destructure": {
          lval = codegenLValue(cx, iterableItem.value.lvalue.pattern);
          break;
        }
        default:
          CompilerError.invariant(false, {
            reason: `Expected a StoreLocal or Destructure to be assigned to the collection`,
            description: `Found ${iterableItem.value.kind}`,
            loc: iterableItem.value.loc,
            suggestions: null,
          });
      }
      let varDeclKind;
      switch (iterableItem.value.lvalue.kind) {
        case InstructionKind.Const:
          varDeclKind = "const";
          break;
        case InstructionKind.Let:
          varDeclKind = "let";
          break;
        case InstructionKind.Reassign:
          CompilerError.invariant(false, {
            reason:
              "Destructure should never be Reassign as it would be an Object/ArrayPattern",
            description: null,
            loc: iterableItem.loc,
            suggestions: null,
          });
        case InstructionKind.Catch:
          CompilerError.invariant(false, {
            reason: "Unexpected catch variable as for..in collection",
            description: null,
            loc: iterableItem.loc,
            suggestions: null,
          });
        case InstructionKind.HoistedConst:
          CompilerError.invariant(false, {
            reason: "Unexpected HoistedConst variable in for..in collection",
            description: null,
            loc: iterableItem.loc,
            suggestions: null,
          });
        default:
          assertExhaustive$1(
            iterableItem.value.lvalue.kind,
            `Unhandled lvalue kind: ${iterableItem.value.lvalue.kind}`
          );
      }
      return libExports.forInStatement(
        createVariableDeclaration(iterableItem.value.loc, varDeclKind, [
          libExports.variableDeclarator(lval, null),
        ]),
        codegenInstructionValueToExpression(cx, iterableCollection.value),
        codegenBlock(cx, terminal.loop)
      );
    }
    case "for-of": {
      CompilerError.invariant(
        terminal.init.kind === "SequenceExpression" &&
          terminal.init.instructions.length === 1 &&
          terminal.init.instructions[0].value.kind === "GetIterator",
        {
          reason: `Expected a single-expression sequence expression init for for..of`,
          description: `Got \`${terminal.init.kind}\` expression instead`,
          loc: terminal.init.loc,
          suggestions: null,
        }
      );
      const iterableCollection = terminal.init.instructions[0].value;
      CompilerError.invariant(terminal.test.kind === "SequenceExpression", {
        reason: `Expected a sequence expression test for for..of`,
        description: `Got \`${terminal.init.kind}\` expression instead`,
        loc: terminal.test.loc,
        suggestions: null,
      });
      if (terminal.test.instructions.length !== 2) {
        CompilerError.throwTodo({
          reason: "Support non-trivial for..of inits",
          description: null,
          loc: terminal.init.loc,
          suggestions: null,
        });
      }
      const iterableItem = terminal.test.instructions[1];
      let lval;
      switch (iterableItem.value.kind) {
        case "StoreLocal": {
          lval = codegenLValue(cx, iterableItem.value.lvalue.place);
          break;
        }
        case "Destructure": {
          lval = codegenLValue(cx, iterableItem.value.lvalue.pattern);
          break;
        }
        default:
          CompilerError.invariant(false, {
            reason: `Expected a StoreLocal or Destructure to be assigned to the collection`,
            description: `Found ${iterableItem.value.kind}`,
            loc: iterableItem.value.loc,
            suggestions: null,
          });
      }
      let varDeclKind;
      switch (iterableItem.value.lvalue.kind) {
        case InstructionKind.Const:
          varDeclKind = "const";
          break;
        case InstructionKind.Let:
          varDeclKind = "let";
          break;
        case InstructionKind.Reassign:
          CompilerError.invariant(false, {
            reason:
              "Destructure should never be Reassign as it would be an Object/ArrayPattern",
            description: null,
            loc: iterableItem.loc,
            suggestions: null,
          });
        case InstructionKind.Catch:
          CompilerError.invariant(false, {
            reason: "Unexpected catch variable as for..of collection",
            description: null,
            loc: iterableItem.loc,
            suggestions: null,
          });
        case InstructionKind.HoistedConst:
          CompilerError.invariant(false, {
            reason: "Unexpected HoistedConst variable in for..of collection",
            description: null,
            loc: iterableItem.loc,
            suggestions: null,
          });
        default:
          assertExhaustive$1(
            iterableItem.value.lvalue.kind,
            `Unhandled lvalue kind: ${iterableItem.value.lvalue.kind}`
          );
      }
      return libExports.forOfStatement(
        createVariableDeclaration(iterableItem.value.loc, varDeclKind, [
          libExports.variableDeclarator(lval, null),
        ]),
        codegenInstructionValueToExpression(cx, iterableCollection),
        codegenBlock(cx, terminal.loop)
      );
    }
    case "if": {
      const test = codegenPlaceToExpression(cx, terminal.test);
      const consequent = codegenBlock(cx, terminal.consequent);
      let alternate = null;
      if (terminal.alternate !== null) {
        const block = codegenBlock(cx, terminal.alternate);
        if (block.body.length !== 0) {
          alternate = block;
        }
      }
      return libExports.ifStatement(test, consequent, alternate);
    }
    case "return": {
      const value = codegenPlaceToExpression(cx, terminal.value);
      if (value.type === "Identifier" && value.name === "undefined") {
        return libExports.returnStatement();
      }
      return libExports.returnStatement(value);
    }
    case "switch": {
      return libExports.switchStatement(
        codegenPlaceToExpression(cx, terminal.test),
        terminal.cases.map((case_) => {
          const test =
            case_.test !== null
              ? codegenPlaceToExpression(cx, case_.test)
              : null;
          const block = codegenBlock(cx, case_.block);
          return libExports.switchCase(test, [block]);
        })
      );
    }
    case "throw": {
      return libExports.throwStatement(
        codegenPlaceToExpression(cx, terminal.value)
      );
    }
    case "do-while": {
      const test = codegenInstructionValueToExpression(cx, terminal.test);
      return libExports.doWhileStatement(test, codegenBlock(cx, terminal.loop));
    }
    case "while": {
      const test = codegenInstructionValueToExpression(cx, terminal.test);
      return libExports.whileStatement(test, codegenBlock(cx, terminal.loop));
    }
    case "label": {
      return codegenBlock(cx, terminal.block);
    }
    case "try": {
      let catchParam = null;
      if (terminal.handlerBinding !== null) {
        catchParam = convertIdentifier(terminal.handlerBinding.identifier);
        cx.temp.set(terminal.handlerBinding.identifier.id, null);
      }
      return libExports.tryStatement(
        codegenBlock(cx, terminal.block),
        libExports.catchClause(catchParam, codegenBlock(cx, terminal.handler))
      );
    }
    default: {
      assertExhaustive$1(
        terminal,
        `Unexpected terminal kind \`${terminal.kind}\``
      );
    }
  }
}
function codegenInstructionNullable(cx, instr) {
  if (
    instr.value.kind === "StoreLocal" ||
    instr.value.kind === "StoreContext" ||
    instr.value.kind === "Destructure" ||
    instr.value.kind === "DeclareLocal" ||
    instr.value.kind === "DeclareContext"
  ) {
    let kind = instr.value.lvalue.kind;
    let lvalue;
    let value;
    if (instr.value.kind === "StoreLocal") {
      kind = cx.hasDeclared(instr.value.lvalue.place.identifier)
        ? InstructionKind.Reassign
        : kind;
      lvalue = instr.value.lvalue.place;
      value = codegenPlaceToExpression(cx, instr.value.value);
    } else if (instr.value.kind === "StoreContext") {
      lvalue = instr.value.lvalue.place;
      value = codegenPlaceToExpression(cx, instr.value.value);
    } else if (
      instr.value.kind === "DeclareLocal" ||
      instr.value.kind === "DeclareContext"
    ) {
      if (cx.hasDeclared(instr.value.lvalue.place.identifier)) {
        return null;
      }
      kind = instr.value.lvalue.kind;
      lvalue = instr.value.lvalue.place;
      value = null;
    } else {
      lvalue = instr.value.lvalue.pattern;
      let hasReasign = false;
      let hasDeclaration = false;
      for (const place of eachPatternOperand(lvalue)) {
        if (
          kind !== InstructionKind.Reassign &&
          place.identifier.name === null
        ) {
          cx.temp.set(place.identifier.id, null);
        }
        const isDeclared = cx.hasDeclared(place.identifier);
        hasReasign || (hasReasign = isDeclared);
        hasDeclaration || (hasDeclaration = !isDeclared);
      }
      if (hasReasign && hasDeclaration) {
        CompilerError.invariant(false, {
          reason:
            "Encountered a destructuring operation where some identifiers are already declared (reassignments) but others are not (declarations)",
          description: null,
          loc: instr.loc,
          suggestions: null,
        });
      } else if (hasReasign) {
        kind = InstructionKind.Reassign;
      }
      value = codegenPlaceToExpression(cx, instr.value.value);
    }
    switch (kind) {
      case InstructionKind.Const: {
        CompilerError.invariant(instr.lvalue === null, {
          reason: `Const declaration cannot be referenced as an expression`,
          description: null,
          loc: instr.value.loc,
          suggestions: null,
        });
        return createVariableDeclaration(instr.loc, "const", [
          libExports.variableDeclarator(codegenLValue(cx, lvalue), value),
        ]);
      }
      case InstructionKind.Let: {
        CompilerError.invariant(instr.lvalue === null, {
          reason: `Const declaration cannot be referenced as an expression`,
          description: null,
          loc: instr.value.loc,
          suggestions: null,
        });
        return createVariableDeclaration(instr.loc, "let", [
          libExports.variableDeclarator(codegenLValue(cx, lvalue), value),
        ]);
      }
      case InstructionKind.Reassign: {
        CompilerError.invariant(value !== null, {
          reason: "Expected a value for reassignment",
          description: null,
          loc: instr.value.loc,
          suggestions: null,
        });
        const expr = libExports.assignmentExpression(
          "=",
          codegenLValue(cx, lvalue),
          value
        );
        if (instr.lvalue !== null) {
          if (instr.value.kind !== "StoreContext") {
            cx.temp.set(instr.lvalue.identifier.id, expr);
            return null;
          } else {
            const statement = codegenInstruction(cx, instr, expr);
            if (statement.type === "EmptyStatement") {
              return null;
            }
            return statement;
          }
        } else {
          return createExpressionStatement(instr.loc, expr);
        }
      }
      case InstructionKind.Catch: {
        return libExports.emptyStatement();
      }
      case InstructionKind.HoistedConst: {
        CompilerError.invariant(false, {
          reason:
            "Expected HoistedConsts to have been pruned in PruneHoistedContexts",
          description: null,
          loc: instr.loc,
          suggestions: null,
        });
      }
      default: {
        assertExhaustive$1(kind, `Unexpected instruction kind \`${kind}\``);
      }
    }
  } else if (
    instr.value.kind === "StartMemoize" ||
    instr.value.kind === "FinishMemoize"
  ) {
    return null;
  } else if (instr.value.kind === "Debugger") {
    return libExports.debuggerStatement();
  } else if (instr.value.kind === "ObjectMethod") {
    CompilerError.invariant(instr.lvalue, {
      reason: "Expected object methods to have a temp lvalue",
      loc: null,
      suggestions: null,
    });
    cx.objectMethods.set(instr.lvalue.identifier.id, instr.value);
    return null;
  } else {
    const value = codegenInstructionValue(cx, instr.value);
    const statement = codegenInstruction(cx, instr, value);
    if (statement.type === "EmptyStatement") {
      return null;
    }
    return statement;
  }
}
function codegenForInit(cx, init) {
  if (init.kind === "SequenceExpression") {
    for (const instr of init.instructions) {
      if (instr.value.kind === "DeclareContext") {
        CompilerError.throwTodo({
          reason: `Support for loops where the index variable is a context variable`,
          loc: instr.loc,
          description:
            instr.value.lvalue.place.identifier.name != null
              ? `\`${instr.value.lvalue.place.identifier.name.value}\` is a context variable`
              : null,
          suggestions: null,
        });
      }
    }
    const body = codegenBlock(
      cx,
      init.instructions.map((instruction) => ({
        kind: "instruction",
        instruction: instruction,
      }))
    ).body;
    const declarators = [];
    let kind = "const";
    body.forEach((instr) => {
      CompilerError.invariant(
        instr.type === "VariableDeclaration" &&
          (instr.kind === "let" || instr.kind === "const"),
        {
          reason: "Expected a variable declaration",
          loc: init.loc,
          description: `Got ${instr.type}`,
          suggestions: null,
        }
      );
      if (instr.kind === "let") {
        kind = "let";
      }
      declarators.push(...instr.declarations);
    });
    CompilerError.invariant(declarators.length > 0, {
      reason: "Expected a variable declaration",
      loc: init.loc,
      description: null,
      suggestions: null,
    });
    return libExports.variableDeclaration(kind, declarators);
  } else {
    return codegenInstructionValueToExpression(cx, init);
  }
}
function printDependencyComment(dependency) {
  const identifier = convertIdentifier(dependency.identifier);
  let name = identifier.name;
  if (dependency.path !== null) {
    for (const path of dependency.path) {
      name += `.${path}`;
    }
  }
  return name;
}
function printDelimitedCommentList(items, finalCompletion) {
  if (items.length === 2) {
    return items.join(` ${finalCompletion} `);
  } else if (items.length <= 1) {
    return items.join("");
  }
  let output = [];
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if (i < items.length - 2) {
      output.push(`${item}, `);
    } else if (i === items.length - 2) {
      output.push(`${item}, ${finalCompletion} `);
    } else {
      output.push(item);
    }
  }
  return output.join("");
}
function codegenDependency(cx, dependency) {
  let object = convertIdentifier(dependency.identifier);
  if (dependency.path !== null) {
    for (const path of dependency.path) {
      object = libExports.memberExpression(object, libExports.identifier(path));
    }
  }
  return object;
}
function withLoc(fn) {
  return (loc, ...args) => {
    const node = fn(...args);
    if (loc != null && loc != GeneratedSource) {
      node.loc = loc;
    }
    return node;
  };
}
const createBinaryExpression = withLoc(libExports.binaryExpression);
const createExpressionStatement = withLoc(libExports.expressionStatement);
const createVariableDeclaration = withLoc(libExports.variableDeclaration);
const createTaggedTemplateExpression = withLoc(
  libExports.taggedTemplateExpression
);
const createLogicalExpression = withLoc(libExports.logicalExpression);
const createSequenceExpression = withLoc(libExports.sequenceExpression);
const createConditionalExpression = withLoc(libExports.conditionalExpression);
const createTemplateLiteral = withLoc(libExports.templateLiteral);
const createJsxNamespacedName = withLoc(libExports.jsxNamespacedName);
const createJsxElement = withLoc(libExports.jsxElement);
const createJsxAttribute = withLoc(libExports.jsxAttribute);
const createJsxIdentifier = withLoc(libExports.jsxIdentifier);
const createJsxExpressionContainer = withLoc(libExports.jsxExpressionContainer);
const createJsxText = withLoc(libExports.jsxText);
const createJsxClosingElement = withLoc(libExports.jsxClosingElement);
const createJsxOpeningElement = withLoc(libExports.jsxOpeningElement);
const createStringLiteral = withLoc(libExports.stringLiteral);
function createHookGuard(guard, stmts, before, after) {
  function createHookGuardImpl(kind) {
    return libExports.expressionStatement(
      libExports.callExpression(
        libExports.identifier(guard.importSpecifierName),
        [libExports.numericLiteral(kind)]
      )
    );
  }
  return libExports.tryStatement(
    libExports.blockStatement([createHookGuardImpl(before), ...stmts]),
    null,
    libExports.blockStatement([createHookGuardImpl(after)])
  );
}
function createCallExpression(config, callee, args, loc, isHook) {
  const callExpr = libExports.callExpression(callee, args);
  if (loc != null && loc != GeneratedSource) {
    callExpr.loc = loc;
  }
  const hookGuard = config.enableEmitHookGuards;
  if (hookGuard != null && isHook) {
    const iife = libExports.functionExpression(
      null,
      [],
      libExports.blockStatement([
        createHookGuard(
          hookGuard,
          [libExports.returnStatement(callExpr)],
          GuardKind.AllowHook,
          GuardKind.DisallowHook
        ),
      ])
    );
    return libExports.callExpression(iife, []);
  } else {
    return callExpr;
  }
}
function codegenLabel(id) {
  return `bb${id}`;
}
function codegenInstruction(cx, instr, value) {
  if (libExports.isStatement(value)) {
    return value;
  }
  if (instr.lvalue === null) {
    return libExports.expressionStatement(convertValueToExpression(value));
  }
  if (instr.lvalue.identifier.name === null) {
    cx.temp.set(instr.lvalue.identifier.id, value);
    return libExports.emptyStatement();
  } else {
    const expressionValue = convertValueToExpression(value);
    if (cx.hasDeclared(instr.lvalue.identifier)) {
      return createExpressionStatement(
        instr.loc,
        libExports.assignmentExpression(
          "=",
          convertIdentifier(instr.lvalue.identifier),
          expressionValue
        )
      );
    } else {
      return createVariableDeclaration(instr.loc, "const", [
        libExports.variableDeclarator(
          convertIdentifier(instr.lvalue.identifier),
          expressionValue
        ),
      ]);
    }
  }
}
function convertValueToExpression(value) {
  if (value.type === "JSXText") {
    return createStringLiteral(value.loc, value.value);
  }
  return value;
}
function codegenInstructionValueToExpression(cx, instrValue) {
  const value = codegenInstructionValue(cx, instrValue);
  return convertValueToExpression(value);
}
function codegenInstructionValue(cx, instrValue) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  let value;
  switch (instrValue.kind) {
    case "ArrayExpression": {
      const elements = instrValue.elements.map((element) => {
        if (element.kind === "Identifier") {
          return codegenPlaceToExpression(cx, element);
        } else if (element.kind === "Spread") {
          return libExports.spreadElement(
            codegenPlaceToExpression(cx, element.place)
          );
        } else {
          return null;
        }
      });
      value = libExports.arrayExpression(elements);
      break;
    }
    case "BinaryExpression": {
      const left = codegenPlaceToExpression(cx, instrValue.left);
      const right = codegenPlaceToExpression(cx, instrValue.right);
      value = createBinaryExpression(
        instrValue.loc,
        instrValue.operator,
        left,
        right
      );
      break;
    }
    case "UnaryExpression": {
      value = libExports.unaryExpression(
        instrValue.operator,
        codegenPlaceToExpression(cx, instrValue.value)
      );
      break;
    }
    case "Primitive": {
      value = codegenValue(cx, instrValue.loc, instrValue.value);
      break;
    }
    case "CallExpression": {
      if (cx.env.config.enableForest) {
        const callee = codegenPlaceToExpression(cx, instrValue.callee);
        const args = instrValue.args.map((arg) => codegenArgument(cx, arg));
        value = libExports.callExpression(callee, args);
        if (instrValue.typeArguments != null) {
          value.typeArguments = libExports.typeParameterInstantiation(
            instrValue.typeArguments
          );
        }
        break;
      }
      const isHook = getHookKind(cx.env, instrValue.callee.identifier) != null;
      const callee = codegenPlaceToExpression(cx, instrValue.callee);
      const args = instrValue.args.map((arg) => codegenArgument(cx, arg));
      value = createCallExpression(
        cx.env.config,
        callee,
        args,
        instrValue.loc,
        isHook
      );
      break;
    }
    case "OptionalExpression": {
      const optionalValue = codegenInstructionValueToExpression(
        cx,
        instrValue.value
      );
      switch (optionalValue.type) {
        case "OptionalCallExpression":
        case "CallExpression": {
          CompilerError.invariant(
            libExports.isExpression(optionalValue.callee),
            {
              reason: "v8 intrinsics are validated during lowering",
              description: null,
              loc:
                (_a = optionalValue.callee.loc) !== null && _a !== void 0
                  ? _a
                  : null,
              suggestions: null,
            }
          );
          value = libExports.optionalCallExpression(
            optionalValue.callee,
            optionalValue.arguments,
            instrValue.optional
          );
          break;
        }
        case "OptionalMemberExpression":
        case "MemberExpression": {
          const property = optionalValue.property;
          CompilerError.invariant(libExports.isExpression(property), {
            reason: "Private names are validated during lowering",
            description: null,
            loc: (_b = property.loc) !== null && _b !== void 0 ? _b : null,
            suggestions: null,
          });
          value = libExports.optionalMemberExpression(
            optionalValue.object,
            property,
            optionalValue.computed,
            instrValue.optional
          );
          break;
        }
        default: {
          CompilerError.invariant(false, {
            reason:
              "Expected an optional value to resolve to a call expression or member expression",
            description: `Got a \`${optionalValue.type}\``,
            loc: instrValue.loc,
            suggestions: null,
          });
        }
      }
      break;
    }
    case "MethodCall": {
      const isHook =
        getHookKind(cx.env, instrValue.property.identifier) != null;
      const memberExpr = codegenPlaceToExpression(cx, instrValue.property);
      CompilerError.invariant(
        libExports.isMemberExpression(memberExpr) ||
          libExports.isOptionalMemberExpression(memberExpr),
        {
          reason:
            "[Codegen] Internal error: MethodCall::property must be an unpromoted + unmemoized MemberExpression. " +
            `Got a \`${memberExpr.type}\``,
          description: null,
          loc: (_c = memberExpr.loc) !== null && _c !== void 0 ? _c : null,
          suggestions: null,
        }
      );
      CompilerError.invariant(
        libExports.isNodesEquivalent(
          memberExpr.object,
          codegenPlaceToExpression(cx, instrValue.receiver)
        ),
        {
          reason:
            "[Codegen] Internal error: Forget should always generate MethodCall::property " +
            "as a MemberExpression of MethodCall::receiver",
          description: null,
          loc: (_d = memberExpr.loc) !== null && _d !== void 0 ? _d : null,
          suggestions: null,
        }
      );
      const args = instrValue.args.map((arg) => codegenArgument(cx, arg));
      value = createCallExpression(
        cx.env.config,
        memberExpr,
        args,
        instrValue.loc,
        isHook
      );
      break;
    }
    case "NewExpression": {
      const callee = codegenPlaceToExpression(cx, instrValue.callee);
      const args = instrValue.args.map((arg) => codegenArgument(cx, arg));
      value = libExports.newExpression(callee, args);
      break;
    }
    case "ObjectExpression": {
      const properties = [];
      for (const property of instrValue.properties) {
        if (property.kind === "ObjectProperty") {
          const key = codegenObjectPropertyKey(cx, property.key);
          switch (property.type) {
            case "property": {
              const value = codegenPlaceToExpression(cx, property.place);
              properties.push(
                libExports.objectProperty(
                  key,
                  value,
                  property.key.kind === "computed",
                  key.type === "Identifier" &&
                    value.type === "Identifier" &&
                    value.name === key.name
                )
              );
              break;
            }
            case "method": {
              const method = cx.objectMethods.get(property.place.identifier.id);
              CompilerError.invariant(method, {
                reason: "Expected ObjectMethod instruction",
                loc: null,
                suggestions: null,
              });
              const loweredFunc = method.loweredFunc;
              const reactiveFunction = buildReactiveFunction(loweredFunc.func);
              pruneUnusedLabels(reactiveFunction);
              pruneTemporaryLValues(reactiveFunction);
              const fn = codegenReactiveFunction(
                new Context$2(
                  cx.env,
                  (_e = reactiveFunction.id) !== null && _e !== void 0
                    ? _e
                    : "[[ anonymous ]]",
                  cx.uniqueIdentifiers,
                  cx.temp
                ),
                reactiveFunction
              ).unwrap();
              const babelNode = libExports.objectMethod(
                "method",
                key,
                fn.params,
                fn.body,
                false
              );
              babelNode.async = fn.async;
              babelNode.generator = fn.generator;
              properties.push(babelNode);
              break;
            }
            default:
              assertExhaustive$1(
                property.type,
                `Unexpected property type: ${property.type}`
              );
          }
        } else {
          properties.push(
            libExports.spreadElement(
              codegenPlaceToExpression(cx, property.place)
            )
          );
        }
      }
      value = libExports.objectExpression(properties);
      break;
    }
    case "JSXText": {
      value = createJsxText(instrValue.loc, instrValue.value);
      break;
    }
    case "JsxExpression": {
      const attributes = [];
      for (const attribute of instrValue.props) {
        attributes.push(codegenJsxAttribute(cx, attribute));
      }
      let tagValue =
        instrValue.tag.kind === "Identifier"
          ? codegenPlaceToExpression(cx, instrValue.tag)
          : libExports.stringLiteral(instrValue.tag.name);
      let tag;
      if (tagValue.type === "Identifier") {
        tag = createJsxIdentifier(instrValue.tag.loc, tagValue.name);
      } else if (tagValue.type === "MemberExpression") {
        tag = convertMemberExpressionToJsx(tagValue);
      } else {
        CompilerError.invariant(tagValue.type === "StringLiteral", {
          reason: `Expected JSX tag to be an identifier or string, got \`${tagValue.type}\``,
          description: null,
          loc: (_f = tagValue.loc) !== null && _f !== void 0 ? _f : null,
          suggestions: null,
        });
        if (tagValue.value.indexOf(":") >= 0) {
          const [namespace, name] = tagValue.value.split(":", 2);
          tag = createJsxNamespacedName(
            instrValue.tag.loc,
            createJsxIdentifier(instrValue.tag.loc, namespace),
            createJsxIdentifier(instrValue.tag.loc, name)
          );
        } else {
          tag = createJsxIdentifier(instrValue.loc, tagValue.value);
        }
      }
      let children;
      if (
        tagValue.type === "StringLiteral" &&
        SINGLE_CHILD_FBT_TAGS.has(tagValue.value)
      ) {
        CompilerError.invariant(instrValue.children != null, {
          loc: instrValue.loc,
          reason: "Expected fbt element to have children",
          suggestions: null,
          description: null,
        });
        children = instrValue.children.map((child) =>
          codegenJsxFbtChildElement(cx, child)
        );
      } else {
        children =
          instrValue.children !== null
            ? instrValue.children.map((child) => codegenJsxElement(cx, child))
            : [];
      }
      value = createJsxElement(
        instrValue.loc,
        createJsxOpeningElement(
          instrValue.openingLoc,
          tag,
          attributes,
          instrValue.children === null
        ),
        instrValue.children !== null
          ? createJsxClosingElement(instrValue.closingLoc, tag)
          : null,
        children,
        instrValue.children === null
      );
      break;
    }
    case "JsxFragment": {
      value = libExports.jsxFragment(
        libExports.jsxOpeningFragment(),
        libExports.jsxClosingFragment(),
        instrValue.children.map((child) => codegenJsxElement(cx, child))
      );
      break;
    }
    case "UnsupportedNode": {
      const node = instrValue.node;
      if (!libExports.isExpression(node)) {
        return node;
      }
      value = node;
      break;
    }
    case "PropertyStore": {
      value = libExports.assignmentExpression(
        "=",
        libExports.memberExpression(
          codegenPlaceToExpression(cx, instrValue.object),
          libExports.identifier(instrValue.property)
        ),
        codegenPlaceToExpression(cx, instrValue.value)
      );
      break;
    }
    case "PropertyLoad": {
      const object = codegenPlaceToExpression(cx, instrValue.object);
      value = libExports.memberExpression(
        object,
        libExports.identifier(instrValue.property),
        undefined
      );
      break;
    }
    case "PropertyDelete": {
      value = libExports.unaryExpression(
        "delete",
        libExports.memberExpression(
          codegenPlaceToExpression(cx, instrValue.object),
          libExports.identifier(instrValue.property)
        )
      );
      break;
    }
    case "ComputedStore": {
      value = libExports.assignmentExpression(
        "=",
        libExports.memberExpression(
          codegenPlaceToExpression(cx, instrValue.object),
          codegenPlaceToExpression(cx, instrValue.property),
          true
        ),
        codegenPlaceToExpression(cx, instrValue.value)
      );
      break;
    }
    case "ComputedLoad": {
      const object = codegenPlaceToExpression(cx, instrValue.object);
      const property = codegenPlaceToExpression(cx, instrValue.property);
      value = libExports.memberExpression(object, property, true);
      break;
    }
    case "ComputedDelete": {
      value = libExports.unaryExpression(
        "delete",
        libExports.memberExpression(
          codegenPlaceToExpression(cx, instrValue.object),
          codegenPlaceToExpression(cx, instrValue.property),
          true
        )
      );
      break;
    }
    case "LoadLocal":
    case "LoadContext": {
      value = codegenPlaceToExpression(cx, instrValue.place);
      break;
    }
    case "FunctionExpression": {
      const loweredFunc = instrValue.loweredFunc.func;
      const reactiveFunction = buildReactiveFunction(loweredFunc);
      pruneUnusedLabels(reactiveFunction);
      pruneTemporaryLValues(reactiveFunction);
      pruneHoistedContexts(reactiveFunction);
      const fn = codegenReactiveFunction(
        new Context$2(
          cx.env,
          (_g = reactiveFunction.id) !== null && _g !== void 0
            ? _g
            : "[[ anonymous ]]",
          cx.uniqueIdentifiers,
          cx.temp
        ),
        reactiveFunction
      ).unwrap();
      if (instrValue.expr.type === "ArrowFunctionExpression") {
        let body = fn.body;
        if (body.body.length === 1 && loweredFunc.directives.length == 0) {
          const stmt = body.body[0];
          if (stmt.type === "ReturnStatement" && stmt.argument != null) {
            body = stmt.argument;
          }
        }
        value = libExports.arrowFunctionExpression(fn.params, body, fn.async);
      } else {
        value = libExports.functionExpression(
          (_h = fn.id) !== null && _h !== void 0
            ? _h
            : instrValue.name != null
              ? libExports.identifier(instrValue.name)
              : null,
          fn.params,
          fn.body,
          fn.generator,
          fn.async
        );
      }
      break;
    }
    case "TaggedTemplateExpression": {
      value = createTaggedTemplateExpression(
        instrValue.loc,
        codegenPlaceToExpression(cx, instrValue.tag),
        libExports.templateLiteral(
          [libExports.templateElement(instrValue.value)],
          []
        )
      );
      break;
    }
    case "TypeCastExpression": {
      if (libExports.isTSType(instrValue.typeAnnotation)) {
        value = libExports.tsAsExpression(
          codegenPlaceToExpression(cx, instrValue.value),
          instrValue.typeAnnotation
        );
      } else {
        value = libExports.typeCastExpression(
          codegenPlaceToExpression(cx, instrValue.value),
          libExports.typeAnnotation(instrValue.typeAnnotation)
        );
      }
      break;
    }
    case "LogicalExpression": {
      value = createLogicalExpression(
        instrValue.loc,
        instrValue.operator,
        codegenInstructionValueToExpression(cx, instrValue.left),
        codegenInstructionValueToExpression(cx, instrValue.right)
      );
      break;
    }
    case "ConditionalExpression": {
      value = createConditionalExpression(
        instrValue.loc,
        codegenInstructionValueToExpression(cx, instrValue.test),
        codegenInstructionValueToExpression(cx, instrValue.consequent),
        codegenInstructionValueToExpression(cx, instrValue.alternate)
      );
      break;
    }
    case "SequenceExpression": {
      const body = codegenBlockNoReset(
        cx,
        instrValue.instructions.map((instruction) => ({
          kind: "instruction",
          instruction: instruction,
        }))
      ).body;
      const expressions = body.map((stmt) => {
        var _a, _b;
        if (stmt.type === "ExpressionStatement") {
          return stmt.expression;
        } else {
          if (libExports.isVariableDeclaration(stmt)) {
            const declarator = stmt.declarations[0];
            cx.errors.push({
              reason: `(CodegenReactiveFunction::codegenInstructionValue) Cannot declare variables in a value block, tried to declare '${declarator.id.name}'`,
              severity: ErrorSeverity.Todo,
              loc: (_a = declarator.loc) !== null && _a !== void 0 ? _a : null,
              suggestions: null,
            });
            return libExports.stringLiteral(`TODO handle ${declarator.id}`);
          } else {
            cx.errors.push({
              reason: `(CodegenReactiveFunction::codegenInstructionValue) Handle conversion of ${stmt.type} to expression`,
              severity: ErrorSeverity.Todo,
              loc: (_b = stmt.loc) !== null && _b !== void 0 ? _b : null,
              suggestions: null,
            });
            return libExports.stringLiteral(`TODO handle ${stmt.type}`);
          }
        }
      });
      if (expressions.length === 0) {
        value = codegenInstructionValueToExpression(cx, instrValue.value);
      } else {
        value = createSequenceExpression(instrValue.loc, [
          ...expressions,
          codegenInstructionValueToExpression(cx, instrValue.value),
        ]);
      }
      break;
    }
    case "TemplateLiteral": {
      value = createTemplateLiteral(
        instrValue.loc,
        instrValue.quasis.map((q) => libExports.templateElement(q)),
        instrValue.subexprs.map((p) => codegenPlaceToExpression(cx, p))
      );
      break;
    }
    case "LoadGlobal": {
      value = libExports.identifier(instrValue.binding.name);
      break;
    }
    case "RegExpLiteral": {
      value = libExports.regExpLiteral(instrValue.pattern, instrValue.flags);
      break;
    }
    case "MetaProperty": {
      value = libExports.metaProperty(
        libExports.identifier(instrValue.meta),
        libExports.identifier(instrValue.property)
      );
      break;
    }
    case "Await": {
      value = libExports.awaitExpression(
        codegenPlaceToExpression(cx, instrValue.value)
      );
      break;
    }
    case "GetIterator": {
      value = codegenPlaceToExpression(cx, instrValue.collection);
      break;
    }
    case "IteratorNext": {
      value = codegenPlaceToExpression(cx, instrValue.iterator);
      break;
    }
    case "NextPropertyOf": {
      value = codegenPlaceToExpression(cx, instrValue.value);
      break;
    }
    case "PostfixUpdate": {
      value = libExports.updateExpression(
        instrValue.operation,
        codegenPlaceToExpression(cx, instrValue.lvalue),
        false
      );
      break;
    }
    case "PrefixUpdate": {
      value = libExports.updateExpression(
        instrValue.operation,
        codegenPlaceToExpression(cx, instrValue.lvalue),
        true
      );
      break;
    }
    case "StoreLocal": {
      CompilerError.invariant(
        instrValue.lvalue.kind === InstructionKind.Reassign,
        {
          reason: `Unexpected StoreLocal in codegenInstructionValue`,
          description: null,
          loc: instrValue.loc,
          suggestions: null,
        }
      );
      value = libExports.assignmentExpression(
        "=",
        codegenLValue(cx, instrValue.lvalue.place),
        codegenPlaceToExpression(cx, instrValue.value)
      );
      break;
    }
    case "StoreGlobal": {
      value = libExports.assignmentExpression(
        "=",
        libExports.identifier(instrValue.name),
        codegenPlaceToExpression(cx, instrValue.value)
      );
      break;
    }
    case "ReactiveFunctionValue":
    case "StartMemoize":
    case "FinishMemoize":
    case "Debugger":
    case "DeclareLocal":
    case "DeclareContext":
    case "Destructure":
    case "ObjectMethod":
    case "StoreContext": {
      CompilerError.invariant(false, {
        reason: `Unexpected ${instrValue.kind} in codegenInstructionValue`,
        description: null,
        loc: instrValue.loc,
        suggestions: null,
      });
    }
    default: {
      assertExhaustive$1(
        instrValue,
        `Unexpected instruction value kind \`${instrValue.kind}\``
      );
    }
  }
  return value;
}
const STRING_REQUIRES_EXPR_CONTAINER_PATTERN =
  /[\u{0000}-\u{001F}|\u{007F}|\u{0080}-\u{FFFF}]|"/u;
function codegenJsxAttribute(cx, attribute) {
  switch (attribute.kind) {
    case "JsxAttribute": {
      let propName;
      if (attribute.name.indexOf(":") === -1) {
        propName = createJsxIdentifier(attribute.place.loc, attribute.name);
      } else {
        const [namespace, name] = attribute.name.split(":", 2);
        propName = createJsxNamespacedName(
          attribute.place.loc,
          createJsxIdentifier(attribute.place.loc, namespace),
          createJsxIdentifier(attribute.place.loc, name)
        );
      }
      const innerValue = codegenPlaceToExpression(cx, attribute.place);
      let value;
      switch (innerValue.type) {
        case "StringLiteral": {
          value = innerValue;
          if (STRING_REQUIRES_EXPR_CONTAINER_PATTERN.test(value.value)) {
            value = createJsxExpressionContainer(value.loc, value);
          }
          break;
        }
        default: {
          value = createJsxExpressionContainer(attribute.place.loc, innerValue);
          break;
        }
      }
      return createJsxAttribute(attribute.place.loc, propName, value);
    }
    case "JsxSpreadAttribute": {
      return libExports.jsxSpreadAttribute(
        codegenPlaceToExpression(cx, attribute.argument)
      );
    }
    default: {
      assertExhaustive$1(
        attribute,
        `Unexpected attribute kind \`${attribute.kind}\``
      );
    }
  }
}
const JSX_TEXT_CHILD_REQUIRES_EXPR_CONTAINER_PATTERN = /[<>&]/;
function codegenJsxElement(cx, place) {
  const value = codegenPlace(cx, place);
  switch (value.type) {
    case "JSXText": {
      if (JSX_TEXT_CHILD_REQUIRES_EXPR_CONTAINER_PATTERN.test(value.value)) {
        return createJsxExpressionContainer(
          place.loc,
          createStringLiteral(place.loc, value.value)
        );
      }
      return createJsxText(place.loc, value.value);
    }
    case "JSXElement":
    case "JSXFragment": {
      return value;
    }
    default: {
      return createJsxExpressionContainer(place.loc, value);
    }
  }
}
function codegenJsxFbtChildElement(cx, place) {
  const value = codegenPlace(cx, place);
  switch (value.type) {
    case "JSXText":
    case "JSXElement": {
      return value;
    }
    default: {
      return createJsxExpressionContainer(place.loc, value);
    }
  }
}
function convertMemberExpressionToJsx(expr) {
  var _a, _b;
  CompilerError.invariant(expr.property.type === "Identifier", {
    reason: "Expected JSX member expression property to be a string",
    description: null,
    loc: (_a = expr.loc) !== null && _a !== void 0 ? _a : null,
    suggestions: null,
  });
  const property = libExports.jsxIdentifier(expr.property.name);
  if (expr.object.type === "Identifier") {
    return libExports.jsxMemberExpression(
      libExports.jsxIdentifier(expr.object.name),
      property
    );
  } else {
    CompilerError.invariant(expr.object.type === "MemberExpression", {
      reason:
        "Expected JSX member expression to be an identifier or nested member expression",
      description: null,
      loc: (_b = expr.object.loc) !== null && _b !== void 0 ? _b : null,
      suggestions: null,
    });
    const object = convertMemberExpressionToJsx(expr.object);
    return libExports.jsxMemberExpression(object, property);
  }
}
function codegenObjectPropertyKey(cx, key) {
  switch (key.kind) {
    case "string": {
      return libExports.stringLiteral(key.name);
    }
    case "identifier": {
      return libExports.identifier(key.name);
    }
    case "computed": {
      const expr = codegenPlace(cx, key.name);
      CompilerError.invariant(libExports.isExpression(expr), {
        reason: "Expected object property key to be an expression",
        description: null,
        loc: key.name.loc,
        suggestions: null,
      });
      return expr;
    }
  }
}
function codegenArrayPattern(cx, pattern) {
  const hasHoles = !pattern.items.every((e) => e.kind !== "Hole");
  if (hasHoles) {
    const result = libExports.arrayPattern([]);
    for (const item of pattern.items) {
      if (item.kind === "Hole") {
        result.elements.push(null);
      } else {
        result.elements.push(codegenLValue(cx, item));
      }
    }
    return result;
  } else {
    return libExports.arrayPattern(
      pattern.items.map((item) => {
        if (item.kind === "Hole") {
          return null;
        }
        return codegenLValue(cx, item);
      })
    );
  }
}
function codegenLValue(cx, pattern) {
  switch (pattern.kind) {
    case "ArrayPattern": {
      return codegenArrayPattern(cx, pattern);
    }
    case "ObjectPattern": {
      return libExports.objectPattern(
        pattern.properties.map((property) => {
          if (property.kind === "ObjectProperty") {
            const key = codegenObjectPropertyKey(cx, property.key);
            const value = codegenLValue(cx, property.place);
            return libExports.objectProperty(
              key,
              value,
              property.key.kind === "computed",
              key.type === "Identifier" &&
                value.type === "Identifier" &&
                value.name === key.name
            );
          } else {
            return libExports.restElement(codegenLValue(cx, property.place));
          }
        })
      );
    }
    case "Spread": {
      return libExports.restElement(codegenLValue(cx, pattern.place));
    }
    case "Identifier": {
      return convertIdentifier(pattern.identifier);
    }
    default: {
      assertExhaustive$1(
        pattern,
        `Unexpected pattern kind \`${pattern.kind}\``
      );
    }
  }
}
function codegenValue(cx, loc, value) {
  if (typeof value === "number") {
    return libExports.numericLiteral(value);
  } else if (typeof value === "boolean") {
    return libExports.booleanLiteral(value);
  } else if (typeof value === "string") {
    return createStringLiteral(loc, value);
  } else if (value === null) {
    return libExports.nullLiteral();
  } else if (value === undefined) {
    return libExports.identifier("undefined");
  } else {
    assertExhaustive$1(value, "Unexpected primitive value kind");
  }
}
function codegenArgument(cx, arg) {
  if (arg.kind === "Identifier") {
    return codegenPlaceToExpression(cx, arg);
  } else {
    return libExports.spreadElement(codegenPlaceToExpression(cx, arg.place));
  }
}
function codegenPlaceToExpression(cx, place) {
  const value = codegenPlace(cx, place);
  return convertValueToExpression(value);
}
function codegenPlace(cx, place) {
  let tmp = cx.temp.get(place.identifier.id);
  if (tmp != null) {
    return tmp;
  }
  CompilerError.invariant(place.identifier.name !== null || tmp !== undefined, {
    reason: `[Codegen] No value found for temporary`,
    description: `Value for '${printPlace(place)}' was not set in the codegen context`,
    loc: place.loc,
    suggestions: null,
  });
  const identifier = convertIdentifier(place.identifier);
  identifier.loc = place.loc;
  return identifier;
}
function convertIdentifier(identifier) {
  CompilerError.invariant(
    identifier.name !== null && identifier.name.kind === "named",
    {
      reason: `Expected temporaries to be promoted to named identifiers in an earlier pass`,
      loc: GeneratedSource,
      description: `identifier ${identifier.id} is unnamed`,
      suggestions: null,
    }
  );
  return libExports.identifier(identifier.name.value);
}
function extractScopeDeclarationsFromDestructuring(fn) {
  const state = new State$2(fn.env);
  visitReactiveFunction(fn, new Visitor$b(), state);
}
let State$2 = class State {
  constructor(env) {
    this.declared = new Set();
    this.env = env;
  }
};
let Visitor$b = class Visitor extends ReactiveFunctionTransform {
  visitScope(scope, state) {
    for (const [, declaration] of scope.scope.declarations) {
      state.declared.add(declaration.identifier.id);
    }
    this.traverseScope(scope, state);
  }
  transformInstruction(instruction, state) {
    this.visitInstruction(instruction, state);
    if (instruction.value.kind === "Destructure") {
      const transformed = transformDestructuring(
        state,
        instruction,
        instruction.value
      );
      if (transformed) {
        return {
          kind: "replace-many",
          value: transformed.map((instruction) => ({
            kind: "instruction",
            instruction: instruction,
          })),
        };
      }
    }
    return { kind: "keep" };
  }
};
function transformDestructuring(state, instr, destructure) {
  let reassigned = new Set();
  let hasDeclaration = false;
  for (const place of eachPatternOperand(destructure.lvalue.pattern)) {
    const isDeclared = state.declared.has(place.identifier.id);
    if (isDeclared) {
      reassigned.add(place.identifier.id);
    }
    hasDeclaration || (hasDeclaration = !isDeclared);
  }
  if (reassigned.size === 0 || !hasDeclaration) {
    return null;
  }
  const instructions = [];
  const renamed = new Map();
  mapPatternOperands(destructure.lvalue.pattern, (place) => {
    if (!reassigned.has(place.identifier.id)) {
      return place;
    }
    const tempId = state.env.nextIdentifierId;
    const temporary = Object.assign(Object.assign({}, place), {
      identifier: Object.assign(Object.assign({}, place.identifier), {
        id: tempId,
        name: null,
      }),
    });
    promoteTemporary(temporary.identifier);
    renamed.set(place, temporary);
    return temporary;
  });
  instructions.push(instr);
  for (const [original, temporary] of renamed) {
    instructions.push({
      id: instr.id,
      lvalue: null,
      value: {
        kind: "StoreLocal",
        lvalue: { kind: InstructionKind.Reassign, place: original },
        value: temporary,
        type: null,
        loc: destructure.loc,
      },
      loc: instr.loc,
    });
  }
  return instructions;
}
function flattenReactiveLoops(fn) {
  visitReactiveFunction(fn, new Transform$6(), false);
}
let Transform$6 = class Transform extends ReactiveFunctionTransform {
  transformScope(scope, isWithinLoop) {
    this.visitScope(scope, isWithinLoop);
    if (isWithinLoop) {
      return {
        kind: "replace",
        value: {
          kind: "pruned-scope",
          scope: scope.scope,
          instructions: scope.instructions,
        },
      };
    } else {
      return { kind: "keep" };
    }
  }
  visitTerminal(stmt, isWithinLoop) {
    switch (stmt.terminal.kind) {
      case "do-while":
      case "while":
      case "for":
      case "for-of":
      case "for-in": {
        this.traverseTerminal(stmt, true);
        break;
      }
      case "try":
      case "label":
      case "break":
      case "continue":
      case "if":
      case "return":
      case "switch":
      case "throw": {
        this.traverseTerminal(stmt, isWithinLoop);
        break;
      }
      default: {
        assertExhaustive$1(
          stmt.terminal,
          `Unexpected terminal kind \`${stmt.terminal.kind}\``
        );
      }
    }
  }
};
function flattenScopesWithHooksOrUse(fn) {
  visitReactiveFunction(fn, new Transform$5(), { env: fn.env, hasHook: false });
}
let Transform$5 = class Transform extends ReactiveFunctionTransform {
  transformScope(scope, outerState) {
    const innerState = { env: outerState.env, hasHook: false };
    this.visitScope(scope, innerState);
    outerState.hasHook || (outerState.hasHook = innerState.hasHook);
    if (innerState.hasHook) {
      if (scope.instructions.length === 1) {
        return { kind: "replace-many", value: scope.instructions };
      }
      return {
        kind: "replace",
        value: {
          kind: "pruned-scope",
          scope: scope.scope,
          instructions: scope.instructions,
        },
      };
    } else {
      return { kind: "keep" };
    }
  }
  visitValue(id, value, state) {
    this.traverseValue(id, value, state);
    switch (value.kind) {
      case "CallExpression": {
        if (
          getHookKind(state.env, value.callee.identifier) != null ||
          isUseOperator(value.callee.identifier)
        ) {
          state.hasHook = true;
        }
        break;
      }
      case "MethodCall": {
        if (
          getHookKind(state.env, value.property.identifier) != null ||
          isUseOperator(value.property.identifier)
        ) {
          state.hasHook = true;
        }
        break;
      }
    }
  }
};
function mergeOverlappingReactiveScopes(fn) {
  const context = new Context$1();
  visitReactiveFunction(fn, new Visitor$a(), context);
  context.complete();
}
let Visitor$a = class Visitor extends ReactiveFunctionVisitor {
  visitID(id, state) {
    state.visitId(id);
  }
  visitPlace(id, place, state) {
    state.visitPlace(id, place);
  }
  visitLValue(id, lvalue, state) {
    state.visitPlace(id, lvalue);
  }
  visitBlock(block, state) {
    state.enter(() => {
      this.traverseBlock(block, state);
    });
  }
  visitInstruction(instruction, state) {
    if (
      instruction.value.kind === "ConditionalExpression" ||
      instruction.value.kind === "LogicalExpression" ||
      instruction.value.kind === "OptionalExpression"
    ) {
      state.enter(() => {
        super.visitInstruction(instruction, state);
      });
    } else {
      super.visitInstruction(instruction, state);
    }
  }
};
class BlockScope {
  constructor() {
    this.seen = new Set();
    this.scopes = [];
  }
}
let Context$1 = class Context {
  constructor() {
    this.scopes = [];
    this.seenScopes = new Set();
    this.joinedScopes = new DisjointSet();
    this.operandScopes = new Map();
  }
  visitId(id) {
    const currentBlock = this.scopes[this.scopes.length - 1];
    retainWhere(currentBlock.scopes, (pending) => {
      if (pending.scope.range.end > id) {
        return true;
      } else {
        currentBlock.seen.delete(pending.scope.id);
        return false;
      }
    });
  }
  visitPlace(id, place) {
    const scope = getPlaceScope(id, place);
    if (scope === null) {
      return;
    }
    this.operandScopes.set(place, scope);
    const currentBlock = this.scopes[this.scopes.length - 1];
    if (!this.seenScopes.has(scope.id)) {
      this.seenScopes.add(scope.id);
      currentBlock.seen.add(scope.id);
      currentBlock.scopes.push({ shadowedBy: null, scope: scope });
      return;
    }
    let index = this.scopes.length - 1;
    let nextBlock = currentBlock;
    while (!nextBlock.seen.has(scope.id)) {
      this.joinedScopes.union([scope, ...nextBlock.scopes.map((s) => s.scope)]);
      index--;
      if (index < 0) {
        currentBlock.seen.add(scope.id);
        currentBlock.scopes.push({ shadowedBy: null, scope: scope });
        return;
      }
      nextBlock = this.scopes[index];
    }
    let found = false;
    for (let i = 0; i < nextBlock.scopes.length; i++) {
      const current = nextBlock.scopes[i];
      if (current.scope.id === scope.id) {
        found = true;
        if (current.shadowedBy !== null) {
          this.joinedScopes.union([current.shadowedBy, current.scope]);
        }
      } else if (found && current.shadowedBy === null) {
        current.shadowedBy = scope;
        if (current.scope.range.end > scope.range.end) {
          const end = makeInstructionId(
            Math.max(current.scope.range.end, scope.range.end)
          );
          current.scope.range.end = end;
          scope.range.end = end;
          this.joinedScopes.union([current.scope, scope]);
        }
      }
    }
    if (!currentBlock.seen.has(scope.id)) {
      currentBlock.seen.add(scope.id);
      currentBlock.scopes.push({ shadowedBy: null, scope: scope });
    }
  }
  enter(fn) {
    this.scopes.push(new BlockScope());
    fn();
    this.scopes.pop();
  }
  complete() {
    this.joinedScopes.forEach((scope, groupScope) => {
      if (scope !== groupScope) {
        groupScope.range.start = makeInstructionId(
          Math.min(groupScope.range.start, scope.range.start)
        );
        groupScope.range.end = makeInstructionId(
          Math.max(groupScope.range.end, scope.range.end)
        );
      }
    });
    for (const [operand, originalScope] of this.operandScopes) {
      const mergedScope = this.joinedScopes.find(originalScope);
      if (mergedScope !== null) {
        operand.identifier.scope = mergedScope;
      }
    }
  }
};
function mergeReactiveScopesThatInvalidateTogether(fn) {
  const lastUsageVisitor = new FindLastUsageVisitor();
  visitReactiveFunction(fn, lastUsageVisitor, undefined);
  visitReactiveFunction(fn, new Transform$4(lastUsageVisitor.lastUsage), null);
}
function log$1(msg) {}
class FindLastUsageVisitor extends ReactiveFunctionVisitor {
  constructor() {
    super(...arguments);
    this.lastUsage = new Map();
  }
  visitPlace(id, place, _state) {
    const previousUsage = this.lastUsage.get(place.identifier.id);
    const lastUsage =
      previousUsage !== undefined
        ? makeInstructionId(Math.max(previousUsage, id))
        : id;
    this.lastUsage.set(place.identifier.id, lastUsage);
  }
}
let Transform$4 = class Transform extends ReactiveFunctionTransform {
  constructor(lastUsage) {
    super();
    this.lastUsage = lastUsage;
  }
  transformScope(scopeBlock, state) {
    this.visitScope(scopeBlock, scopeBlock.scope.dependencies);
    if (
      state !== null &&
      areEqualDependencies(state, scopeBlock.scope.dependencies)
    ) {
      return { kind: "replace-many", value: scopeBlock.instructions };
    } else {
      return { kind: "keep" };
    }
  }
  visitBlock(block, state) {
    this.traverseBlock(block, state);
    let current = null;
    const merged = [];
    function reset() {
      CompilerError.invariant(current !== null, {
        loc: null,
        reason:
          "MergeConsecutiveScopes: expected current scope to be non-null if reset()",
        suggestions: null,
        description: null,
      });
      if (current.to > current.from + 1) {
        merged.push(current);
      }
      current = null;
    }
    for (let i = 0; i < block.length; i++) {
      const instr = block[i];
      switch (instr.kind) {
        case "terminal": {
          if (current !== null) {
            log$1(
              `Reset scope @${current.block.scope.id} from terminal [${instr.terminal.id}]`
            );
            reset();
          }
          break;
        }
        case "pruned-scope": {
          if (current !== null) {
            log$1(
              `Reset scope @${current.block.scope.id} from pruned scope @${instr.scope.id}`
            );
            reset();
          }
          break;
        }
        case "instruction": {
          switch (instr.instruction.value.kind) {
            case "BinaryExpression":
            case "ComputedLoad":
            case "JSXText":
            case "LoadGlobal":
            case "LoadLocal":
            case "Primitive":
            case "PropertyLoad":
            case "TemplateLiteral":
            case "UnaryExpression": {
              if (current !== null && instr.instruction.lvalue !== null) {
                current.lvalues.add(instr.instruction.lvalue.identifier.id);
              }
              break;
            }
            case "StoreLocal": {
              if (current !== null) {
                if (
                  instr.instruction.value.lvalue.kind === InstructionKind.Const
                ) {
                  for (const lvalue of eachInstructionLValue(
                    instr.instruction
                  )) {
                    current.lvalues.add(lvalue.identifier.id);
                  }
                } else {
                  log$1(
                    `Reset scope @${current.block.scope.id} from StoreLocal in [${instr.instruction.id}]`
                  );
                  reset();
                }
              }
              break;
            }
            default: {
              if (current !== null) {
                log$1(
                  `Reset scope @${current.block.scope.id} from instruction [${instr.instruction.id}]`
                );
                reset();
              }
            }
          }
          break;
        }
        case "scope": {
          if (
            current !== null &&
            canMergeScopes(current.block, instr) &&
            areLValuesLastUsedByScope(
              instr.scope,
              current.lvalues,
              this.lastUsage
            )
          ) {
            log$1(
              `Can merge scope @${current.block.scope.id} with @${instr.scope.id}`
            );
            current.block.scope.range.end = makeInstructionId(
              Math.max(current.block.scope.range.end, instr.scope.range.end)
            );
            for (const [key, value] of instr.scope.declarations) {
              current.block.scope.declarations.set(key, value);
            }
            updateScopeDeclarations(current.block.scope, this.lastUsage);
            current.to = i + 1;
            current.lvalues.clear();
            if (!scopeIsEligibleForMerging(instr)) {
              log$1(
                `  but scope @${instr.scope.id} doesnt guaranteed invalidate so it cannot merge further`
              );
              reset();
            }
          } else {
            if (current !== null) {
              log$1(
                `Reset scope @${current.block.scope.id}, not mergeable with subsequent scope @${instr.scope.id}`
              );
              reset();
            }
            if (scopeIsEligibleForMerging(instr)) {
              current = {
                block: instr,
                from: i,
                to: i + 1,
                lvalues: new Set(),
              };
            } else {
              log$1(
                `scope @${instr.scope.id} doesnt guaranteed invalidate so it cannot merge further`
              );
            }
          }
          break;
        }
        default: {
          assertExhaustive$1(
            instr,
            `Unexpected instruction kind \`${instr.kind}\``
          );
        }
      }
    }
    if (current !== null) {
      reset();
    }
    if (merged.length) {
      log$1(`merged ${merged.length} scopes:`);
      for (const entry of merged) {
        log$1(
          printReactiveScopeSummary(entry.block.scope) +
            ` from=${entry.from} to=${entry.to}`
        );
      }
    }
    if (merged.length === 0) {
      return;
    }
    const nextInstructions = [];
    let index = 0;
    for (const entry of merged) {
      if (index < entry.from) {
        nextInstructions.push(...block.slice(index, entry.from));
        index = entry.from;
      }
      const mergedScope = block[entry.from];
      CompilerError.invariant(mergedScope.kind === "scope", {
        loc: null,
        reason:
          "MergeConsecutiveScopes: Expected scope starting index to be a scope",
        description: null,
        suggestions: null,
      });
      nextInstructions.push(mergedScope);
      index++;
      while (index < entry.to) {
        const instr = block[index++];
        if (instr.kind === "scope") {
          mergedScope.instructions.push(...instr.instructions);
          mergedScope.scope.merged.add(instr.scope.id);
        } else {
          mergedScope.instructions.push(instr);
        }
      }
    }
    while (index < block.length) {
      nextInstructions.push(block[index++]);
    }
    block.length = 0;
    block.push(...nextInstructions);
  }
};
function updateScopeDeclarations(scope, lastUsage) {
  for (const [key] of scope.declarations) {
    const lastUsedAt = lastUsage.get(key);
    if (lastUsedAt < scope.range.end) {
      scope.declarations.delete(key);
    }
  }
}
function areLValuesLastUsedByScope(scope, lvalues, lastUsage) {
  for (const lvalue of lvalues) {
    const lastUsedAt = lastUsage.get(lvalue);
    if (lastUsedAt >= scope.range.end) {
      log$1(`  lvalue ${lvalue} used after scope @${scope.id}, cannot merge`);
      return false;
    }
  }
  return true;
}
function canMergeScopes(current, next) {
  if (
    current.scope.reassignments.size !== 0 ||
    next.scope.reassignments.size !== 0
  ) {
    return false;
  }
  if (
    areEqualDependencies(current.scope.dependencies, next.scope.dependencies)
  ) {
    return true;
  }
  if (
    areEqualDependencies(
      new Set(
        [...current.scope.declarations.values()].map((declaration) => ({
          identifier: declaration.identifier,
          path: [],
        }))
      ),
      next.scope.dependencies
    ) ||
    (next.scope.dependencies.size !== 0 &&
      [...next.scope.dependencies].every(
        (dep) =>
          current.scope.declarations.has(dep.identifier.id) &&
          isAlwaysInvalidatingType(dep.identifier.type)
      ))
  ) {
    return true;
  }
  log$1(`  ${printReactiveScopeSummary(current.scope)}`);
  log$1(`  ${printReactiveScopeSummary(next.scope)}`);
  return false;
}
function isAlwaysInvalidatingType(type) {
  if (type.kind === "Object") {
    switch (type.shapeId) {
      case BuiltInArrayId:
      case BuiltInObjectId:
      case BuiltInFunctionId:
      case BuiltInJsxId: {
        return true;
      }
    }
  }
  return false;
}
function areEqualDependencies(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const aValue of a) {
    let found = false;
    for (const bValue of b) {
      if (
        aValue.identifier === bValue.identifier &&
        areEqualPaths(aValue.path, bValue.path)
      ) {
        found = true;
        break;
      }
    }
    if (!found) {
      return false;
    }
  }
  return true;
}
function areEqualPaths(a, b) {
  return a.length === b.length && a.every((item, ix) => item === b[ix]);
}
function scopeIsEligibleForMerging(scopeBlock) {
  if (scopeBlock.scope.dependencies.size === 0) {
    return true;
  }
  return [...scopeBlock.scope.declarations].some(([, decl]) =>
    isAlwaysInvalidatingType(decl.identifier.type)
  );
}
let Visitor$9 = class Visitor extends ReactiveFunctionVisitor {
  visitScope(scopeBlock, state) {
    this.traverseScope(scopeBlock, state);
    for (const dep of scopeBlock.scope.dependencies) {
      const { identifier: identifier } = dep;
      if (identifier.name == null) {
        promoteIdentifier(identifier, state);
      }
    }
    for (const [, declaration] of scopeBlock.scope.declarations) {
      if (declaration.identifier.name == null) {
        promoteIdentifier(declaration.identifier, state);
      }
    }
  }
  visitPrunedScope(scopeBlock, state) {
    var _a;
    this.traversePrunedScope(scopeBlock, state);
    for (const [, declaration] of scopeBlock.scope.declarations) {
      if (
        declaration.identifier.name == null &&
        ((_a = state.pruned.get(declaration.identifier.id)) === null ||
        _a === void 0
          ? void 0
          : _a.usedOutsideScope) === true
      ) {
        promoteIdentifier(declaration.identifier, state);
      }
    }
  }
  visitParam(place, state) {
    if (place.identifier.name === null) {
      promoteIdentifier(place.identifier, state);
    }
  }
  visitValue(id, value, state) {
    this.traverseValue(id, value, state);
    if (value.kind === "FunctionExpression" || value.kind === "ObjectMethod") {
      this.visitHirFunction(value.loweredFunc.func, state);
    }
  }
  visitReactiveFunctionValue(_id, _dependencies, fn, state) {
    for (const operand of fn.params) {
      const place = operand.kind === "Identifier" ? operand : operand.place;
      if (place.identifier.name === null) {
        promoteIdentifier(place.identifier, state);
      }
    }
    visitReactiveFunction(fn, this, state);
  }
};
class CollectPromotableTemporaries extends ReactiveFunctionVisitor {
  constructor() {
    super(...arguments);
    this.activeScopes = [];
  }
  visitPlace(_id, place, state) {
    if (
      this.activeScopes.length !== 0 &&
      state.pruned.has(place.identifier.id)
    ) {
      const prunedPlace = state.pruned.get(place.identifier.id);
      if (prunedPlace.activeScopes.indexOf(this.activeScopes.at(-1)) === -1) {
        prunedPlace.usedOutsideScope = true;
      }
    }
  }
  visitValue(id, value, state) {
    this.traverseValue(id, value, state);
    if (value.kind === "JsxExpression" && value.tag.kind === "Identifier") {
      state.tags.add(value.tag.identifier.id);
    }
  }
  visitPrunedScope(scopeBlock, state) {
    for (const [id] of scopeBlock.scope.declarations) {
      state.pruned.set(id, {
        activeScopes: [...this.activeScopes],
        usedOutsideScope: false,
      });
    }
  }
  visitScope(scopeBlock, state) {
    this.activeScopes.push(scopeBlock.scope.id);
    this.traverseScope(scopeBlock, state);
    this.activeScopes.pop();
  }
}
function promoteUsedTemporaries(fn) {
  const state = { tags: new Set(), pruned: new Map() };
  visitReactiveFunction(fn, new CollectPromotableTemporaries(), state);
  for (const operand of fn.params) {
    const place = operand.kind === "Identifier" ? operand : operand.place;
    if (place.identifier.name === null) {
      promoteIdentifier(place.identifier, state);
    }
  }
  visitReactiveFunction(fn, new Visitor$9(), state);
}
function promoteIdentifier(identifier, state) {
  CompilerError.invariant(identifier.name === null, {
    reason:
      "promoteTemporary: Expected to be called only for temporary variables",
    description: null,
    loc: GeneratedSource,
    suggestions: null,
  });
  if (state.tags.has(identifier.id)) {
    promoteTemporaryJsxTag(identifier);
  } else {
    promoteTemporary(identifier);
  }
}
function propagateEarlyReturns(fn) {
  visitReactiveFunction(fn, new Transform$3(fn.env), {
    withinReactiveScope: false,
    earlyReturnValue: null,
  });
}
let Transform$3 = class Transform extends ReactiveFunctionTransform {
  constructor(env) {
    super();
    this.env = env;
  }
  visitScope(scopeBlock, parentState) {
    const innerState = {
      withinReactiveScope: true,
      earlyReturnValue: parentState.earlyReturnValue,
    };
    this.traverseScope(scopeBlock, innerState);
    const earlyReturnValue = innerState.earlyReturnValue;
    if (earlyReturnValue !== null) {
      if (!parentState.withinReactiveScope) {
        scopeBlock.scope.earlyReturnValue = earlyReturnValue;
        scopeBlock.scope.declarations.set(earlyReturnValue.value.id, {
          identifier: earlyReturnValue.value,
          scope: scopeBlock.scope,
        });
        const instructions = scopeBlock.instructions;
        const loc = earlyReturnValue.loc;
        const sentinelTemp = createTemporaryPlace(this.env, loc);
        const symbolTemp = createTemporaryPlace(this.env, loc);
        const forTemp = createTemporaryPlace(this.env, loc);
        const argTemp = createTemporaryPlace(this.env, loc);
        scopeBlock.instructions = [
          {
            kind: "instruction",
            instruction: {
              id: makeInstructionId(0),
              loc: loc,
              lvalue: Object.assign({}, symbolTemp),
              value: {
                kind: "LoadGlobal",
                binding: { kind: "Global", name: "Symbol" },
                loc: loc,
              },
            },
          },
          {
            kind: "instruction",
            instruction: {
              id: makeInstructionId(0),
              loc: loc,
              lvalue: Object.assign({}, forTemp),
              value: {
                kind: "PropertyLoad",
                object: Object.assign({}, symbolTemp),
                property: "for",
                loc: loc,
              },
            },
          },
          {
            kind: "instruction",
            instruction: {
              id: makeInstructionId(0),
              loc: loc,
              lvalue: Object.assign({}, argTemp),
              value: {
                kind: "Primitive",
                value: EARLY_RETURN_SENTINEL,
                loc: loc,
              },
            },
          },
          {
            kind: "instruction",
            instruction: {
              id: makeInstructionId(0),
              loc: loc,
              lvalue: Object.assign({}, sentinelTemp),
              value: {
                kind: "MethodCall",
                receiver: symbolTemp,
                property: forTemp,
                args: [argTemp],
                loc: loc,
              },
            },
          },
          {
            kind: "instruction",
            instruction: {
              id: makeInstructionId(0),
              loc: loc,
              lvalue: null,
              value: {
                kind: "StoreLocal",
                loc: loc,
                type: null,
                lvalue: {
                  kind: InstructionKind.Let,
                  place: {
                    kind: "Identifier",
                    effect: Effect.ConditionallyMutate,
                    loc: loc,
                    reactive: true,
                    identifier: earlyReturnValue.value,
                  },
                },
                value: Object.assign({}, sentinelTemp),
              },
            },
          },
          {
            kind: "terminal",
            label: { id: earlyReturnValue.label, implicit: false },
            terminal: {
              kind: "label",
              id: makeInstructionId(0),
              loc: GeneratedSource,
              block: instructions,
            },
          },
        ];
      } else {
        parentState.earlyReturnValue = earlyReturnValue;
      }
    }
  }
  transformTerminal(stmt, state) {
    if (state.withinReactiveScope && stmt.terminal.kind === "return") {
      const loc = stmt.terminal.value.loc;
      let earlyReturnValue;
      if (state.earlyReturnValue !== null) {
        earlyReturnValue = state.earlyReturnValue;
      } else {
        const identifier = createTemporaryPlace(this.env, loc).identifier;
        promoteTemporary(identifier);
        earlyReturnValue = {
          label: this.env.nextBlockId,
          loc: loc,
          value: identifier,
        };
      }
      state.earlyReturnValue = earlyReturnValue;
      return {
        kind: "replace-many",
        value: [
          {
            kind: "instruction",
            instruction: {
              id: makeInstructionId(0),
              loc: loc,
              lvalue: null,
              value: {
                kind: "StoreLocal",
                loc: loc,
                type: null,
                lvalue: {
                  kind: InstructionKind.Reassign,
                  place: {
                    kind: "Identifier",
                    identifier: earlyReturnValue.value,
                    effect: Effect.Capture,
                    loc: loc,
                    reactive: true,
                  },
                },
                value: stmt.terminal.value,
              },
            },
          },
          {
            kind: "terminal",
            label: null,
            terminal: {
              kind: "break",
              id: makeInstructionId(0),
              loc: loc,
              targetKind: "labeled",
              target: earlyReturnValue.label,
            },
          },
        ],
      };
    }
    this.traverseTerminal(stmt, state);
    return { kind: "keep" };
  }
};
var _Node_value, _Node_next;
function empty() {
  return EMPTY;
}
class Node {
  constructor(value, next = EMPTY) {
    _Node_value.set(this, void 0);
    _Node_next.set(this, void 0);
    __classPrivateFieldSet(this, _Node_value, value, "f");
    __classPrivateFieldSet(this, _Node_next, next, "f");
  }
  push(value) {
    return new Node(value, this);
  }
  pop() {
    return __classPrivateFieldGet(this, _Node_next, "f");
  }
  find(fn) {
    return fn(__classPrivateFieldGet(this, _Node_value, "f"))
      ? true
      : __classPrivateFieldGet(this, _Node_next, "f").find(fn);
  }
  contains(value) {
    return (
      value === __classPrivateFieldGet(this, _Node_value, "f") ||
      (__classPrivateFieldGet(this, _Node_next, "f") !== null &&
        __classPrivateFieldGet(this, _Node_next, "f").contains(value))
    );
  }
  each(fn) {
    fn(__classPrivateFieldGet(this, _Node_value, "f"));
    __classPrivateFieldGet(this, _Node_next, "f").each(fn);
  }
  get value() {
    return __classPrivateFieldGet(this, _Node_value, "f");
  }
  print(fn) {
    return (
      fn(__classPrivateFieldGet(this, _Node_value, "f")) +
      __classPrivateFieldGet(this, _Node_next, "f").print(fn)
    );
  }
}
(_Node_value = new WeakMap()), (_Node_next = new WeakMap());
class Empty {
  push(value) {
    return new Node(value, this);
  }
  pop() {
    return this;
  }
  find(_fn) {
    return false;
  }
  contains(_value) {
    return false;
  }
  each(_fn) {
    return;
  }
  get value() {
    return null;
  }
  print(_) {
    return "";
  }
}
const EMPTY = new Empty();
var _ReactiveScopeDependencyTree_instances,
  _ReactiveScopeDependencyTree_roots,
  _ReactiveScopeDependencyTree_getOrCreateRoot;
class ReactiveScopeDependencyTree {
  constructor() {
    _ReactiveScopeDependencyTree_instances.add(this);
    _ReactiveScopeDependencyTree_roots.set(this, new Map());
  }
  add(dep, inConditional) {
    const { path: path, optionalPath: optionalPath } = dep;
    let currNode = __classPrivateFieldGet(
      this,
      _ReactiveScopeDependencyTree_instances,
      "m",
      _ReactiveScopeDependencyTree_getOrCreateRoot
    ).call(this, dep.identifier);
    const accessType = inConditional
      ? PropertyAccessType.ConditionalAccess
      : PropertyAccessType.UnconditionalAccess;
    for (const property of path) {
      let currChild = getOrMakeProperty(currNode, property);
      currChild.accessType = merge(currChild.accessType, accessType);
      currNode = currChild;
    }
    if (optionalPath.length === 0) {
      const depType = inConditional
        ? PropertyAccessType.ConditionalDependency
        : PropertyAccessType.UnconditionalDependency;
      currNode.accessType = merge(currNode.accessType, depType);
    } else {
      for (const property of optionalPath) {
        let currChild = getOrMakeProperty(currNode, property);
        currChild.accessType = merge(
          currChild.accessType,
          PropertyAccessType.ConditionalAccess
        );
        currNode = currChild;
      }
      currNode.accessType = merge(
        currNode.accessType,
        PropertyAccessType.ConditionalDependency
      );
    }
  }
  deriveMinimalDependencies() {
    const results = new Set();
    for (const [rootId, rootNode] of __classPrivateFieldGet(
      this,
      _ReactiveScopeDependencyTree_roots,
      "f"
    ).entries()) {
      const deps = deriveMinimalDependenciesInSubtree(rootNode);
      CompilerError.invariant(
        deps.every(
          (dep) => dep.accessType === PropertyAccessType.UnconditionalDependency
        ),
        {
          reason:
            "[PropagateScopeDependencies] All dependencies must be reduced to unconditional dependencies.",
          description: null,
          loc: null,
          suggestions: null,
        }
      );
      for (const dep of deps) {
        results.add({ identifier: rootId, path: dep.relativePath });
      }
    }
    return results;
  }
  addDepsFromInnerScope(
    depsFromInnerScope,
    innerScopeInConditionalWithinParent,
    checkValidDepIdFn
  ) {
    for (const [id, otherRoot] of __classPrivateFieldGet(
      depsFromInnerScope,
      _ReactiveScopeDependencyTree_roots,
      "f"
    )) {
      if (!checkValidDepIdFn({ identifier: id, path: [] })) {
        continue;
      }
      let currRoot = __classPrivateFieldGet(
        this,
        _ReactiveScopeDependencyTree_instances,
        "m",
        _ReactiveScopeDependencyTree_getOrCreateRoot
      ).call(this, id);
      addSubtree(currRoot, otherRoot, innerScopeInConditionalWithinParent);
      if (!isUnconditional(currRoot.accessType)) {
        currRoot.accessType = isDependency(currRoot.accessType)
          ? PropertyAccessType.UnconditionalDependency
          : PropertyAccessType.UnconditionalAccess;
      }
    }
  }
  promoteDepsFromExhaustiveConditionals(trees) {
    CompilerError.invariant(trees.length > 1, {
      reason: "Expected trees to be at least 2 elements long.",
      description: null,
      loc: null,
      suggestions: null,
    });
    for (const [id, root] of __classPrivateFieldGet(
      this,
      _ReactiveScopeDependencyTree_roots,
      "f"
    )) {
      const nodesForRootId = mapNonNull(trees, (tree) => {
        const node = __classPrivateFieldGet(
          tree,
          _ReactiveScopeDependencyTree_roots,
          "f"
        ).get(id);
        if (node != null && isUnconditional(node.accessType)) {
          return node;
        } else {
          return null;
        }
      });
      if (nodesForRootId) {
        addSubtreeIntersection(
          root.properties,
          nodesForRootId.map((root) => root.properties)
        );
      }
    }
  }
  printDeps(includeAccesses) {
    let res = [];
    for (const [rootId, rootNode] of __classPrivateFieldGet(
      this,
      _ReactiveScopeDependencyTree_roots,
      "f"
    ).entries()) {
      const rootResults = printSubtree(rootNode, includeAccesses).map(
        (result) => `${printIdentifier(rootId)}.${result}`
      );
      res.push(rootResults);
    }
    return res.flat().join("\n");
  }
}
(_ReactiveScopeDependencyTree_roots = new WeakMap()),
  (_ReactiveScopeDependencyTree_instances = new WeakSet()),
  (_ReactiveScopeDependencyTree_getOrCreateRoot =
    function _ReactiveScopeDependencyTree_getOrCreateRoot(identifier) {
      let rootNode = __classPrivateFieldGet(
        this,
        _ReactiveScopeDependencyTree_roots,
        "f"
      ).get(identifier);
      if (rootNode === undefined) {
        rootNode = {
          properties: new Map(),
          accessType: PropertyAccessType.UnconditionalAccess,
        };
        __classPrivateFieldGet(
          this,
          _ReactiveScopeDependencyTree_roots,
          "f"
        ).set(identifier, rootNode);
      }
      return rootNode;
    });
var PropertyAccessType;
(function (PropertyAccessType) {
  PropertyAccessType["ConditionalAccess"] = "ConditionalAccess";
  PropertyAccessType["UnconditionalAccess"] = "UnconditionalAccess";
  PropertyAccessType["ConditionalDependency"] = "ConditionalDependency";
  PropertyAccessType["UnconditionalDependency"] = "UnconditionalDependency";
})(PropertyAccessType || (PropertyAccessType = {}));
const MIN_ACCESS_TYPE = PropertyAccessType.ConditionalAccess;
function isUnconditional(access) {
  return (
    access === PropertyAccessType.UnconditionalAccess ||
    access === PropertyAccessType.UnconditionalDependency
  );
}
function isDependency(access) {
  return (
    access === PropertyAccessType.ConditionalDependency ||
    access === PropertyAccessType.UnconditionalDependency
  );
}
function merge(access1, access2) {
  const resultIsUnconditional =
    isUnconditional(access1) || isUnconditional(access2);
  const resultIsDependency = isDependency(access1) || isDependency(access2);
  if (resultIsUnconditional) {
    if (resultIsDependency) {
      return PropertyAccessType.UnconditionalDependency;
    } else {
      return PropertyAccessType.UnconditionalAccess;
    }
  } else {
    if (resultIsDependency) {
      return PropertyAccessType.ConditionalDependency;
    } else {
      return PropertyAccessType.ConditionalAccess;
    }
  }
}
const promoteUncondResult = [
  { relativePath: [], accessType: PropertyAccessType.UnconditionalDependency },
];
const promoteCondResult = [
  { relativePath: [], accessType: PropertyAccessType.ConditionalDependency },
];
function deriveMinimalDependenciesInSubtree(dep) {
  const results = [];
  for (const [childName, childNode] of dep.properties) {
    const childResult = deriveMinimalDependenciesInSubtree(childNode).map(
      ({ relativePath: relativePath, accessType: accessType }) => ({
        relativePath: [childName, ...relativePath],
        accessType: accessType,
      })
    );
    results.push(...childResult);
  }
  switch (dep.accessType) {
    case PropertyAccessType.UnconditionalDependency: {
      return promoteUncondResult;
    }
    case PropertyAccessType.UnconditionalAccess: {
      if (
        results.every(
          ({ accessType: accessType }) =>
            accessType === PropertyAccessType.UnconditionalDependency
        )
      ) {
        return results;
      } else {
        return promoteUncondResult;
      }
    }
    case PropertyAccessType.ConditionalAccess:
    case PropertyAccessType.ConditionalDependency: {
      if (
        results.every(
          ({ accessType: accessType }) =>
            accessType === PropertyAccessType.ConditionalDependency
        )
      ) {
        return promoteCondResult;
      } else {
        return promoteUncondResult;
      }
    }
    default: {
      assertExhaustive$1(
        dep.accessType,
        "[PropgateScopeDependencies] Unhandled access type!"
      );
    }
  }
}
function demoteSubtreeToConditional(subtree) {
  const stack = [subtree];
  let node;
  while ((node = stack.pop()) !== undefined) {
    const { accessType: accessType, properties: properties } = node;
    if (!isUnconditional(accessType)) {
      continue;
    }
    node.accessType = isDependency(accessType)
      ? PropertyAccessType.ConditionalDependency
      : PropertyAccessType.ConditionalAccess;
    for (const childNode of properties.values()) {
      if (isUnconditional(accessType)) {
        stack.push(childNode);
      }
    }
  }
}
function addSubtree(currNode, otherNode, demoteOtherNode) {
  let otherType = otherNode.accessType;
  if (demoteOtherNode) {
    otherType = isDependency(otherType)
      ? PropertyAccessType.ConditionalDependency
      : PropertyAccessType.ConditionalAccess;
  }
  currNode.accessType = merge(currNode.accessType, otherType);
  for (const [propertyName, otherChild] of otherNode.properties) {
    const currChild = currNode.properties.get(propertyName);
    if (currChild) {
      addSubtree(currChild, otherChild, demoteOtherNode);
    } else {
      if (demoteOtherNode) {
        demoteSubtreeToConditional(otherChild);
      }
      currNode.properties.set(propertyName, otherChild);
    }
  }
}
function addSubtreeIntersection(currProperties, otherProperties) {
  CompilerError.invariant(otherProperties.length > 1, {
    reason:
      "[DeriveMinimalDependencies] Expected otherProperties to be at least 2 elements long.",
    description: null,
    loc: null,
    suggestions: null,
  });
  for (const [propertyName, currNode] of currProperties) {
    const otherNodes = mapNonNull(otherProperties, (properties) => {
      const node = properties.get(propertyName);
      if (node != null && isUnconditional(node.accessType)) {
        return node;
      } else {
        return null;
      }
    });
    if (otherNodes) {
      addSubtreeIntersection(
        currNode.properties,
        otherNodes.map((node) => node.properties)
      );
      const isDep = otherNodes.some((tree) => isDependency(tree.accessType));
      const externalAccessType = isDep
        ? PropertyAccessType.UnconditionalDependency
        : PropertyAccessType.UnconditionalAccess;
      currNode.accessType = merge(externalAccessType, currNode.accessType);
    }
  }
}
function printSubtree(node, includeAccesses) {
  const results = [];
  for (const [propertyName, propertyNode] of node.properties) {
    if (includeAccesses || isDependency(propertyNode.accessType)) {
      results.push(`${propertyName} (${propertyNode.accessType})`);
    }
    const propertyResults = printSubtree(propertyNode, includeAccesses);
    results.push(
      ...propertyResults.map((result) => `${propertyName}.${result}`)
    );
  }
  return results;
}
function getOrMakeProperty(node, property) {
  let child = node.properties.get(property);
  if (child == null) {
    child = { properties: new Map(), accessType: MIN_ACCESS_TYPE };
    node.properties.set(property, child);
  }
  return child;
}
function mapNonNull(arr, fn) {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    const element = fn(arr[i]);
    if (element) {
      result.push(element);
    } else {
      return null;
    }
  }
  return result;
}
var _PoisonState_instances,
  _PoisonState_invalidate,
  _Context_instances,
  _Context_temporariesUsedOutsideScope,
  _Context_declarations,
  _Context_reassignments,
  _Context_dependencies,
  _Context_properties,
  _Context_temporaries,
  _Context_inConditionalWithinScope,
  _Context_depsInCurrentConditional,
  _Context_scopes,
  _Context_getProperty,
  _Context_checkValidDependency,
  _Context_isScopeActive;
function propagateScopeDependencies(fn) {
  const escapingTemporaries = {
    declarations: new Map(),
    usedOutsideDeclaringScope: new Set(),
  };
  visitReactiveFunction(fn, new FindPromotedTemporaries(), escapingTemporaries);
  const context = new Context(escapingTemporaries.usedOutsideDeclaringScope);
  for (const param of fn.params) {
    if (param.kind === "Identifier") {
      context.declare(param.identifier, {
        id: makeInstructionId(0),
        scope: empty(),
      });
    } else {
      context.declare(param.place.identifier, {
        id: makeInstructionId(0),
        scope: empty(),
      });
    }
  }
  visitReactiveFunction(
    fn,
    new PropagationVisitor(fn.env.config.enableTreatFunctionDepsAsConditional),
    context
  );
}
class FindPromotedTemporaries extends ReactiveFunctionVisitor {
  constructor() {
    super(...arguments);
    this.scopes = [];
  }
  visitScope(scope, state) {
    this.scopes.push(scope.scope.id);
    this.traverseScope(scope, state);
    this.scopes.pop();
  }
  visitInstruction(instruction, state) {
    this.traverseInstruction(instruction, state);
    const scope = this.scopes.at(-1);
    if (instruction.lvalue === null || scope === undefined) {
      return;
    }
    switch (instruction.value.kind) {
      case "LoadLocal":
      case "LoadContext":
      case "PropertyLoad": {
        state.declarations.set(instruction.lvalue.identifier.id, scope);
        break;
      }
    }
  }
  visitPlace(_id, place, state) {
    const declaringScope = state.declarations.get(place.identifier.id);
    if (declaringScope === undefined) {
      return;
    }
    if (this.scopes.indexOf(declaringScope) === -1) {
      state.usedOutsideDeclaringScope.add(place.identifier.id);
    }
  }
}
class PoisonState {
  constructor(poisonedBlocks, poisonedScopes, isPoisoned) {
    _PoisonState_instances.add(this);
    this.poisonedBlocks = new Set();
    this.poisonedScopes = new Set();
    this.isPoisoned = false;
    this.poisonedBlocks = poisonedBlocks;
    this.poisonedScopes = poisonedScopes;
    this.isPoisoned = isPoisoned;
  }
  clone() {
    return new PoisonState(
      new Set(this.poisonedBlocks),
      new Set(this.poisonedScopes),
      this.isPoisoned
    );
  }
  take(other) {
    const copy = new PoisonState(
      this.poisonedBlocks,
      this.poisonedScopes,
      this.isPoisoned
    );
    this.poisonedBlocks = other.poisonedBlocks;
    this.poisonedScopes = other.poisonedScopes;
    this.isPoisoned = other.isPoisoned;
    return copy;
  }
  merge(others, currentScope) {
    for (const other of others) {
      for (const id of other.poisonedBlocks) {
        this.poisonedBlocks.add(id);
      }
      for (const id of other.poisonedScopes) {
        this.poisonedScopes.add(id);
      }
    }
    __classPrivateFieldGet(
      this,
      _PoisonState_instances,
      "m",
      _PoisonState_invalidate
    ).call(this, currentScope);
  }
  addPoisonTarget(target, activeScopes) {
    const currentScope = activeScopes.value;
    if (target == null && currentScope != null) {
      let cursor = activeScopes;
      while (true) {
        const next = cursor.pop();
        if (next.value == null) {
          const poisonedScope = cursor.value.value.id;
          this.poisonedScopes.add(poisonedScope);
          if (
            poisonedScope ===
            (currentScope === null || currentScope === void 0
              ? void 0
              : currentScope.value.id)
          ) {
            this.isPoisoned = true;
          }
          break;
        } else {
          cursor = next;
        }
      }
    } else if (target != null) {
      this.poisonedBlocks.add(target);
      if (
        !this.isPoisoned &&
        (currentScope === null || currentScope === void 0
          ? void 0
          : currentScope.ownBlocks.find((blockId) => blockId === target))
      ) {
        this.isPoisoned = true;
      }
    }
  }
  removeMaybePoisonedScope(id, currentScope) {
    this.poisonedScopes.delete(id);
    __classPrivateFieldGet(
      this,
      _PoisonState_instances,
      "m",
      _PoisonState_invalidate
    ).call(this, currentScope);
  }
  removeMaybePoisonedBlock(id, currentScope) {
    this.poisonedBlocks.delete(id);
    __classPrivateFieldGet(
      this,
      _PoisonState_instances,
      "m",
      _PoisonState_invalidate
    ).call(this, currentScope);
  }
}
(_PoisonState_instances = new WeakSet()),
  (_PoisonState_invalidate = function _PoisonState_invalidate(currentScope) {
    if (currentScope != null) {
      if (this.poisonedScopes.has(currentScope.value.id)) {
        this.isPoisoned = true;
        return;
      } else if (
        currentScope.ownBlocks.find((blockId) =>
          this.poisonedBlocks.has(blockId)
        )
      ) {
        this.isPoisoned = true;
        return;
      }
    }
    this.isPoisoned = false;
  });
class Context {
  constructor(temporariesUsedOutsideScope) {
    _Context_instances.add(this);
    _Context_temporariesUsedOutsideScope.set(this, void 0);
    _Context_declarations.set(this, new Map());
    _Context_reassignments.set(this, new Map());
    _Context_dependencies.set(this, new ReactiveScopeDependencyTree());
    _Context_properties.set(this, new Map());
    _Context_temporaries.set(this, new Map());
    _Context_inConditionalWithinScope.set(this, false);
    _Context_depsInCurrentConditional.set(
      this,
      new ReactiveScopeDependencyTree()
    );
    _Context_scopes.set(this, empty());
    this.poisonState = new PoisonState(new Set(), new Set(), false);
    __classPrivateFieldSet(
      this,
      _Context_temporariesUsedOutsideScope,
      temporariesUsedOutsideScope,
      "f"
    );
  }
  enter(scope, fn) {
    const prevInConditional = __classPrivateFieldGet(
      this,
      _Context_inConditionalWithinScope,
      "f"
    );
    const previousDependencies = __classPrivateFieldGet(
      this,
      _Context_dependencies,
      "f"
    );
    const prevDepsInConditional = this.isPoisoned
      ? __classPrivateFieldGet(this, _Context_depsInCurrentConditional, "f")
      : null;
    if (prevDepsInConditional != null) {
      __classPrivateFieldSet(
        this,
        _Context_depsInCurrentConditional,
        new ReactiveScopeDependencyTree(),
        "f"
      );
    }
    const scopedDependencies = new ReactiveScopeDependencyTree();
    __classPrivateFieldSet(this, _Context_inConditionalWithinScope, false, "f");
    __classPrivateFieldSet(
      this,
      _Context_dependencies,
      scopedDependencies,
      "f"
    );
    __classPrivateFieldSet(
      this,
      _Context_scopes,
      __classPrivateFieldGet(this, _Context_scopes, "f").push({
        value: scope,
        ownBlocks: empty(),
      }),
      "f"
    );
    this.poisonState.isPoisoned = false;
    fn();
    __classPrivateFieldSet(
      this,
      _Context_scopes,
      __classPrivateFieldGet(this, _Context_scopes, "f").pop(),
      "f"
    );
    this.poisonState.removeMaybePoisonedScope(
      scope.id,
      __classPrivateFieldGet(this, _Context_scopes, "f").value
    );
    __classPrivateFieldSet(
      this,
      _Context_dependencies,
      previousDependencies,
      "f"
    );
    __classPrivateFieldSet(
      this,
      _Context_inConditionalWithinScope,
      prevInConditional,
      "f"
    );
    const minInnerScopeDependencies =
      scopedDependencies.deriveMinimalDependencies();
    __classPrivateFieldGet(
      this,
      _Context_dependencies,
      "f"
    ).addDepsFromInnerScope(
      scopedDependencies,
      __classPrivateFieldGet(this, _Context_inConditionalWithinScope, "f") ||
        this.isPoisoned,
      __classPrivateFieldGet(
        this,
        _Context_instances,
        "m",
        _Context_checkValidDependency
      ).bind(this)
    );
    if (prevDepsInConditional != null) {
      prevDepsInConditional.addDepsFromInnerScope(
        __classPrivateFieldGet(this, _Context_depsInCurrentConditional, "f"),
        true,
        __classPrivateFieldGet(
          this,
          _Context_instances,
          "m",
          _Context_checkValidDependency
        ).bind(this)
      );
      __classPrivateFieldSet(
        this,
        _Context_depsInCurrentConditional,
        prevDepsInConditional,
        "f"
      );
    }
    return minInnerScopeDependencies;
  }
  isUsedOutsideDeclaringScope(place) {
    return __classPrivateFieldGet(
      this,
      _Context_temporariesUsedOutsideScope,
      "f"
    ).has(place.identifier.id);
  }
  printDeps(includeAccesses = false) {
    return __classPrivateFieldGet(this, _Context_dependencies, "f").printDeps(
      includeAccesses
    );
  }
  enterConditional(fn) {
    const prevInConditional = __classPrivateFieldGet(
      this,
      _Context_inConditionalWithinScope,
      "f"
    );
    const prevUncondAccessed = __classPrivateFieldGet(
      this,
      _Context_depsInCurrentConditional,
      "f"
    );
    __classPrivateFieldSet(this, _Context_inConditionalWithinScope, true, "f");
    __classPrivateFieldSet(
      this,
      _Context_depsInCurrentConditional,
      new ReactiveScopeDependencyTree(),
      "f"
    );
    fn();
    const result = __classPrivateFieldGet(
      this,
      _Context_depsInCurrentConditional,
      "f"
    );
    __classPrivateFieldSet(
      this,
      _Context_inConditionalWithinScope,
      prevInConditional,
      "f"
    );
    __classPrivateFieldSet(
      this,
      _Context_depsInCurrentConditional,
      prevUncondAccessed,
      "f"
    );
    return result;
  }
  promoteDepsFromExhaustiveConditionals(depsInConditionals) {
    __classPrivateFieldGet(
      this,
      _Context_dependencies,
      "f"
    ).promoteDepsFromExhaustiveConditionals(depsInConditionals);
    __classPrivateFieldGet(
      this,
      _Context_depsInCurrentConditional,
      "f"
    ).promoteDepsFromExhaustiveConditionals(depsInConditionals);
  }
  declare(identifier, decl) {
    if (
      !__classPrivateFieldGet(this, _Context_declarations, "f").has(
        identifier.id
      )
    ) {
      __classPrivateFieldGet(this, _Context_declarations, "f").set(
        identifier.id,
        decl
      );
    }
    __classPrivateFieldGet(this, _Context_reassignments, "f").set(
      identifier,
      decl
    );
  }
  declareTemporary(lvalue, place) {
    __classPrivateFieldGet(this, _Context_temporaries, "f").set(
      lvalue.identifier,
      place
    );
  }
  resolveTemporary(place) {
    var _a;
    return (_a = __classPrivateFieldGet(this, _Context_temporaries, "f").get(
      place.identifier
    )) !== null && _a !== void 0
      ? _a
      : place;
  }
  declareProperty(lvalue, object, property) {
    const nextDependency = __classPrivateFieldGet(
      this,
      _Context_instances,
      "m",
      _Context_getProperty
    ).call(this, object, property, false);
    __classPrivateFieldGet(this, _Context_properties, "f").set(
      lvalue.identifier,
      nextDependency
    );
  }
  get currentScope() {
    return __classPrivateFieldGet(this, _Context_scopes, "f");
  }
  get isPoisoned() {
    return this.poisonState.isPoisoned;
  }
  visitOperand(place) {
    const resolved = this.resolveTemporary(place);
    let dependency = {
      identifier: resolved.identifier,
      path: [],
      optionalPath: [],
    };
    if (resolved.identifier.name === null) {
      const propertyDependency = __classPrivateFieldGet(
        this,
        _Context_properties,
        "f"
      ).get(resolved.identifier);
      if (propertyDependency !== undefined) {
        dependency = Object.assign({}, propertyDependency);
      }
    }
    this.visitDependency(dependency);
  }
  visitProperty(object, property) {
    const nextDependency = __classPrivateFieldGet(
      this,
      _Context_instances,
      "m",
      _Context_getProperty
    ).call(this, object, property, false);
    this.visitDependency(nextDependency);
  }
  visitDependency(maybeDependency) {
    const originalDeclaration = __classPrivateFieldGet(
      this,
      _Context_declarations,
      "f"
    ).get(maybeDependency.identifier.id);
    if (
      originalDeclaration !== undefined &&
      originalDeclaration.scope.value !== null
    ) {
      originalDeclaration.scope.each((scope) => {
        if (
          !__classPrivateFieldGet(
            this,
            _Context_instances,
            "m",
            _Context_isScopeActive
          ).call(this, scope.value)
        ) {
          scope.value.declarations.set(maybeDependency.identifier.id, {
            identifier: maybeDependency.identifier,
            scope: originalDeclaration.scope.value.value,
          });
        }
      });
    }
    if (
      __classPrivateFieldGet(
        this,
        _Context_instances,
        "m",
        _Context_checkValidDependency
      ).call(this, maybeDependency)
    ) {
      const isPoisoned = this.isPoisoned;
      __classPrivateFieldGet(this, _Context_depsInCurrentConditional, "f").add(
        maybeDependency,
        isPoisoned
      );
      __classPrivateFieldGet(this, _Context_dependencies, "f").add(
        maybeDependency,
        __classPrivateFieldGet(this, _Context_inConditionalWithinScope, "f") ||
          isPoisoned
      );
    }
  }
  visitReassignment(place) {
    var _a;
    const currentScope =
      (_a = this.currentScope.value) === null || _a === void 0
        ? void 0
        : _a.value;
    if (
      currentScope != null &&
      !Array.from(currentScope.reassignments).some(
        (identifier) => identifier.id === place.identifier.id
      ) &&
      __classPrivateFieldGet(
        this,
        _Context_instances,
        "m",
        _Context_checkValidDependency
      ).call(this, { identifier: place.identifier, path: [] })
    ) {
      currentScope.reassignments.add(place.identifier);
    }
  }
  pushLabeledBlock(id) {
    const currentScope = __classPrivateFieldGet(
      this,
      _Context_scopes,
      "f"
    ).value;
    if (currentScope != null) {
      currentScope.ownBlocks = currentScope.ownBlocks.push(id);
    }
  }
  popLabeledBlock(id) {
    const currentScope = __classPrivateFieldGet(
      this,
      _Context_scopes,
      "f"
    ).value;
    if (currentScope != null) {
      const last = currentScope.ownBlocks.value;
      currentScope.ownBlocks = currentScope.ownBlocks.pop();
      CompilerError.invariant(last != null && last === id, {
        reason: "[PropagateScopeDependencies] Misformed block stack",
        loc: GeneratedSource,
      });
    }
    this.poisonState.removeMaybePoisonedBlock(id, currentScope);
  }
}
(_Context_temporariesUsedOutsideScope = new WeakMap()),
  (_Context_declarations = new WeakMap()),
  (_Context_reassignments = new WeakMap()),
  (_Context_dependencies = new WeakMap()),
  (_Context_properties = new WeakMap()),
  (_Context_temporaries = new WeakMap()),
  (_Context_inConditionalWithinScope = new WeakMap()),
  (_Context_depsInCurrentConditional = new WeakMap()),
  (_Context_scopes = new WeakMap()),
  (_Context_instances = new WeakSet()),
  (_Context_getProperty = function _Context_getProperty(
    object,
    property,
    isConditional
  ) {
    const resolvedObject = this.resolveTemporary(object);
    const resolvedDependency = __classPrivateFieldGet(
      this,
      _Context_properties,
      "f"
    ).get(resolvedObject.identifier);
    let objectDependency;
    if (resolvedDependency === undefined) {
      objectDependency = {
        identifier: resolvedObject.identifier,
        path: [],
        optionalPath: [],
      };
    } else {
      objectDependency = {
        identifier: resolvedDependency.identifier,
        path: [...resolvedDependency.path],
        optionalPath: [...resolvedDependency.optionalPath],
      };
    }
    if (objectDependency.optionalPath.length > 0) {
      objectDependency.optionalPath.push(property);
    } else if (isConditional) {
      objectDependency.optionalPath.push(property);
    } else {
      objectDependency.path.push(property);
    }
    return objectDependency;
  }),
  (_Context_checkValidDependency = function _Context_checkValidDependency(
    maybeDependency
  ) {
    var _a, _b, _c;
    if (
      isUseRefType(maybeDependency.identifier) &&
      maybeDependency.path.at(0) === "current"
    ) {
      return false;
    }
    if (isRefValueType(maybeDependency.identifier)) {
      return false;
    }
    if (isObjectMethodType(maybeDependency.identifier)) {
      return false;
    }
    const identifier = maybeDependency.identifier;
    const currentDeclaration =
      (_a = __classPrivateFieldGet(this, _Context_reassignments, "f").get(
        identifier
      )) !== null && _a !== void 0
        ? _a
        : __classPrivateFieldGet(this, _Context_declarations, "f").get(
            identifier.id
          );
    const currentScope =
      (_b = this.currentScope.value) === null || _b === void 0
        ? void 0
        : _b.value;
    return (
      currentScope != null &&
      currentDeclaration !== undefined &&
      currentDeclaration.id < currentScope.range.start &&
      (currentDeclaration.scope == null ||
        ((_c = currentDeclaration.scope.value) === null || _c === void 0
          ? void 0
          : _c.value) !== currentScope)
    );
  }),
  (_Context_isScopeActive = function _Context_isScopeActive(scope) {
    if (__classPrivateFieldGet(this, _Context_scopes, "f") === null) {
      return false;
    }
    return __classPrivateFieldGet(this, _Context_scopes, "f").find(
      (state) => state.value === scope
    );
  });
class PropagationVisitor extends ReactiveFunctionVisitor {
  constructor(enableTreatFunctionDepsAsConditional) {
    super();
    this.enableTreatFunctionDepsAsConditional = false;
    this.enableTreatFunctionDepsAsConditional =
      enableTreatFunctionDepsAsConditional;
  }
  visitScope(scope, context) {
    const scopeDependencies = context.enter(scope.scope, () => {
      this.visitBlock(scope.instructions, context);
    });
    scope.scope.dependencies = scopeDependencies;
  }
  visitPrunedScope(scopeBlock, context) {
    context.enter(scopeBlock.scope, () => {
      this.visitBlock(scopeBlock.instructions, context);
    });
  }
  visitInstruction(instruction, context) {
    const { id: id, value: value, lvalue: lvalue } = instruction;
    this.visitInstructionValue(context, id, value, lvalue);
    if (lvalue == null) {
      return;
    }
    context.declare(lvalue.identifier, { id: id, scope: context.currentScope });
  }
  visitReactiveValue(context, id, value) {
    switch (value.kind) {
      case "OptionalExpression": {
        const inner = value.value;
        CompilerError.invariant(inner.kind === "SequenceExpression", {
          reason:
            "Expected OptionalExpression value to be a SequenceExpression",
          description: `Found a \`${value.kind}\``,
          loc: value.loc,
          suggestions: null,
        });
        for (const instr of inner.instructions) {
          this.visitInstruction(instr, context);
        }
        context.enterConditional(() => {
          this.visitReactiveValue(context, id, inner.value);
        });
        break;
      }
      case "LogicalExpression": {
        this.visitReactiveValue(context, id, value.left);
        context.enterConditional(() => {
          this.visitReactiveValue(context, id, value.right);
        });
        break;
      }
      case "ConditionalExpression": {
        this.visitReactiveValue(context, id, value.test);
        const consequentDeps = context.enterConditional(() => {
          this.visitReactiveValue(context, id, value.consequent);
        });
        const alternateDeps = context.enterConditional(() => {
          this.visitReactiveValue(context, id, value.alternate);
        });
        context.promoteDepsFromExhaustiveConditionals([
          consequentDeps,
          alternateDeps,
        ]);
        break;
      }
      case "SequenceExpression": {
        for (const instr of value.instructions) {
          this.visitInstruction(instr, context);
        }
        this.visitInstructionValue(context, id, value.value, null);
        break;
      }
      case "FunctionExpression": {
        if (this.enableTreatFunctionDepsAsConditional) {
          context.enterConditional(() => {
            for (const operand of eachInstructionValueOperand(value)) {
              context.visitOperand(operand);
            }
          });
        } else {
          for (const operand of eachInstructionValueOperand(value)) {
            context.visitOperand(operand);
          }
        }
        break;
      }
      case "ReactiveFunctionValue": {
        CompilerError.invariant(false, {
          reason: `Unexpected ReactiveFunctionValue`,
          loc: value.loc,
          description: null,
          suggestions: null,
        });
      }
      default: {
        for (const operand of eachInstructionValueOperand(value)) {
          context.visitOperand(operand);
        }
      }
    }
  }
  visitInstructionValue(context, id, value, lvalue) {
    if (value.kind === "LoadLocal" && lvalue !== null) {
      if (
        value.place.identifier.name !== null &&
        lvalue.identifier.name === null &&
        !context.isUsedOutsideDeclaringScope(lvalue)
      ) {
        context.declareTemporary(lvalue, value.place);
      } else {
        context.visitOperand(value.place);
      }
    } else if (value.kind === "PropertyLoad") {
      if (lvalue !== null && !context.isUsedOutsideDeclaringScope(lvalue)) {
        context.declareProperty(lvalue, value.object, value.property);
      } else {
        context.visitProperty(value.object, value.property);
      }
    } else if (value.kind === "StoreLocal") {
      context.visitOperand(value.value);
      if (value.lvalue.kind === InstructionKind.Reassign) {
        context.visitReassignment(value.lvalue.place);
      }
      context.declare(value.lvalue.place.identifier, {
        id: id,
        scope: context.currentScope,
      });
    } else if (
      value.kind === "DeclareLocal" ||
      value.kind === "DeclareContext"
    ) {
      context.declare(value.lvalue.place.identifier, {
        id: id,
        scope: context.currentScope,
      });
    } else if (value.kind === "Destructure") {
      context.visitOperand(value.value);
      for (const place of eachPatternOperand(value.lvalue.pattern)) {
        if (value.lvalue.kind === InstructionKind.Reassign) {
          context.visitReassignment(place);
        }
        context.declare(place.identifier, {
          id: id,
          scope: context.currentScope,
        });
      }
    } else {
      this.visitReactiveValue(context, id, value);
    }
  }
  enterTerminal(stmt, context) {
    if (stmt.label != null) {
      context.pushLabeledBlock(stmt.label.id);
    }
    const terminal = stmt.terminal;
    switch (terminal.kind) {
      case "continue":
      case "break": {
        context.poisonState.addPoisonTarget(
          terminal.target,
          context.currentScope
        );
        break;
      }
      case "throw":
      case "return": {
        context.poisonState.addPoisonTarget(null, context.currentScope);
        break;
      }
    }
  }
  exitTerminal(stmt, context) {
    if (stmt.label != null) {
      context.popLabeledBlock(stmt.label.id);
    }
  }
  visitTerminal(stmt, context) {
    this.enterTerminal(stmt, context);
    const terminal = stmt.terminal;
    switch (terminal.kind) {
      case "break":
      case "continue": {
        break;
      }
      case "return": {
        context.visitOperand(terminal.value);
        break;
      }
      case "throw": {
        context.visitOperand(terminal.value);
        break;
      }
      case "for": {
        this.visitReactiveValue(context, terminal.id, terminal.init);
        this.visitReactiveValue(context, terminal.id, terminal.test);
        context.enterConditional(() => {
          this.visitBlock(terminal.loop, context);
          if (terminal.update !== null) {
            this.visitReactiveValue(context, terminal.id, terminal.update);
          }
        });
        break;
      }
      case "for-of": {
        this.visitReactiveValue(context, terminal.id, terminal.init);
        context.enterConditional(() => {
          this.visitBlock(terminal.loop, context);
        });
        break;
      }
      case "for-in": {
        this.visitReactiveValue(context, terminal.id, terminal.init);
        context.enterConditional(() => {
          this.visitBlock(terminal.loop, context);
        });
        break;
      }
      case "do-while": {
        this.visitBlock(terminal.loop, context);
        context.enterConditional(() => {
          this.visitReactiveValue(context, terminal.id, terminal.test);
        });
        break;
      }
      case "while": {
        this.visitReactiveValue(context, terminal.id, terminal.test);
        context.enterConditional(() => {
          this.visitBlock(terminal.loop, context);
        });
        break;
      }
      case "if": {
        context.visitOperand(terminal.test);
        const { consequent: consequent, alternate: alternate } = terminal;
        const prevPoisonState = context.poisonState.clone();
        const depsInIf = context.enterConditional(() => {
          this.visitBlock(consequent, context);
        });
        if (alternate !== null) {
          const ifPoisonState = context.poisonState.take(prevPoisonState);
          const depsInElse = context.enterConditional(() => {
            this.visitBlock(alternate, context);
          });
          context.poisonState.merge(
            [ifPoisonState],
            context.currentScope.value
          );
          context.promoteDepsFromExhaustiveConditionals([depsInIf, depsInElse]);
        }
        break;
      }
      case "switch": {
        context.visitOperand(terminal.test);
        const isDefaultOnly =
          terminal.cases.length === 1 && terminal.cases[0].test == null;
        if (isDefaultOnly) {
          const case_ = terminal.cases[0];
          if (case_.block != null) {
            this.visitBlock(case_.block, context);
            break;
          }
        }
        const depsInCases = [];
        let foundDefault = false;
        const prevPoisonState = context.poisonState.clone();
        const mutExPoisonStates = [];
        for (const { test: test, block: block } of terminal.cases) {
          if (test !== null) {
            context.visitOperand(test);
          } else {
            foundDefault = true;
          }
          if (block !== undefined) {
            mutExPoisonStates.push(
              context.poisonState.take(prevPoisonState.clone())
            );
            depsInCases.push(
              context.enterConditional(() => {
                this.visitBlock(block, context);
              })
            );
          }
        }
        if (foundDefault) {
          context.promoteDepsFromExhaustiveConditionals(depsInCases);
        }
        context.poisonState.merge(
          mutExPoisonStates,
          context.currentScope.value
        );
        break;
      }
      case "label": {
        this.visitBlock(terminal.block, context);
        break;
      }
      case "try": {
        this.visitBlock(terminal.block, context);
        this.visitBlock(terminal.handler, context);
        break;
      }
      default: {
        assertExhaustive$1(
          terminal,
          `Unexpected terminal kind \`${terminal.kind}\``
        );
      }
    }
    this.exitTerminal(stmt, context);
  }
}
function pruneHoistedContexts(fn) {
  const hoistedIdentifiers = new Set();
  visitReactiveFunction(fn, new Visitor$8(), hoistedIdentifiers);
}
let Visitor$8 = class Visitor extends ReactiveFunctionTransform {
  transformInstruction(instruction, state) {
    this.visitInstruction(instruction, state);
    if (
      instruction.value.kind === "DeclareContext" &&
      instruction.value.lvalue.kind === "HoistedConst"
    ) {
      state.add(instruction.value.lvalue.place.identifier);
      return { kind: "remove" };
    }
    if (
      instruction.value.kind === "StoreContext" &&
      state.has(instruction.value.lvalue.place.identifier)
    ) {
      return {
        kind: "replace",
        value: {
          kind: "instruction",
          instruction: Object.assign(Object.assign({}, instruction), {
            value: Object.assign(Object.assign({}, instruction.value), {
              lvalue: Object.assign(
                Object.assign({}, instruction.value.lvalue),
                { kind: InstructionKind.Const }
              ),
              type: null,
              kind: "StoreLocal",
            }),
          }),
        },
      };
    }
    return { kind: "keep" };
  }
};
function validateMemoizedEffectDependencies(fn) {
  const errors = new CompilerError();
  visitReactiveFunction(fn, new Visitor$7(), errors);
  if (errors.hasErrors()) {
    throw errors;
  }
}
let Visitor$7 = class Visitor extends ReactiveFunctionVisitor {
  constructor() {
    super(...arguments);
    this.scopes = new Set();
  }
  visitScope(scopeBlock, state) {
    this.traverseScope(scopeBlock, state);
    let areDependenciesMemoized = true;
    for (const dep of scopeBlock.scope.dependencies) {
      if (isUnmemoized$1(dep.identifier, this.scopes)) {
        areDependenciesMemoized = false;
        break;
      }
    }
    if (areDependenciesMemoized) {
      this.scopes.add(scopeBlock.scope.id);
      for (const id of scopeBlock.scope.merged) {
        this.scopes.add(id);
      }
    }
  }
  visitInstruction(instruction, state) {
    this.traverseInstruction(instruction, state);
    if (
      instruction.value.kind === "CallExpression" &&
      isEffectHook(instruction.value.callee.identifier) &&
      instruction.value.args.length >= 2
    ) {
      const deps = instruction.value.args[1];
      if (
        deps.kind === "Identifier" &&
        (isMutable(instruction, deps) ||
          isUnmemoized$1(deps.identifier, this.scopes))
      ) {
        state.push({
          reason:
            "React Compiler has skipped optimizing this component because the effect dependencies could not be memoized. Unmemoized effect dependencies can trigger an infinite loop or other unexpected behavior",
          description: null,
          severity: ErrorSeverity.CannotPreserveMemoization,
          loc: typeof instruction.loc !== "symbol" ? instruction.loc : null,
          suggestions: null,
        });
      }
    }
  }
};
function isUnmemoized$1(operand, scopes) {
  return operand.scope != null && !scopes.has(operand.scope.id);
}
function isEffectHook(identifier) {
  return (
    isUseEffectHookType(identifier) ||
    isUseLayoutEffectHookType(identifier) ||
    isUseInsertionEffectHookType(identifier)
  );
}
var _InferenceState_env, _InferenceState_values, _InferenceState_variables;
const UndefinedValue = {
  kind: "Primitive",
  loc: GeneratedSource,
  value: undefined,
};
function inferReferenceEffects(fn, options = { isFunctionExpression: false }) {
  var _a;
  const initialState = InferenceState.empty(fn.env);
  const value = { kind: "Primitive", loc: fn.loc, value: undefined };
  initialState.initialize(value, {
    kind: ValueKind.Frozen,
    reason: new Set([ValueReason.Other]),
    context: new Set(),
  });
  for (const ref of fn.context) {
    const value = { kind: "ObjectExpression", properties: [], loc: ref.loc };
    initialState.initialize(value, {
      kind: ValueKind.Context,
      reason: new Set([ValueReason.Other]),
      context: new Set([ref]),
    });
    initialState.define(ref, value);
  }
  const paramKind = options.isFunctionExpression
    ? {
        kind: ValueKind.Mutable,
        reason: new Set([ValueReason.Other]),
        context: new Set(),
      }
    : {
        kind: ValueKind.Frozen,
        reason: new Set([ValueReason.ReactiveFunctionArgument]),
        context: new Set(),
      };
  if (fn.fnType === "Component") {
    CompilerError.invariant(fn.params.length <= 2, {
      reason:
        "Expected React component to have not more than two parameters: one for props and for ref",
      description: null,
      loc: fn.loc,
      suggestions: null,
    });
    const [props, ref] = fn.params;
    let value;
    let place;
    if (props) {
      inferParam(props, initialState, paramKind);
    }
    if (ref) {
      if (ref.kind === "Identifier") {
        place = ref;
        value = { kind: "ObjectExpression", properties: [], loc: ref.loc };
      } else {
        place = ref.place;
        value = {
          kind: "ObjectExpression",
          properties: [],
          loc: ref.place.loc,
        };
      }
      initialState.initialize(value, {
        kind: ValueKind.Mutable,
        reason: new Set([ValueReason.Other]),
        context: new Set(),
      });
      initialState.define(place, value);
    }
  } else {
    for (const param of fn.params) {
      inferParam(param, initialState, paramKind);
    }
  }
  const statesByBlock = new Map();
  const queuedStates = new Map();
  function queue(blockId, state) {
    var _a;
    let queuedState = queuedStates.get(blockId);
    if (queuedState != null) {
      state =
        (_a = queuedState.merge(state)) !== null && _a !== void 0
          ? _a
          : queuedState;
      queuedStates.set(blockId, state);
    } else {
      const prevState = statesByBlock.get(blockId);
      const nextState = prevState != null ? prevState.merge(state) : state;
      if (nextState != null) {
        queuedStates.set(blockId, nextState);
      }
    }
  }
  queue(fn.body.entry, initialState);
  const functionEffects = (_a = fn.effects) !== null && _a !== void 0 ? _a : [];
  while (queuedStates.size !== 0) {
    for (const [blockId, block] of fn.body.blocks) {
      const incomingState = queuedStates.get(blockId);
      queuedStates.delete(blockId);
      if (incomingState == null) {
        continue;
      }
      statesByBlock.set(blockId, incomingState);
      const state = incomingState.clone();
      inferBlock(fn.env, functionEffects, state, block);
      for (const nextBlockId of eachTerminalSuccessor(block.terminal)) {
        queue(nextBlockId, state);
      }
    }
  }
  if (!options.isFunctionExpression) {
    functionEffects.forEach((eff) => {
      switch (eff.kind) {
        case "ReactMutation":
        case "GlobalMutation": {
          CompilerError.throw(eff.error);
        }
        case "ContextMutation": {
          CompilerError.throw({
            severity: ErrorSeverity.Invariant,
            reason: `Unexpected ContextMutation in top-level function effects`,
            loc: eff.loc,
          });
        }
        default:
          assertExhaustive$1(
            eff,
            `Unexpected function effect kind \`${eff.kind}\``
          );
      }
    });
  } else {
    fn.effects = functionEffects;
  }
}
class InferenceState {
  constructor(env, values, variables) {
    _InferenceState_env.set(this, void 0);
    _InferenceState_values.set(this, void 0);
    _InferenceState_variables.set(this, void 0);
    __classPrivateFieldSet(this, _InferenceState_env, env, "f");
    __classPrivateFieldSet(this, _InferenceState_values, values, "f");
    __classPrivateFieldSet(this, _InferenceState_variables, variables, "f");
  }
  static empty(env) {
    return new InferenceState(env, new Map(), new Map());
  }
  initialize(value, kind) {
    CompilerError.invariant(value.kind !== "LoadLocal", {
      reason:
        "Expected all top-level identifiers to be defined as variables, not values",
      description: null,
      loc: value.loc,
      suggestions: null,
    });
    __classPrivateFieldGet(this, _InferenceState_values, "f").set(value, kind);
  }
  values(place) {
    const values = __classPrivateFieldGet(
      this,
      _InferenceState_variables,
      "f"
    ).get(place.identifier.id);
    CompilerError.invariant(values != null, {
      reason: `[hoisting] Expected value kind to be initialized`,
      description: `${printPlace(place)}`,
      loc: place.loc,
      suggestions: null,
    });
    return Array.from(values);
  }
  kind(place) {
    const values = __classPrivateFieldGet(
      this,
      _InferenceState_variables,
      "f"
    ).get(place.identifier.id);
    CompilerError.invariant(values != null, {
      reason: `[hoisting] Expected value kind to be initialized`,
      description: `${printPlace(place)}`,
      loc: place.loc,
      suggestions: null,
    });
    let mergedKind = null;
    for (const value of values) {
      const kind = __classPrivateFieldGet(
        this,
        _InferenceState_values,
        "f"
      ).get(value);
      mergedKind =
        mergedKind !== null ? mergeAbstractValues(mergedKind, kind) : kind;
    }
    CompilerError.invariant(mergedKind !== null, {
      reason: `InferReferenceEffects::kind: Expected at least one value`,
      description: `No value found at \`${printPlace(place)}\``,
      loc: place.loc,
      suggestions: null,
    });
    return mergedKind;
  }
  alias(place, value) {
    const values = __classPrivateFieldGet(
      this,
      _InferenceState_variables,
      "f"
    ).get(value.identifier.id);
    CompilerError.invariant(values != null, {
      reason: `[hoisting] Expected value for identifier to be initialized`,
      description: `${printIdentifier(value.identifier)}`,
      loc: value.loc,
      suggestions: null,
    });
    __classPrivateFieldGet(this, _InferenceState_variables, "f").set(
      place.identifier.id,
      new Set(values)
    );
  }
  define(place, value) {
    CompilerError.invariant(
      __classPrivateFieldGet(this, _InferenceState_values, "f").has(value),
      {
        reason: `Expected value to be initialized at '${printSourceLocation(value.loc)}'`,
        description: null,
        loc: value.loc,
        suggestions: null,
      }
    );
    __classPrivateFieldGet(this, _InferenceState_variables, "f").set(
      place.identifier.id,
      new Set([value])
    );
  }
  isDefined(place) {
    return __classPrivateFieldGet(this, _InferenceState_variables, "f").has(
      place.identifier.id
    );
  }
  referenceAndRecordEffects(place, effectKind, reason, functionEffects) {
    const values = __classPrivateFieldGet(
      this,
      _InferenceState_variables,
      "f"
    ).get(place.identifier.id);
    if (values === undefined) {
      CompilerError.invariant(effectKind !== Effect.Store, {
        reason: "[InferReferenceEffects] Unhandled store reference effect",
        description: null,
        loc: place.loc,
        suggestions: null,
      });
      place.effect =
        effectKind === Effect.ConditionallyMutate
          ? Effect.ConditionallyMutate
          : Effect.Read;
      return;
    }
    for (const value of values) {
      if (
        (value.kind === "FunctionExpression" ||
          value.kind === "ObjectMethod") &&
        value.loweredFunc.func.effects != null
      ) {
        for (const effect of value.loweredFunc.func.effects) {
          if (
            effect.kind === "GlobalMutation" ||
            effect.kind === "ReactMutation"
          ) {
            functionEffects.push(effect);
          } else {
            for (const place of effect.places) {
              if (this.isDefined(place)) {
                const replayedEffect = this.reference(
                  Object.assign(Object.assign({}, place), { loc: effect.loc }),
                  effect.effect,
                  reason
                );
                if (replayedEffect != null) {
                  if (replayedEffect.kind === "ContextMutation") {
                    functionEffects.push(effect);
                  } else {
                    functionEffects.push(replayedEffect);
                  }
                }
              }
            }
          }
        }
      }
    }
    const functionEffect = this.reference(place, effectKind, reason);
    if (functionEffect !== null) {
      functionEffects.push(functionEffect);
    }
  }
  reference(place, effectKind, reason) {
    const values = __classPrivateFieldGet(
      this,
      _InferenceState_variables,
      "f"
    ).get(place.identifier.id);
    CompilerError.invariant(values !== undefined, {
      reason: "[InferReferenceEffects] Expected value to be initialized",
      description: null,
      loc: place.loc,
      suggestions: null,
    });
    let valueKind = this.kind(place);
    let effect = null;
    let functionEffect = null;
    switch (effectKind) {
      case Effect.Freeze: {
        if (
          valueKind.kind === ValueKind.Mutable ||
          valueKind.kind === ValueKind.Context ||
          valueKind.kind === ValueKind.MaybeFrozen
        ) {
          const reasonSet = new Set([reason]);
          effect = Effect.Freeze;
          valueKind = {
            kind: ValueKind.Frozen,
            reason: reasonSet,
            context: new Set(),
          };
          values.forEach((value) => {
            __classPrivateFieldGet(this, _InferenceState_values, "f").set(
              value,
              { kind: ValueKind.Frozen, reason: reasonSet, context: new Set() }
            );
            if (
              __classPrivateFieldGet(this, _InferenceState_env, "f").config
                .enablePreserveExistingMemoizationGuarantees ||
              __classPrivateFieldGet(this, _InferenceState_env, "f").config
                .enableTransitivelyFreezeFunctionExpressions
            ) {
              if (value.kind === "FunctionExpression") {
                for (const operand of eachInstructionValueOperand(value)) {
                  this.referenceAndRecordEffects(
                    operand,
                    Effect.Freeze,
                    ValueReason.Other,
                    []
                  );
                }
              }
            }
          });
        } else {
          effect = Effect.Read;
        }
        break;
      }
      case Effect.ConditionallyMutate: {
        if (
          valueKind.kind === ValueKind.Mutable ||
          valueKind.kind === ValueKind.Context
        ) {
          effect = Effect.ConditionallyMutate;
        } else {
          effect = Effect.Read;
        }
        break;
      }
      case Effect.Mutate: {
        if (isRefValueType(place.identifier) || isUseRefType(place.identifier));
        else if (valueKind.kind === ValueKind.Context) {
          functionEffect = {
            kind: "ContextMutation",
            loc: place.loc,
            effect: effectKind,
            places:
              valueKind.context.size === 0
                ? new Set([place])
                : valueKind.context,
          };
        } else if (
          valueKind.kind !== ValueKind.Mutable &&
          valueKind.kind !== ValueKind.Primitive
        ) {
          let reason = getWriteErrorReason(valueKind);
          functionEffect = {
            kind:
              valueKind.reason.size === 1 &&
              valueKind.reason.has(ValueReason.Global)
                ? "GlobalMutation"
                : "ReactMutation",
            error: {
              reason: reason,
              description:
                place.identifier.name !== null &&
                place.identifier.name.kind === "named"
                  ? `Found mutation of \`${place.identifier.name.value}\``
                  : null,
              loc: place.loc,
              suggestions: null,
              severity: ErrorSeverity.InvalidReact,
            },
          };
        }
        effect = Effect.Mutate;
        break;
      }
      case Effect.Store: {
        if (isRefValueType(place.identifier) || isUseRefType(place.identifier));
        else if (valueKind.kind === ValueKind.Context) {
          functionEffect = {
            kind: "ContextMutation",
            loc: place.loc,
            effect: effectKind,
            places:
              valueKind.context.size === 0
                ? new Set([place])
                : valueKind.context,
          };
        } else if (
          valueKind.kind !== ValueKind.Mutable &&
          valueKind.kind !== ValueKind.Primitive
        ) {
          let reason = getWriteErrorReason(valueKind);
          functionEffect = {
            kind:
              valueKind.reason.size === 1 &&
              valueKind.reason.has(ValueReason.Global)
                ? "GlobalMutation"
                : "ReactMutation",
            error: {
              reason: reason,
              description:
                place.identifier.name !== null &&
                place.identifier.name.kind === "named"
                  ? `Found mutation of \`${place.identifier.name.value}\``
                  : null,
              loc: place.loc,
              suggestions: null,
              severity: ErrorSeverity.InvalidReact,
            },
          };
        }
        effect = isObjectType(place.identifier) ? Effect.Store : Effect.Mutate;
        break;
      }
      case Effect.Capture: {
        if (
          valueKind.kind === ValueKind.Primitive ||
          valueKind.kind === ValueKind.Global ||
          valueKind.kind === ValueKind.Frozen ||
          valueKind.kind === ValueKind.MaybeFrozen
        ) {
          effect = Effect.Read;
        } else {
          effect = Effect.Capture;
        }
        break;
      }
      case Effect.Read: {
        effect = Effect.Read;
        break;
      }
      case Effect.Unknown: {
        CompilerError.invariant(false, {
          reason:
            "Unexpected unknown effect, expected to infer a precise effect kind",
          description: null,
          loc: place.loc,
          suggestions: null,
        });
      }
      default: {
        assertExhaustive$1(
          effectKind,
          `Unexpected reference kind \`${effectKind}\``
        );
      }
    }
    CompilerError.invariant(effect !== null, {
      reason: "Expected effect to be set",
      description: null,
      loc: place.loc,
      suggestions: null,
    });
    place.effect = effect;
    return functionEffect;
  }
  merge(other) {
    let nextValues = null;
    let nextVariables = null;
    for (const [id, thisValue] of __classPrivateFieldGet(
      this,
      _InferenceState_values,
      "f"
    )) {
      const otherValue = __classPrivateFieldGet(
        other,
        _InferenceState_values,
        "f"
      ).get(id);
      if (otherValue !== undefined) {
        const mergedValue = mergeAbstractValues(thisValue, otherValue);
        if (mergedValue !== thisValue) {
          nextValues =
            nextValues !== null && nextValues !== void 0
              ? nextValues
              : new Map(
                  __classPrivateFieldGet(this, _InferenceState_values, "f")
                );
          nextValues.set(id, mergedValue);
        }
      }
    }
    for (const [id, otherValue] of __classPrivateFieldGet(
      other,
      _InferenceState_values,
      "f"
    )) {
      if (__classPrivateFieldGet(this, _InferenceState_values, "f").has(id)) {
        continue;
      }
      nextValues =
        nextValues !== null && nextValues !== void 0
          ? nextValues
          : new Map(__classPrivateFieldGet(this, _InferenceState_values, "f"));
      nextValues.set(id, otherValue);
    }
    for (const [id, thisValues] of __classPrivateFieldGet(
      this,
      _InferenceState_variables,
      "f"
    )) {
      const otherValues = __classPrivateFieldGet(
        other,
        _InferenceState_variables,
        "f"
      ).get(id);
      if (otherValues !== undefined) {
        let mergedValues = null;
        for (const otherValue of otherValues) {
          if (!thisValues.has(otherValue)) {
            mergedValues =
              mergedValues !== null && mergedValues !== void 0
                ? mergedValues
                : new Set(thisValues);
            mergedValues.add(otherValue);
          }
        }
        if (mergedValues !== null) {
          nextVariables =
            nextVariables !== null && nextVariables !== void 0
              ? nextVariables
              : new Map(
                  __classPrivateFieldGet(this, _InferenceState_variables, "f")
                );
          nextVariables.set(id, mergedValues);
        }
      }
    }
    for (const [id, otherValues] of __classPrivateFieldGet(
      other,
      _InferenceState_variables,
      "f"
    )) {
      if (
        __classPrivateFieldGet(this, _InferenceState_variables, "f").has(id)
      ) {
        continue;
      }
      nextVariables =
        nextVariables !== null && nextVariables !== void 0
          ? nextVariables
          : new Map(
              __classPrivateFieldGet(this, _InferenceState_variables, "f")
            );
      nextVariables.set(id, new Set(otherValues));
    }
    if (nextVariables === null && nextValues === null) {
      return null;
    } else {
      return new InferenceState(
        __classPrivateFieldGet(this, _InferenceState_env, "f"),
        nextValues !== null && nextValues !== void 0
          ? nextValues
          : new Map(__classPrivateFieldGet(this, _InferenceState_values, "f")),
        nextVariables !== null && nextVariables !== void 0
          ? nextVariables
          : new Map(
              __classPrivateFieldGet(this, _InferenceState_variables, "f")
            )
      );
    }
  }
  clone() {
    return new InferenceState(
      __classPrivateFieldGet(this, _InferenceState_env, "f"),
      new Map(__classPrivateFieldGet(this, _InferenceState_values, "f")),
      new Map(__classPrivateFieldGet(this, _InferenceState_variables, "f"))
    );
  }
  debug() {
    const result = { values: {}, variables: {} };
    const objects = new Map();
    function identify(value) {
      let id = objects.get(value);
      if (id == null) {
        id = objects.size;
        objects.set(value, id);
      }
      return id;
    }
    for (const [value, kind] of __classPrivateFieldGet(
      this,
      _InferenceState_values,
      "f"
    )) {
      const id = identify(value);
      result.values[id] = { kind: kind, value: printMixedHIR(value) };
    }
    for (const [variable, values] of __classPrivateFieldGet(
      this,
      _InferenceState_variables,
      "f"
    )) {
      result.variables[`$${variable}`] = [...values].map(identify);
    }
    return result;
  }
  inferPhi(phi) {
    const values = new Set();
    for (const [_, operand] of phi.operands) {
      const operandValues = __classPrivateFieldGet(
        this,
        _InferenceState_variables,
        "f"
      ).get(operand.id);
      if (operandValues === undefined) continue;
      for (const v of operandValues) {
        values.add(v);
      }
    }
    if (values.size > 0) {
      __classPrivateFieldGet(this, _InferenceState_variables, "f").set(
        phi.id.id,
        values
      );
    }
  }
}
(_InferenceState_env = new WeakMap()),
  (_InferenceState_values = new WeakMap()),
  (_InferenceState_variables = new WeakMap());
function inferParam(param, initialState, paramKind) {
  let value;
  let place;
  if (param.kind === "Identifier") {
    place = param;
    value = { kind: "Primitive", loc: param.loc, value: undefined };
  } else {
    place = param.place;
    value = { kind: "Primitive", loc: param.place.loc, value: undefined };
  }
  initialState.initialize(value, paramKind);
  initialState.define(place, value);
}
function mergeValues(a, b) {
  if (a === b) {
    return a;
  } else if (a === ValueKind.MaybeFrozen || b === ValueKind.MaybeFrozen) {
    return ValueKind.MaybeFrozen;
  } else if (a === ValueKind.Mutable || b === ValueKind.Mutable) {
    if (a === ValueKind.Frozen || b === ValueKind.Frozen) {
      return ValueKind.MaybeFrozen;
    } else if (a === ValueKind.Context || b === ValueKind.Context) {
      return ValueKind.Context;
    } else {
      return ValueKind.Mutable;
    }
  } else if (a === ValueKind.Context || b === ValueKind.Context) {
    if (a === ValueKind.Frozen || b === ValueKind.Frozen) {
      return ValueKind.MaybeFrozen;
    } else {
      return ValueKind.Context;
    }
  } else if (a === ValueKind.Frozen || b === ValueKind.Frozen) {
    return ValueKind.Frozen;
  } else if (a === ValueKind.Global || b === ValueKind.Global) {
    return ValueKind.Global;
  } else {
    CompilerError.invariant(
      a === ValueKind.Primitive && b == ValueKind.Primitive,
      {
        reason: `Unexpected value kind in mergeValues()`,
        description: `Found kinds ${a} and ${b}`,
        loc: GeneratedSource,
      }
    );
    return ValueKind.Primitive;
  }
}
function isSuperset(a, b) {
  for (const v of b) {
    if (!a.has(v)) {
      return false;
    }
  }
  return true;
}
function mergeAbstractValues(a, b) {
  const kind = mergeValues(a.kind, b.kind);
  if (
    kind === a.kind &&
    kind === b.kind &&
    isSuperset(a.reason, b.reason) &&
    isSuperset(a.context, b.context)
  ) {
    return a;
  }
  const reason = new Set(a.reason);
  for (const r of b.reason) {
    reason.add(r);
  }
  const context = new Set(a.context);
  for (const c of b.context) {
    context.add(c);
  }
  return { kind: kind, reason: reason, context: context };
}
function inferBlock(env, functionEffects, state, block) {
  var _a, _b;
  var _c;
  for (const phi of block.phis) {
    state.inferPhi(phi);
  }
  for (const instr of block.instructions) {
    const instrValue = instr.value;
    let effect = null;
    let lvalueEffect = Effect.ConditionallyMutate;
    let valueKind;
    switch (instrValue.kind) {
      case "BinaryExpression": {
        valueKind = {
          kind: ValueKind.Primitive,
          reason: new Set([ValueReason.Other]),
          context: new Set(),
        };
        effect = { kind: Effect.Read, reason: ValueReason.Other };
        break;
      }
      case "ArrayExpression": {
        valueKind = hasContextRefOperand(state, instrValue)
          ? {
              kind: ValueKind.Context,
              reason: new Set([ValueReason.Other]),
              context: new Set(),
            }
          : {
              kind: ValueKind.Mutable,
              reason: new Set([ValueReason.Other]),
              context: new Set(),
            };
        effect = { kind: Effect.Capture, reason: ValueReason.Other };
        lvalueEffect = Effect.Store;
        break;
      }
      case "NewExpression": {
        valueKind = {
          kind: ValueKind.Mutable,
          reason: new Set([ValueReason.Other]),
          context: new Set(),
        };
        state.referenceAndRecordEffects(
          instrValue.callee,
          Effect.Read,
          ValueReason.Other,
          functionEffects
        );
        for (const operand of eachCallArgument(instrValue.args)) {
          state.referenceAndRecordEffects(
            operand,
            Effect.ConditionallyMutate,
            ValueReason.Other,
            functionEffects
          );
        }
        state.initialize(instrValue, valueKind);
        state.define(instr.lvalue, instrValue);
        instr.lvalue.effect = lvalueEffect;
        continue;
      }
      case "ObjectExpression": {
        valueKind = hasContextRefOperand(state, instrValue)
          ? {
              kind: ValueKind.Context,
              reason: new Set([ValueReason.Other]),
              context: new Set(),
            }
          : {
              kind: ValueKind.Mutable,
              reason: new Set([ValueReason.Other]),
              context: new Set(),
            };
        for (const property of instrValue.properties) {
          switch (property.kind) {
            case "ObjectProperty": {
              if (property.key.kind === "computed") {
                state.referenceAndRecordEffects(
                  property.key.name,
                  Effect.Freeze,
                  ValueReason.Other,
                  functionEffects
                );
              }
              state.referenceAndRecordEffects(
                property.place,
                Effect.Capture,
                ValueReason.Other,
                functionEffects
              );
              break;
            }
            case "Spread": {
              state.referenceAndRecordEffects(
                property.place,
                Effect.Capture,
                ValueReason.Other,
                functionEffects
              );
              break;
            }
            default: {
              assertExhaustive$1(
                property,
                `Unexpected property kind \`${property.kind}\``
              );
            }
          }
        }
        state.initialize(instrValue, valueKind);
        state.define(instr.lvalue, instrValue);
        instr.lvalue.effect = Effect.Store;
        continue;
      }
      case "UnaryExpression": {
        valueKind = {
          kind: ValueKind.Primitive,
          reason: new Set([ValueReason.Other]),
          context: new Set(),
        };
        effect = { kind: Effect.Read, reason: ValueReason.Other };
        break;
      }
      case "UnsupportedNode": {
        valueKind = {
          kind: ValueKind.Mutable,
          reason: new Set([ValueReason.Other]),
          context: new Set(),
        };
        break;
      }
      case "JsxExpression": {
        if (instrValue.tag.kind === "Identifier") {
          state.referenceAndRecordEffects(
            instrValue.tag,
            Effect.Freeze,
            ValueReason.JsxCaptured,
            functionEffects
          );
        }
        if (instrValue.children !== null) {
          for (const child of instrValue.children) {
            state.referenceAndRecordEffects(
              child,
              Effect.Freeze,
              ValueReason.JsxCaptured,
              functionEffects
            );
          }
        }
        for (const attr of instrValue.props) {
          if (attr.kind === "JsxSpreadAttribute") {
            state.referenceAndRecordEffects(
              attr.argument,
              Effect.Freeze,
              ValueReason.JsxCaptured,
              functionEffects
            );
          } else {
            const propEffects = [];
            state.referenceAndRecordEffects(
              attr.place,
              Effect.Freeze,
              ValueReason.JsxCaptured,
              propEffects
            );
            functionEffects.push(
              ...propEffects.filter(
                (propEffect) => propEffect.kind !== "GlobalMutation"
              )
            );
          }
        }
        state.initialize(instrValue, {
          kind: ValueKind.Frozen,
          reason: new Set([ValueReason.Other]),
          context: new Set(),
        });
        state.define(instr.lvalue, instrValue);
        instr.lvalue.effect = Effect.ConditionallyMutate;
        continue;
      }
      case "JsxFragment": {
        valueKind = {
          kind: ValueKind.Frozen,
          reason: new Set([ValueReason.Other]),
          context: new Set(),
        };
        effect = { kind: Effect.Freeze, reason: ValueReason.Other };
        break;
      }
      case "TaggedTemplateExpression": {
        valueKind = {
          kind: ValueKind.Mutable,
          reason: new Set([ValueReason.Other]),
          context: new Set(),
        };
        effect = {
          kind: Effect.ConditionallyMutate,
          reason: ValueReason.Other,
        };
        break;
      }
      case "TemplateLiteral": {
        valueKind = {
          kind: ValueKind.Primitive,
          reason: new Set([ValueReason.Other]),
          context: new Set(),
        };
        effect = { kind: Effect.Read, reason: ValueReason.Other };
        break;
      }
      case "RegExpLiteral": {
        valueKind = {
          kind: ValueKind.Mutable,
          reason: new Set([ValueReason.Other]),
          context: new Set(),
        };
        effect = {
          kind: Effect.ConditionallyMutate,
          reason: ValueReason.Other,
        };
        break;
      }
      case "MetaProperty": {
        if (instrValue.meta !== "import" || instrValue.property !== "meta") {
          continue;
        }
        valueKind = {
          kind: ValueKind.Global,
          reason: new Set([ValueReason.Global]),
          context: new Set(),
        };
        break;
      }
      case "LoadGlobal":
        valueKind = {
          kind: ValueKind.Global,
          reason: new Set([ValueReason.Global]),
          context: new Set(),
        };
        break;
      case "Debugger":
      case "JSXText":
      case "Primitive": {
        valueKind = {
          kind: ValueKind.Primitive,
          reason: new Set([ValueReason.Other]),
          context: new Set(),
        };
        break;
      }
      case "ObjectMethod":
      case "FunctionExpression": {
        let hasMutableOperand = false;
        for (const operand of eachInstructionOperand(instr)) {
          state.referenceAndRecordEffects(
            operand,
            operand.effect === Effect.Unknown ? Effect.Read : operand.effect,
            ValueReason.Other,
            []
          );
          hasMutableOperand ||
            (hasMutableOperand = isMutableEffect(operand.effect, operand.loc));
          const values = state.values(operand);
          for (const value of values) {
            if (
              (value.kind === "ObjectMethod" ||
                value.kind === "FunctionExpression") &&
              value.loweredFunc.func.effects !== null
            ) {
              (_a = (_c = instrValue.loweredFunc.func).effects) !== null &&
              _a !== void 0
                ? _a
                : (_c.effects = []);
              instrValue.loweredFunc.func.effects.push(
                ...value.loweredFunc.func.effects
              );
            }
          }
        }
        state.initialize(instrValue, {
          kind: hasMutableOperand ? ValueKind.Mutable : ValueKind.Frozen,
          reason: new Set([ValueReason.Other]),
          context: new Set(),
        });
        state.define(instr.lvalue, instrValue);
        instr.lvalue.effect = Effect.Store;
        continue;
      }
      case "CallExpression": {
        const signature = getFunctionCallSignature(
          env,
          instrValue.callee.identifier.type
        );
        const effects =
          signature !== null ? getFunctionEffects(instrValue, signature) : null;
        const returnValueKind =
          signature !== null
            ? {
                kind: signature.returnValueKind,
                reason: new Set([
                  (_b = signature.returnValueReason) !== null && _b !== void 0
                    ? _b
                    : ValueReason.KnownReturnSignature,
                ]),
                context: new Set(),
              }
            : {
                kind: ValueKind.Mutable,
                reason: new Set([ValueReason.Other]),
                context: new Set(),
              };
        let hasCaptureArgument = false;
        let isUseEffect = isEffectHook(instrValue.callee.identifier);
        for (let i = 0; i < instrValue.args.length; i++) {
          const argumentEffects = [];
          const arg = instrValue.args[i];
          const place = arg.kind === "Identifier" ? arg : arg.place;
          if (effects !== null) {
            state.referenceAndRecordEffects(
              place,
              effects[i],
              ValueReason.Other,
              argumentEffects
            );
          } else {
            state.referenceAndRecordEffects(
              place,
              Effect.ConditionallyMutate,
              ValueReason.Other,
              argumentEffects
            );
          }
          functionEffects.push(
            ...argumentEffects.filter(
              (argEffect) =>
                !isUseEffect || i !== 0 || argEffect.kind !== "GlobalMutation"
            )
          );
          hasCaptureArgument ||
            (hasCaptureArgument = place.effect === Effect.Capture);
        }
        if (signature !== null) {
          state.referenceAndRecordEffects(
            instrValue.callee,
            signature.calleeEffect,
            ValueReason.Other,
            functionEffects
          );
        } else {
          state.referenceAndRecordEffects(
            instrValue.callee,
            Effect.ConditionallyMutate,
            ValueReason.Other,
            functionEffects
          );
        }
        hasCaptureArgument ||
          (hasCaptureArgument = instrValue.callee.effect === Effect.Capture);
        state.initialize(instrValue, returnValueKind);
        state.define(instr.lvalue, instrValue);
        instr.lvalue.effect = hasCaptureArgument
          ? Effect.Store
          : Effect.ConditionallyMutate;
        continue;
      }
      case "MethodCall": {
        CompilerError.invariant(state.isDefined(instrValue.receiver), {
          reason:
            "[InferReferenceEffects] Internal error: receiver of PropertyCall should have been defined by corresponding PropertyLoad",
          description: null,
          loc: instrValue.loc,
          suggestions: null,
        });
        state.referenceAndRecordEffects(
          instrValue.property,
          Effect.Read,
          ValueReason.Other,
          functionEffects
        );
        const signature = getFunctionCallSignature(
          env,
          instrValue.property.identifier.type
        );
        const returnValueKind =
          signature !== null
            ? {
                kind: signature.returnValueKind,
                reason: new Set([ValueReason.Other]),
                context: new Set(),
              }
            : {
                kind: ValueKind.Mutable,
                reason: new Set([ValueReason.Other]),
                context: new Set(),
              };
        if (
          signature !== null &&
          signature.mutableOnlyIfOperandsAreMutable &&
          areArgumentsImmutableAndNonMutating(state, instrValue.args)
        ) {
          for (const arg of instrValue.args) {
            const place = arg.kind === "Identifier" ? arg : arg.place;
            state.referenceAndRecordEffects(
              place,
              Effect.Read,
              ValueReason.Other,
              functionEffects
            );
          }
          state.referenceAndRecordEffects(
            instrValue.receiver,
            Effect.Capture,
            ValueReason.Other,
            functionEffects
          );
          state.initialize(instrValue, returnValueKind);
          state.define(instr.lvalue, instrValue);
          instr.lvalue.effect =
            instrValue.receiver.effect === Effect.Capture
              ? Effect.Store
              : Effect.ConditionallyMutate;
          continue;
        }
        const effects =
          signature !== null ? getFunctionEffects(instrValue, signature) : null;
        let hasCaptureArgument = false;
        let isUseEffect = isEffectHook(instrValue.property.identifier);
        for (let i = 0; i < instrValue.args.length; i++) {
          const argumentEffects = [];
          const arg = instrValue.args[i];
          const place = arg.kind === "Identifier" ? arg : arg.place;
          if (effects !== null) {
            state.referenceAndRecordEffects(
              place,
              effects[i],
              ValueReason.Other,
              argumentEffects
            );
          } else {
            state.referenceAndRecordEffects(
              place,
              Effect.ConditionallyMutate,
              ValueReason.Other,
              argumentEffects
            );
          }
          functionEffects.push(
            ...argumentEffects.filter(
              (argEffect) =>
                !isUseEffect || i !== 0 || argEffect.kind !== "GlobalMutation"
            )
          );
          hasCaptureArgument ||
            (hasCaptureArgument = place.effect === Effect.Capture);
        }
        if (signature !== null) {
          state.referenceAndRecordEffects(
            instrValue.receiver,
            signature.calleeEffect,
            ValueReason.Other,
            functionEffects
          );
        } else {
          state.referenceAndRecordEffects(
            instrValue.receiver,
            Effect.ConditionallyMutate,
            ValueReason.Other,
            functionEffects
          );
        }
        hasCaptureArgument ||
          (hasCaptureArgument = instrValue.receiver.effect === Effect.Capture);
        state.initialize(instrValue, returnValueKind);
        state.define(instr.lvalue, instrValue);
        instr.lvalue.effect = hasCaptureArgument
          ? Effect.Store
          : Effect.ConditionallyMutate;
        continue;
      }
      case "PropertyStore": {
        const effect =
          state.kind(instrValue.object).kind === ValueKind.Context
            ? Effect.ConditionallyMutate
            : Effect.Capture;
        state.referenceAndRecordEffects(
          instrValue.value,
          effect,
          ValueReason.Other,
          functionEffects
        );
        state.referenceAndRecordEffects(
          instrValue.object,
          Effect.Store,
          ValueReason.Other,
          functionEffects
        );
        const lvalue = instr.lvalue;
        state.alias(lvalue, instrValue.value);
        lvalue.effect = Effect.Store;
        continue;
      }
      case "PropertyDelete": {
        valueKind = {
          kind: ValueKind.Primitive,
          reason: new Set([ValueReason.Other]),
          context: new Set(),
        };
        effect = { kind: Effect.Mutate, reason: ValueReason.Other };
        break;
      }
      case "PropertyLoad": {
        state.referenceAndRecordEffects(
          instrValue.object,
          Effect.Read,
          ValueReason.Other,
          functionEffects
        );
        const lvalue = instr.lvalue;
        lvalue.effect = Effect.ConditionallyMutate;
        state.initialize(instrValue, state.kind(instrValue.object));
        state.define(lvalue, instrValue);
        continue;
      }
      case "ComputedStore": {
        const effect =
          state.kind(instrValue.object).kind === ValueKind.Context
            ? Effect.ConditionallyMutate
            : Effect.Capture;
        state.referenceAndRecordEffects(
          instrValue.value,
          effect,
          ValueReason.Other,
          functionEffects
        );
        state.referenceAndRecordEffects(
          instrValue.property,
          Effect.Capture,
          ValueReason.Other,
          functionEffects
        );
        state.referenceAndRecordEffects(
          instrValue.object,
          Effect.Store,
          ValueReason.Other,
          functionEffects
        );
        const lvalue = instr.lvalue;
        state.alias(lvalue, instrValue.value);
        lvalue.effect = Effect.Store;
        continue;
      }
      case "ComputedDelete": {
        state.referenceAndRecordEffects(
          instrValue.object,
          Effect.Mutate,
          ValueReason.Other,
          functionEffects
        );
        state.referenceAndRecordEffects(
          instrValue.property,
          Effect.Read,
          ValueReason.Other,
          functionEffects
        );
        state.initialize(instrValue, {
          kind: ValueKind.Primitive,
          reason: new Set([ValueReason.Other]),
          context: new Set(),
        });
        state.define(instr.lvalue, instrValue);
        instr.lvalue.effect = Effect.Mutate;
        continue;
      }
      case "ComputedLoad": {
        state.referenceAndRecordEffects(
          instrValue.object,
          Effect.Read,
          ValueReason.Other,
          functionEffects
        );
        state.referenceAndRecordEffects(
          instrValue.property,
          Effect.Read,
          ValueReason.Other,
          functionEffects
        );
        const lvalue = instr.lvalue;
        lvalue.effect = Effect.ConditionallyMutate;
        state.initialize(instrValue, state.kind(instrValue.object));
        state.define(lvalue, instrValue);
        continue;
      }
      case "Await": {
        state.initialize(instrValue, state.kind(instrValue.value));
        state.referenceAndRecordEffects(
          instrValue.value,
          Effect.ConditionallyMutate,
          ValueReason.Other,
          functionEffects
        );
        const lvalue = instr.lvalue;
        lvalue.effect = Effect.ConditionallyMutate;
        state.alias(lvalue, instrValue.value);
        continue;
      }
      case "TypeCastExpression": {
        state.initialize(instrValue, state.kind(instrValue.value));
        state.referenceAndRecordEffects(
          instrValue.value,
          Effect.Read,
          ValueReason.Other,
          functionEffects
        );
        const lvalue = instr.lvalue;
        lvalue.effect = Effect.ConditionallyMutate;
        state.alias(lvalue, instrValue.value);
        continue;
      }
      case "StartMemoize":
      case "FinishMemoize": {
        for (const val of eachInstructionValueOperand(instrValue)) {
          if (env.config.enablePreserveExistingMemoizationGuarantees) {
            state.referenceAndRecordEffects(
              val,
              Effect.Freeze,
              ValueReason.Other,
              []
            );
          } else {
            state.referenceAndRecordEffects(
              val,
              Effect.Read,
              ValueReason.Other,
              []
            );
          }
        }
        const lvalue = instr.lvalue;
        lvalue.effect = Effect.ConditionallyMutate;
        state.initialize(instrValue, {
          kind: ValueKind.Frozen,
          reason: new Set([ValueReason.Other]),
          context: new Set(),
        });
        state.define(lvalue, instrValue);
        continue;
      }
      case "LoadLocal": {
        const lvalue = instr.lvalue;
        const effect =
          state.isDefined(lvalue) &&
          state.kind(lvalue).kind === ValueKind.Context
            ? Effect.ConditionallyMutate
            : Effect.Capture;
        state.referenceAndRecordEffects(
          instrValue.place,
          effect,
          ValueReason.Other,
          []
        );
        lvalue.effect = Effect.ConditionallyMutate;
        state.alias(lvalue, instrValue.place);
        continue;
      }
      case "LoadContext": {
        state.referenceAndRecordEffects(
          instrValue.place,
          Effect.Capture,
          ValueReason.Other,
          functionEffects
        );
        const lvalue = instr.lvalue;
        lvalue.effect = Effect.ConditionallyMutate;
        const valueKind = state.kind(instrValue.place);
        state.initialize(instrValue, valueKind);
        state.define(lvalue, instrValue);
        continue;
      }
      case "DeclareLocal": {
        const value = UndefinedValue;
        state.initialize(
          value,
          instrValue.lvalue.kind === InstructionKind.Catch
            ? {
                kind: ValueKind.Mutable,
                reason: new Set([ValueReason.Other]),
                context: new Set(),
              }
            : {
                kind: ValueKind.Primitive,
                reason: new Set([ValueReason.Other]),
                context: new Set(),
              }
        );
        state.define(instrValue.lvalue.place, value);
        continue;
      }
      case "DeclareContext": {
        state.initialize(instrValue, {
          kind: ValueKind.Mutable,
          reason: new Set([ValueReason.Other]),
          context: new Set(),
        });
        state.define(instrValue.lvalue.place, instrValue);
        continue;
      }
      case "PostfixUpdate":
      case "PrefixUpdate": {
        const effect =
          state.isDefined(instrValue.lvalue) &&
          state.kind(instrValue.lvalue).kind === ValueKind.Context
            ? Effect.ConditionallyMutate
            : Effect.Capture;
        state.referenceAndRecordEffects(
          instrValue.value,
          effect,
          ValueReason.Other,
          functionEffects
        );
        const lvalue = instr.lvalue;
        state.alias(lvalue, instrValue.value);
        lvalue.effect = Effect.Store;
        state.alias(instrValue.lvalue, instrValue.value);
        instrValue.lvalue.effect = Effect.Store;
        continue;
      }
      case "StoreLocal": {
        const effect =
          state.isDefined(instrValue.lvalue.place) &&
          state.kind(instrValue.lvalue.place).kind === ValueKind.Context
            ? Effect.ConditionallyMutate
            : Effect.Capture;
        state.referenceAndRecordEffects(
          instrValue.value,
          effect,
          ValueReason.Other,
          []
        );
        const lvalue = instr.lvalue;
        state.alias(lvalue, instrValue.value);
        lvalue.effect = Effect.Store;
        state.alias(instrValue.lvalue.place, instrValue.value);
        instrValue.lvalue.place.effect = Effect.Store;
        continue;
      }
      case "StoreContext": {
        state.referenceAndRecordEffects(
          instrValue.value,
          Effect.ConditionallyMutate,
          ValueReason.Other,
          functionEffects
        );
        state.referenceAndRecordEffects(
          instrValue.lvalue.place,
          Effect.Mutate,
          ValueReason.Other,
          functionEffects
        );
        const lvalue = instr.lvalue;
        state.alias(lvalue, instrValue.value);
        lvalue.effect = Effect.Store;
        continue;
      }
      case "StoreGlobal": {
        state.referenceAndRecordEffects(
          instrValue.value,
          Effect.Capture,
          ValueReason.Other,
          functionEffects
        );
        const lvalue = instr.lvalue;
        lvalue.effect = Effect.Store;
        functionEffects.push({
          kind: "GlobalMutation",
          error: {
            reason:
              "Unexpected reassignment of a variable which was defined outside of the component. Components and hooks should be pure and side-effect free, but variable reassignment is a form of side-effect. If this variable is used in rendering, use useState instead. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render)",
            loc: instr.loc,
            suggestions: null,
            severity: ErrorSeverity.InvalidReact,
          },
        });
        continue;
      }
      case "Destructure": {
        let effect = Effect.Capture;
        for (const place of eachPatternOperand(instrValue.lvalue.pattern)) {
          if (
            state.isDefined(place) &&
            state.kind(place).kind === ValueKind.Context
          ) {
            effect = Effect.ConditionallyMutate;
            break;
          }
        }
        state.referenceAndRecordEffects(
          instrValue.value,
          effect,
          ValueReason.Other,
          functionEffects
        );
        const lvalue = instr.lvalue;
        state.alias(lvalue, instrValue.value);
        lvalue.effect = Effect.Store;
        for (const place of eachPatternOperand(instrValue.lvalue.pattern)) {
          state.alias(place, instrValue.value);
          place.effect = Effect.Store;
        }
        continue;
      }
      case "GetIterator": {
        const kind = state.kind(instrValue.collection).kind;
        const isMutable =
          kind === ValueKind.Mutable || kind === ValueKind.Context;
        if (!isMutable || isArrayType(instrValue.collection.identifier)) {
          effect = { kind: Effect.Read, reason: ValueReason.Other };
          valueKind = {
            kind: ValueKind.Mutable,
            reason: new Set([ValueReason.Other]),
            context: new Set(),
          };
        } else {
          effect = { kind: Effect.Capture, reason: ValueReason.Other };
          valueKind = state.kind(instrValue.collection);
        }
        lvalueEffect = Effect.Store;
        break;
      }
      case "IteratorNext": {
        state.referenceAndRecordEffects(
          instrValue.iterator,
          Effect.ConditionallyMutate,
          ValueReason.Other,
          functionEffects
        );
        state.referenceAndRecordEffects(
          instrValue.collection,
          Effect.Capture,
          ValueReason.Other,
          functionEffects
        );
        state.initialize(instrValue, state.kind(instrValue.collection));
        state.define(instr.lvalue, instrValue);
        instr.lvalue.effect = Effect.Store;
        continue;
      }
      case "NextPropertyOf": {
        effect = { kind: Effect.Read, reason: ValueReason.Other };
        lvalueEffect = Effect.Store;
        valueKind = {
          kind: ValueKind.Primitive,
          reason: new Set([ValueReason.Other]),
          context: new Set(),
        };
        break;
      }
      default: {
        assertExhaustive$1(instrValue, "Unexpected instruction kind");
      }
    }
    for (const operand of eachInstructionOperand(instr)) {
      CompilerError.invariant(effect != null, {
        reason: `effectKind must be set for instruction value \`${instrValue.kind}\``,
        description: null,
        loc: instrValue.loc,
        suggestions: null,
      });
      state.referenceAndRecordEffects(
        operand,
        effect.kind,
        effect.reason,
        functionEffects
      );
    }
    state.initialize(instrValue, valueKind);
    state.define(instr.lvalue, instrValue);
    instr.lvalue.effect = lvalueEffect;
  }
  for (const operand of eachTerminalOperand(block.terminal)) {
    let effect;
    if (block.terminal.kind === "return" || block.terminal.kind === "throw") {
      if (
        state.isDefined(operand) &&
        state.kind(operand).kind === ValueKind.Context
      ) {
        effect = Effect.ConditionallyMutate;
      } else {
        effect = Effect.Freeze;
      }
    } else {
      effect = Effect.Read;
    }
    state.referenceAndRecordEffects(
      operand,
      effect,
      ValueReason.Other,
      functionEffects
    );
  }
}
function hasContextRefOperand(state, instrValue) {
  for (const place of eachInstructionValueOperand(instrValue)) {
    if (
      state.isDefined(place) &&
      state.kind(place).kind === ValueKind.Context
    ) {
      return true;
    }
  }
  return false;
}
function getFunctionCallSignature(env, type) {
  if (type.kind !== "Function") {
    return null;
  }
  return env.getFunctionSignature(type);
}
function getFunctionEffects(fn, sig) {
  const results = [];
  for (let i = 0; i < fn.args.length; i++) {
    const arg = fn.args[i];
    if (i < sig.positionalParams.length) {
      if (arg.kind === "Identifier") {
        results.push(sig.positionalParams[i]);
      } else {
        return null;
      }
    } else if (sig.restParam !== null) {
      results.push(sig.restParam);
    } else {
      return null;
    }
  }
  return results;
}
function areArgumentsImmutableAndNonMutating(state, args) {
  for (const arg of args) {
    const place = arg.kind === "Identifier" ? arg : arg.place;
    const kind = state.kind(place).kind;
    switch (kind) {
      case ValueKind.Global:
      case ValueKind.Primitive:
      case ValueKind.Frozen: {
        break;
      }
      default: {
        return false;
      }
    }
    const values = state.values(place);
    for (const value of values) {
      if (
        value.kind === "FunctionExpression" &&
        value.loweredFunc.func.params.some((param) => {
          const place = param.kind === "Identifier" ? param : param.place;
          const range = place.identifier.mutableRange;
          return range.end > range.start + 1;
        })
      ) {
        return false;
      }
    }
  }
  return true;
}
function getWriteErrorReason(abstractValue) {
  if (abstractValue.reason.has(ValueReason.Global)) {
    return "Writing to a variable defined outside a component or hook is not allowed. Consider using an effect";
  } else if (abstractValue.reason.has(ValueReason.JsxCaptured)) {
    return "Updating a value used previously in JSX is not allowed. Consider moving the mutation before the JSX";
  } else if (abstractValue.reason.has(ValueReason.Context)) {
    return `Mutating a value returned from 'useContext()', which should not be mutated`;
  } else if (abstractValue.reason.has(ValueReason.KnownReturnSignature)) {
    return "Mutating a value returned from a function whose return value should not be mutated";
  } else if (abstractValue.reason.has(ValueReason.ReactiveFunctionArgument)) {
    return "Mutating component props or hook arguments is not allowed. Consider using a local variable instead";
  } else if (abstractValue.reason.has(ValueReason.State)) {
    return "Mutating a value returned from 'useState()', which should not be mutated. Use the setter function to update instead";
  } else if (abstractValue.reason.has(ValueReason.ReducerState)) {
    return "Mutating a value returned from 'useReducer()', which should not be mutated. Use the dispatch function to update instead";
  } else {
    return "This mutates a variable that React considers immutable";
  }
}
function pruneNonEscapingScopes(fn) {
  const state = new State$1(fn.env);
  for (const param of fn.params) {
    if (param.kind === "Identifier") {
      state.declare(param.identifier.id);
    } else {
      state.declare(param.place.identifier.id);
    }
  }
  visitReactiveFunction(fn, new CollectDependenciesVisitor(fn.env), state);
  const memoized = computeMemoizedIdentifiers(state);
  visitReactiveFunction(fn, new PruneScopesTransform(), memoized);
}
var MemoizationLevel;
(function (MemoizationLevel) {
  MemoizationLevel["Memoized"] = "Memoized";
  MemoizationLevel["Conditional"] = "Conditional";
  MemoizationLevel["Unmemoized"] = "Unmemoized";
  MemoizationLevel["Never"] = "Never";
})(MemoizationLevel || (MemoizationLevel = {}));
function joinAliases(kind1, kind2) {
  if (
    kind1 === MemoizationLevel.Memoized ||
    kind2 === MemoizationLevel.Memoized
  ) {
    return MemoizationLevel.Memoized;
  } else if (
    kind1 === MemoizationLevel.Conditional ||
    kind2 === MemoizationLevel.Conditional
  ) {
    return MemoizationLevel.Conditional;
  } else if (
    kind1 === MemoizationLevel.Unmemoized ||
    kind2 === MemoizationLevel.Unmemoized
  ) {
    return MemoizationLevel.Unmemoized;
  } else {
    return MemoizationLevel.Never;
  }
}
let State$1 = class State {
  constructor(env) {
    this.definitions = new Map();
    this.identifiers = new Map();
    this.scopes = new Map();
    this.escapingValues = new Set();
    this.env = env;
  }
  declare(id) {
    this.identifiers.set(id, {
      level: MemoizationLevel.Never,
      memoized: false,
      dependencies: new Set(),
      scopes: new Set(),
      seen: false,
    });
  }
  visitOperand(id, place, identifier) {
    const scope = getPlaceScope(id, place);
    if (scope !== null) {
      let node = this.scopes.get(scope.id);
      if (node === undefined) {
        node = {
          dependencies: [...scope.dependencies].map((dep) => dep.identifier.id),
          seen: false,
        };
        this.scopes.set(scope.id, node);
      }
      const identifierNode = this.identifiers.get(identifier);
      CompilerError.invariant(identifierNode !== undefined, {
        reason: "Expected identifier to be initialized",
        description: null,
        loc: place.loc,
        suggestions: null,
      });
      identifierNode.scopes.add(scope.id);
    }
  }
};
function computeMemoizedIdentifiers(state) {
  const memoized = new Set();
  function visit(id, forceMemoize = false) {
    const node = state.identifiers.get(id);
    CompilerError.invariant(node !== undefined, {
      reason: `Expected a node for all identifiers, none found for \`${id}\``,
      description: null,
      loc: null,
      suggestions: null,
    });
    if (node.seen) {
      return node.memoized;
    }
    node.seen = true;
    node.memoized = false;
    let hasMemoizedDependency = false;
    for (const dep of node.dependencies) {
      const isDepMemoized = visit(dep);
      hasMemoizedDependency || (hasMemoizedDependency = isDepMemoized);
    }
    if (
      node.level === MemoizationLevel.Memoized ||
      (node.level === MemoizationLevel.Conditional &&
        (hasMemoizedDependency || forceMemoize)) ||
      (node.level === MemoizationLevel.Unmemoized && forceMemoize)
    ) {
      node.memoized = true;
      memoized.add(id);
      for (const scope of node.scopes) {
        forceMemoizeScopeDependencies(scope);
      }
    }
    return node.memoized;
  }
  function forceMemoizeScopeDependencies(id) {
    const node = state.scopes.get(id);
    CompilerError.invariant(node !== undefined, {
      reason: "Expected a node for all scopes",
      description: null,
      loc: null,
      suggestions: null,
    });
    if (node.seen) {
      return;
    }
    node.seen = true;
    for (const dep of node.dependencies) {
      visit(dep, true);
    }
    return;
  }
  for (const value of state.escapingValues) {
    visit(value);
  }
  return memoized;
}
function computeMemoizationInputs(env, value, lvalue, options) {
  switch (value.kind) {
    case "ConditionalExpression": {
      return {
        lvalues:
          lvalue !== null
            ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
            : [],
        rvalues: [
          ...computeMemoizationInputs(env, value.consequent, null, options)
            .rvalues,
          ...computeMemoizationInputs(env, value.alternate, null, options)
            .rvalues,
        ],
      };
    }
    case "LogicalExpression": {
      return {
        lvalues:
          lvalue !== null
            ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
            : [],
        rvalues: [
          ...computeMemoizationInputs(env, value.left, null, options).rvalues,
          ...computeMemoizationInputs(env, value.right, null, options).rvalues,
        ],
      };
    }
    case "SequenceExpression": {
      return {
        lvalues:
          lvalue !== null
            ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
            : [],
        rvalues: computeMemoizationInputs(env, value.value, null, options)
          .rvalues,
      };
    }
    case "JsxExpression": {
      const operands = [];
      if (value.tag.kind === "Identifier") {
        operands.push(value.tag);
      }
      for (const prop of value.props) {
        if (prop.kind === "JsxAttribute") {
          operands.push(prop.place);
        } else {
          operands.push(prop.argument);
        }
      }
      if (value.children !== null) {
        for (const child of value.children) {
          operands.push(child);
        }
      }
      const level = options.memoizeJsxElements
        ? MemoizationLevel.Memoized
        : MemoizationLevel.Unmemoized;
      return {
        lvalues: lvalue !== null ? [{ place: lvalue, level: level }] : [],
        rvalues: operands,
      };
    }
    case "JsxFragment": {
      const level = options.memoizeJsxElements
        ? MemoizationLevel.Memoized
        : MemoizationLevel.Unmemoized;
      return {
        lvalues: lvalue !== null ? [{ place: lvalue, level: level }] : [],
        rvalues: value.children,
      };
    }
    case "NextPropertyOf":
    case "StartMemoize":
    case "FinishMemoize":
    case "Debugger":
    case "ComputedDelete":
    case "PropertyDelete":
    case "LoadGlobal":
    case "MetaProperty":
    case "TemplateLiteral":
    case "Primitive":
    case "JSXText":
    case "BinaryExpression":
    case "UnaryExpression": {
      const level = options.forceMemoizePrimitives
        ? MemoizationLevel.Memoized
        : MemoizationLevel.Never;
      return {
        lvalues: lvalue !== null ? [{ place: lvalue, level: level }] : [],
        rvalues: [],
      };
    }
    case "Await":
    case "TypeCastExpression": {
      return {
        lvalues:
          lvalue !== null
            ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
            : [],
        rvalues: [value.value],
      };
    }
    case "IteratorNext": {
      return {
        lvalues:
          lvalue !== null
            ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
            : [],
        rvalues: [value.iterator, value.collection],
      };
    }
    case "GetIterator": {
      return {
        lvalues:
          lvalue !== null
            ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
            : [],
        rvalues: [value.collection],
      };
    }
    case "LoadLocal": {
      return {
        lvalues:
          lvalue !== null
            ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
            : [],
        rvalues: [value.place],
      };
    }
    case "LoadContext": {
      return {
        lvalues:
          lvalue !== null
            ? [{ place: lvalue, level: MemoizationLevel.Conditional }]
            : [],
        rvalues: [value.place],
      };
    }
    case "DeclareContext": {
      const lvalues = [
        { place: value.lvalue.place, level: MemoizationLevel.Memoized },
      ];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Unmemoized });
      }
      return { lvalues: lvalues, rvalues: [] };
    }
    case "DeclareLocal": {
      const lvalues = [
        { place: value.lvalue.place, level: MemoizationLevel.Unmemoized },
      ];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Unmemoized });
      }
      return { lvalues: lvalues, rvalues: [] };
    }
    case "PrefixUpdate":
    case "PostfixUpdate": {
      const lvalues = [
        { place: value.lvalue, level: MemoizationLevel.Conditional },
      ];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Conditional });
      }
      return { lvalues: lvalues, rvalues: [value.value] };
    }
    case "StoreLocal": {
      const lvalues = [
        { place: value.lvalue.place, level: MemoizationLevel.Conditional },
      ];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Conditional });
      }
      return { lvalues: lvalues, rvalues: [value.value] };
    }
    case "StoreContext": {
      const lvalues = [
        { place: value.lvalue.place, level: MemoizationLevel.Memoized },
      ];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Conditional });
      }
      return { lvalues: lvalues, rvalues: [value.value] };
    }
    case "StoreGlobal": {
      const lvalues = [];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Unmemoized });
      }
      return { lvalues: lvalues, rvalues: [value.value] };
    }
    case "Destructure": {
      const lvalues = [];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Conditional });
      }
      lvalues.push(...computePatternLValues(value.lvalue.pattern));
      return { lvalues: lvalues, rvalues: [value.value] };
    }
    case "ComputedLoad":
    case "PropertyLoad": {
      const level = options.forceMemoizePrimitives
        ? MemoizationLevel.Memoized
        : MemoizationLevel.Conditional;
      return {
        lvalues: lvalue !== null ? [{ place: lvalue, level: level }] : [],
        rvalues: [value.object],
      };
    }
    case "ComputedStore": {
      const lvalues = [
        { place: value.object, level: MemoizationLevel.Conditional },
      ];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Conditional });
      }
      return { lvalues: lvalues, rvalues: [value.value] };
    }
    case "OptionalExpression": {
      const lvalues = [];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Conditional });
      }
      return {
        lvalues: lvalues,
        rvalues: [
          ...computeMemoizationInputs(env, value.value, null, options).rvalues,
        ],
      };
    }
    case "CallExpression": {
      const signature = getFunctionCallSignature(
        env,
        value.callee.identifier.type
      );
      const operands = [...eachReactiveValueOperand(value)];
      let lvalues = [];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Memoized });
      }
      if (
        (signature === null || signature === void 0
          ? void 0
          : signature.noAlias) === true
      ) {
        return { lvalues: lvalues, rvalues: [] };
      }
      lvalues.push(
        ...operands
          .filter((operand) => isMutableEffect(operand.effect, operand.loc))
          .map((place) => ({ place: place, level: MemoizationLevel.Memoized }))
      );
      return { lvalues: lvalues, rvalues: operands };
    }
    case "MethodCall": {
      const signature = getFunctionCallSignature(
        env,
        value.property.identifier.type
      );
      const operands = [...eachReactiveValueOperand(value)];
      let lvalues = [];
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Memoized });
      }
      if (
        (signature === null || signature === void 0
          ? void 0
          : signature.noAlias) === true
      ) {
        return { lvalues: lvalues, rvalues: [] };
      }
      lvalues.push(
        ...operands
          .filter((operand) => isMutableEffect(operand.effect, operand.loc))
          .map((place) => ({ place: place, level: MemoizationLevel.Memoized }))
      );
      return { lvalues: lvalues, rvalues: operands };
    }
    case "RegExpLiteral":
    case "ObjectMethod":
    case "FunctionExpression":
    case "TaggedTemplateExpression":
    case "ArrayExpression":
    case "NewExpression":
    case "ObjectExpression":
    case "PropertyStore": {
      const operands = [...eachReactiveValueOperand(value)];
      const lvalues = operands
        .filter((operand) => isMutableEffect(operand.effect, operand.loc))
        .map((place) => ({ place: place, level: MemoizationLevel.Memoized }));
      if (lvalue !== null) {
        lvalues.push({ place: lvalue, level: MemoizationLevel.Memoized });
      }
      return { lvalues: lvalues, rvalues: operands };
    }
    case "ReactiveFunctionValue": {
      CompilerError.invariant(false, {
        reason: `Unexpected ReactiveFunctionValue node`,
        description: null,
        loc: value.loc,
        suggestions: null,
      });
    }
    case "UnsupportedNode": {
      CompilerError.invariant(false, {
        reason: `Unexpected unsupported node`,
        description: null,
        loc: value.loc,
        suggestions: null,
      });
    }
    default: {
      assertExhaustive$1(value, `Unexpected value kind \`${value.kind}\``);
    }
  }
}
function computePatternLValues(pattern) {
  const lvalues = [];
  switch (pattern.kind) {
    case "ArrayPattern": {
      for (const item of pattern.items) {
        if (item.kind === "Identifier") {
          lvalues.push({ place: item, level: MemoizationLevel.Conditional });
        } else if (item.kind === "Spread") {
          lvalues.push({ place: item.place, level: MemoizationLevel.Memoized });
        }
      }
      break;
    }
    case "ObjectPattern": {
      for (const property of pattern.properties) {
        if (property.kind === "ObjectProperty") {
          lvalues.push({
            place: property.place,
            level: MemoizationLevel.Conditional,
          });
        } else {
          lvalues.push({
            place: property.place,
            level: MemoizationLevel.Memoized,
          });
        }
      }
      break;
    }
    default: {
      assertExhaustive$1(
        pattern,
        `Unexpected pattern kind \`${pattern.kind}\``
      );
    }
  }
  return lvalues;
}
class CollectDependenciesVisitor extends ReactiveFunctionVisitor {
  constructor(env) {
    super();
    this.env = env;
    this.options = {
      memoizeJsxElements: !this.env.config.enableForest,
      forceMemoizePrimitives: this.env.config.enableForest,
    };
  }
  visitInstruction(instruction, state) {
    var _a, _b, _c;
    this.traverseInstruction(instruction, state);
    const aliasing = computeMemoizationInputs(
      this.env,
      instruction.value,
      instruction.lvalue,
      this.options
    );
    for (const operand of aliasing.rvalues) {
      const operandId =
        (_a = state.definitions.get(operand.identifier.id)) !== null &&
        _a !== void 0
          ? _a
          : operand.identifier.id;
      state.visitOperand(instruction.id, operand, operandId);
    }
    for (const { place: lvalue, level: level } of aliasing.lvalues) {
      const lvalueId =
        (_b = state.definitions.get(lvalue.identifier.id)) !== null &&
        _b !== void 0
          ? _b
          : lvalue.identifier.id;
      let node = state.identifiers.get(lvalueId);
      if (node === undefined) {
        node = {
          level: MemoizationLevel.Never,
          memoized: false,
          dependencies: new Set(),
          scopes: new Set(),
          seen: false,
        };
        state.identifiers.set(lvalueId, node);
      }
      node.level = joinAliases(node.level, level);
      for (const operand of aliasing.rvalues) {
        const operandId =
          (_c = state.definitions.get(operand.identifier.id)) !== null &&
          _c !== void 0
            ? _c
            : operand.identifier.id;
        if (operandId === lvalueId) {
          continue;
        }
        node.dependencies.add(operandId);
      }
      state.visitOperand(instruction.id, lvalue, lvalueId);
    }
    if (instruction.value.kind === "LoadLocal" && instruction.lvalue !== null) {
      state.definitions.set(
        instruction.lvalue.identifier.id,
        instruction.value.place.identifier.id
      );
    } else if (
      instruction.value.kind === "CallExpression" ||
      instruction.value.kind === "MethodCall"
    ) {
      let callee =
        instruction.value.kind === "CallExpression"
          ? instruction.value.callee
          : instruction.value.property;
      if (getHookKind(state.env, callee.identifier) != null) {
        const signature = getFunctionCallSignature(
          this.env,
          callee.identifier.type
        );
        if (signature && signature.noAlias === true) {
          return;
        }
        for (const operand of instruction.value.args) {
          const place = operand.kind === "Spread" ? operand.place : operand;
          state.escapingValues.add(place.identifier.id);
        }
      }
    }
  }
  visitTerminal(stmt, state) {
    this.traverseTerminal(stmt, state);
    if (stmt.terminal.kind === "return") {
      state.escapingValues.add(stmt.terminal.value.identifier.id);
    }
  }
}
class PruneScopesTransform extends ReactiveFunctionTransform {
  constructor() {
    super(...arguments);
    this.prunedScopes = new Set();
  }
  transformScope(scopeBlock, state) {
    this.visitScope(scopeBlock, state);
    if (
      scopeBlock.scope.declarations.size === 0 &&
      scopeBlock.scope.reassignments.size === 0
    ) {
      return { kind: "keep" };
    }
    const hasMemoizedOutput =
      Array.from(scopeBlock.scope.declarations.keys()).some((id) =>
        state.has(id)
      ) ||
      Array.from(scopeBlock.scope.reassignments).some((identifier) =>
        state.has(identifier.id)
      );
    if (hasMemoizedOutput) {
      return { kind: "keep" };
    } else {
      this.prunedScopes.add(scopeBlock.scope.id);
      return { kind: "replace-many", value: scopeBlock.instructions };
    }
  }
  transformInstruction(instruction, state) {
    this.traverseInstruction(instruction, state);
    if (instruction.value.kind === "FinishMemoize") {
      const identifier = instruction.value.decl.identifier;
      if (
        identifier.scope !== null &&
        this.prunedScopes.has(identifier.scope.id)
      ) {
        instruction.value.pruned = true;
      }
    }
    return { kind: "keep" };
  }
}
let Visitor$6 = class Visitor extends ReactiveFunctionVisitor {
  visitLValue(id, lvalue, state) {
    this.visitPlace(id, lvalue, state);
  }
  visitPlace(_id, place, state) {
    if (place.reactive) {
      state.add(place.identifier.id);
    }
  }
  visitPrunedScope(scopeBlock, state) {
    this.traversePrunedScope(scopeBlock, state);
    for (const [id, decl] of scopeBlock.scope.declarations) {
      if (!isPrimitiveType(decl.identifier)) {
        state.add(id);
      }
    }
  }
};
function collectReactiveIdentifiers(fn) {
  const visitor = new Visitor$6();
  const state = new Set();
  visitReactiveFunction(fn, visitor, state);
  return state;
}
function pruneNonReactiveDependencies(fn) {
  const reactiveIdentifiers = collectReactiveIdentifiers(fn);
  visitReactiveFunction(fn, new Visitor$5(), reactiveIdentifiers);
}
let Visitor$5 = class Visitor extends ReactiveFunctionVisitor {
  visitInstruction(instruction, state) {
    this.traverseInstruction(instruction, state);
    const { lvalue: lvalue, value: value } = instruction;
    switch (value.kind) {
      case "LoadLocal": {
        if (lvalue !== null && state.has(value.place.identifier.id)) {
          state.add(lvalue.identifier.id);
        }
        break;
      }
      case "StoreLocal": {
        if (state.has(value.value.identifier.id)) {
          state.add(value.lvalue.place.identifier.id);
          if (lvalue !== null) {
            state.add(lvalue.identifier.id);
          }
        }
        break;
      }
      case "Destructure": {
        if (state.has(value.value.identifier.id)) {
          for (const lvalue of eachPatternOperand(value.lvalue.pattern)) {
            if (isStableType(lvalue.identifier)) {
              continue;
            }
            state.add(lvalue.identifier.id);
          }
          if (lvalue !== null) {
            state.add(lvalue.identifier.id);
          }
        }
        break;
      }
      case "PropertyLoad": {
        if (
          lvalue !== null &&
          state.has(value.object.identifier.id) &&
          !isStableType(lvalue.identifier)
        ) {
          state.add(lvalue.identifier.id);
        }
        break;
      }
      case "ComputedLoad": {
        if (
          lvalue !== null &&
          (state.has(value.object.identifier.id) ||
            state.has(value.property.identifier.id))
        ) {
          state.add(lvalue.identifier.id);
        }
        break;
      }
    }
  }
  visitScope(scopeBlock, state) {
    this.traverseScope(scopeBlock, state);
    for (const dep of scopeBlock.scope.dependencies) {
      const isReactive = state.has(dep.identifier.id);
      if (!isReactive) {
        scopeBlock.scope.dependencies.delete(dep);
      }
    }
    if (scopeBlock.scope.dependencies.size !== 0) {
      for (const [, declaration] of scopeBlock.scope.declarations) {
        state.add(declaration.identifier.id);
      }
      for (const reassignment of scopeBlock.scope.reassignments) {
        state.add(reassignment.id);
      }
    }
  }
};
function pruneTemporaryLValues(fn) {
  const lvalues = new Map();
  visitReactiveFunction(fn, new Visitor$4(), lvalues);
  for (const [, instr] of lvalues) {
    instr.lvalue = null;
  }
}
let Visitor$4 = class Visitor extends ReactiveFunctionVisitor {
  visitPlace(id, place, state) {
    state.delete(place.identifier);
  }
  visitInstruction(instruction, state) {
    this.traverseInstruction(instruction, state);
    if (
      instruction.lvalue !== null &&
      instruction.lvalue.identifier.name === null
    ) {
      state.set(instruction.lvalue.identifier, instruction);
    }
  }
};
function pruneUnusedLabels(fn) {
  const labels = new Set();
  visitReactiveFunction(fn, new Transform$2(), labels);
}
let Transform$2 = class Transform extends ReactiveFunctionTransform {
  transformTerminal(stmt, state) {
    this.traverseTerminal(stmt, state);
    const { terminal: terminal } = stmt;
    if (
      (terminal.kind === "break" || terminal.kind === "continue") &&
      terminal.targetKind === "labeled"
    ) {
      state.add(terminal.target);
    }
    const isReachableLabel = stmt.label !== null && state.has(stmt.label.id);
    if (stmt.terminal.kind === "label" && !isReachableLabel) {
      const block = [...stmt.terminal.block];
      const last = block.at(-1);
      if (
        last !== undefined &&
        last.kind === "terminal" &&
        last.terminal.kind === "break" &&
        last.terminal.target === null
      ) {
        block.pop();
      }
      return { kind: "replace-many", value: block };
    } else {
      if (!isReachableLabel && stmt.label != null) {
        stmt.label.implicit = true;
      }
      return { kind: "keep" };
    }
  }
};
function pruneUnusedScopes(fn) {
  visitReactiveFunction(fn, new Transform$1(), { hasReturnStatement: false });
}
let Transform$1 = class Transform extends ReactiveFunctionTransform {
  visitTerminal(stmt, state) {
    this.traverseTerminal(stmt, state);
    if (stmt.terminal.kind === "return") {
      state.hasReturnStatement = true;
    }
  }
  transformScope(scopeBlock, _state) {
    const scopeState = { hasReturnStatement: false };
    this.visitScope(scopeBlock, scopeState);
    if (
      !scopeState.hasReturnStatement &&
      scopeBlock.scope.reassignments.size === 0 &&
      (scopeBlock.scope.declarations.size === 0 ||
        !hasOwnDeclaration(scopeBlock))
    ) {
      return {
        kind: "replace",
        value: {
          kind: "pruned-scope",
          scope: scopeBlock.scope,
          instructions: scopeBlock.instructions,
        },
      };
    } else {
      return { kind: "keep" };
    }
  }
};
function hasOwnDeclaration(block) {
  for (const declaration of block.scope.declarations.values()) {
    if (declaration.scope.id === block.scope.id) {
      return true;
    }
  }
  return false;
}
function collectReferencedGlobals(fn) {
  const identifiers = new Set();
  visitReactiveFunction(fn, new Visitor$3(), identifiers);
  return identifiers;
}
let Visitor$3 = class Visitor extends ReactiveFunctionVisitor {
  visitValue(id, value, state) {
    this.traverseValue(id, value, state);
    if (value.kind === "FunctionExpression" || value.kind === "ObjectMethod") {
      this.visitHirFunction(value.loweredFunc.func, state);
    } else if (value.kind === "LoadGlobal") {
      state.add(value.binding.name);
    }
  }
  visitReactiveFunctionValue(_id, _dependencies, fn, state) {
    visitReactiveFunction(fn, this, state);
  }
};
var _Scopes_instances,
  _Scopes_seen,
  _Scopes_stack,
  _Scopes_globals,
  _Scopes_lookup;
function renameVariables(fn) {
  const globals = collectReferencedGlobals(fn);
  const scopes = new Scopes(globals);
  renameVariablesImpl(fn, new Visitor$2(), scopes);
  return new Set([...scopes.names, ...globals]);
}
function renameVariablesImpl(fn, visitor, scopes) {
  scopes.enter(() => {
    for (const param of fn.params) {
      if (param.kind === "Identifier") {
        scopes.visit(param.identifier);
      } else {
        scopes.visit(param.place.identifier);
      }
    }
    visitReactiveFunction(fn, visitor, scopes);
  });
}
let Visitor$2 = class Visitor extends ReactiveFunctionVisitor {
  visitParam(place, state) {
    state.visit(place.identifier);
  }
  visitLValue(_id, lvalue, state) {
    state.visit(lvalue.identifier);
  }
  visitPlace(id, place, state) {
    state.visit(place.identifier);
  }
  visitBlock(block, state) {
    state.enter(() => {
      this.traverseBlock(block, state);
    });
  }
  visitPrunedScope(scopeBlock, state) {
    this.traverseBlock(scopeBlock.instructions, state);
  }
  visitScope(scope, state) {
    for (const [_, declaration] of scope.scope.declarations) {
      state.visit(declaration.identifier);
    }
    this.traverseScope(scope, state);
  }
  visitValue(id, value, state) {
    this.traverseValue(id, value, state);
    if (value.kind === "FunctionExpression" || value.kind === "ObjectMethod") {
      this.visitHirFunction(value.loweredFunc.func, state);
    }
  }
  visitReactiveFunctionValue(_id, _dependencies, _fn, _state) {
    renameVariablesImpl(_fn, this, _state);
  }
};
class Scopes {
  constructor(globals) {
    _Scopes_instances.add(this);
    _Scopes_seen.set(this, new Map());
    _Scopes_stack.set(this, [new Map()]);
    _Scopes_globals.set(this, void 0);
    this.names = new Set();
    __classPrivateFieldSet(this, _Scopes_globals, globals, "f");
  }
  visit(identifier) {
    const originalName = identifier.name;
    if (originalName === null) {
      return;
    }
    const mappedName = __classPrivateFieldGet(this, _Scopes_seen, "f").get(
      identifier.id
    );
    if (mappedName !== undefined) {
      identifier.name = mappedName;
      return;
    }
    let name = originalName.value;
    let id = 0;
    if (isPromotedTemporary(originalName.value)) {
      name = `t${id++}`;
    } else if (isPromotedJsxTemporary(originalName.value)) {
      name = `T${id++}`;
    }
    while (
      __classPrivateFieldGet(this, _Scopes_instances, "m", _Scopes_lookup).call(
        this,
        name
      ) !== null ||
      __classPrivateFieldGet(this, _Scopes_globals, "f").has(name)
    ) {
      if (isPromotedTemporary(originalName.value)) {
        name = `t${id++}`;
      } else if (isPromotedJsxTemporary(originalName.value)) {
        name = `T${id++}`;
      } else {
        name = `${originalName.value}$${id++}`;
      }
    }
    const identifierName = makeIdentifierName(name);
    identifier.name = identifierName;
    __classPrivateFieldGet(this, _Scopes_seen, "f").set(
      identifier.id,
      identifierName
    );
    __classPrivateFieldGet(this, _Scopes_stack, "f")
      .at(-1)
      .set(identifierName.value, identifier.id);
    this.names.add(identifierName.value);
  }
  enter(fn) {
    const next = new Map();
    __classPrivateFieldGet(this, _Scopes_stack, "f").push(next);
    fn();
    const last = __classPrivateFieldGet(this, _Scopes_stack, "f").pop();
    CompilerError.invariant(last === next, {
      reason: "Mismatch push/pop calls",
      description: null,
      loc: null,
      suggestions: null,
    });
  }
}
(_Scopes_seen = new WeakMap()),
  (_Scopes_stack = new WeakMap()),
  (_Scopes_globals = new WeakMap()),
  (_Scopes_instances = new WeakSet()),
  (_Scopes_lookup = function _Scopes_lookup(name) {
    for (
      let i = __classPrivateFieldGet(this, _Scopes_stack, "f").length - 1;
      i >= 0;
      i--
    ) {
      const scope = __classPrivateFieldGet(this, _Scopes_stack, "f")[i];
      const entry = scope.get(name);
      if (entry !== undefined) {
        return entry;
      }
    }
    return null;
  });
function stabilizeBlockIds(fn) {
  const referenced = new Set();
  visitReactiveFunction(fn, new CollectReferencedLabels(), referenced);
  const mappings = new Map();
  for (const blockId of referenced) {
    mappings.set(blockId, makeBlockId(mappings.size));
  }
  visitReactiveFunction(fn, new RewriteBlockIds(), mappings);
}
class CollectReferencedLabels extends ReactiveFunctionVisitor {
  visitScope(scope, state) {
    const { earlyReturnValue: earlyReturnValue } = scope.scope;
    if (earlyReturnValue != null) {
      state.add(earlyReturnValue.label);
    }
    this.traverseScope(scope, state);
  }
  visitTerminal(stmt, state) {
    if (stmt.label != null) {
      if (!stmt.label.implicit) {
        state.add(stmt.label.id);
      }
    }
    this.traverseTerminal(stmt, state);
  }
}
class RewriteBlockIds extends ReactiveFunctionVisitor {
  visitScope(scope, state) {
    const { earlyReturnValue: earlyReturnValue } = scope.scope;
    if (earlyReturnValue != null) {
      const rewrittenId = getOrInsertDefault(
        state,
        earlyReturnValue.label,
        state.size
      );
      earlyReturnValue.label = makeBlockId(rewrittenId);
    }
    this.traverseScope(scope, state);
  }
  visitTerminal(stmt, state) {
    if (stmt.label != null) {
      const rewrittenId = getOrInsertDefault(state, stmt.label.id, state.size);
      stmt.label.id = makeBlockId(rewrittenId);
    }
    const terminal = stmt.terminal;
    if (terminal.kind === "break" || terminal.kind === "continue") {
      const rewrittenId = getOrInsertDefault(
        state,
        terminal.target,
        state.size
      );
      terminal.target = makeBlockId(rewrittenId);
    }
    this.traverseTerminal(stmt, state);
  }
}
function logDebug(step, value) {}
function logCodegenFunction(step, fn) {}
function logHIRFunction(step, fn) {}
function logReactiveFunction(step, fn) {}
function inferReactiveScopeVariables(fn) {
  const scopeIdentifiers = findDisjointMutableValues(fn);
  const scopes = new Map();
  scopeIdentifiers.forEach((identifier, groupIdentifier) => {
    let scope = scopes.get(groupIdentifier);
    if (scope === undefined) {
      scope = {
        id: fn.env.nextScopeId,
        range: identifier.mutableRange,
        dependencies: new Set(),
        declarations: new Map(),
        reassignments: new Set(),
        earlyReturnValue: null,
        merged: new Set(),
        loc: identifier.loc,
      };
      scopes.set(groupIdentifier, scope);
    } else {
      scope.range.start = makeInstructionId(
        Math.min(scope.range.start, identifier.mutableRange.start)
      );
      scope.range.end = makeInstructionId(
        Math.max(scope.range.end, identifier.mutableRange.end)
      );
      scope.loc = mergeLocation(scope.loc, identifier.loc);
    }
    identifier.scope = scope;
    identifier.mutableRange = scope.range;
  });
  let maxInstruction = 0;
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      maxInstruction = makeInstructionId(Math.max(maxInstruction, instr.id));
    }
    maxInstruction = makeInstructionId(
      Math.max(maxInstruction, block.terminal.id)
    );
  }
  for (const [, scope] of scopes) {
    if (
      scope.range.start === 0 ||
      scope.range.end === 0 ||
      maxInstruction === 0 ||
      scope.range.end > maxInstruction + 1
    ) {
      CompilerError.invariant(false, {
        reason: `Invalid mutable range for scope`,
        loc: GeneratedSource,
        description: `Scope @${scope.id} has range [${scope.range.start}:${scope.range.end}] but the valid range is [1:${maxInstruction + 1}]`,
      });
    }
  }
}
function mergeLocation(l, r) {
  if (l === GeneratedSource) {
    return r;
  } else if (r === GeneratedSource) {
    return l;
  } else {
    return {
      start: {
        line: Math.min(l.start.line, r.start.line),
        column: Math.min(l.start.column, r.start.column),
      },
      end: {
        line: Math.max(l.end.line, r.end.line),
        column: Math.max(l.end.column, r.end.column),
      },
    };
  }
}
function isMutable({ id: id }, place) {
  const range = place.identifier.mutableRange;
  return id >= range.start && id < range.end;
}
function mayAllocate(env, instruction) {
  const { value: value } = instruction;
  switch (value.kind) {
    case "Destructure": {
      return doesPatternContainSpreadElement(value.lvalue.pattern);
    }
    case "PostfixUpdate":
    case "PrefixUpdate":
    case "Await":
    case "DeclareLocal":
    case "DeclareContext":
    case "StoreLocal":
    case "LoadGlobal":
    case "MetaProperty":
    case "TypeCastExpression":
    case "LoadLocal":
    case "LoadContext":
    case "StoreContext":
    case "PropertyDelete":
    case "ComputedLoad":
    case "ComputedDelete":
    case "JSXText":
    case "TemplateLiteral":
    case "Primitive":
    case "GetIterator":
    case "IteratorNext":
    case "NextPropertyOf":
    case "Debugger":
    case "StartMemoize":
    case "FinishMemoize":
    case "UnaryExpression":
    case "BinaryExpression":
    case "PropertyLoad":
    case "StoreGlobal": {
      return false;
    }
    case "CallExpression":
    case "MethodCall": {
      return instruction.lvalue.identifier.type.kind !== "Primitive";
    }
    case "RegExpLiteral":
    case "PropertyStore":
    case "ComputedStore":
    case "ArrayExpression":
    case "JsxExpression":
    case "JsxFragment":
    case "NewExpression":
    case "ObjectExpression":
    case "UnsupportedNode":
    case "ObjectMethod":
    case "FunctionExpression":
    case "TaggedTemplateExpression": {
      return true;
    }
    default: {
      assertExhaustive$1(value, `Unexpected value kind \`${value.kind}\``);
    }
  }
}
function findDisjointMutableValues(fn) {
  var _a, _b;
  const scopeIdentifiers = new DisjointSet();
  for (const [_, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      if (
        phi.id.mutableRange.start + 1 !== phi.id.mutableRange.end &&
        phi.id.mutableRange.end >
          ((_b =
            (_a = block.instructions.at(0)) === null || _a === void 0
              ? void 0
              : _a.id) !== null && _b !== void 0
            ? _b
            : block.terminal.id)
      ) {
        for (const [, phiId] of phi.operands) {
          scopeIdentifiers.union([phi.id, phiId]);
        }
      } else if (fn.env.config.enableForest) {
        for (const [, phiId] of phi.operands) {
          scopeIdentifiers.union([phi.id, phiId]);
        }
      }
    }
    for (const instr of block.instructions) {
      const operands = [];
      const range = instr.lvalue.identifier.mutableRange;
      if (range.end > range.start + 1 || mayAllocate(fn.env, instr)) {
        operands.push(instr.lvalue.identifier);
      }
      if (
        instr.value.kind === "StoreLocal" ||
        instr.value.kind === "StoreContext"
      ) {
        if (
          instr.value.lvalue.place.identifier.mutableRange.end >
          instr.value.lvalue.place.identifier.mutableRange.start + 1
        ) {
          operands.push(instr.value.lvalue.place.identifier);
        }
        if (
          isMutable(instr, instr.value.value) &&
          instr.value.value.identifier.mutableRange.start > 0
        ) {
          operands.push(instr.value.value.identifier);
        }
      } else if (instr.value.kind === "Destructure") {
        for (const place of eachPatternOperand(instr.value.lvalue.pattern)) {
          if (
            place.identifier.mutableRange.end >
            place.identifier.mutableRange.start + 1
          ) {
            operands.push(place.identifier);
          }
        }
        if (
          isMutable(instr, instr.value.value) &&
          instr.value.value.identifier.mutableRange.start > 0
        ) {
          operands.push(instr.value.value.identifier);
        }
      } else if (instr.value.kind === "MethodCall") {
        for (const operand of eachInstructionOperand(instr)) {
          if (
            isMutable(instr, operand) &&
            operand.identifier.mutableRange.start > 0
          ) {
            operands.push(operand.identifier);
          }
        }
        operands.push(instr.value.property.identifier);
      } else {
        for (const operand of eachInstructionOperand(instr)) {
          if (
            isMutable(instr, operand) &&
            operand.identifier.mutableRange.start > 0
          ) {
            operands.push(operand.identifier);
          }
        }
      }
      if (operands.length !== 0) {
        scopeIdentifiers.union(operands);
      }
    }
  }
  return scopeIdentifiers;
}
function mergeOverlappingReactiveScopesHIR(fn) {
  const scopesInfo = collectScopeInfo(fn);
  const joinedScopes = getOverlappingReactiveScopes(fn, scopesInfo);
  joinedScopes.forEach((scope, groupScope) => {
    if (scope !== groupScope) {
      groupScope.range.start = makeInstructionId(
        Math.min(groupScope.range.start, scope.range.start)
      );
      groupScope.range.end = makeInstructionId(
        Math.max(groupScope.range.end, scope.range.end)
      );
    }
  });
  for (const [place, originalScope] of scopesInfo.placeScopes) {
    const nextScope = joinedScopes.find(originalScope);
    if (nextScope !== null && nextScope !== originalScope) {
      place.identifier.scope = nextScope;
    }
  }
}
function collectScopeInfo(fn) {
  const scopeStarts = new Map();
  const scopeEnds = new Map();
  const placeScopes = new Map();
  function collectPlaceScope(place) {
    const scope = place.identifier.scope;
    if (scope != null) {
      placeScopes.set(place, scope);
      if (scope.range.start !== scope.range.end) {
        getOrInsertDefault(scopeStarts, scope.range.start, new Set()).add(
          scope
        );
        getOrInsertDefault(scopeEnds, scope.range.end, new Set()).add(scope);
      }
    }
  }
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      for (const operand of eachInstructionLValue(instr)) {
        collectPlaceScope(operand);
      }
      for (const operand of eachInstructionOperand(instr)) {
        collectPlaceScope(operand);
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      collectPlaceScope(operand);
    }
  }
  return {
    scopeStarts: [...scopeStarts.entries()]
      .map(([id, scopes]) => ({ id: id, scopes: scopes }))
      .sort((a, b) => b.id - a.id),
    scopeEnds: [...scopeEnds.entries()]
      .map(([id, scopes]) => ({ id: id, scopes: scopes }))
      .sort((a, b) => b.id - a.id),
    placeScopes: placeScopes,
  };
}
function visitInstructionId(
  id,
  { scopeEnds: scopeEnds, scopeStarts: scopeStarts },
  { activeScopes: activeScopes, joined: joined }
) {
  const scopeEndTop = scopeEnds.at(-1);
  if (scopeEndTop != null && scopeEndTop.id <= id) {
    scopeEnds.pop();
    const scopesSortedStartDescending = [...scopeEndTop.scopes].sort(
      (a, b) => b.range.start - a.range.start
    );
    for (const scope of scopesSortedStartDescending) {
      const idx = activeScopes.indexOf(scope);
      if (idx !== -1) {
        if (idx !== activeScopes.length - 1) {
          joined.union([scope, ...activeScopes.slice(idx + 1)]);
        }
        activeScopes.splice(idx, 1);
      }
    }
  }
  const scopeStartTop = scopeStarts.at(-1);
  if (scopeStartTop != null && scopeStartTop.id <= id) {
    scopeStarts.pop();
    const scopesSortedEndDescending = [...scopeStartTop.scopes].sort(
      (a, b) => b.range.end - a.range.end
    );
    activeScopes.push(...scopesSortedEndDescending);
    for (let i = 1; i < scopesSortedEndDescending.length; i++) {
      const prev = scopesSortedEndDescending[i - 1];
      const curr = scopesSortedEndDescending[i];
      if (prev.range.end === curr.range.end) {
        joined.union([prev, curr]);
      }
    }
  }
}
function visitPlace(id, place, { activeScopes: activeScopes, joined: joined }) {
  const placeScope = getPlaceScope(id, place);
  if (placeScope != null && isMutable({ id: id }, place)) {
    const placeScopeIdx = activeScopes.indexOf(placeScope);
    if (placeScopeIdx !== -1 && placeScopeIdx !== activeScopes.length - 1) {
      joined.union([placeScope, ...activeScopes.slice(placeScopeIdx + 1)]);
    }
  }
}
function getOverlappingReactiveScopes(fn, context) {
  const state = { joined: new DisjointSet(), activeScopes: [] };
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      visitInstructionId(instr.id, context, state);
      for (const place of eachInstructionOperand(instr)) {
        visitPlace(instr.id, place, state);
      }
      for (const place of eachInstructionLValue(instr)) {
        visitPlace(instr.id, place, state);
      }
    }
    visitInstructionId(block.terminal.id, context, state);
    for (const place of eachTerminalOperand(block.terminal)) {
      visitPlace(block.terminal.id, place, state);
    }
  }
  return state.joined;
}
function pruneUnusedLabelsHIR(fn) {
  var _a;
  const merged = [];
  const rewrites = new Map();
  for (const [blockId, block] of fn.body.blocks) {
    const terminal = block.terminal;
    if (terminal.kind === "label") {
      const { block: nextId, fallthrough: fallthroughId } = terminal;
      const next = fn.body.blocks.get(nextId);
      const fallthrough = fn.body.blocks.get(fallthroughId);
      if (
        next.terminal.kind === "goto" &&
        next.terminal.variant === GotoVariant.Break &&
        next.terminal.block === fallthroughId
      ) {
        if (next.kind === "block" && fallthrough.kind === "block") {
          merged.push({
            label: blockId,
            next: nextId,
            fallthrough: fallthroughId,
          });
        }
      }
    }
  }
  for (const {
    label: originalLabelId,
    next: nextId,
    fallthrough: fallthroughId,
  } of merged) {
    const labelId =
      (_a = rewrites.get(originalLabelId)) !== null && _a !== void 0
        ? _a
        : originalLabelId;
    const label = fn.body.blocks.get(labelId);
    const next = fn.body.blocks.get(nextId);
    const fallthrough = fn.body.blocks.get(fallthroughId);
    CompilerError.invariant(
      next.phis.size === 0 && fallthrough.phis.size === 0,
      {
        reason: "Unexpected phis when merging label blocks",
        loc: label.terminal.loc,
      }
    );
    CompilerError.invariant(
      next.preds.size === 1 &&
        fallthrough.preds.size === 1 &&
        next.preds.has(originalLabelId) &&
        fallthrough.preds.has(nextId),
      {
        reason: "Unexpected block predecessors when merging label blocks",
        loc: label.terminal.loc,
      }
    );
    label.instructions.push(...next.instructions, ...fallthrough.instructions);
    label.terminal = fallthrough.terminal;
    fn.body.blocks.delete(nextId);
    fn.body.blocks.delete(fallthroughId);
    rewrites.set(fallthroughId, labelId);
  }
}
function addImportsToProgram(path, importList) {
  const identifiers = new Set();
  const sortedImports = new Map();
  for (const {
    importSpecifierName: importSpecifierName,
    source: source,
  } of importList) {
    CompilerError.invariant(identifiers.has(importSpecifierName) === false, {
      reason: `Encountered conflicting import specifier for ${importSpecifierName} in Forget config.`,
      description: null,
      loc: GeneratedSource,
      suggestions: null,
    });
    CompilerError.invariant(
      path.scope.hasBinding(importSpecifierName) === false,
      {
        reason: `Encountered conflicting import specifiers for ${importSpecifierName} in generated program.`,
        description: null,
        loc: GeneratedSource,
        suggestions: null,
      }
    );
    identifiers.add(importSpecifierName);
    const importSpecifierNameList = getOrInsertDefault(
      sortedImports,
      source,
      []
    );
    importSpecifierNameList.push(importSpecifierName);
  }
  const stmts = [];
  for (const [source, importSpecifierNameList] of sortedImports) {
    const importSpecifiers = importSpecifierNameList.map((name) => {
      const id = libExports.identifier(name);
      return libExports.importSpecifier(id, id);
    });
    stmts.push(
      libExports.importDeclaration(
        importSpecifiers,
        libExports.stringLiteral(source)
      )
    );
  }
  path.unshiftContainer("body", stmts);
}
function isNonNamespacedImport(importDeclPath, moduleName) {
  return (
    importDeclPath.get("source").node.value === moduleName &&
    importDeclPath
      .get("specifiers")
      .every((specifier) => specifier.isImportSpecifier()) &&
    importDeclPath.node.importKind !== "type" &&
    importDeclPath.node.importKind !== "typeof"
  );
}
function hasExistingNonNamespacedImportOfModule(program, moduleName) {
  let hasExistingImport = false;
  program.traverse({
    ImportDeclaration(importDeclPath) {
      if (isNonNamespacedImport(importDeclPath, moduleName)) {
        hasExistingImport = true;
      }
    },
  });
  return hasExistingImport;
}
function addMemoCacheFunctionSpecifierToExistingImport(
  program,
  moduleName,
  identifierName
) {
  let didInsertUseMemoCache = false;
  program.traverse({
    ImportDeclaration(importDeclPath) {
      if (
        !didInsertUseMemoCache &&
        isNonNamespacedImport(importDeclPath, moduleName)
      ) {
        importDeclPath.pushContainer(
          "specifiers",
          libExports.importSpecifier(
            libExports.identifier(identifierName),
            libExports.identifier("c")
          )
        );
        didInsertUseMemoCache = true;
      }
    },
  });
  return didInsertUseMemoCache;
}
function updateMemoCacheFunctionImport(
  program,
  moduleName,
  useMemoCacheIdentifier
) {
  const hasExistingImport = hasExistingNonNamespacedImportOfModule(
    program,
    moduleName
  );
  if (hasExistingImport) {
    const didUpdateImport = addMemoCacheFunctionSpecifierToExistingImport(
      program,
      moduleName,
      useMemoCacheIdentifier
    );
    if (!didUpdateImport) {
      throw new Error(
        `Expected an ImportDeclaration of \`${moduleName}\` in order to update ImportSpecifiers with useMemoCache`
      );
    }
  } else {
    addMemoCacheFunctionImportDeclaration(
      program,
      moduleName,
      useMemoCacheIdentifier
    );
  }
}
function addMemoCacheFunctionImportDeclaration(program, moduleName, localName) {
  program.unshiftContainer(
    "body",
    libExports.importDeclaration(
      [
        libExports.importSpecifier(
          libExports.identifier(localName),
          libExports.identifier("c")
        ),
      ],
      libExports.stringLiteral(moduleName)
    )
  );
}
zod.z.enum(["all_errors", "critical_errors", "none"]);
zod.z.enum(["infer", "syntax", "annotation", "all"]);
const defaultOptions = {
  compilationMode: "infer",
  panicThreshold: "none",
  environment: {},
  logger: null,
  gating: null,
  noEmit: false,
  runtimeModule: null,
  eslintSuppressionRules: null,
  flowSuppressions: false,
  ignoreUseNoForget: false,
  sources: (filename) => filename.indexOf("node_modules") === -1,
  enableReanimatedCheck: true,
};
function parsePluginOptions(obj) {
  if (obj == null || typeof obj !== "object") {
    return defaultOptions;
  }
  const parsedOptions = Object.create(null);
  for (let [key, value] of Object.entries(obj)) {
    if (typeof value === "string") {
      value = value.toLowerCase();
    }
    if (isCompilerFlag(key)) {
      parsedOptions[key] = value;
    }
  }
  return Object.assign(Object.assign({}, defaultOptions), parsedOptions);
}
function isCompilerFlag(s) {
  return hasOwnProperty(defaultOptions, s);
}
const DEFAULT_IDENTIFIER_INFO = {
  reassigned: false,
  reassignedByInnerFn: false,
  referencedByInnerFn: false,
};
const withFunctionScope = {
  enter: function (path, state) {
    state.currentFn.push(path);
  },
  exit: function (_, state) {
    state.currentFn.pop();
  },
};
function findContextIdentifiers(func) {
  const state = { currentFn: [], identifiers: new Map() };
  func.traverse(
    {
      FunctionDeclaration: withFunctionScope,
      FunctionExpression: withFunctionScope,
      ArrowFunctionExpression: withFunctionScope,
      ObjectMethod: withFunctionScope,
      AssignmentExpression(path, state) {
        var _a;
        const left = path.get("left");
        const currentFn =
          (_a = state.currentFn.at(-1)) !== null && _a !== void 0 ? _a : null;
        handleAssignment(currentFn, state.identifiers, left);
      },
      UpdateExpression(path, state) {
        var _a;
        const argument = path.get("argument");
        const currentFn =
          (_a = state.currentFn.at(-1)) !== null && _a !== void 0 ? _a : null;
        if (argument.isLVal()) {
          handleAssignment(currentFn, state.identifiers, argument);
        }
      },
      Identifier(path, state) {
        var _a;
        const currentFn =
          (_a = state.currentFn.at(-1)) !== null && _a !== void 0 ? _a : null;
        if (path.isReferencedIdentifier()) {
          handleIdentifier(currentFn, state.identifiers, path);
        }
      },
    },
    state
  );
  const result = new Set();
  for (const [id, info] of state.identifiers.entries()) {
    if (info.reassignedByInnerFn) {
      result.add(id);
    } else if (info.reassigned && info.referencedByInnerFn) {
      result.add(id);
    }
  }
  return result;
}
function handleIdentifier(currentFn, identifiers, path) {
  const name = path.node.name;
  const binding = path.scope.getBinding(name);
  if (binding == null) {
    return;
  }
  const identifier = getOrInsertDefault(
    identifiers,
    binding.identifier,
    Object.assign({}, DEFAULT_IDENTIFIER_INFO)
  );
  if (currentFn != null) {
    const bindingAboveLambdaScope = currentFn.scope.parent.getBinding(name);
    if (binding === bindingAboveLambdaScope) {
      identifier.referencedByInnerFn = true;
    }
  }
}
function handleAssignment(currentFn, identifiers, lvalPath) {
  var _a, _b, _c;
  const lvalNode = lvalPath.node;
  switch (lvalNode.type) {
    case "Identifier": {
      const path = lvalPath;
      const name = path.node.name;
      const binding = path.scope.getBinding(name);
      if (binding == null) {
        break;
      }
      const state = getOrInsertDefault(
        identifiers,
        binding.identifier,
        Object.assign({}, DEFAULT_IDENTIFIER_INFO)
      );
      state.reassigned = true;
      if (currentFn != null) {
        const bindingAboveLambdaScope = currentFn.scope.parent.getBinding(name);
        if (binding === bindingAboveLambdaScope) {
          state.reassignedByInnerFn = true;
        }
      }
      break;
    }
    case "ArrayPattern": {
      const path = lvalPath;
      for (const element of path.get("elements")) {
        if (nonNull(element)) {
          handleAssignment(currentFn, identifiers, element);
        }
      }
      break;
    }
    case "ObjectPattern": {
      const path = lvalPath;
      for (const property of path.get("properties")) {
        if (property.isObjectProperty()) {
          const valuePath = property.get("value");
          CompilerError.invariant(valuePath.isLVal(), {
            reason: `[FindContextIdentifiers] Expected object property value to be an LVal, got: ${valuePath.type}`,
            description: null,
            loc:
              (_a = valuePath.node.loc) !== null && _a !== void 0
                ? _a
                : GeneratedSource,
            suggestions: null,
          });
          handleAssignment(currentFn, identifiers, valuePath);
        } else {
          CompilerError.invariant(property.isRestElement(), {
            reason: `[FindContextIdentifiers] Invalid assumptions for babel types.`,
            description: null,
            loc:
              (_b = property.node.loc) !== null && _b !== void 0
                ? _b
                : GeneratedSource,
            suggestions: null,
          });
          handleAssignment(currentFn, identifiers, property);
        }
      }
      break;
    }
    case "AssignmentPattern": {
      const path = lvalPath;
      const left = path.get("left");
      handleAssignment(currentFn, identifiers, left);
      break;
    }
    case "RestElement": {
      const path = lvalPath;
      handleAssignment(currentFn, identifiers, path.get("argument"));
      break;
    }
    case "MemberExpression": {
      break;
    }
    default: {
      CompilerError.throwTodo({
        reason: `[FindContextIdentifiers] Cannot handle Object destructuring assignment target ${lvalNode.type}`,
        description: null,
        loc:
          (_c = lvalNode.loc) !== null && _c !== void 0 ? _c : GeneratedSource,
        suggestions: null,
      });
    }
  }
}
function nonNull(t) {
  return t.node != null;
}
function eliminateRedundantPhi(fn, sharedRewrites) {
  const ir = fn.body;
  const rewrites = sharedRewrites != null ? sharedRewrites : new Map();
  let hasBackEdge = false;
  const visited = new Set();
  let size = rewrites.size;
  do {
    size = rewrites.size;
    for (const [blockId, block] of ir.blocks) {
      if (!hasBackEdge) {
        for (const predId of block.preds) {
          if (!visited.has(predId)) {
            hasBackEdge = true;
          }
        }
      }
      visited.add(blockId);
      phis: for (const phi of block.phis) {
        phi.operands = new Map(
          Array.from(phi.operands).map(([block, id]) => {
            var _a;
            return [
              block,
              (_a = rewrites.get(id)) !== null && _a !== void 0 ? _a : id,
            ];
          })
        );
        let same = null;
        for (const [_, operand] of phi.operands) {
          if (
            (same !== null && operand.id === same.id) ||
            operand.id === phi.id.id
          ) {
            continue;
          } else if (same !== null) {
            continue phis;
          } else {
            same = operand;
          }
        }
        CompilerError.invariant(same !== null, {
          reason: "Expected phis to be non-empty",
          description: null,
          loc: null,
          suggestions: null,
        });
        rewrites.set(phi.id, same);
        block.phis.delete(phi);
      }
      for (const instr of block.instructions) {
        for (const place of eachInstructionLValue(instr)) {
          rewritePlace$1(place, rewrites);
        }
        for (const place of eachInstructionOperand(instr)) {
          rewritePlace$1(place, rewrites);
        }
        if (
          instr.value.kind === "FunctionExpression" ||
          instr.value.kind === "ObjectMethod"
        ) {
          const { context: context } = instr.value.loweredFunc.func;
          for (const place of context) {
            rewritePlace$1(place, rewrites);
          }
          eliminateRedundantPhi(instr.value.loweredFunc.func, rewrites);
        }
      }
      const { terminal: terminal } = block;
      for (const place of eachTerminalOperand(terminal)) {
        rewritePlace$1(place, rewrites);
      }
    }
  } while (rewrites.size > size && hasBackEdge);
}
function rewritePlace$1(place, rewrites) {
  const rewrite = rewrites.get(place.identifier);
  if (rewrite != null) {
    place.identifier = rewrite;
  }
}
var _SSABuilder_states,
  _SSABuilder_current,
  _SSABuilder_blocks,
  _SSABuilder_env,
  _SSABuilder_unknown,
  _SSABuilder_context;
class SSABuilder {
  constructor(env, blocks) {
    _SSABuilder_states.set(this, new Map());
    _SSABuilder_current.set(this, null);
    this.unsealedPreds = new Map();
    _SSABuilder_blocks.set(this, void 0);
    _SSABuilder_env.set(this, void 0);
    _SSABuilder_unknown.set(this, new Set());
    _SSABuilder_context.set(this, new Set());
    __classPrivateFieldSet(this, _SSABuilder_blocks, new Map(blocks), "f");
    __classPrivateFieldSet(this, _SSABuilder_env, env, "f");
  }
  get nextSsaId() {
    return __classPrivateFieldGet(this, _SSABuilder_env, "f").nextIdentifierId;
  }
  defineFunction(func) {
    for (const [id, block] of func.body.blocks) {
      __classPrivateFieldGet(this, _SSABuilder_blocks, "f").set(id, block);
    }
  }
  enter(fn) {
    const current = __classPrivateFieldGet(this, _SSABuilder_current, "f");
    fn();
    __classPrivateFieldSet(this, _SSABuilder_current, current, "f");
  }
  state() {
    CompilerError.invariant(
      __classPrivateFieldGet(this, _SSABuilder_current, "f") !== null,
      {
        reason: "we need to be in a block to access state!",
        description: null,
        loc: null,
        suggestions: null,
      }
    );
    return __classPrivateFieldGet(this, _SSABuilder_states, "f").get(
      __classPrivateFieldGet(this, _SSABuilder_current, "f")
    );
  }
  makeId(oldId) {
    return {
      id: this.nextSsaId,
      name: oldId.name,
      mutableRange: { start: makeInstructionId(0), end: makeInstructionId(0) },
      scope: null,
      type: makeType(),
      loc: oldId.loc,
    };
  }
  defineContext(oldPlace) {
    const newPlace = this.definePlace(oldPlace);
    __classPrivateFieldGet(this, _SSABuilder_context, "f").add(
      oldPlace.identifier
    );
    return newPlace;
  }
  definePlace(oldPlace) {
    const oldId = oldPlace.identifier;
    if (__classPrivateFieldGet(this, _SSABuilder_unknown, "f").has(oldId)) {
      CompilerError.throwTodo({
        reason: `[hoisting] EnterSSA: Expected identifier to be defined before being used`,
        description: `Identifier ${printIdentifier(oldId)} is undefined`,
        loc: oldPlace.loc,
        suggestions: null,
      });
    }
    if (__classPrivateFieldGet(this, _SSABuilder_context, "f").has(oldId)) {
      return this.getPlace(oldPlace);
    }
    const newId = this.makeId(oldId);
    this.state().defs.set(oldId, newId);
    return Object.assign(Object.assign({}, oldPlace), { identifier: newId });
  }
  getPlace(oldPlace) {
    const newId = this.getIdAt(
      oldPlace.identifier,
      __classPrivateFieldGet(this, _SSABuilder_current, "f").id
    );
    return Object.assign(Object.assign({}, oldPlace), { identifier: newId });
  }
  getIdAt(oldId, blockId) {
    const block = __classPrivateFieldGet(this, _SSABuilder_blocks, "f").get(
      blockId
    );
    const state = __classPrivateFieldGet(this, _SSABuilder_states, "f").get(
      block
    );
    if (state.defs.has(oldId)) {
      return state.defs.get(oldId);
    }
    if (block.preds.size == 0) {
      __classPrivateFieldGet(this, _SSABuilder_unknown, "f").add(oldId);
      return oldId;
    }
    if (this.unsealedPreds.get(block) > 0) {
      const newId = this.makeId(oldId);
      state.incompletePhis.push({ oldId: oldId, newId: newId });
      state.defs.set(oldId, newId);
      return newId;
    }
    if (block.preds.size == 1) {
      const [pred] = block.preds;
      const newId = this.getIdAt(oldId, pred);
      state.defs.set(oldId, newId);
      return newId;
    }
    const newId = this.makeId(oldId);
    state.defs.set(oldId, newId);
    return this.addPhi(block, oldId, newId);
  }
  addPhi(block, oldId, newId) {
    const predDefs = new Map();
    for (const predBlockId of block.preds) {
      const predId = this.getIdAt(oldId, predBlockId);
      predDefs.set(predBlockId, predId);
    }
    const phi = {
      kind: "Phi",
      id: newId,
      operands: predDefs,
      type: makeType(),
    };
    block.phis.add(phi);
    return newId;
  }
  fixIncompletePhis(block) {
    const state = __classPrivateFieldGet(this, _SSABuilder_states, "f").get(
      block
    );
    for (const phi of state.incompletePhis) {
      this.addPhi(block, phi.oldId, phi.newId);
    }
  }
  startBlock(block) {
    __classPrivateFieldSet(this, _SSABuilder_current, block, "f");
    __classPrivateFieldGet(this, _SSABuilder_states, "f").set(block, {
      defs: new Map(),
      incompletePhis: [],
    });
  }
  print() {
    var _a;
    const text = [];
    for (const [block, state] of __classPrivateFieldGet(
      this,
      _SSABuilder_states,
      "f"
    )) {
      text.push(`bb${block.id}:`);
      for (const [oldId, newId] of state.defs) {
        text.push(`  $${printIdentifier(oldId)}: $${printIdentifier(newId)}`);
      }
      for (const incompletePhi of state.incompletePhis) {
        text.push(
          `  iphi $${printIdentifier(incompletePhi.newId)} = $${printIdentifier(incompletePhi.oldId)}`
        );
      }
    }
    text.push(
      `current block: bb${(_a = __classPrivateFieldGet(this, _SSABuilder_current, "f")) === null || _a === void 0 ? void 0 : _a.id}`
    );
    console.log(text.join("\n"));
  }
}
(_SSABuilder_states = new WeakMap()),
  (_SSABuilder_current = new WeakMap()),
  (_SSABuilder_blocks = new WeakMap()),
  (_SSABuilder_env = new WeakMap()),
  (_SSABuilder_unknown = new WeakMap()),
  (_SSABuilder_context = new WeakMap());
function enterSSA(func) {
  const builder = new SSABuilder(func.env, func.body.blocks);
  enterSSAImpl(func, builder, func.body.entry);
}
function enterSSAImpl(func, builder, rootEntry) {
  const visitedBlocks = new Set();
  for (const [blockId, block] of func.body.blocks) {
    CompilerError.invariant(!visitedBlocks.has(block), {
      reason: `found a cycle! visiting bb${block.id} again`,
      description: null,
      loc: null,
      suggestions: null,
    });
    visitedBlocks.add(block);
    builder.startBlock(block);
    if (blockId === rootEntry) {
      CompilerError.invariant(func.context.length === 0, {
        reason: `Expected function context to be empty for outer function declarations`,
        description: null,
        loc: func.loc,
        suggestions: null,
      });
      func.params = func.params.map((param) => {
        if (param.kind === "Identifier") {
          return builder.definePlace(param);
        } else {
          return { kind: "Spread", place: builder.definePlace(param.place) };
        }
      });
    }
    for (const instr of block.instructions) {
      mapInstructionOperands(instr, (place) => builder.getPlace(place));
      mapInstructionLValues(instr, (lvalue) => builder.definePlace(lvalue));
      if (
        instr.value.kind === "FunctionExpression" ||
        instr.value.kind === "ObjectMethod"
      ) {
        const loweredFunc = instr.value.loweredFunc.func;
        const entry = loweredFunc.body.blocks.get(loweredFunc.body.entry);
        CompilerError.invariant(entry.preds.size === 0, {
          reason:
            "Expected function expression entry block to have zero predecessors",
          description: null,
          loc: null,
          suggestions: null,
        });
        entry.preds.add(blockId);
        builder.defineFunction(loweredFunc);
        builder.enter(() => {
          loweredFunc.context = loweredFunc.context.map((p) =>
            builder.getPlace(p)
          );
          loweredFunc.params = loweredFunc.params.map((param) => {
            if (param.kind === "Identifier") {
              return builder.definePlace(param);
            } else {
              return {
                kind: "Spread",
                place: builder.definePlace(param.place),
              };
            }
          });
          enterSSAImpl(loweredFunc, builder, rootEntry);
        });
        entry.preds.clear();
      }
    }
    mapTerminalOperands(block.terminal, (place) => builder.getPlace(place));
    for (const outputId of eachTerminalSuccessor(block.terminal)) {
      const output = func.body.blocks.get(outputId);
      let count;
      if (builder.unsealedPreds.has(output)) {
        count = builder.unsealedPreds.get(output) - 1;
      } else {
        count = output.preds.size - 1;
      }
      builder.unsealedPreds.set(output, count);
      if (count === 0 && visitedBlocks.has(output)) {
        builder.fixIncompletePhis(output);
      }
    }
  }
}
function leaveSSA(fn) {
  var _a, _b, _c;
  const declarations = new Map();
  for (const param of fn.params) {
    let place = param.kind === "Identifier" ? param : param.place;
    if (place.identifier.name !== null) {
      declarations.set(place.identifier.name.value, {
        lvalue: { kind: InstructionKind.Let, place: place },
        place: place,
      });
    }
  }
  const rewrites = new Map();
  const seen = new Set();
  const backEdgePhis = new Set();
  for (const [, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      for (const [pred] of phi.operands) {
        if (!seen.has(pred)) {
          backEdgePhis.add(phi);
          break;
        }
      }
    }
    seen.add(block.id);
  }
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      const { lvalue: lvalue, value: value } = instr;
      if (value.kind === "DeclareLocal") {
        const name = value.lvalue.place.identifier.name;
        if (name !== null) {
          CompilerError.invariant(!declarations.has(name.value), {
            reason: `Unexpected duplicate declaration`,
            description: `Found duplicate declaration for \`${name.value}\``,
            loc: value.lvalue.place.loc,
            suggestions: null,
          });
          declarations.set(name.value, {
            lvalue: value.lvalue,
            place: value.lvalue.place,
          });
        }
      } else if (
        value.kind === "PrefixUpdate" ||
        value.kind === "PostfixUpdate"
      ) {
        CompilerError.invariant(value.lvalue.identifier.name !== null, {
          reason: `Expected update expression to be applied to a named variable`,
          description: null,
          loc: value.lvalue.loc,
          suggestions: null,
        });
        const originalLVal = declarations.get(
          value.lvalue.identifier.name.value
        );
        CompilerError.invariant(originalLVal !== undefined, {
          reason: `Expected update expression to be applied to a previously defined variable`,
          description: null,
          loc: value.lvalue.loc,
          suggestions: null,
        });
        originalLVal.lvalue.kind = InstructionKind.Let;
      } else if (value.kind === "StoreLocal") {
        if (value.lvalue.place.identifier.name != null) {
          const originalLVal = declarations.get(
            value.lvalue.place.identifier.name.value
          );
          if (
            originalLVal === undefined ||
            originalLVal.lvalue === value.lvalue
          ) {
            CompilerError.invariant(
              originalLVal !== undefined ||
                block.kind === "block" ||
                block.kind === "catch",
              {
                reason: `TODO: Handle reassignment in a value block where the original declaration was removed by dead code elimination (DCE)`,
                description: null,
                loc: value.lvalue.place.loc,
                suggestions: null,
              }
            );
            declarations.set(value.lvalue.place.identifier.name.value, {
              lvalue: value.lvalue,
              place: value.lvalue.place,
            });
            value.lvalue.kind = InstructionKind.Const;
          } else {
            originalLVal.lvalue.kind = InstructionKind.Let;
            value.lvalue.kind = InstructionKind.Reassign;
          }
        } else if (rewrites.has(value.lvalue.place.identifier)) {
          value.lvalue.kind = InstructionKind.Const;
        }
      } else if (value.kind === "Destructure") {
        let kind = null;
        for (const place of eachPatternOperand(value.lvalue.pattern)) {
          if (place.identifier.name == null) {
            CompilerError.invariant(
              kind === null || kind === InstructionKind.Const,
              {
                reason: `Expected consistent kind for destructuring`,
                description: `other places were \`${kind}\` but '${printPlace(place)}' is const`,
                loc: place.loc,
                suggestions: null,
              }
            );
            kind = InstructionKind.Const;
          } else {
            const originalLVal = declarations.get(place.identifier.name.value);
            if (
              originalLVal === undefined ||
              originalLVal.lvalue === value.lvalue
            ) {
              CompilerError.invariant(
                originalLVal !== undefined || block.kind !== "value",
                {
                  reason: `TODO: Handle reassignment in a value block where the original declaration was removed by dead code elimination (DCE)`,
                  description: null,
                  loc: place.loc,
                  suggestions: null,
                }
              );
              declarations.set(place.identifier.name.value, {
                lvalue: value.lvalue,
                place: place,
              });
              CompilerError.invariant(
                kind === null || kind === InstructionKind.Const,
                {
                  reason: `Expected consistent kind for destructuring`,
                  description: `Other places were \`${kind}\` but '${printPlace(place)}' is const`,
                  loc: place.loc,
                  suggestions: null,
                }
              );
              kind = InstructionKind.Const;
            } else {
              CompilerError.invariant(
                kind === null || kind === InstructionKind.Reassign,
                {
                  reason: `Expected consistent kind for destructuring`,
                  description: `Other places were \`${kind}\` but '${printPlace(place)}' is reassigned`,
                  loc: place.loc,
                  suggestions: null,
                }
              );
              kind = InstructionKind.Reassign;
              originalLVal.lvalue.kind = InstructionKind.Let;
            }
          }
        }
        CompilerError.invariant(kind !== null, {
          reason: "Expected at least one operand",
          description: null,
          loc: null,
          suggestions: null,
        });
        value.lvalue.kind = kind;
      }
      rewritePlace(lvalue, rewrites, declarations);
      for (const operand of eachInstructionLValue(instr)) {
        rewritePlace(operand, rewrites, declarations);
      }
      for (const operand of eachInstructionValueOperand(instr.value)) {
        rewritePlace(operand, rewrites, declarations);
      }
    }
    const terminal = block.terminal;
    for (const operand of eachTerminalOperand(terminal)) {
      rewritePlace(operand, rewrites, declarations);
    }
    const reassignmentPhis = [];
    const rewritePhis = [];
    function pushPhis(phiBlock) {
      for (const phi of phiBlock.phis) {
        if (phi.id.name === null) {
          rewritePhis.push({ phi: phi, block: phiBlock });
        } else {
          reassignmentPhis.push({ phi: phi, block: phiBlock });
        }
      }
    }
    const fallthroughId = terminalFallthrough(terminal);
    if (fallthroughId !== null) {
      const fallthrough = fn.body.blocks.get(fallthroughId);
      pushPhis(fallthrough);
    }
    if (terminal.kind === "while" || terminal.kind === "for") {
      const test = fn.body.blocks.get(terminal.test);
      pushPhis(test);
      const loop = fn.body.blocks.get(terminal.loop);
      pushPhis(loop);
    }
    if (
      terminal.kind === "for" ||
      terminal.kind === "for-of" ||
      terminal.kind === "for-in"
    ) {
      let init = fn.body.blocks.get(terminal.init);
      pushPhis(init);
      let initContinuation =
        terminal.kind === "for" ? terminal.test : terminal.loop;
      const queue = [init.id];
      while (queue.length !== 0) {
        const blockId = queue.shift();
        if (blockId === initContinuation) {
          break;
        }
        const block = fn.body.blocks.get(blockId);
        for (const instr of block.instructions) {
          if (
            instr.value.kind === "StoreLocal" &&
            instr.value.lvalue.kind !== InstructionKind.Reassign
          ) {
            const value = instr.value;
            if (value.lvalue.place.identifier.name !== null) {
              const originalLVal = declarations.get(
                value.lvalue.place.identifier.name.value
              );
              if (originalLVal === undefined) {
                declarations.set(value.lvalue.place.identifier.name.value, {
                  lvalue: value.lvalue,
                  place: value.lvalue.place,
                });
                value.lvalue.kind = InstructionKind.Const;
              }
            }
          }
        }
        switch (block.terminal.kind) {
          case "maybe-throw": {
            queue.push(block.terminal.continuation);
            break;
          }
          case "goto": {
            queue.push(block.terminal.block);
            break;
          }
          case "branch":
          case "logical":
          case "optional":
          case "ternary":
          case "label": {
            for (const successor of eachTerminalSuccessor(block.terminal)) {
              queue.push(successor);
            }
            break;
          }
        }
      }
      if (terminal.kind === "for" && terminal.update !== null) {
        const update = fn.body.blocks.get(terminal.update);
        pushPhis(update);
      }
    }
    for (const { phi: phi, block: phiBlock } of reassignmentPhis) {
      for (const [, operand] of phi.operands) {
        if (operand.mutableRange.start < terminal.id);
      }
      const isPhiMutatedAfterCreation =
        phi.id.mutableRange.end >
        ((_b =
          (_a = phiBlock.instructions.at(0)) === null || _a === void 0
            ? void 0
            : _a.id) !== null && _b !== void 0
          ? _b
          : phiBlock.terminal.id);
      CompilerError.invariant(phi.id.name != null, {
        reason: "Expected reassignment phis to have a name",
        description: null,
        loc: null,
        suggestions: null,
      });
      const declaration = declarations.get(phi.id.name.value);
      CompilerError.invariant(declaration != null, {
        loc: null,
        reason: "Expected a declaration for all variables",
        description: `${printIdentifier(phi.id)} in block bb${phiBlock.id}`,
        suggestions: null,
      });
      if (isPhiMutatedAfterCreation) {
        declaration.place.identifier.mutableRange.end = phi.id.mutableRange.end;
      }
      rewrites.set(phi.id, declaration.place.identifier);
    }
    for (const { phi: phi } of rewritePhis) {
      let canonicalId = rewrites.get(phi.id);
      if (canonicalId === undefined) {
        canonicalId = phi.id;
        for (const [, operand] of phi.operands) {
          let canonicalOperand =
            (_c = rewrites.get(operand)) !== null && _c !== void 0
              ? _c
              : operand;
          if (canonicalOperand.id < canonicalId.id) {
            canonicalId = canonicalOperand;
          }
        }
        rewrites.set(phi.id, canonicalId);
        if (canonicalId.name !== null) {
          const declaration = declarations.get(canonicalId.name.value);
          if (declaration !== undefined) {
            declaration.lvalue.kind = InstructionKind.Let;
          }
        }
      }
      for (const [, operand] of phi.operands) {
        rewrites.set(operand, canonicalId);
      }
    }
  }
}
function rewritePlace(place, rewrites, declarations) {
  const prevIdentifier = place.identifier;
  const nextIdentifier = rewrites.get(prevIdentifier);
  if (nextIdentifier !== undefined) {
    if (nextIdentifier === prevIdentifier) return;
    place.identifier = nextIdentifier;
  } else if (prevIdentifier.name != null) {
    const declaration = declarations.get(prevIdentifier.name.value);
    if (declaration === undefined) return;
    const originalIdentifier = declaration.place.identifier;
    prevIdentifier.id = originalIdentifier.id;
  }
}
function constantPropagation(fn) {
  const constants = new Map();
  constantPropagationImpl(fn, constants);
}
function constantPropagationImpl(fn, constants) {
  while (true) {
    const haveTerminalsChanged = applyConstantPropagation(fn, constants);
    if (!haveTerminalsChanged) {
      break;
    }
    reversePostorderBlocks(fn.body);
    removeUnreachableForUpdates(fn.body);
    removeDeadDoWhileStatements(fn.body);
    removeUnnecessaryTryCatch(fn.body);
    markInstructionIds(fn.body);
    markPredecessors(fn.body);
    for (const [, block] of fn.body.blocks) {
      for (const phi of block.phis) {
        for (const [predecessor] of phi.operands) {
          if (!block.preds.has(predecessor)) {
            phi.operands.delete(predecessor);
          }
        }
      }
    }
    eliminateRedundantPhi(fn);
    mergeConsecutiveBlocks(fn);
    assertConsistentIdentifiers(fn);
    assertTerminalSuccessorsExist(fn);
  }
}
function applyConstantPropagation(fn, constants) {
  let hasChanges = false;
  for (const [, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      let value = evaluatePhi(phi, constants);
      if (value !== null) {
        constants.set(phi.id.id, value);
      }
    }
    for (let i = 0; i < block.instructions.length; i++) {
      if (block.kind === "sequence" && i === block.instructions.length - 1) {
        continue;
      }
      const instr = block.instructions[i];
      const value = evaluateInstruction(fn.env, constants, instr);
      if (value !== null) {
        constants.set(instr.lvalue.identifier.id, value);
      }
    }
    const terminal = block.terminal;
    switch (terminal.kind) {
      case "if": {
        const testValue = read(constants, terminal.test);
        if (testValue !== null && testValue.kind === "Primitive") {
          hasChanges = true;
          const targetBlockId = testValue.value
            ? terminal.consequent
            : terminal.alternate;
          block.terminal = {
            kind: "goto",
            variant: GotoVariant.Break,
            block: targetBlockId,
            id: terminal.id,
            loc: terminal.loc,
          };
        }
        break;
      }
    }
  }
  return hasChanges;
}
function evaluatePhi(phi, constants) {
  var _a;
  let value = null;
  for (const [, operand] of phi.operands) {
    const operandValue =
      (_a = constants.get(operand.id)) !== null && _a !== void 0 ? _a : null;
    if (operandValue === null) {
      return null;
    }
    if (value === null) {
      value = operandValue;
      continue;
    }
    if (operandValue.kind !== value.kind) {
      return null;
    }
    switch (operandValue.kind) {
      case "Primitive": {
        CompilerError.invariant(value.kind === "Primitive", {
          reason: "value kind expected to be Primitive",
          loc: null,
          suggestions: null,
        });
        if (operandValue.value !== value.value) {
          return null;
        }
        break;
      }
      case "LoadGlobal": {
        CompilerError.invariant(value.kind === "LoadGlobal", {
          reason: "value kind expected to be LoadGlobal",
          loc: null,
          suggestions: null,
        });
        if (operandValue.binding.name !== value.binding.name) {
          return null;
        }
        break;
      }
      default:
        return null;
    }
  }
  return value;
}
function evaluateInstruction(env, constants, instr) {
  const value = instr.value;
  switch (value.kind) {
    case "Primitive": {
      return value;
    }
    case "LoadGlobal": {
      return value;
    }
    case "ComputedLoad": {
      const property = read(constants, value.property);
      if (
        property !== null &&
        property.kind === "Primitive" &&
        typeof property.value === "string" &&
        libExports.isValidIdentifier(property.value)
      ) {
        const nextValue = {
          kind: "PropertyLoad",
          loc: value.loc,
          property: property.value,
          object: value.object,
        };
        instr.value = nextValue;
      }
      return null;
    }
    case "ComputedStore": {
      const property = read(constants, value.property);
      if (
        property !== null &&
        property.kind === "Primitive" &&
        typeof property.value === "string" &&
        libExports.isValidIdentifier(property.value)
      ) {
        const nextValue = {
          kind: "PropertyStore",
          loc: value.loc,
          property: property.value,
          object: value.object,
          value: value.value,
        };
        instr.value = nextValue;
      }
      return null;
    }
    case "PostfixUpdate": {
      const previous = read(constants, value.value);
      if (
        previous !== null &&
        previous.kind === "Primitive" &&
        typeof previous.value === "number"
      ) {
        const next =
          value.operation === "++" ? previous.value + 1 : previous.value - 1;
        constants.set(value.lvalue.identifier.id, {
          kind: "Primitive",
          value: next,
          loc: value.loc,
        });
        return previous;
      }
      return null;
    }
    case "PrefixUpdate": {
      const previous = read(constants, value.value);
      if (
        previous !== null &&
        previous.kind === "Primitive" &&
        typeof previous.value === "number"
      ) {
        const next = {
          kind: "Primitive",
          value:
            value.operation === "++" ? previous.value + 1 : previous.value - 1,
          loc: value.loc,
        };
        constants.set(value.lvalue.identifier.id, next);
        return next;
      }
      return null;
    }
    case "UnaryExpression": {
      switch (value.operator) {
        case "!": {
          const operand = read(constants, value.value);
          if (operand !== null && operand.kind === "Primitive") {
            const result = {
              kind: "Primitive",
              value: !operand.value,
              loc: value.loc,
            };
            instr.value = result;
            return result;
          }
          return null;
        }
        default:
          return null;
      }
    }
    case "BinaryExpression": {
      const lhsValue = read(constants, value.left);
      const rhsValue = read(constants, value.right);
      if (
        lhsValue !== null &&
        rhsValue !== null &&
        lhsValue.kind === "Primitive" &&
        rhsValue.kind === "Primitive"
      ) {
        const lhs = lhsValue.value;
        const rhs = rhsValue.value;
        let result = null;
        switch (value.operator) {
          case "+": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs + rhs, loc: value.loc };
            } else if (typeof lhs === "string" && typeof rhs === "string") {
              result = { kind: "Primitive", value: lhs + rhs, loc: value.loc };
            }
            break;
          }
          case "-": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs - rhs, loc: value.loc };
            }
            break;
          }
          case "*": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs * rhs, loc: value.loc };
            }
            break;
          }
          case "/": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs / rhs, loc: value.loc };
            }
            break;
          }
          case "|": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs | rhs, loc: value.loc };
            }
            break;
          }
          case "&": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs & rhs, loc: value.loc };
            }
            break;
          }
          case "^": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs ^ rhs, loc: value.loc };
            }
            break;
          }
          case "<<": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs << rhs, loc: value.loc };
            }
            break;
          }
          case ">>": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs >> rhs, loc: value.loc };
            }
            break;
          }
          case ">>>": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = {
                kind: "Primitive",
                value: lhs >>> rhs,
                loc: value.loc,
              };
            }
            break;
          }
          case "%": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs % rhs, loc: value.loc };
            }
            break;
          }
          case "**": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = {
                kind: "Primitive",
                value: Math.pow(lhs, rhs),
                loc: value.loc,
              };
            }
            break;
          }
          case "<": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs < rhs, loc: value.loc };
            }
            break;
          }
          case "<=": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs <= rhs, loc: value.loc };
            }
            break;
          }
          case ">": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs > rhs, loc: value.loc };
            }
            break;
          }
          case ">=": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs >= rhs, loc: value.loc };
            }
            break;
          }
          case "==": {
            result = { kind: "Primitive", value: lhs == rhs, loc: value.loc };
            break;
          }
          case "===": {
            result = { kind: "Primitive", value: lhs === rhs, loc: value.loc };
            break;
          }
          case "!=": {
            result = { kind: "Primitive", value: lhs != rhs, loc: value.loc };
            break;
          }
          case "!==": {
            result = { kind: "Primitive", value: lhs !== rhs, loc: value.loc };
            break;
          }
        }
        if (result !== null) {
          instr.value = result;
          return result;
        }
      }
      return null;
    }
    case "PropertyLoad": {
      const objectValue = read(constants, value.object);
      if (objectValue !== null) {
        if (
          objectValue.kind === "Primitive" &&
          typeof objectValue.value === "string" &&
          value.property === "length"
        ) {
          const result = {
            kind: "Primitive",
            value: objectValue.value.length,
            loc: value.loc,
          };
          instr.value = result;
          return result;
        }
      }
      return null;
    }
    case "LoadLocal": {
      const placeValue = read(constants, value.place);
      if (placeValue !== null) {
        instr.value = placeValue;
      }
      return placeValue;
    }
    case "StoreLocal": {
      const placeValue = read(constants, value.value);
      if (placeValue !== null) {
        constants.set(value.lvalue.place.identifier.id, placeValue);
      }
      return placeValue;
    }
    case "ObjectMethod":
    case "FunctionExpression": {
      constantPropagationImpl(value.loweredFunc.func, constants);
      return null;
    }
    default: {
      return null;
    }
  }
}
function read(constants, place) {
  var _a;
  return (_a = constants.get(place.identifier.id)) !== null && _a !== void 0
    ? _a
    : null;
}
function deadCodeElimination(fn) {
  const state = findReferencedIdentifiers(fn);
  for (const [, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      if (!state.isIdOrNameUsed(phi.id)) {
        block.phis.delete(phi);
      }
    }
    retainWhere(block.instructions, (instr) =>
      state.isIdOrNameUsed(instr.lvalue.identifier)
    );
    for (let i = 0; i < block.instructions.length; i++) {
      const isBlockValue =
        block.kind !== "block" && i === block.instructions.length - 1;
      if (!isBlockValue) {
        rewriteInstruction(block.instructions[i], state);
      }
    }
  }
}
class State {
  constructor() {
    this.named = new Set();
    this.identifiers = new Set();
  }
  reference(identifier) {
    this.identifiers.add(identifier.id);
    if (identifier.name !== null) {
      this.named.add(identifier.name.value);
    }
  }
  isIdOrNameUsed(identifier) {
    return (
      this.identifiers.has(identifier.id) ||
      (identifier.name !== null && this.named.has(identifier.name.value))
    );
  }
  isIdUsed(identifier) {
    return this.identifiers.has(identifier.id);
  }
  get count() {
    return this.identifiers.size;
  }
}
function findReferencedIdentifiers(fn) {
  const hasLoop = hasBackEdge(fn);
  const reversedBlocks = [...fn.body.blocks.values()].reverse();
  const state = new State();
  let size = state.count;
  do {
    size = state.count;
    for (const block of reversedBlocks) {
      for (const operand of eachTerminalOperand(block.terminal)) {
        state.reference(operand.identifier);
      }
      for (let i = block.instructions.length - 1; i >= 0; i--) {
        const instr = block.instructions[i];
        const isBlockValue =
          block.kind !== "block" && i === block.instructions.length - 1;
        if (isBlockValue) {
          state.reference(instr.lvalue.identifier);
          for (const place of eachInstructionValueOperand(instr.value)) {
            state.reference(place.identifier);
          }
        } else if (
          state.isIdOrNameUsed(instr.lvalue.identifier) ||
          !pruneableValue(instr.value, state)
        ) {
          state.reference(instr.lvalue.identifier);
          if (instr.value.kind === "StoreLocal") {
            if (
              instr.value.lvalue.kind === InstructionKind.Reassign ||
              state.isIdUsed(instr.value.lvalue.place.identifier)
            ) {
              state.reference(instr.value.value.identifier);
            }
          } else {
            for (const operand of eachInstructionValueOperand(instr.value)) {
              state.reference(operand.identifier);
            }
          }
        }
      }
      for (const phi of block.phis) {
        if (state.isIdOrNameUsed(phi.id)) {
          for (const [_pred, operand] of phi.operands) {
            state.reference(operand);
          }
        }
      }
    }
  } while (state.count > size && hasLoop);
  return state;
}
function rewriteInstruction(instr, state) {
  if (instr.value.kind === "Destructure") {
    switch (instr.value.lvalue.pattern.kind) {
      case "ArrayPattern": {
        let nextItems = null;
        const originalItems = instr.value.lvalue.pattern.items;
        for (let i = originalItems.length - 1; i >= 0; i--) {
          const item = originalItems[i];
          if (item.kind === "Identifier") {
            if (state.isIdOrNameUsed(item.identifier)) {
              nextItems = originalItems.slice(0, i + 1);
              break;
            }
          } else if (item.kind === "Spread") {
            if (state.isIdOrNameUsed(item.place.identifier)) {
              nextItems = originalItems.slice(0, i + 1);
              break;
            }
          }
        }
        if (nextItems !== null) {
          instr.value.lvalue.pattern.items = nextItems;
        }
        break;
      }
      case "ObjectPattern": {
        let nextProperties = null;
        for (const property of instr.value.lvalue.pattern.properties) {
          if (property.kind === "ObjectProperty") {
            if (state.isIdOrNameUsed(property.place.identifier)) {
              nextProperties !== null && nextProperties !== void 0
                ? nextProperties
                : (nextProperties = []);
              nextProperties.push(property);
            }
          } else {
            if (state.isIdOrNameUsed(property.place.identifier)) {
              nextProperties = null;
              break;
            }
          }
        }
        if (nextProperties !== null) {
          instr.value.lvalue.pattern.properties = nextProperties;
        }
        break;
      }
      default: {
        assertExhaustive$1(
          instr.value.lvalue.pattern,
          `Unexpected pattern kind '${instr.value.lvalue.pattern.kind}'`
        );
      }
    }
  } else if (instr.value.kind === "StoreLocal") {
    if (
      instr.value.lvalue.kind !== InstructionKind.Reassign &&
      !state.isIdUsed(instr.value.lvalue.place.identifier)
    ) {
      instr.value = {
        kind: "DeclareLocal",
        lvalue: instr.value.lvalue,
        type: instr.value.type,
        loc: instr.value.loc,
      };
    }
  }
}
function pruneableValue(value, state) {
  switch (value.kind) {
    case "DeclareLocal": {
      return !state.isIdOrNameUsed(value.lvalue.place.identifier);
    }
    case "StoreLocal": {
      if (value.lvalue.kind === InstructionKind.Reassign) {
        return !state.isIdUsed(value.lvalue.place.identifier);
      }
      return !state.isIdOrNameUsed(value.lvalue.place.identifier);
    }
    case "Destructure": {
      let isIdOrNameUsed = false;
      let isIdUsed = false;
      for (const place of eachPatternOperand(value.lvalue.pattern)) {
        if (state.isIdUsed(place.identifier)) {
          isIdOrNameUsed = true;
          isIdUsed = true;
        } else if (state.isIdOrNameUsed(place.identifier)) {
          isIdOrNameUsed = true;
        }
      }
      if (value.lvalue.kind === InstructionKind.Reassign) {
        return !isIdUsed;
      } else {
        return !isIdOrNameUsed;
      }
    }
    case "PostfixUpdate":
    case "PrefixUpdate": {
      return !state.isIdUsed(value.lvalue.identifier);
    }
    case "Debugger": {
      return false;
    }
    case "Await":
    case "CallExpression":
    case "ComputedDelete":
    case "ComputedStore":
    case "PropertyDelete":
    case "MethodCall":
    case "PropertyStore":
    case "StoreGlobal": {
      return false;
    }
    case "NewExpression":
    case "UnsupportedNode":
    case "TaggedTemplateExpression": {
      return false;
    }
    case "GetIterator":
    case "NextPropertyOf":
    case "IteratorNext": {
      return false;
    }
    case "LoadContext":
    case "DeclareContext":
    case "StoreContext": {
      return false;
    }
    case "StartMemoize":
    case "FinishMemoize": {
      return false;
    }
    case "RegExpLiteral":
    case "MetaProperty":
    case "LoadGlobal":
    case "ArrayExpression":
    case "BinaryExpression":
    case "ComputedLoad":
    case "ObjectMethod":
    case "FunctionExpression":
    case "LoadLocal":
    case "JsxExpression":
    case "JsxFragment":
    case "JSXText":
    case "ObjectExpression":
    case "Primitive":
    case "PropertyLoad":
    case "TemplateLiteral":
    case "TypeCastExpression":
    case "UnaryExpression": {
      return true;
    }
    default: {
      assertExhaustive$1(value, `Unexepcted value kind \`${value.kind}\``);
    }
  }
}
function hasBackEdge(fn) {
  return findBlocksWithBackEdges(fn).size > 0;
}
function findBlocksWithBackEdges(fn) {
  const visited = new Set();
  const blocks = new Set();
  for (const [blockId, block] of fn.body.blocks) {
    for (const predId of block.preds) {
      if (!visited.has(predId)) {
        blocks.add(blockId);
      }
    }
    visited.add(blockId);
  }
  return blocks;
}
function pruneMaybeThrows(fn) {
  const terminalMapping = pruneMaybeThrowsImpl(fn);
  if (terminalMapping) {
    reversePostorderBlocks(fn.body);
    removeUnreachableForUpdates(fn.body);
    removeDeadDoWhileStatements(fn.body);
    removeUnnecessaryTryCatch(fn.body);
    markInstructionIds(fn.body);
    mergeConsecutiveBlocks(fn);
    for (const [, block] of fn.body.blocks) {
      for (const phi of block.phis) {
        for (const [predecessor, operand] of phi.operands) {
          if (!block.preds.has(predecessor)) {
            const mappedTerminal = terminalMapping.get(predecessor);
            CompilerError.invariant(mappedTerminal != null, {
              reason: `Expected non-existing phi operand's predecessor to have been mapped to a new terminal`,
              loc: GeneratedSource,
              description: `Could not find mapping for predecessor bb${predecessor} in block bb${block.id} for phi ${printIdentifier(phi.id)}`,
              suggestions: null,
            });
            phi.operands.delete(predecessor);
            phi.operands.set(mappedTerminal, operand);
          }
        }
      }
    }
    assertConsistentIdentifiers(fn);
    assertTerminalSuccessorsExist(fn);
  }
}
function pruneMaybeThrowsImpl(fn) {
  var _a;
  const terminalMapping = new Map();
  for (const [_, block] of fn.body.blocks) {
    const terminal = block.terminal;
    if (terminal.kind !== "maybe-throw") {
      continue;
    }
    const canThrow = block.instructions.some((instr) =>
      instructionMayThrow(instr)
    );
    if (!canThrow) {
      const source =
        (_a = terminalMapping.get(block.id)) !== null && _a !== void 0
          ? _a
          : block.id;
      terminalMapping.set(terminal.continuation, source);
      block.terminal = {
        kind: "goto",
        block: terminal.continuation,
        variant: GotoVariant.Break,
        id: terminal.id,
        loc: terminal.loc,
      };
    }
  }
  return terminalMapping.size > 0 ? terminalMapping : null;
}
function instructionMayThrow(instr) {
  switch (instr.value.kind) {
    case "Primitive":
    case "ArrayExpression":
    case "ObjectExpression": {
      return false;
    }
    default: {
      return true;
    }
  }
}
function inferMutableContextVariables(fn) {
  const state = new IdentifierState();
  const knownMutatedIdentifiers = new Set();
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      switch (instr.value.kind) {
        case "PropertyLoad": {
          state.declareProperty(
            instr.lvalue,
            instr.value.object,
            instr.value.property
          );
          break;
        }
        case "ComputedLoad": {
          state.declareProperty(instr.lvalue, instr.value.object, "");
          break;
        }
        case "LoadLocal":
        case "LoadContext": {
          if (instr.lvalue.identifier.name === null) {
            state.declareTemporary(instr.lvalue, instr.value.place);
          }
          break;
        }
        default: {
          for (const operand of eachInstructionValueOperand(instr.value)) {
            visitOperand(state, knownMutatedIdentifiers, operand);
          }
        }
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      visitOperand(state, knownMutatedIdentifiers, operand);
    }
  }
  for (const operand of fn.context) {
    if (knownMutatedIdentifiers.has(operand.identifier)) {
      operand.effect = Effect.Mutate;
    }
  }
}
function visitOperand(state, knownMutatedIdentifiers, operand) {
  const resolved = state.resolve(operand.identifier);
  if (operand.effect === Effect.Mutate || operand.effect === Effect.Store) {
    knownMutatedIdentifiers.add(resolved);
  }
}
function inferAliases(func) {
  const aliases = new DisjointSet();
  for (const [_, block] of func.body.blocks) {
    for (const instr of block.instructions) {
      inferInstr(instr, aliases);
    }
  }
  return aliases;
}
function inferInstr(instr, aliases) {
  const { lvalue: lvalue, value: instrValue } = instr;
  let alias = null;
  switch (instrValue.kind) {
    case "LoadLocal":
    case "LoadContext": {
      if (isPrimitiveType(instrValue.place.identifier)) {
        return;
      }
      alias = instrValue.place;
      break;
    }
    case "StoreLocal":
    case "StoreContext": {
      alias = instrValue.value;
      break;
    }
    case "Destructure": {
      alias = instrValue.value;
      break;
    }
    case "ComputedLoad":
    case "PropertyLoad": {
      alias = instrValue.object;
      break;
    }
    case "TypeCastExpression": {
      alias = instrValue.value;
      break;
    }
    default:
      return;
  }
  aliases.union([lvalue.identifier, alias.identifier]);
}
function inferAliasForPhis(func, aliases) {
  var _a, _b;
  for (const [_, block] of func.body.blocks) {
    for (const phi of block.phis) {
      const isPhiMutatedAfterCreation =
        phi.id.mutableRange.end >
        ((_b =
          (_a = block.instructions.at(0)) === null || _a === void 0
            ? void 0
            : _a.id) !== null && _b !== void 0
          ? _b
          : block.terminal.id);
      if (isPhiMutatedAfterCreation) {
        for (const [, operand] of phi.operands) {
          aliases.union([phi.id, operand]);
        }
      }
    }
  }
}
function inferAliasForStores(func, aliases) {
  for (const [_, block] of func.body.blocks) {
    for (const instr of block.instructions) {
      const { value: value, lvalue: lvalue } = instr;
      const isStore =
        lvalue.effect === Effect.Store ||
        ![...eachInstructionValueOperand(value)].every(
          (operand) => operand.effect !== Effect.Store
        );
      if (!isStore) {
        continue;
      }
      for (const operand of eachInstructionLValue(instr)) {
        maybeAlias(aliases, lvalue, operand, instr.id);
      }
      for (const operand of eachInstructionValueOperand(value)) {
        if (
          operand.effect === Effect.Capture ||
          operand.effect === Effect.Store
        ) {
          maybeAlias(aliases, lvalue, operand, instr.id);
        }
      }
    }
  }
}
function maybeAlias(aliases, lvalue, rvalue, id) {
  if (
    lvalue.identifier.mutableRange.end > id + 1 ||
    rvalue.identifier.mutableRange.end > id
  ) {
    aliases.union([lvalue.identifier, rvalue.identifier]);
  }
}
function infer$1(place, instrId) {
  place.identifier.mutableRange.end = makeInstructionId(instrId + 1);
}
function inferPlace(place, instrId, inferMutableRangeForStores) {
  switch (place.effect) {
    case Effect.Unknown: {
      throw new Error(`Found an unknown place ${printPlace(place)}}!`);
    }
    case Effect.Capture:
    case Effect.Read:
    case Effect.Freeze:
      return;
    case Effect.Store:
      if (inferMutableRangeForStores) {
        infer$1(place, instrId);
      }
      return;
    case Effect.ConditionallyMutate:
    case Effect.Mutate: {
      infer$1(place, instrId);
      return;
    }
    default:
      assertExhaustive$1(
        place.effect,
        `Unexpected ${printPlace(place)} effect`
      );
  }
}
function inferMutableLifetimes(func, inferMutableRangeForStores) {
  var _a, _b;
  const contextVariableDeclarationInstructions = new Map();
  for (const [_, block] of func.body.blocks) {
    for (const phi of block.phis) {
      const isPhiMutatedAfterCreation =
        phi.id.mutableRange.end >
        ((_b =
          (_a = block.instructions.at(0)) === null || _a === void 0
            ? void 0
            : _a.id) !== null && _b !== void 0
          ? _b
          : block.terminal.id);
      if (
        inferMutableRangeForStores &&
        isPhiMutatedAfterCreation &&
        phi.id.mutableRange.start === 0
      ) {
        for (const [, operand] of phi.operands) {
          if (phi.id.mutableRange.start === 0) {
            phi.id.mutableRange.start = operand.mutableRange.start;
          } else {
            phi.id.mutableRange.start = makeInstructionId(
              Math.min(phi.id.mutableRange.start, operand.mutableRange.start)
            );
          }
        }
      }
    }
    for (const instr of block.instructions) {
      for (const operand of eachInstructionLValue(instr)) {
        const lvalueId = operand.identifier;
        lvalueId.mutableRange.start = instr.id;
        lvalueId.mutableRange.end = makeInstructionId(instr.id + 1);
      }
      for (const operand of eachInstructionOperand(instr)) {
        inferPlace(operand, instr.id, inferMutableRangeForStores);
      }
      if (
        instr.value.kind === "DeclareContext" ||
        (instr.value.kind === "StoreContext" &&
          instr.value.lvalue.kind !== InstructionKind.Reassign)
      ) {
        contextVariableDeclarationInstructions.set(
          instr.value.lvalue.place.identifier,
          instr.id
        );
      } else if (instr.value.kind === "StoreContext") {
        const declaration = contextVariableDeclarationInstructions.get(
          instr.value.lvalue.place.identifier
        );
        if (declaration != null) {
          const range = instr.value.lvalue.place.identifier.mutableRange;
          if (range.start === 0) {
            range.start = declaration;
          } else {
            range.start = makeInstructionId(Math.min(range.start, declaration));
          }
        }
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      inferPlace(operand, block.terminal.id, inferMutableRangeForStores);
    }
  }
}
function inferMutableRangesForAlias(_fn, aliases) {
  const aliasSets = aliases.buildSets();
  for (const aliasSet of aliasSets) {
    const mutatingIdentifiers = [...aliasSet].filter(
      (id) => id.mutableRange.end - id.mutableRange.start > 1
    );
    if (mutatingIdentifiers.length > 0) {
      let lastMutatingInstructionId = 0;
      for (const id of mutatingIdentifiers) {
        if (id.mutableRange.end > lastMutatingInstructionId) {
          lastMutatingInstructionId = id.mutableRange.end;
        }
      }
      for (const alias of aliasSet) {
        if (alias.mutableRange.end < lastMutatingInstructionId) {
          alias.mutableRange.end = lastMutatingInstructionId;
        }
      }
    }
  }
}
function inferTryCatchAliases(fn, aliases) {
  const handlerParams = new Map();
  for (const [_, block] of fn.body.blocks) {
    if (
      block.terminal.kind === "try" &&
      block.terminal.handlerBinding !== null
    ) {
      handlerParams.set(
        block.terminal.handler,
        block.terminal.handlerBinding.identifier
      );
    } else if (block.terminal.kind === "maybe-throw") {
      const handlerParam = handlerParams.get(block.terminal.handler);
      if (handlerParam === undefined) {
        continue;
      }
      for (const instr of block.instructions) {
        aliases.union([handlerParam, instr.lvalue.identifier]);
      }
    }
  }
}
function inferMutableRanges(ir) {
  inferMutableLifetimes(ir, false);
  const aliases = inferAliases(ir);
  inferTryCatchAliases(ir, aliases);
  let prevAliases = aliases.canonicalize();
  while (true) {
    inferMutableRangesForAlias(ir, aliases);
    inferAliasForStores(ir, aliases);
    inferAliasForPhis(ir, aliases);
    const nextAliases = aliases.canonicalize();
    if (areEqualMaps(prevAliases, nextAliases)) {
      break;
    }
    prevAliases = nextAliases;
  }
  inferMutableLifetimes(ir, true);
  inferMutableRangesForAlias(ir, aliases);
}
function areEqualMaps(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const [key, value] of a) {
    if (!b.has(key)) {
      return false;
    }
    if (b.get(key) !== value) {
      return false;
    }
  }
  return true;
}
class IdentifierState {
  constructor() {
    this.properties = new Map();
  }
  resolve(identifier) {
    const resolved = this.properties.get(identifier);
    if (resolved !== undefined) {
      return resolved.identifier;
    }
    return identifier;
  }
  declareProperty(lvalue, object, property) {
    const objectDependency = this.properties.get(object.identifier);
    let nextDependency;
    if (objectDependency === undefined) {
      nextDependency = { identifier: object.identifier, path: [property] };
    } else {
      nextDependency = {
        identifier: objectDependency.identifier,
        path: [...objectDependency.path, property],
      };
    }
    this.properties.set(lvalue.identifier, nextDependency);
  }
  declareTemporary(lvalue, value) {
    var _a;
    const resolved =
      (_a = this.properties.get(value.identifier)) !== null && _a !== void 0
        ? _a
        : { identifier: value.identifier, path: [] };
    this.properties.set(lvalue.identifier, resolved);
  }
}
function analyseFunctions(func) {
  const state = new IdentifierState();
  for (const [_, block] of func.body.blocks) {
    for (const instr of block.instructions) {
      switch (instr.value.kind) {
        case "ObjectMethod":
        case "FunctionExpression": {
          lower(instr.value.loweredFunc.func);
          infer(instr.value.loweredFunc, state, func.context);
          break;
        }
        case "PropertyLoad": {
          state.declareProperty(
            instr.lvalue,
            instr.value.object,
            instr.value.property
          );
          break;
        }
        case "ComputedLoad": {
          state.declareProperty(instr.lvalue, instr.value.object, "");
          break;
        }
        case "LoadLocal":
        case "LoadContext": {
          if (instr.lvalue.identifier.name === null) {
            state.declareTemporary(instr.lvalue, instr.value.place);
          }
          break;
        }
      }
    }
  }
}
function lower(func) {
  analyseFunctions(func);
  inferReferenceEffects(func, { isFunctionExpression: true });
  deadCodeElimination(func);
  inferMutableRanges(func);
  leaveSSA(func);
  inferReactiveScopeVariables(func);
  inferMutableContextVariables(func);
}
function infer(loweredFunc, state, context) {
  const mutations = new Map();
  for (const operand of loweredFunc.func.context) {
    if (
      isMutatedOrReassigned(operand.identifier) &&
      operand.identifier.name !== null
    ) {
      mutations.set(operand.identifier.name.value, operand.effect);
    }
  }
  for (const dep of loweredFunc.dependencies) {
    let name = null;
    if (state.properties.has(dep.identifier)) {
      const receiver = state.properties.get(dep.identifier);
      name = receiver.identifier.name;
    } else {
      name = dep.identifier.name;
    }
    if (isUseRefType(dep.identifier) || isRefValueType(dep.identifier)) {
      dep.effect = Effect.Capture;
    } else if (name !== null) {
      const effect = mutations.get(name.value);
      if (effect !== undefined) {
        dep.effect = effect === Effect.Unknown ? Effect.Capture : effect;
      }
    }
  }
  for (const place of context) {
    CompilerError.invariant(place.identifier.name !== null, {
      reason: "context refs should always have a name",
      description: null,
      loc: place.loc,
      suggestions: null,
    });
    const effect = mutations.get(place.identifier.name.value);
    if (effect !== undefined) {
      place.effect = effect === Effect.Unknown ? Effect.Capture : effect;
      loweredFunc.dependencies.push(place);
    }
  }
  for (const operand of loweredFunc.func.context) {
    operand.identifier.mutableRange.start = makeInstructionId(0);
    operand.identifier.mutableRange.end = makeInstructionId(0);
    operand.identifier.scope = null;
  }
}
function isMutatedOrReassigned(id) {
  return id.mutableRange.end > id.mutableRange.start;
}
function collectMaybeMemoDependencies(value, maybeDeps) {
  var _a;
  switch (value.kind) {
    case "LoadGlobal": {
      return {
        root: { kind: "Global", identifierName: value.binding.name },
        path: [],
      };
    }
    case "PropertyLoad": {
      const object = maybeDeps.get(value.object.identifier.id);
      if (object != null) {
        return { root: object.root, path: [...object.path, value.property] };
      }
      break;
    }
    case "LoadLocal":
    case "LoadContext": {
      const source = maybeDeps.get(value.place.identifier.id);
      if (source != null) {
        return source;
      } else if (
        value.place.identifier.name != null &&
        value.place.identifier.name.kind === "named"
      ) {
        return {
          root: { kind: "NamedLocal", value: Object.assign({}, value.place) },
          path: [],
        };
      }
      break;
    }
    case "StoreLocal": {
      const lvalue = value.lvalue.place.identifier;
      const rvalue = value.value.identifier.id;
      const aliased = maybeDeps.get(rvalue);
      if (
        aliased != null &&
        ((_a = lvalue.name) === null || _a === void 0 ? void 0 : _a.kind) !==
          "named"
      ) {
        maybeDeps.set(lvalue.id, aliased);
        return aliased;
      }
      break;
    }
  }
  return null;
}
function collectTemporaries(instr, env, sidemap) {
  const { value: value, lvalue: lvalue } = instr;
  switch (value.kind) {
    case "FunctionExpression": {
      sidemap.functions.set(instr.lvalue.identifier.id, instr);
      break;
    }
    case "LoadGlobal": {
      const global = env.getGlobalDeclaration(value.binding);
      const hookKind = global !== null ? getHookKindForType(env, global) : null;
      const lvalId = instr.lvalue.identifier.id;
      if (hookKind === "useMemo" || hookKind === "useCallback") {
        sidemap.manualMemos.set(lvalId, { kind: hookKind, loadInstr: instr });
      } else if (value.binding.name === "React") {
        sidemap.react.add(lvalId);
      }
      break;
    }
    case "PropertyLoad": {
      if (sidemap.react.has(value.object.identifier.id)) {
        if (value.property === "useMemo" || value.property === "useCallback") {
          sidemap.manualMemos.set(instr.lvalue.identifier.id, {
            kind: value.property,
            loadInstr: instr,
          });
        }
      }
      break;
    }
    case "ArrayExpression": {
      if (value.elements.every((e) => e.kind === "Identifier")) {
        sidemap.maybeDepsLists.set(instr.lvalue.identifier.id, value.elements);
      }
      break;
    }
  }
  const maybeDep = collectMaybeMemoDependencies(value, sidemap.maybeDeps);
  if (maybeDep != null) {
    sidemap.maybeDeps.set(lvalue.identifier.id, maybeDep);
  }
}
function makeManualMemoizationMarkers(
  fnExpr,
  env,
  depsList,
  memoDecl,
  manualMemoId
) {
  return [
    {
      id: makeInstructionId(0),
      lvalue: createTemporaryPlace(env, fnExpr.loc),
      value: {
        kind: "StartMemoize",
        manualMemoId: manualMemoId,
        deps: depsList,
        loc: fnExpr.loc,
      },
      loc: fnExpr.loc,
    },
    {
      id: makeInstructionId(0),
      lvalue: createTemporaryPlace(env, fnExpr.loc),
      value: {
        kind: "FinishMemoize",
        manualMemoId: manualMemoId,
        decl: Object.assign({}, memoDecl),
        loc: fnExpr.loc,
      },
      loc: fnExpr.loc,
    },
  ];
}
function getManualMemoizationReplacement(fn, loc, kind) {
  if (kind === "useMemo") {
    return { kind: "CallExpression", callee: fn, args: [], loc: loc };
  } else {
    return {
      kind: "LoadLocal",
      place: {
        kind: "Identifier",
        identifier: fn.identifier,
        effect: Effect.Unknown,
        reactive: false,
        loc: loc,
      },
      loc: loc,
    };
  }
}
function extractManualMemoizationArgs(instr, kind, sidemap) {
  const [fnPlace, depsListPlace] = instr.value.args;
  if (fnPlace == null) {
    CompilerError.throwInvalidReact({
      reason: `Expected a callback function to be passed to ${kind}`,
      loc: instr.value.loc,
      suggestions: null,
    });
  }
  if (
    fnPlace.kind === "Spread" ||
    (depsListPlace === null || depsListPlace === void 0
      ? void 0
      : depsListPlace.kind) === "Spread"
  ) {
    CompilerError.throwInvalidReact({
      reason: `Unexpected spread argument to ${kind}`,
      loc: instr.value.loc,
      suggestions: null,
    });
  }
  let depsList = null;
  if (depsListPlace != null) {
    const maybeDepsList = sidemap.maybeDepsLists.get(
      depsListPlace.identifier.id
    );
    if (maybeDepsList == null) {
      CompilerError.throwInvalidReact({
        reason: `Expected the dependency list for ${kind} to be an array literal`,
        suggestions: null,
        loc: depsListPlace.loc,
      });
    }
    depsList = maybeDepsList.map((dep) => {
      const maybeDep = sidemap.maybeDeps.get(dep.identifier.id);
      if (maybeDep == null) {
        CompilerError.throwInvalidReact({
          reason: `Expected the dependency list to be an array of simple expressions (e.g. \`x\`, \`x.y.z\`, \`x?.y?.z\`)`,
          suggestions: null,
          loc: dep.loc,
        });
      }
      return maybeDep;
    });
  }
  return { fnPlace: fnPlace, depsList: depsList };
}
function dropManualMemoization(func) {
  const isValidationEnabled =
    func.env.config.validatePreserveExistingMemoizationGuarantees ||
    func.env.config.enablePreserveExistingMemoizationGuarantees;
  const sidemap = {
    functions: new Map(),
    manualMemos: new Map(),
    react: new Set(),
    maybeDeps: new Map(),
    maybeDepsLists: new Map(),
  };
  let nextManualMemoId = 0;
  const queuedInserts = new Map();
  for (const [_, block] of func.body.blocks) {
    for (let i = 0; i < block.instructions.length; i++) {
      const instr = block.instructions[i];
      if (
        instr.value.kind === "CallExpression" ||
        instr.value.kind === "MethodCall"
      ) {
        const id =
          instr.value.kind === "CallExpression"
            ? instr.value.callee.identifier.id
            : instr.value.property.identifier.id;
        const manualMemo = sidemap.manualMemos.get(id);
        if (manualMemo != null) {
          const { fnPlace: fnPlace, depsList: depsList } =
            extractManualMemoizationArgs(instr, manualMemo.kind, sidemap);
          instr.value = getManualMemoizationReplacement(
            fnPlace,
            instr.value.loc,
            manualMemo.kind
          );
          if (isValidationEnabled) {
            if (!sidemap.functions.has(fnPlace.identifier.id)) {
              CompilerError.throwInvalidReact({
                reason: `Expected the first argument to be an inline function expression`,
                suggestions: [],
                loc: fnPlace.loc,
              });
            }
            const memoDecl =
              manualMemo.kind === "useMemo"
                ? instr.lvalue
                : {
                    kind: "Identifier",
                    identifier: fnPlace.identifier,
                    effect: Effect.Unknown,
                    reactive: false,
                    loc: fnPlace.loc,
                  };
            const [startMarker, finishMarker] = makeManualMemoizationMarkers(
              fnPlace,
              func.env,
              depsList,
              memoDecl,
              nextManualMemoId++
            );
            queuedInserts.set(manualMemo.loadInstr.id, startMarker);
            queuedInserts.set(instr.id, finishMarker);
          }
        }
      } else {
        collectTemporaries(instr, func.env, sidemap);
      }
    }
  }
  if (queuedInserts.size > 0) {
    let hasChanges = false;
    for (const [_, block] of func.body.blocks) {
      let nextInstructions = null;
      for (let i = 0; i < block.instructions.length; i++) {
        const instr = block.instructions[i];
        const insertInstr = queuedInserts.get(instr.id);
        if (insertInstr != null) {
          nextInstructions =
            nextInstructions !== null && nextInstructions !== void 0
              ? nextInstructions
              : block.instructions.slice(0, i);
          nextInstructions.push(instr);
          nextInstructions.push(insertInstr);
        } else if (nextInstructions != null) {
          nextInstructions.push(instr);
        }
      }
      if (nextInstructions !== null) {
        block.instructions = nextInstructions;
        hasChanges = true;
      }
    }
    if (hasChanges) {
      markInstructionIds(func.body);
    }
  }
}
function inferReactivePlaces(fn) {
  var _a;
  const reactiveIdentifiers = new ReactivityMap(findDisjointMutableValues(fn));
  for (const param of fn.params) {
    const place = param.kind === "Identifier" ? param : param.place;
    reactiveIdentifiers.markReactive(place);
  }
  const postDominators = computePostDominatorTree(fn, {
    includeThrowsAsExitNode: false,
  });
  const postDominatorFrontierCache = new Map();
  function isReactiveControlledBlock(id) {
    let controlBlocks = postDominatorFrontierCache.get(id);
    if (controlBlocks === undefined) {
      controlBlocks = postDominatorFrontier(fn, postDominators, id);
      postDominatorFrontierCache.set(id, controlBlocks);
    }
    for (const blockId of controlBlocks) {
      const controlBlock = fn.body.blocks.get(blockId);
      switch (controlBlock.terminal.kind) {
        case "if":
        case "branch": {
          if (reactiveIdentifiers.isReactive(controlBlock.terminal.test)) {
            return true;
          }
          break;
        }
        case "switch": {
          if (reactiveIdentifiers.isReactive(controlBlock.terminal.test)) {
            return true;
          }
          for (const case_ of controlBlock.terminal.cases) {
            if (
              case_.test !== null &&
              reactiveIdentifiers.isReactive(case_.test)
            ) {
              return true;
            }
          }
          break;
        }
      }
    }
    return false;
  }
  do {
    const identifierMapping = new Map();
    for (const [, block] of fn.body.blocks) {
      let hasReactiveControl = isReactiveControlledBlock(block.id);
      for (const phi of block.phis) {
        if (reactiveIdentifiers.isReactiveIdentifier(phi.id)) {
          continue;
        }
        let isPhiReactive = false;
        for (const [, operand] of phi.operands) {
          if (reactiveIdentifiers.isReactiveIdentifier(operand)) {
            isPhiReactive = true;
            break;
          }
        }
        if (isPhiReactive) {
          reactiveIdentifiers.markReactiveIdentifier(phi.id);
        } else {
          for (const [pred] of phi.operands) {
            if (isReactiveControlledBlock(pred)) {
              reactiveIdentifiers.markReactiveIdentifier(phi.id);
              break;
            }
          }
        }
      }
      for (const instruction of block.instructions) {
        const { value: value } = instruction;
        let hasReactiveInput = false;
        for (const operand of eachInstructionValueOperand(value)) {
          const reactive = reactiveIdentifiers.isReactive(operand);
          hasReactiveInput || (hasReactiveInput = reactive);
        }
        if (
          value.kind === "CallExpression" &&
          (getHookKind(fn.env, value.callee.identifier) != null ||
            isUseOperator(value.callee.identifier))
        ) {
          hasReactiveInput = true;
        } else if (
          value.kind === "MethodCall" &&
          (getHookKind(fn.env, value.property.identifier) != null ||
            isUseOperator(value.property.identifier))
        ) {
          hasReactiveInput = true;
        }
        if (hasReactiveInput) {
          for (const lvalue of eachInstructionLValue(instruction)) {
            if (isStableType(lvalue.identifier)) {
              continue;
            }
            reactiveIdentifiers.markReactive(lvalue);
          }
        }
        if (hasReactiveInput || hasReactiveControl) {
          for (const operand of eachInstructionValueOperand(value)) {
            switch (operand.effect) {
              case Effect.Capture:
              case Effect.Store:
              case Effect.ConditionallyMutate:
              case Effect.Mutate: {
                if (isMutable(instruction, operand)) {
                  const resolvedId = identifierMapping.get(operand.identifier);
                  if (resolvedId !== undefined) {
                    reactiveIdentifiers.markReactiveIdentifier(resolvedId);
                  }
                  reactiveIdentifiers.markReactive(operand);
                }
                break;
              }
              case Effect.Freeze:
              case Effect.Read: {
                break;
              }
              case Effect.Unknown: {
                CompilerError.invariant(false, {
                  reason: "Unexpected unknown effect",
                  description: null,
                  loc: operand.loc,
                  suggestions: null,
                });
              }
              default: {
                assertExhaustive$1(
                  operand.effect,
                  `Unexpected effect kind \`${operand.effect}\``
                );
              }
            }
          }
        }
        switch (value.kind) {
          case "LoadLocal": {
            identifierMapping.set(
              instruction.lvalue.identifier,
              value.place.identifier
            );
            break;
          }
          case "PropertyLoad":
          case "ComputedLoad": {
            const resolvedId =
              (_a = identifierMapping.get(value.object.identifier)) !== null &&
              _a !== void 0
                ? _a
                : value.object.identifier;
            identifierMapping.set(instruction.lvalue.identifier, resolvedId);
            break;
          }
          case "LoadContext": {
            identifierMapping.set(
              instruction.lvalue.identifier,
              value.place.identifier
            );
            break;
          }
        }
      }
      for (const operand of eachTerminalOperand(block.terminal)) {
        reactiveIdentifiers.isReactive(operand);
      }
    }
  } while (reactiveIdentifiers.snapshot());
}
function postDominatorFrontier(fn, postDominators, targetId) {
  const visited = new Set();
  const frontier = new Set();
  const targetPostDominators = postDominatorsOf(fn, postDominators, targetId);
  for (const blockId of [...targetPostDominators, targetId]) {
    if (visited.has(blockId)) {
      continue;
    }
    visited.add(blockId);
    const block = fn.body.blocks.get(blockId);
    for (const pred of block.preds) {
      if (!targetPostDominators.has(pred)) {
        frontier.add(pred);
      }
    }
  }
  return frontier;
}
function postDominatorsOf(fn, postDominators, targetId) {
  var _a;
  const result = new Set();
  const visited = new Set();
  const queue = [targetId];
  while (queue.length) {
    const currentId = queue.shift();
    if (visited.has(currentId)) {
      continue;
    }
    visited.add(currentId);
    const current = fn.body.blocks.get(currentId);
    for (const pred of current.preds) {
      const predPostDominator =
        (_a = postDominators.get(pred)) !== null && _a !== void 0 ? _a : pred;
      if (predPostDominator === targetId || result.has(predPostDominator)) {
        result.add(pred);
      }
      queue.push(pred);
    }
  }
  return result;
}
class ReactivityMap {
  constructor(aliasedIdentifiers) {
    this.hasChanges = false;
    this.reactive = new Set();
    this.aliasedIdentifiers = aliasedIdentifiers;
  }
  isReactive(place) {
    const reactive = this.isReactiveIdentifier(place.identifier);
    if (reactive) {
      place.reactive = true;
    }
    return reactive;
  }
  isReactiveIdentifier(inputIdentifier) {
    var _a;
    const identifier =
      (_a = this.aliasedIdentifiers.find(inputIdentifier)) !== null &&
      _a !== void 0
        ? _a
        : inputIdentifier;
    return this.reactive.has(identifier.id);
  }
  markReactive(place) {
    place.reactive = true;
    this.markReactiveIdentifier(place.identifier);
  }
  markReactiveIdentifier(inputIdentifier) {
    var _a;
    const identifier =
      (_a = this.aliasedIdentifiers.find(inputIdentifier)) !== null &&
      _a !== void 0
        ? _a
        : inputIdentifier;
    if (!this.reactive.has(identifier.id)) {
      this.hasChanges = true;
      this.reactive.add(identifier.id);
    }
  }
  snapshot() {
    const hasChanges = this.hasChanges;
    this.hasChanges = false;
    return hasChanges;
  }
}
function inlineImmediatelyInvokedFunctionExpressions(fn) {
  const functions = new Map();
  const inlinedFunctions = new Set();
  const queue = Array.from(fn.body.blocks.values());
  queue: for (const block of queue) {
    for (let ii = 0; ii < block.instructions.length; ii++) {
      const instr = block.instructions[ii];
      switch (instr.value.kind) {
        case "FunctionExpression": {
          if (instr.lvalue.identifier.name === null) {
            functions.set(instr.lvalue.identifier.id, instr.value);
          }
          break;
        }
        case "CallExpression": {
          if (instr.value.args.length !== 0) {
            continue;
          }
          const body = functions.get(instr.value.callee.identifier.id);
          if (body === undefined) {
            continue;
          }
          if (
            body.loweredFunc.func.params.length > 0 ||
            body.loweredFunc.func.async ||
            body.loweredFunc.func.generator
          ) {
            continue;
          }
          inlinedFunctions.add(instr.value.callee.identifier.id);
          const continuationBlockId = fn.env.nextBlockId;
          const continuationBlock = {
            id: continuationBlockId,
            instructions: block.instructions.slice(ii + 1),
            kind: block.kind,
            phis: new Set(),
            preds: new Set(),
            terminal: block.terminal,
          };
          fn.body.blocks.set(continuationBlockId, continuationBlock);
          block.instructions.length = ii;
          const newTerminal = {
            block: body.loweredFunc.func.body.entry,
            id: makeInstructionId(0),
            kind: "label",
            fallthrough: continuationBlockId,
            loc: block.terminal.loc,
          };
          block.terminal = newTerminal;
          const result = instr.lvalue;
          declareTemporary(fn.env, block, result);
          promoteTemporary(result.identifier);
          for (const [id, block] of body.loweredFunc.func.body.blocks) {
            block.preds.clear();
            rewriteBlock(fn.env, block, continuationBlockId, result);
            fn.body.blocks.set(id, block);
          }
          queue.push(continuationBlock);
          continue queue;
        }
        default: {
          for (const place of eachInstructionValueOperand(instr.value)) {
            functions.delete(place.identifier.id);
          }
        }
      }
    }
  }
  if (inlinedFunctions.size !== 0) {
    for (const [, block] of fn.body.blocks) {
      retainWhere(
        block.instructions,
        (instr) => !inlinedFunctions.has(instr.lvalue.identifier.id)
      );
    }
    reversePostorderBlocks(fn.body);
    markInstructionIds(fn.body);
    markPredecessors(fn.body);
  }
}
function rewriteBlock(env, block, returnTarget, returnValue) {
  const { terminal: terminal } = block;
  if (terminal.kind !== "return") {
    return;
  }
  block.instructions.push({
    id: makeInstructionId(0),
    loc: terminal.loc,
    lvalue: {
      effect: Effect.Unknown,
      identifier: {
        id: env.nextIdentifierId,
        mutableRange: {
          start: makeInstructionId(0),
          end: makeInstructionId(0),
        },
        name: null,
        scope: null,
        type: makeType(),
        loc: terminal.loc,
      },
      kind: "Identifier",
      reactive: false,
      loc: terminal.loc,
    },
    value: {
      kind: "StoreLocal",
      lvalue: {
        kind: InstructionKind.Reassign,
        place: Object.assign({}, returnValue),
      },
      value: terminal.value,
      type: null,
      loc: terminal.loc,
    },
  });
  block.terminal = {
    kind: "goto",
    block: returnTarget,
    id: makeInstructionId(0),
    variant: GotoVariant.Break,
    loc: block.terminal.loc,
  };
}
function declareTemporary(env, block, result) {
  block.instructions.push({
    id: makeInstructionId(0),
    loc: GeneratedSource,
    lvalue: {
      effect: Effect.Unknown,
      identifier: {
        id: env.nextIdentifierId,
        mutableRange: {
          start: makeInstructionId(0),
          end: makeInstructionId(0),
        },
        name: null,
        scope: null,
        type: makeType(),
        loc: result.loc,
      },
      kind: "Identifier",
      reactive: false,
      loc: GeneratedSource,
    },
    value: {
      kind: "DeclareLocal",
      lvalue: { place: result, kind: InstructionKind.Let },
      type: null,
      loc: result.loc,
    },
  });
}
function instructionReordering(fn) {
  var _a;
  const shared = new Map();
  const references = findReferencedRangeOfTemporaries(fn);
  for (const [, block] of fn.body.blocks) {
    reorderBlock(fn.env, block, shared, references);
  }
  CompilerError.invariant(shared.size === 0, {
    reason: `InstructionReordering: expected all reorderable nodes to have been emitted`,
    loc:
      (_a = [...shared.values()]
        .map((node) => {
          var _a;
          return (_a = node.instruction) === null || _a === void 0
            ? void 0
            : _a.loc;
        })
        .filter((loc) => loc != null)[0]) !== null && _a !== void 0
        ? _a
        : GeneratedSource,
  });
  markInstructionIds(fn.body);
}
var ReferenceKind;
(function (ReferenceKind) {
  ReferenceKind[(ReferenceKind["Read"] = 0)] = "Read";
  ReferenceKind[(ReferenceKind["Write"] = 1)] = "Write";
})(ReferenceKind || (ReferenceKind = {}));
function findReferencedRangeOfTemporaries(fn) {
  const singleUseIdentifiers = new Map();
  const lastAssignments = new Map();
  function reference(instr, place, kind) {
    var _a;
    if (
      place.identifier.name !== null &&
      place.identifier.name.kind === "named"
    ) {
      if (kind === ReferenceKind.Write) {
        const name = place.identifier.name.value;
        const previous = lastAssignments.get(name);
        if (previous === undefined) {
          lastAssignments.set(name, instr);
        } else {
          lastAssignments.set(
            name,
            makeInstructionId(Math.max(previous, instr))
          );
        }
      }
      return;
    } else if (kind === ReferenceKind.Read) {
      const previousCount =
        (_a = singleUseIdentifiers.get(place.identifier.id)) !== null &&
        _a !== void 0
          ? _a
          : 0;
      singleUseIdentifiers.set(place.identifier.id, previousCount + 1);
    }
  }
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      for (const operand of eachInstructionValueLValue(instr.value)) {
        reference(instr.id, operand, ReferenceKind.Read);
      }
      for (const lvalue of eachInstructionLValue(instr)) {
        reference(instr.id, lvalue, ReferenceKind.Write);
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      reference(block.terminal.id, operand, ReferenceKind.Read);
    }
  }
  return {
    singleUseIdentifiers: new Set(
      [...singleUseIdentifiers]
        .filter(([, count]) => count === 1)
        .map(([id]) => id)
    ),
    lastAssignments: lastAssignments,
  };
}
function reorderBlock(env, block, shared, references) {
  var _a, _b;
  const locals = new Map();
  const named = new Map();
  let previous = null;
  for (const instr of block.instructions) {
    const { lvalue: lvalue, value: value } = instr;
    const reorderability = getReorderability(instr, references);
    const node = getOrInsertWith(locals, lvalue.identifier.id, () => ({
      instruction: instr,
      dependencies: new Set(),
      reorderability: reorderability,
      depth: null,
    }));
    if (reorderability === Reorderability.Nonreorderable) {
      if (previous !== null) {
        node.dependencies.add(previous);
      }
      previous = lvalue.identifier.id;
    }
    for (const operand of eachInstructionValueOperand(value)) {
      const { name: name, id: id } = operand.identifier;
      if (name !== null && name.kind === "named") {
        const previous = named.get(name.value);
        if (previous !== undefined) {
          node.dependencies.add(previous);
        }
        named.set(name.value, lvalue.identifier.id);
      } else if (locals.has(id) || shared.has(id)) {
        node.dependencies.add(id);
      }
    }
    for (const lvalueOperand of eachInstructionValueLValue(value)) {
      const lvalueNode = getOrInsertWith(
        locals,
        lvalueOperand.identifier.id,
        () => ({ instruction: null, dependencies: new Set(), depth: null })
      );
      lvalueNode.dependencies.add(lvalue.identifier.id);
      const name = lvalueOperand.identifier.name;
      if (name !== null && name.kind === "named") {
        const previous = named.get(name.value);
        if (previous !== undefined) {
          node.dependencies.add(previous);
        }
        named.set(name.value, lvalue.identifier.id);
      }
    }
  }
  const nextInstructions = [];
  if (isExpressionBlockKind(block.kind)) {
    if (previous !== null) {
      emit(env, locals, shared, nextInstructions, previous);
    }
    if (block.instructions.length !== 0) {
      emit(
        env,
        locals,
        shared,
        nextInstructions,
        block.instructions.at(-1).lvalue.identifier.id
      );
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      emit(env, locals, shared, nextInstructions, operand.identifier.id);
    }
    for (const [id, node] of locals) {
      if (node.instruction == null) {
        continue;
      }
      CompilerError.invariant(
        node.reorderability === Reorderability.Reorderable,
        {
          reason: `Expected all remaining instructions to be reorderable`,
          loc:
            (_b =
              (_a = node.instruction) === null || _a === void 0
                ? void 0
                : _a.loc) !== null && _b !== void 0
              ? _b
              : block.terminal.loc,
          description:
            node.instruction != null
              ? `Instruction [${node.instruction.id}] was not emitted yet but is not reorderable`
              : `Lvalue $${id} was not emitted yet but is not reorderable`,
        }
      );
      shared.set(id, node);
    }
  } else {
    for (const operand of eachTerminalOperand(block.terminal)) {
      emit(env, locals, shared, nextInstructions, operand.identifier.id);
    }
    for (const id of Array.from(locals.keys()).reverse()) {
      const node = locals.get(id);
      if (node === undefined) {
        continue;
      }
      if (node.reorderability === Reorderability.Reorderable) {
        shared.set(id, node);
      } else {
        emit(env, locals, shared, nextInstructions, id);
      }
    }
  }
  block.instructions = nextInstructions;
}
function getDepth(env, nodes, id) {
  const node = nodes.get(id);
  if (node == null) {
    return 0;
  }
  if (node.depth != null) {
    return node.depth;
  }
  node.depth = 0;
  let depth = node.reorderability === Reorderability.Reorderable ? 1 : 10;
  for (const dep of node.dependencies) {
    depth += getDepth(env, nodes, dep);
  }
  node.depth = depth;
  return depth;
}
function emit(env, locals, shared, instructions, id) {
  var _a;
  const node =
    (_a = locals.get(id)) !== null && _a !== void 0 ? _a : shared.get(id);
  if (node == null) {
    return;
  }
  locals.delete(id);
  shared.delete(id);
  const deps = [...node.dependencies];
  deps.sort((a, b) => {
    const aDepth = getDepth(env, locals, a);
    const bDepth = getDepth(env, locals, b);
    return bDepth - aDepth;
  });
  for (const dep of deps) {
    emit(env, locals, shared, instructions, dep);
  }
  if (node.instruction !== null) {
    instructions.push(node.instruction);
  }
}
var Reorderability;
(function (Reorderability) {
  Reorderability[(Reorderability["Reorderable"] = 0)] = "Reorderable";
  Reorderability[(Reorderability["Nonreorderable"] = 1)] = "Nonreorderable";
})(Reorderability || (Reorderability = {}));
function getReorderability(instr, references) {
  switch (instr.value.kind) {
    case "JsxExpression":
    case "JsxFragment":
    case "JSXText":
    case "LoadGlobal":
    case "Primitive":
    case "TemplateLiteral":
    case "BinaryExpression":
    case "UnaryExpression": {
      return Reorderability.Reorderable;
    }
    case "LoadLocal": {
      const name = instr.value.place.identifier.name;
      if (name !== null && name.kind === "named") {
        const lastAssignment = references.lastAssignments.get(name.value);
        if (
          lastAssignment !== undefined &&
          lastAssignment < instr.id &&
          references.singleUseIdentifiers.has(instr.lvalue.identifier.id)
        ) {
          return Reorderability.Reorderable;
        }
      }
      return Reorderability.Nonreorderable;
    }
    default: {
      return Reorderability.Nonreorderable;
    }
  }
}
function alignMethodCallScopes(fn) {
  const scopeMapping = new Map();
  const mergedScopes = new DisjointSet();
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      const { lvalue: lvalue, value: value } = instr;
      if (value.kind === "MethodCall") {
        const lvalueScope = lvalue.identifier.scope;
        const propertyScope = value.property.identifier.scope;
        if (lvalueScope !== null) {
          if (propertyScope !== null) {
            mergedScopes.union([lvalueScope, propertyScope]);
          } else {
            scopeMapping.set(value.property.identifier.id, lvalueScope);
          }
        } else if (propertyScope !== null) {
          scopeMapping.set(value.property.identifier.id, null);
        }
      } else if (
        value.kind === "FunctionExpression" ||
        value.kind === "ObjectMethod"
      ) {
        alignMethodCallScopes(value.loweredFunc.func);
      }
    }
  }
  mergedScopes.forEach((scope, root) => {
    if (scope === root) {
      return;
    }
    root.range.start = makeInstructionId(
      Math.min(scope.range.start, root.range.start)
    );
    root.range.end = makeInstructionId(
      Math.max(scope.range.end, root.range.end)
    );
  });
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      const mappedScope = scopeMapping.get(instr.lvalue.identifier.id);
      if (mappedScope !== undefined) {
        instr.lvalue.identifier.scope = mappedScope;
      } else if (instr.lvalue.identifier.scope !== null) {
        const mergedScope = mergedScopes.find(instr.lvalue.identifier.scope);
        if (mergedScope != null) {
          instr.lvalue.identifier.scope = mergedScope;
        }
      }
    }
  }
}
function alignReactiveScopesToBlockScopesHIR(fn) {
  var _a, _b, _c, _d;
  const blockNodes = new Map();
  const rootNode = {
    kind: "node",
    valueRange: null,
    children: [],
    id: makeInstructionId(0),
  };
  blockNodes.set(fn.body.entry, rootNode);
  const seen = new Set();
  const placeScopes = new Map();
  function recordPlace(id, place, node) {
    if (place.identifier.scope !== null) {
      placeScopes.set(place, place.identifier.scope);
    }
    const scope = getPlaceScope(id, place);
    if (scope == null) {
      return;
    }
    node.children.push({ kind: "scope", scope: scope, id: id });
    if (seen.has(scope)) {
      return;
    }
    seen.add(scope);
    if (node.valueRange !== null) {
      scope.range.start = makeInstructionId(
        Math.min(node.valueRange.start, scope.range.start)
      );
      scope.range.end = makeInstructionId(
        Math.max(node.valueRange.end, scope.range.end)
      );
    }
  }
  for (const [, block] of fn.body.blocks) {
    const { instructions: instructions, terminal: terminal } = block;
    const node = blockNodes.get(block.id);
    if (node === undefined) {
      CompilerError.invariant(false, {
        reason: `Expected a node to be initialized for block`,
        loc:
          (_b =
            (_a = instructions[0]) === null || _a === void 0
              ? void 0
              : _a.loc) !== null && _b !== void 0
            ? _b
            : terminal.loc,
        description: `No node for block bb${block.id} (${block.kind})`,
      });
    }
    for (const instr of instructions) {
      for (const lvalue of eachInstructionLValue(instr)) {
        recordPlace(instr.id, lvalue, node);
      }
      for (const operand of eachInstructionValueOperand(instr.value)) {
        recordPlace(instr.id, operand, node);
      }
    }
    for (const operand of eachTerminalOperand(terminal)) {
      recordPlace(terminal.id, operand, node);
    }
    const fallthrough = terminalFallthrough(terminal);
    if (fallthrough !== null && !blockNodes.has(fallthrough)) {
      const fallthroughBlock = fn.body.blocks.get(fallthrough);
      const nextId =
        (_d =
          (_c = fallthroughBlock.instructions[0]) === null || _c === void 0
            ? void 0
            : _c.id) !== null && _d !== void 0
          ? _d
          : fallthroughBlock.terminal.id;
      for (const child of node.children) {
        if (child.kind !== "scope") {
          continue;
        }
        const scope = child.scope;
        if (scope.range.end > terminal.id) {
          scope.range.end = makeInstructionId(
            Math.max(scope.range.end, nextId)
          );
        }
      }
      blockNodes.set(fallthrough, node);
    }
    mapTerminalSuccessors(terminal, (successor) => {
      var _a, _b;
      if (blockNodes.has(successor)) {
        return successor;
      }
      const successorBlock = fn.body.blocks.get(successor);
      if (successorBlock.kind === "block" || successorBlock.kind === "catch") {
        const childNode = {
          kind: "node",
          id: terminal.id,
          children: [],
          valueRange: null,
        };
        node.children.push(childNode);
        blockNodes.set(successor, childNode);
      } else if (
        node.valueRange === null ||
        terminal.kind === "ternary" ||
        terminal.kind === "logical" ||
        terminal.kind === "optional"
      ) {
        const childNode = {
          kind: "node",
          id: terminal.id,
          children: [],
          valueRange: null,
        };
        if (node.valueRange === null) {
          CompilerError.invariant(fallthrough !== null, {
            reason: `Expected a fallthrough for value block`,
            loc: terminal.loc,
          });
          const fallthroughBlock = fn.body.blocks.get(fallthrough);
          const nextId =
            (_b =
              (_a = fallthroughBlock.instructions[0]) === null || _a === void 0
                ? void 0
                : _a.id) !== null && _b !== void 0
              ? _b
              : fallthroughBlock.terminal.id;
          childNode.valueRange = { start: terminal.id, end: nextId };
        } else {
          childNode.valueRange = node.valueRange;
        }
        node.children.push(childNode);
        blockNodes.set(successor, childNode);
      } else {
        blockNodes.set(successor, node);
      }
      return successor;
    });
  }
}
function flattenReactiveLoopsHIR(fn) {
  const activeLoops = Array();
  for (const [, block] of fn.body.blocks) {
    retainWhere(activeLoops, (id) => id !== block.id);
    const { terminal: terminal } = block;
    switch (terminal.kind) {
      case "do-while":
      case "for":
      case "for-in":
      case "for-of":
      case "while": {
        activeLoops.push(terminal.fallthrough);
        break;
      }
      case "scope": {
        if (activeLoops.length !== 0) {
          block.terminal = {
            kind: "pruned-scope",
            block: terminal.block,
            fallthrough: terminal.fallthrough,
            id: terminal.id,
            loc: terminal.loc,
            scope: terminal.scope,
          };
        }
        break;
      }
      case "branch":
      case "goto":
      case "if":
      case "label":
      case "logical":
      case "maybe-throw":
      case "optional":
      case "pruned-scope":
      case "return":
      case "sequence":
      case "switch":
      case "ternary":
      case "throw":
      case "try":
      case "unreachable":
      case "unsupported": {
        break;
      }
      default: {
        assertExhaustive$1(
          terminal,
          `Unexpected terminal kind \`${terminal.kind}\``
        );
      }
    }
  }
}
function flattenScopesWithHooksOrUseHIR(fn) {
  var _a, _b;
  const activeScopes = [];
  const prune = [];
  for (const [, block] of fn.body.blocks) {
    const firstId =
      (_b =
        (_a = block.instructions[0]) === null || _a === void 0
          ? void 0
          : _a.id) !== null && _b !== void 0
        ? _b
        : block.terminal.id;
    retainWhere(activeScopes, (current) => current.scope.range.end > firstId);
    for (const instr of block.instructions) {
      const { value: value } = instr;
      switch (value.kind) {
        case "MethodCall":
        case "CallExpression": {
          const callee =
            value.kind === "MethodCall" ? value.property : value.callee;
          if (
            getHookKind(fn.env, callee.identifier) != null ||
            isUseOperator(callee.identifier)
          ) {
            prune.push(...activeScopes.map((entry) => entry.block));
            activeScopes.length = 0;
          }
        }
      }
    }
    if (block.terminal.kind === "scope") {
      activeScopes.push({ block: block.id, scope: block.terminal.scope });
    }
  }
  for (const id of prune) {
    const block = fn.body.blocks.get(id);
    const terminal = block.terminal;
    CompilerError.invariant(terminal.kind === "scope", {
      reason: `Expected block to have a scope terminal`,
      description: `Expected block bb${block.id} to end in a scope terminal`,
      loc: terminal.loc,
    });
    const body = fn.body.blocks.get(terminal.block);
    if (
      body.instructions.length === 1 &&
      body.terminal.kind === "goto" &&
      body.terminal.block === terminal.fallthrough
    ) {
      block.terminal = {
        kind: "label",
        block: terminal.block,
        fallthrough: terminal.fallthrough,
        id: terminal.id,
        loc: terminal.loc,
      };
      continue;
    }
    block.terminal = {
      kind: "pruned-scope",
      block: terminal.block,
      fallthrough: terminal.fallthrough,
      id: terminal.id,
      loc: terminal.loc,
      scope: terminal.scope,
    };
  }
}
function pruneAlwaysInvalidatingScopes(fn) {
  visitReactiveFunction(fn, new Transform(), false);
}
class Transform extends ReactiveFunctionTransform {
  constructor() {
    super(...arguments);
    this.alwaysInvalidatingValues = new Set();
    this.unmemoizedValues = new Set();
  }
  transformInstruction(instruction, withinScope) {
    this.visitInstruction(instruction, withinScope);
    const { lvalue: lvalue, value: value } = instruction;
    switch (value.kind) {
      case "ArrayExpression":
      case "ObjectExpression":
      case "JsxExpression":
      case "JsxFragment":
      case "NewExpression": {
        if (lvalue !== null) {
          this.alwaysInvalidatingValues.add(lvalue.identifier);
          if (!withinScope) {
            this.unmemoizedValues.add(lvalue.identifier);
          }
        }
        break;
      }
      case "StoreLocal": {
        if (this.alwaysInvalidatingValues.has(value.value.identifier)) {
          this.alwaysInvalidatingValues.add(value.lvalue.place.identifier);
        }
        if (this.unmemoizedValues.has(value.value.identifier)) {
          this.unmemoizedValues.add(value.lvalue.place.identifier);
        }
        break;
      }
      case "LoadLocal": {
        if (
          lvalue !== null &&
          this.alwaysInvalidatingValues.has(value.place.identifier)
        ) {
          this.alwaysInvalidatingValues.add(lvalue.identifier);
        }
        if (
          lvalue !== null &&
          this.unmemoizedValues.has(value.place.identifier)
        ) {
          this.unmemoizedValues.add(lvalue.identifier);
        }
        break;
      }
    }
    return { kind: "keep" };
  }
  transformScope(scopeBlock, _withinScope) {
    this.visitScope(scopeBlock, true);
    for (const dep of scopeBlock.scope.dependencies) {
      if (this.unmemoizedValues.has(dep.identifier)) {
        for (const [_, decl] of scopeBlock.scope.declarations) {
          if (this.alwaysInvalidatingValues.has(decl.identifier)) {
            this.unmemoizedValues.add(decl.identifier);
          }
        }
        for (const identifier of scopeBlock.scope.reassignments) {
          if (this.alwaysInvalidatingValues.has(identifier)) {
            this.unmemoizedValues.add(identifier);
          }
        }
        return {
          kind: "replace",
          value: {
            kind: "pruned-scope",
            scope: scopeBlock.scope,
            instructions: scopeBlock.instructions,
          },
        };
      }
    }
    return { kind: "keep" };
  }
}
let Visitor$1 = class Visitor extends ReactiveFunctionVisitor {
  constructor(env, aliases, paths) {
    super();
    this.map = new Map();
    this.aliases = aliases;
    this.paths = paths;
    this.env = env;
  }
  join(values) {
    function join2(l, r) {
      if (l === "Update" || r === "Update") {
        return "Update";
      } else if (l === "Create" || r === "Create") {
        return "Create";
      } else if (l === "Unknown" || r === "Unknown") {
        return "Unknown";
      }
      assertExhaustive$1(r, `Unhandled variable kind ${r}`);
    }
    return values.reduce(join2, "Unknown");
  }
  isCreateOnlyHook(id) {
    return isUseStateType(id) || isUseRefType(id);
  }
  visitPlace(_, place, state) {
    var _a;
    this.map.set(
      place.identifier.id,
      this.join([
        state,
        (_a = this.map.get(place.identifier.id)) !== null && _a !== void 0
          ? _a
          : "Unknown",
      ])
    );
  }
  visitBlock(block, state) {
    super.visitBlock([...block].reverse(), state);
  }
  visitInstruction(instruction) {
    const state = this.join(
      [...eachInstructionLValue(instruction)].map((operand) => {
        var _a;
        return (_a = this.map.get(operand.identifier.id)) !== null &&
          _a !== void 0
          ? _a
          : "Unknown";
      })
    );
    const visitCallOrMethodNonArgs = () => {
      switch (instruction.value.kind) {
        case "CallExpression": {
          this.visitPlace(instruction.id, instruction.value.callee, state);
          break;
        }
        case "MethodCall": {
          this.visitPlace(instruction.id, instruction.value.property, state);
          this.visitPlace(instruction.id, instruction.value.receiver, state);
          break;
        }
      }
    };
    const isHook = () => {
      let callee = null;
      switch (instruction.value.kind) {
        case "CallExpression": {
          callee = instruction.value.callee.identifier;
          break;
        }
        case "MethodCall": {
          callee = instruction.value.property.identifier;
          break;
        }
      }
      return callee != null && getHookKind(this.env, callee) != null;
    };
    switch (instruction.value.kind) {
      case "CallExpression":
      case "MethodCall": {
        if (
          instruction.lvalue &&
          this.isCreateOnlyHook(instruction.lvalue.identifier)
        ) {
          [...eachCallArgument(instruction.value.args)].forEach((operand) =>
            this.visitPlace(instruction.id, operand, "Create")
          );
          visitCallOrMethodNonArgs();
        } else {
          this.traverseInstruction(instruction, isHook() ? "Update" : state);
        }
        break;
      }
      default: {
        this.traverseInstruction(instruction, state);
      }
    }
  }
  visitScope(scope) {
    const state = this.join(
      [
        ...scope.scope.declarations.keys(),
        ...[...scope.scope.reassignments.values()].map((ident) => ident.id),
      ].map((id) => {
        var _a;
        return (_a = this.map.get(id)) !== null && _a !== void 0
          ? _a
          : "Unknown";
      })
    );
    super.visitScope(scope, state);
    [...scope.scope.dependencies].forEach((ident) => {
      var _a;
      let target =
        (_a = this.aliases.find(ident.identifier.id)) !== null && _a !== void 0
          ? _a
          : ident.identifier.id;
      ident.path.forEach((key) => {
        var _a;
        target &&
          (target =
            (_a = this.paths.get(target)) === null || _a === void 0
              ? void 0
              : _a.get(key));
      });
      if (target && this.map.get(target) === "Create") {
        scope.scope.dependencies.delete(ident);
      }
    });
  }
  visitTerminal(stmt, state) {
    CompilerError.invariant(state !== "Create", {
      reason: "Visiting a terminal statement with state 'Create'",
      loc: stmt.terminal.loc,
    });
    super.visitTerminal(stmt, state);
  }
  visitReactiveFunctionValue(_id, _dependencies, fn, state) {
    visitReactiveFunction(fn, this, state);
  }
};
function pruneInitializationDependencies(fn) {
  const [aliases, paths] = getAliases(fn);
  visitReactiveFunction(fn, new Visitor$1(fn.env, aliases, paths), "Update");
}
function update(map, key, path, value) {
  var _a;
  const inner = (_a = map.get(key)) !== null && _a !== void 0 ? _a : new Map();
  inner.set(path, value);
  map.set(key, inner);
}
class AliasVisitor extends ReactiveFunctionVisitor {
  constructor() {
    super(...arguments);
    this.scopeIdentifiers = new DisjointSet();
    this.scopePaths = new Map();
  }
  visitInstruction(instr) {
    if (
      instr.value.kind === "StoreLocal" ||
      instr.value.kind === "StoreContext"
    ) {
      this.scopeIdentifiers.union([
        instr.value.lvalue.place.identifier.id,
        instr.value.value.identifier.id,
      ]);
    } else if (
      instr.value.kind === "LoadLocal" ||
      instr.value.kind === "LoadContext"
    ) {
      instr.lvalue &&
        this.scopeIdentifiers.union([
          instr.lvalue.identifier.id,
          instr.value.place.identifier.id,
        ]);
    } else if (instr.value.kind === "PropertyLoad") {
      instr.lvalue &&
        update(
          this.scopePaths,
          instr.value.object.identifier.id,
          instr.value.property,
          instr.lvalue.identifier.id
        );
    } else if (instr.value.kind === "PropertyStore") {
      update(
        this.scopePaths,
        instr.value.object.identifier.id,
        instr.value.property,
        instr.value.value.identifier.id
      );
    }
  }
}
function getAliases(fn) {
  var _a, _b;
  const visitor = new AliasVisitor();
  visitReactiveFunction(fn, visitor, null);
  let disjoint = visitor.scopeIdentifiers;
  let scopePaths = new Map();
  for (const [key, value] of visitor.scopePaths) {
    for (const [path, id] of value) {
      update(
        scopePaths,
        (_a = disjoint.find(key)) !== null && _a !== void 0 ? _a : key,
        path,
        (_b = disjoint.find(id)) !== null && _b !== void 0 ? _b : id
      );
    }
  }
  return [disjoint, scopePaths];
}
function isPrimitiveBinaryOp(op) {
  switch (op) {
    case "+":
    case "-":
    case "/":
    case "%":
    case "*":
    case "**":
    case "&":
    case "|":
    case ">>":
    case "<<":
    case "^":
    case ">":
    case "<":
    case ">=":
    case "<=":
    case "|>":
      return true;
    default:
      return false;
  }
}
function inferTypes(func) {
  const unifier = new Unifier(func.env);
  for (const e of generate(func)) {
    unifier.unify(e.left, e.right);
  }
  apply(func, unifier);
}
function apply(func, unifier) {
  for (const [_, block] of func.body.blocks) {
    for (const phi of block.phis) {
      phi.type = unifier.get(phi.type);
    }
    for (const instr of block.instructions) {
      for (const operand of eachInstructionLValue(instr)) {
        operand.identifier.type = unifier.get(operand.identifier.type);
      }
      for (const place of eachInstructionOperand(instr)) {
        place.identifier.type = unifier.get(place.identifier.type);
      }
      const { lvalue: lvalue, value: value } = instr;
      lvalue.identifier.type = unifier.get(lvalue.identifier.type);
      if (
        value.kind === "FunctionExpression" ||
        value.kind === "ObjectMethod"
      ) {
        apply(value.loweredFunc.func, unifier);
      }
    }
  }
}
function equation(left, right) {
  return { left: left, right: right };
}
function* generate(func) {
  if (func.env.fnType === "Component") {
    const [props, ref] = func.params;
    if (props && props.kind === "Identifier") {
      yield equation(props.identifier.type, {
        kind: "Object",
        shapeId: BuiltInPropsId,
      });
    }
    if (ref && ref.kind === "Identifier") {
      yield equation(ref.identifier.type, {
        kind: "Object",
        shapeId: BuiltInUseRefId,
      });
    }
  }
  const names = new Map();
  for (const [_, block] of func.body.blocks) {
    for (const phi of block.phis) {
      yield equation(phi.type, {
        kind: "Phi",
        operands: [...phi.operands.values()].map((id) => id.type),
      });
    }
    for (const instr of block.instructions) {
      yield* generateInstructionTypes(func.env, names, instr);
    }
  }
}
function setName(names, id, name) {
  var _a;
  if (
    ((_a = name.name) === null || _a === void 0 ? void 0 : _a.kind) === "named"
  ) {
    names.set(id, name.name.value);
  }
}
function getName(names, id) {
  var _a;
  return (_a = names.get(id)) !== null && _a !== void 0 ? _a : "";
}
function* generateInstructionTypes(env, names, instr) {
  const { lvalue: lvalue, value: value } = instr;
  const left = lvalue.identifier.type;
  switch (value.kind) {
    case "TemplateLiteral":
    case "JSXText":
    case "Primitive": {
      yield equation(left, { kind: "Primitive" });
      break;
    }
    case "UnaryExpression": {
      yield equation(left, { kind: "Primitive" });
      break;
    }
    case "LoadLocal": {
      setName(names, lvalue.identifier.id, value.place.identifier);
      yield equation(left, value.place.identifier.type);
      break;
    }
    case "DeclareContext":
    case "StoreContext":
    case "LoadContext": {
      break;
    }
    case "StoreLocal": {
      if (env.config.enableUseTypeAnnotations) {
        yield equation(
          value.lvalue.place.identifier.type,
          value.value.identifier.type
        );
        const valueType =
          value.type === null ? makeType() : lowerType(value.type);
        yield equation(valueType, value.lvalue.place.identifier.type);
        yield equation(left, valueType);
      } else {
        yield equation(left, value.value.identifier.type);
        yield equation(
          value.lvalue.place.identifier.type,
          value.value.identifier.type
        );
      }
      break;
    }
    case "StoreGlobal": {
      yield equation(left, value.value.identifier.type);
      break;
    }
    case "BinaryExpression": {
      if (isPrimitiveBinaryOp(value.operator)) {
        yield equation(value.left.identifier.type, { kind: "Primitive" });
        yield equation(value.right.identifier.type, { kind: "Primitive" });
      }
      yield equation(left, { kind: "Primitive" });
      break;
    }
    case "PostfixUpdate":
    case "PrefixUpdate": {
      yield equation(value.value.identifier.type, { kind: "Primitive" });
      yield equation(value.lvalue.identifier.type, { kind: "Primitive" });
      yield equation(left, { kind: "Primitive" });
      break;
    }
    case "LoadGlobal": {
      const globalType = env.getGlobalDeclaration(value.binding);
      if (globalType) {
        yield equation(left, globalType);
      }
      break;
    }
    case "CallExpression": {
      yield equation(value.callee.identifier.type, {
        kind: "Function",
        shapeId: null,
        return: left,
      });
      break;
    }
    case "ObjectExpression": {
      for (const property of value.properties) {
        if (
          property.kind === "ObjectProperty" &&
          property.key.kind === "computed"
        ) {
          yield equation(property.key.name.identifier.type, {
            kind: "Primitive",
          });
        }
      }
      yield equation(left, { kind: "Object", shapeId: BuiltInObjectId });
      break;
    }
    case "ArrayExpression": {
      yield equation(left, { kind: "Object", shapeId: BuiltInArrayId });
      break;
    }
    case "PropertyLoad": {
      yield equation(left, {
        kind: "Property",
        objectType: value.object.identifier.type,
        objectName: getName(names, value.object.identifier.id),
        propertyName: value.property,
      });
      break;
    }
    case "MethodCall": {
      const returnType = makeType();
      yield equation(value.property.identifier.type, {
        kind: "Function",
        return: returnType,
        shapeId: null,
      });
      yield equation(left, returnType);
      break;
    }
    case "Destructure": {
      const pattern = value.lvalue.pattern;
      if (pattern.kind === "ArrayPattern") {
        for (let i = 0; i < pattern.items.length; i++) {
          const item = pattern.items[i];
          if (item.kind === "Identifier") {
            const propertyName = String(i);
            yield equation(item.identifier.type, {
              kind: "Property",
              objectType: value.value.identifier.type,
              objectName: getName(names, value.value.identifier.id),
              propertyName: propertyName,
            });
          } else {
            break;
          }
        }
      } else {
        for (const property of pattern.properties) {
          if (property.kind === "ObjectProperty") {
            if (
              property.key.kind === "identifier" ||
              property.key.kind === "string"
            ) {
              yield equation(property.place.identifier.type, {
                kind: "Property",
                objectType: value.value.identifier.type,
                objectName: getName(names, value.value.identifier.id),
                propertyName: property.key.name,
              });
            }
          }
        }
      }
      break;
    }
    case "TypeCastExpression": {
      if (env.config.enableUseTypeAnnotations) {
        yield equation(value.type, value.value.identifier.type);
        yield equation(left, value.type);
      } else {
        yield equation(left, value.value.identifier.type);
      }
      break;
    }
    case "PropertyDelete":
    case "ComputedDelete": {
      yield equation(left, { kind: "Primitive" });
      break;
    }
    case "FunctionExpression": {
      yield* generate(value.loweredFunc.func);
      yield equation(left, { kind: "Object", shapeId: BuiltInFunctionId });
      break;
    }
    case "NextPropertyOf": {
      yield equation(left, { kind: "Primitive" });
      break;
    }
    case "ObjectMethod": {
      yield* generate(value.loweredFunc.func);
      yield equation(left, { kind: "ObjectMethod" });
      break;
    }
    case "JsxExpression":
    case "JsxFragment": {
      yield equation(left, { kind: "Object", shapeId: BuiltInJsxId });
      break;
    }
    case "PropertyStore":
    case "DeclareLocal":
    case "NewExpression":
    case "RegExpLiteral":
    case "MetaProperty":
    case "ComputedStore":
    case "ComputedLoad":
    case "TaggedTemplateExpression":
    case "Await":
    case "GetIterator":
    case "IteratorNext":
    case "UnsupportedNode":
    case "Debugger":
    case "FinishMemoize":
    case "StartMemoize": {
      break;
    }
    default:
      assertExhaustive$1(value, `Unhandled instruction value kind: ${value}`);
  }
}
class Unifier {
  constructor(env) {
    this.substitutions = new Map();
    this.env = env;
  }
  unify(tA, tB) {
    if (tB.kind === "Property") {
      if (
        this.env.config.enableTreatRefLikeIdentifiersAsRefs &&
        isRefLikeName(tB)
      ) {
        this.unify(tB.objectType, { kind: "Object", shapeId: BuiltInUseRefId });
        this.unify(tA, { kind: "Object", shapeId: BuiltInRefValueId });
        return;
      }
      const objectType = this.get(tB.objectType);
      const propertyType = this.env.getPropertyType(
        objectType,
        tB.propertyName
      );
      if (propertyType !== null) {
        this.unify(tA, propertyType);
      }
      return;
    }
    if (typeEquals(tA, tB)) {
      return;
    }
    if (tA.kind === "Type") {
      this.bindVariableTo(tA, tB);
      return;
    }
    if (tB.kind === "Type") {
      this.bindVariableTo(tB, tA);
      return;
    }
    if (tB.kind === "Function" && tA.kind === "Function") {
      this.unify(tA.return, tB.return);
      return;
    }
  }
  bindVariableTo(v, type) {
    if (type.kind === "Poly") {
      return;
    }
    if (this.substitutions.has(v.id)) {
      this.unify(this.substitutions.get(v.id), type);
      return;
    }
    if (type.kind === "Type" && this.substitutions.has(type.id)) {
      this.unify(v, this.substitutions.get(type.id));
      return;
    }
    if (type.kind === "Phi") {
      const operands = new Set(type.operands.map((i) => this.get(i).kind));
      CompilerError.invariant(operands.size > 0, {
        reason: "there should be at least one operand",
        description: null,
        loc: null,
        suggestions: null,
      });
      const kind = operands.values().next().value;
      if (operands.size === 1 && kind !== "Type") {
        this.unify(v, type.operands[0]);
        return;
      }
    }
    if (this.occursCheck(v, type)) {
      throw new Error("cycle detected");
    }
    this.substitutions.set(v.id, type);
  }
  occursCheck(v, type) {
    if (typeEquals(v, type)) return true;
    if (type.kind === "Type" && this.substitutions.has(type.id)) {
      return this.occursCheck(v, this.substitutions.get(type.id));
    }
    if (type.kind === "Phi") {
      return type.operands.some((o) => this.occursCheck(v, o));
    }
    if (type.kind === "Function") {
      return this.occursCheck(v, type.return);
    }
    return false;
  }
  get(type) {
    if (type.kind === "Type") {
      if (this.substitutions.has(type.id)) {
        return this.get(this.substitutions.get(type.id));
      }
    }
    if (type.kind === "Phi") {
      return { kind: "Phi", operands: type.operands.map((o) => this.get(o)) };
    }
    return type;
  }
}
const RefLikeNameRE = /^(?:[a-zA-Z$_][a-zA-Z$_0-9]*)Ref$|^ref$/;
function isRefLikeName(t) {
  return RefLikeNameRE.test(t.objectName) && t.propertyName === "current";
}
function validateContextVariableLValues(fn) {
  const identifierKinds = new Map();
  validateContextVariableLValuesImpl(fn, identifierKinds);
}
function validateContextVariableLValuesImpl(fn, identifierKinds) {
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      const { value: value } = instr;
      switch (value.kind) {
        case "DeclareContext":
        case "StoreContext": {
          visit(identifierKinds, value.lvalue.place, "context");
          break;
        }
        case "LoadContext": {
          visit(identifierKinds, value.place, "context");
          break;
        }
        case "StoreLocal":
        case "DeclareLocal": {
          visit(identifierKinds, value.lvalue.place, "local");
          break;
        }
        case "LoadLocal": {
          visit(identifierKinds, value.place, "local");
          break;
        }
        case "PostfixUpdate":
        case "PrefixUpdate": {
          visit(identifierKinds, value.lvalue, "local");
          break;
        }
        case "Destructure": {
          for (const lvalue of eachPatternOperand(value.lvalue.pattern)) {
            visit(identifierKinds, lvalue, "destructure");
          }
          break;
        }
        case "ObjectMethod":
        case "FunctionExpression": {
          validateContextVariableLValuesImpl(
            value.loweredFunc.func,
            identifierKinds
          );
          break;
        }
        default: {
          for (const _ of eachInstructionValueLValue(value)) {
            CompilerError.throwTodo({
              reason:
                "ValidateContextVariableLValues: unhandled instruction variant",
              loc: value.loc,
              description: `Handle '${value.kind} lvalues`,
              suggestions: null,
            });
          }
        }
      }
    }
  }
}
function visit(identifiers, place, kind) {
  const prev = identifiers.get(place.identifier.id);
  if (prev !== undefined) {
    const wasContext = prev.kind === "context";
    const isContext = kind === "context";
    if (wasContext !== isContext) {
      if (prev.kind === "destructure" || kind === "destructure") {
        CompilerError.throwTodo({
          reason: `Support destructuring of context variables`,
          loc: kind === "destructure" ? place.loc : prev.place.loc,
          description: null,
          suggestions: null,
        });
      }
      CompilerError.invariant(false, {
        reason: `Expected all references to a variable to be consistently local or context references`,
        loc: place.loc,
        description: `Identifier ${printPlace(place)} is referenced as a ${kind} variable, but was previously referenced as a ${prev} variable`,
        suggestions: null,
      });
    }
  }
  identifiers.set(place.identifier.id, { place: place, kind: kind });
}
function computeUnconditionalBlocks(fn) {
  const unconditionalBlocks = new Set();
  const dominators = computePostDominatorTree(fn, {
    includeThrowsAsExitNode: false,
  });
  const exit = dominators.exit;
  let current = fn.body.entry;
  while (current !== null && current !== exit) {
    CompilerError.invariant(!unconditionalBlocks.has(current), {
      reason:
        "Internal error: non-terminating loop in ComputeUnconditionalBlocks",
      loc: null,
      suggestions: null,
    });
    unconditionalBlocks.add(current);
    current = dominators.get(current);
  }
  return unconditionalBlocks;
}
var Kind;
(function (Kind) {
  Kind["Error"] = "Error";
  Kind["KnownHook"] = "KnownHook";
  Kind["PotentialHook"] = "PotentialHook";
  Kind["Global"] = "Global";
  Kind["Local"] = "Local";
})(Kind || (Kind = {}));
function joinKinds(a, b) {
  if (a === Kind.Error || b === Kind.Error) {
    return Kind.Error;
  } else if (a === Kind.KnownHook || b === Kind.KnownHook) {
    return Kind.KnownHook;
  } else if (a === Kind.PotentialHook || b === Kind.PotentialHook) {
    return Kind.PotentialHook;
  } else if (a === Kind.Global || b === Kind.Global) {
    return Kind.Global;
  } else {
    return Kind.Local;
  }
}
function validateHooksUsage(fn) {
  const unconditionalBlocks = computeUnconditionalBlocks(fn);
  const errors = new CompilerError();
  const errorsByPlace = new Map();
  function recordError(loc, errorDetail) {
    if (typeof loc === "symbol") {
      errors.pushErrorDetail(errorDetail);
    } else {
      errorsByPlace.set(loc, errorDetail);
    }
  }
  function recordConditionalHookError(place) {
    setKind(place, Kind.Error);
    const reason =
      "Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning)";
    const previousError =
      typeof place.loc !== "symbol" ? errorsByPlace.get(place.loc) : undefined;
    if (previousError === undefined || previousError.reason !== reason) {
      recordError(
        place.loc,
        new CompilerErrorDetail({
          description: null,
          reason: reason,
          loc: place.loc,
          severity: ErrorSeverity.InvalidReact,
          suggestions: null,
        })
      );
    }
  }
  function recordInvalidHookUsageError(place) {
    const previousError =
      typeof place.loc !== "symbol" ? errorsByPlace.get(place.loc) : undefined;
    if (previousError === undefined) {
      recordError(
        place.loc,
        new CompilerErrorDetail({
          description: null,
          reason:
            "Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values",
          loc: place.loc,
          severity: ErrorSeverity.InvalidReact,
          suggestions: null,
        })
      );
    }
  }
  function recordDynamicHookUsageError(place) {
    const previousError =
      typeof place.loc !== "symbol" ? errorsByPlace.get(place.loc) : undefined;
    if (previousError === undefined) {
      recordError(
        place.loc,
        new CompilerErrorDetail({
          description: null,
          reason:
            "Hooks must be the same function on every render, but this value may change over time to a different function. See https://react.dev/reference/rules/react-calls-components-and-hooks#dont-dynamically-use-hooks",
          loc: place.loc,
          severity: ErrorSeverity.InvalidReact,
          suggestions: null,
        })
      );
    }
  }
  const valueKinds = new Map();
  function getKindForPlace(place) {
    const knownKind = valueKinds.get(place.identifier.id);
    if (
      place.identifier.name !== null &&
      isHookName$1(place.identifier.name.value)
    ) {
      return joinKinds(
        knownKind !== null && knownKind !== void 0 ? knownKind : Kind.Local,
        Kind.PotentialHook
      );
    } else {
      return knownKind !== null && knownKind !== void 0
        ? knownKind
        : Kind.Local;
    }
  }
  function visitPlace(place) {
    const kind = valueKinds.get(place.identifier.id);
    if (kind === Kind.KnownHook) {
      recordInvalidHookUsageError(place);
    }
  }
  function setKind(place, kind) {
    valueKinds.set(place.identifier.id, kind);
  }
  for (const param of fn.params) {
    const place = param.kind === "Identifier" ? param : param.place;
    const kind = getKindForPlace(place);
    setKind(place, kind);
  }
  for (const [, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      let kind =
        phi.id.name !== null && isHookName$1(phi.id.name.value)
          ? Kind.PotentialHook
          : Kind.Local;
      for (const [, operand] of phi.operands) {
        const operandKind = valueKinds.get(operand.id);
        if (operandKind !== undefined) {
          kind = joinKinds(kind, operandKind);
        }
      }
      valueKinds.set(phi.id.id, kind);
    }
    for (const instr of block.instructions) {
      switch (instr.value.kind) {
        case "LoadGlobal": {
          if (getHookKind(fn.env, instr.lvalue.identifier) != null) {
            setKind(instr.lvalue, Kind.KnownHook);
          } else {
            setKind(instr.lvalue, Kind.Global);
          }
          break;
        }
        case "LoadContext":
        case "LoadLocal": {
          visitPlace(instr.value.place);
          const kind = getKindForPlace(instr.value.place);
          setKind(instr.lvalue, kind);
          break;
        }
        case "StoreLocal":
        case "StoreContext": {
          visitPlace(instr.value.value);
          const kind = joinKinds(
            getKindForPlace(instr.value.value),
            getKindForPlace(instr.value.lvalue.place)
          );
          setKind(instr.value.lvalue.place, kind);
          setKind(instr.lvalue, kind);
          break;
        }
        case "ComputedLoad": {
          visitPlace(instr.value.object);
          const kind = getKindForPlace(instr.value.object);
          setKind(instr.lvalue, joinKinds(getKindForPlace(instr.lvalue), kind));
          break;
        }
        case "PropertyLoad": {
          const objectKind = getKindForPlace(instr.value.object);
          const isHookProperty = isHookName$1(instr.value.property);
          let kind;
          switch (objectKind) {
            case Kind.Error: {
              kind = Kind.Error;
              break;
            }
            case Kind.KnownHook: {
              kind = isHookProperty ? Kind.KnownHook : Kind.Local;
              break;
            }
            case Kind.PotentialHook: {
              kind = Kind.PotentialHook;
              break;
            }
            case Kind.Global: {
              kind = isHookProperty ? Kind.KnownHook : Kind.Global;
              break;
            }
            case Kind.Local: {
              kind = isHookProperty ? Kind.PotentialHook : Kind.Local;
              break;
            }
            default: {
              assertExhaustive$1(
                objectKind,
                `Unexpected kind \`${objectKind}\``
              );
            }
          }
          setKind(instr.lvalue, kind);
          break;
        }
        case "CallExpression": {
          const calleeKind = getKindForPlace(instr.value.callee);
          const isHookCallee =
            calleeKind === Kind.KnownHook || calleeKind === Kind.PotentialHook;
          if (isHookCallee && !unconditionalBlocks.has(block.id)) {
            recordConditionalHookError(instr.value.callee);
          } else if (calleeKind === Kind.PotentialHook) {
            recordDynamicHookUsageError(instr.value.callee);
          }
          for (const operand of eachInstructionOperand(instr)) {
            if (operand === instr.value.callee) {
              continue;
            }
            visitPlace(operand);
          }
          break;
        }
        case "MethodCall": {
          const calleeKind = getKindForPlace(instr.value.property);
          const isHookCallee =
            calleeKind === Kind.KnownHook || calleeKind === Kind.PotentialHook;
          if (isHookCallee && !unconditionalBlocks.has(block.id)) {
            recordConditionalHookError(instr.value.property);
          } else if (calleeKind === Kind.PotentialHook) {
            recordDynamicHookUsageError(instr.value.property);
          }
          for (const operand of eachInstructionOperand(instr)) {
            if (operand === instr.value.property) {
              continue;
            }
            visitPlace(operand);
          }
          break;
        }
        case "Destructure": {
          visitPlace(instr.value.value);
          const objectKind = getKindForPlace(instr.value.value);
          for (const lvalue of eachInstructionLValue(instr)) {
            const isHookProperty =
              lvalue.identifier.name !== null &&
              isHookName$1(lvalue.identifier.name.value);
            let kind;
            switch (objectKind) {
              case Kind.Error: {
                kind = Kind.Error;
                break;
              }
              case Kind.KnownHook: {
                kind = Kind.KnownHook;
                break;
              }
              case Kind.PotentialHook: {
                kind = Kind.PotentialHook;
                break;
              }
              case Kind.Global: {
                kind = isHookProperty ? Kind.KnownHook : Kind.Global;
                break;
              }
              case Kind.Local: {
                kind = isHookProperty ? Kind.PotentialHook : Kind.Local;
                break;
              }
              default: {
                assertExhaustive$1(
                  objectKind,
                  `Unexpected kind \`${objectKind}\``
                );
              }
            }
            setKind(lvalue, kind);
          }
          break;
        }
        case "ObjectMethod":
        case "FunctionExpression": {
          visitFunctionExpression(errors, instr.value.loweredFunc.func);
          break;
        }
        default: {
          for (const operand of eachInstructionOperand(instr)) {
            visitPlace(operand);
          }
          for (const lvalue of eachInstructionLValue(instr)) {
            const kind = getKindForPlace(lvalue);
            setKind(lvalue, kind);
          }
        }
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      visitPlace(operand);
    }
  }
  for (const [, error] of errorsByPlace) {
    errors.push(error);
  }
  if (errors.hasErrors()) {
    throw errors;
  }
}
function visitFunctionExpression(errors, fn) {
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      switch (instr.value.kind) {
        case "ObjectMethod":
        case "FunctionExpression": {
          visitFunctionExpression(errors, instr.value.loweredFunc.func);
          break;
        }
        case "MethodCall":
        case "CallExpression": {
          const callee =
            instr.value.kind === "CallExpression"
              ? instr.value.callee
              : instr.value.property;
          const hookKind = getHookKind(fn.env, callee.identifier);
          if (hookKind != null) {
            errors.pushErrorDetail(
              new CompilerErrorDetail({
                severity: ErrorSeverity.InvalidReact,
                reason:
                  "Hooks must be called at the top level in the body of a function component or custom hook, and may not be called within function expressions. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning)",
                loc: callee.loc,
                description: `Cannot call ${hookKind} within a function component`,
                suggestions: null,
              })
            );
          }
          break;
        }
      }
    }
  }
}
function validateNoCapitalizedCalls(fn) {
  var _a;
  const envConfig = fn.env.config;
  const ALLOW_LIST = new Set([
    ...DEFAULT_GLOBALS.keys(),
    ...((_a = envConfig.validateNoCapitalizedCalls) !== null && _a !== void 0
      ? _a
      : []),
  ]);
  const hookPattern =
    envConfig.hookPattern != null ? new RegExp(envConfig.hookPattern) : null;
  const isAllowed = (name) =>
    ALLOW_LIST.has(name) || (hookPattern != null && hookPattern.test(name));
  const capitalLoadGlobals = new Map();
  const capitalizedProperties = new Map();
  const reason =
    "Capitalized functions are reserved for components, which must be invoked with JSX. If this is a component, render it with JSX. Otherwise, ensure that it has no hook calls and rename it to begin with a lowercase letter. Alternatively, if you know for a fact that this function is not a component, you can allowlist it via the compiler config";
  for (const [, block] of fn.body.blocks) {
    for (const { lvalue: lvalue, value: value } of block.instructions) {
      switch (value.kind) {
        case "LoadGlobal": {
          if (
            value.binding.name != "" &&
            /^[A-Z]/.test(value.binding.name) &&
            !(value.binding.name.toUpperCase() === value.binding.name) &&
            !isAllowed(value.binding.name)
          ) {
            capitalLoadGlobals.set(lvalue.identifier.id, value.binding.name);
          }
          break;
        }
        case "CallExpression": {
          const calleeIdentifier = value.callee.identifier.id;
          const calleeName = capitalLoadGlobals.get(calleeIdentifier);
          if (calleeName != null) {
            CompilerError.throwInvalidReact({
              reason: reason,
              description: `${calleeName} may be a component.`,
              loc: value.loc,
              suggestions: null,
            });
          }
          break;
        }
        case "PropertyLoad": {
          if (/^[A-Z]/.test(value.property)) {
            capitalizedProperties.set(lvalue.identifier.id, value.property);
          }
          break;
        }
        case "MethodCall": {
          const propertyIdentifier = value.property.identifier.id;
          const propertyName = capitalizedProperties.get(propertyIdentifier);
          if (propertyName != null) {
            CompilerError.throwInvalidReact({
              reason: reason,
              description: `${propertyName} may be a component.`,
              loc: value.loc,
              suggestions: null,
            });
          }
          break;
        }
      }
    }
  }
}
function validateNoRefAccessInRender(fn) {
  const refAccessingFunctions = new Set();
  validateNoRefAccessInRenderImpl(fn, refAccessingFunctions).unwrap();
}
function validateNoRefAccessInRenderImpl(fn, refAccessingFunctions) {
  const errors = new CompilerError();
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      switch (instr.value.kind) {
        case "JsxExpression":
        case "JsxFragment": {
          for (const operand of eachInstructionValueOperand(instr.value)) {
            if (isRefValueType(operand.identifier)) {
              errors.push({
                severity: ErrorSeverity.InvalidReact,
                reason:
                  "Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef)",
                loc: operand.loc,
                description: `Cannot access ref value at ${printPlace(operand)}`,
                suggestions: null,
              });
            }
          }
          break;
        }
        case "PropertyLoad": {
          break;
        }
        case "LoadLocal": {
          if (refAccessingFunctions.has(instr.value.place.identifier.id)) {
            refAccessingFunctions.add(instr.lvalue.identifier.id);
          }
          break;
        }
        case "StoreLocal": {
          if (refAccessingFunctions.has(instr.value.value.identifier.id)) {
            refAccessingFunctions.add(instr.value.lvalue.place.identifier.id);
            refAccessingFunctions.add(instr.lvalue.identifier.id);
          }
          break;
        }
        case "ObjectMethod":
        case "FunctionExpression": {
          if (
            [...eachInstructionValueOperand(instr.value)].some(
              (operand) =>
                isRefValueType(operand.identifier) ||
                refAccessingFunctions.has(operand.identifier.id)
            ) ||
            ([...eachInstructionValueOperand(instr.value)].some((operand) =>
              isUseRefType(operand.identifier)
            ) &&
              validateNoRefAccessInRenderImpl(
                instr.value.loweredFunc.func,
                refAccessingFunctions
              ).isErr())
          ) {
            refAccessingFunctions.add(instr.lvalue.identifier.id);
          }
          break;
        }
        case "MethodCall": {
          if (!isEffectHook(instr.value.property.identifier)) {
            for (const operand of eachInstructionValueOperand(instr.value)) {
              validateNoRefAccess(
                errors,
                refAccessingFunctions,
                operand,
                operand.loc
              );
            }
          }
          break;
        }
        case "CallExpression": {
          const callee = instr.value.callee;
          const isUseEffect = isEffectHook(callee.identifier);
          if (!isUseEffect) {
            if (refAccessingFunctions.has(callee.identifier.id)) {
              errors.push({
                severity: ErrorSeverity.InvalidReact,
                reason:
                  "This function accesses a ref value (the `current` property), which may not be accessed during render. (https://react.dev/reference/react/useRef)",
                loc: callee.loc,
                description: `Function ${printPlace(callee)} accesses a ref`,
                suggestions: null,
              });
            }
            for (const operand of eachInstructionValueOperand(instr.value)) {
              validateNoRefAccess(
                errors,
                refAccessingFunctions,
                operand,
                operand.loc
              );
            }
          }
          break;
        }
        case "ObjectExpression":
        case "ArrayExpression": {
          for (const operand of eachInstructionValueOperand(instr.value)) {
            validateNoRefAccess(
              errors,
              refAccessingFunctions,
              operand,
              operand.loc
            );
          }
          break;
        }
        case "PropertyDelete":
        case "PropertyStore":
        case "ComputedDelete":
        case "ComputedStore": {
          validateNoRefAccess(
            errors,
            refAccessingFunctions,
            instr.value.object,
            instr.loc
          );
          for (const operand of eachInstructionValueOperand(instr.value)) {
            if (operand === instr.value.object) {
              continue;
            }
            validateNoRefValueAccess(errors, refAccessingFunctions, operand);
          }
          break;
        }
        default: {
          for (const operand of eachInstructionValueOperand(instr.value)) {
            validateNoRefValueAccess(errors, refAccessingFunctions, operand);
          }
          break;
        }
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      validateNoRefValueAccess(errors, refAccessingFunctions, operand);
    }
  }
  if (errors.hasErrors()) {
    return Err(errors);
  } else {
    return Ok(undefined);
  }
}
function validateNoRefValueAccess(errors, refAccessingFunctions, operand) {
  if (
    isRefValueType(operand.identifier) ||
    refAccessingFunctions.has(operand.identifier.id)
  ) {
    errors.push({
      severity: ErrorSeverity.InvalidReact,
      reason:
        "Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef)",
      loc: operand.loc,
      description: `Cannot access ref value at ${printPlace(operand)}`,
      suggestions: null,
    });
  }
}
function validateNoRefAccess(errors, refAccessingFunctions, operand, loc) {
  if (
    isRefValueType(operand.identifier) ||
    isUseRefType(operand.identifier) ||
    refAccessingFunctions.has(operand.identifier.id)
  ) {
    errors.push({
      severity: ErrorSeverity.InvalidReact,
      reason:
        "Ref values (the `current` property) may not be accessed during render. (https://react.dev/reference/react/useRef)",
      loc: loc,
      description:
        operand.identifier.name !== null &&
        operand.identifier.name.kind === "named"
          ? `Cannot access ref value \`${operand.identifier.name.value}\``
          : null,
      suggestions: null,
    });
  }
}
function validateNoSetStateInRender(fn) {
  const unconditionalSetStateFunctions = new Set();
  validateNoSetStateInRenderImpl(fn, unconditionalSetStateFunctions).unwrap();
}
function validateNoSetStateInRenderImpl(fn, unconditionalSetStateFunctions) {
  const unconditionalBlocks = computeUnconditionalBlocks(fn);
  const errors = new CompilerError();
  for (const [, block] of fn.body.blocks) {
    if (unconditionalBlocks.has(block.id)) {
      for (const instr of block.instructions) {
        switch (instr.value.kind) {
          case "LoadLocal": {
            if (
              unconditionalSetStateFunctions.has(
                instr.value.place.identifier.id
              )
            ) {
              unconditionalSetStateFunctions.add(instr.lvalue.identifier.id);
            }
            break;
          }
          case "StoreLocal": {
            if (
              unconditionalSetStateFunctions.has(
                instr.value.value.identifier.id
              )
            ) {
              unconditionalSetStateFunctions.add(
                instr.value.lvalue.place.identifier.id
              );
              unconditionalSetStateFunctions.add(instr.lvalue.identifier.id);
            }
            break;
          }
          case "ObjectMethod":
          case "FunctionExpression": {
            if (
              [...eachInstructionValueOperand(instr.value)].some(
                (operand) =>
                  isSetStateType(operand.identifier) ||
                  unconditionalSetStateFunctions.has(operand.identifier.id)
              ) &&
              validateNoSetStateInRenderImpl(
                instr.value.loweredFunc.func,
                unconditionalSetStateFunctions
              ).isErr()
            ) {
              unconditionalSetStateFunctions.add(instr.lvalue.identifier.id);
            }
            break;
          }
          case "CallExpression": {
            validateNonSetState(
              errors,
              unconditionalSetStateFunctions,
              instr.value.callee
            );
            break;
          }
        }
      }
    }
  }
  if (errors.hasErrors()) {
    return Err(errors);
  } else {
    return Ok(undefined);
  }
}
function validateNonSetState(errors, unconditionalSetStateFunctions, operand) {
  if (
    isSetStateType(operand.identifier) ||
    unconditionalSetStateFunctions.has(operand.identifier.id)
  ) {
    errors.push({
      reason:
        "This is an unconditional set state during render, which will trigger an infinite loop. (https://react.dev/reference/react/useState)",
      description: null,
      severity: ErrorSeverity.InvalidReact,
      loc: typeof operand.loc !== "symbol" ? operand.loc : null,
      suggestions: null,
    });
  }
}
function validatePreservedManualMemoization(fn) {
  const state = { errors: new CompilerError(), manualMemoState: null };
  visitReactiveFunction(fn, new Visitor(), state);
  if (state.errors.hasErrors()) {
    throw state.errors;
  }
}
var CompareDependencyResult;
(function (CompareDependencyResult) {
  CompareDependencyResult[(CompareDependencyResult["Ok"] = 0)] = "Ok";
  CompareDependencyResult[(CompareDependencyResult["RootDifference"] = 1)] =
    "RootDifference";
  CompareDependencyResult[(CompareDependencyResult["PathDifference"] = 2)] =
    "PathDifference";
  CompareDependencyResult[(CompareDependencyResult["Subpath"] = 3)] = "Subpath";
  CompareDependencyResult[
    (CompareDependencyResult["RefAccessDifference"] = 4)
  ] = "RefAccessDifference";
})(CompareDependencyResult || (CompareDependencyResult = {}));
function compareDeps(inferred, source) {
  const rootsEqual =
    (inferred.root.kind === "Global" &&
      source.root.kind === "Global" &&
      inferred.root.identifierName === source.root.identifierName) ||
    (inferred.root.kind === "NamedLocal" &&
      source.root.kind === "NamedLocal" &&
      inferred.root.value.identifier.id === source.root.value.identifier.id);
  if (!rootsEqual) {
    return CompareDependencyResult.RootDifference;
  }
  let isSubpath = true;
  for (let i = 0; i < Math.min(inferred.path.length, source.path.length); i++) {
    if (inferred.path[i] !== source.path[i]) {
      isSubpath = false;
      break;
    }
  }
  if (
    isSubpath &&
    (source.path.length === inferred.path.length ||
      (inferred.path.length >= source.path.length &&
        !inferred.path.includes("current")))
  ) {
    return CompareDependencyResult.Ok;
  } else {
    if (isSubpath) {
      if (
        source.path.includes("current") ||
        inferred.path.includes("current")
      ) {
        return CompareDependencyResult.RefAccessDifference;
      } else {
        return CompareDependencyResult.Subpath;
      }
    } else {
      return CompareDependencyResult.PathDifference;
    }
  }
}
function validateInferredDep(
  dep,
  temporaries,
  declsWithinMemoBlock,
  validDepsInMemoBlock,
  errorState,
  memoLocation
) {
  var _a;
  let normalizedDep;
  const maybeNormalizedRoot = temporaries.get(dep.identifier.id);
  if (maybeNormalizedRoot != null) {
    normalizedDep = {
      root: maybeNormalizedRoot.root,
      path: [...maybeNormalizedRoot.path, ...dep.path],
    };
  } else {
    CompilerError.invariant(
      ((_a = dep.identifier.name) === null || _a === void 0
        ? void 0
        : _a.kind) === "named",
      {
        reason:
          "ValidatePreservedManualMemoization: expected scope dependency to be named",
        loc: GeneratedSource,
        suggestions: null,
      }
    );
    normalizedDep = {
      root: {
        kind: "NamedLocal",
        value: {
          kind: "Identifier",
          identifier: dep.identifier,
          loc: GeneratedSource,
          effect: Effect.Read,
          reactive: false,
        },
      },
      path: [...dep.path],
    };
  }
  for (const decl of declsWithinMemoBlock) {
    if (
      normalizedDep.root.kind === "NamedLocal" &&
      decl === normalizedDep.root.value.identifier.id
    ) {
      return;
    }
  }
  for (const originalDep of validDepsInMemoBlock) {
    const compareResult = compareDeps(normalizedDep, originalDep);
    if (compareResult === CompareDependencyResult.Ok) {
      return;
    }
  }
  errorState.push({
    severity: ErrorSeverity.CannotPreserveMemoization,
    reason:
      "React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected",
    description: null,
    loc: memoLocation,
    suggestions: null,
  });
}
class Visitor extends ReactiveFunctionVisitor {
  constructor() {
    super(...arguments);
    this.scopes = new Set();
    this.scopeMapping = new Map();
    this.temporaries = new Map();
  }
  collectMaybeMemoDependencies(value, state) {
    var _a, _b;
    switch (value.kind) {
      case "SequenceExpression": {
        for (const instr of value.instructions) {
          this.visitInstruction(instr, state);
        }
        const result = this.collectMaybeMemoDependencies(value.value, state);
        return result;
      }
      case "OptionalExpression": {
        return this.collectMaybeMemoDependencies(value.value, state);
      }
      case "ReactiveFunctionValue":
      case "ConditionalExpression":
      case "LogicalExpression": {
        return null;
      }
      default: {
        const dep = collectMaybeMemoDependencies(value, this.temporaries);
        if (value.kind === "StoreLocal" || value.kind === "StoreContext") {
          const storeTarget = value.lvalue.place;
          (_a = state.manualMemoState) === null || _a === void 0
            ? void 0
            : _a.decls.add(storeTarget.identifier.id);
          if (
            ((_b = storeTarget.identifier.name) === null || _b === void 0
              ? void 0
              : _b.kind) === "named" &&
            dep == null
          ) {
            const dep = {
              root: { kind: "NamedLocal", value: storeTarget },
              path: [],
            };
            this.temporaries.set(storeTarget.identifier.id, dep);
            return dep;
          }
        }
        return dep;
      }
    }
  }
  recordTemporaries(instr, state) {
    var _a, _b, _c;
    const temporaries = this.temporaries;
    const { value: value } = instr;
    const lvalId =
      (_a = instr.lvalue) === null || _a === void 0 ? void 0 : _a.identifier.id;
    if (lvalId != null && temporaries.has(lvalId)) {
      return;
    }
    const isNamedLocal =
      lvalId != null &&
      ((_c =
        (_b = instr.lvalue) === null || _b === void 0
          ? void 0
          : _b.identifier.name) === null || _c === void 0
        ? void 0
        : _c.kind) === "named";
    if (isNamedLocal && state.manualMemoState != null) {
      state.manualMemoState.decls.add(lvalId);
    }
    const maybeDep = this.collectMaybeMemoDependencies(value, state);
    if (lvalId != null) {
      if (maybeDep != null) {
        temporaries.set(lvalId, maybeDep);
      } else if (isNamedLocal) {
        temporaries.set(lvalId, {
          root: { kind: "NamedLocal", value: Object.assign({}, instr.lvalue) },
          path: [],
        });
      }
    }
  }
  visitScope(scopeBlock, state) {
    this.traverseScope(scopeBlock, state);
    if (
      state.manualMemoState != null &&
      state.manualMemoState.depsFromSource != null
    ) {
      for (const dep of scopeBlock.scope.dependencies) {
        validateInferredDep(
          dep,
          this.temporaries,
          state.manualMemoState.decls,
          state.manualMemoState.depsFromSource,
          state.errors,
          state.manualMemoState.loc
        );
      }
    }
    let areDependenciesMemoized = true;
    for (const dep of scopeBlock.scope.dependencies) {
      if (isUnmemoized(dep.identifier, this.scopes)) {
        areDependenciesMemoized = false;
        break;
      }
    }
    if (areDependenciesMemoized) {
      this.scopes.add(scopeBlock.scope.id);
      for (const id of scopeBlock.scope.merged) {
        this.scopes.add(id);
      }
    }
  }
  visitInstruction(instruction, state) {
    var _a, _b;
    this.traverseInstruction(instruction, state);
    this.recordTemporaries(instruction, state);
    if (instruction.value.kind === "StartMemoize") {
      let depsFromSource = null;
      if (instruction.value.deps != null) {
        depsFromSource = instruction.value.deps;
      }
      CompilerError.invariant(state.manualMemoState == null, {
        reason: "Unexpected nested StartMemoize instructions",
        description: `Bad manual memoization ids: ${(_a = state.manualMemoState) === null || _a === void 0 ? void 0 : _a.manualMemoId}, ${instruction.value.manualMemoId}`,
        loc: instruction.value.loc,
        suggestions: null,
      });
      state.manualMemoState = {
        loc: instruction.loc,
        decls: new Set(),
        depsFromSource: depsFromSource,
        manualMemoId: instruction.value.manualMemoId,
      };
    }
    if (instruction.value.kind === "FinishMemoize") {
      CompilerError.invariant(
        state.manualMemoState != null &&
          state.manualMemoState.manualMemoId === instruction.value.manualMemoId,
        {
          reason: "Unexpected mismatch between StartMemoize and FinishMemoize",
          description: `Encountered StartMemoize id=${(_b = state.manualMemoState) === null || _b === void 0 ? void 0 : _b.manualMemoId} followed by FinishMemoize id=${instruction.value.manualMemoId}`,
          loc: instruction.value.loc,
          suggestions: null,
        }
      );
      state.manualMemoState = null;
    }
    const isDep = instruction.value.kind === "StartMemoize";
    const isDecl =
      instruction.value.kind === "FinishMemoize" && !instruction.value.pruned;
    if (isDep || isDecl) {
      for (const value of eachInstructionValueOperand(instruction.value)) {
        if (
          isMutable(instruction, value) ||
          (isDecl && isUnmemoized(value.identifier, this.scopes))
        ) {
          state.errors.push({
            reason:
              "React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This value may be mutated later, which could cause the value to change unexpectedly",
            description: null,
            severity: ErrorSeverity.CannotPreserveMemoization,
            loc: typeof instruction.loc !== "symbol" ? instruction.loc : null,
            suggestions: null,
          });
        }
      }
    }
  }
}
function isUnmemoized(operand, scopes) {
  return operand.scope != null && !scopes.has(operand.scope.id);
}
function validateUseMemo(fn) {
  const useMemos = new Set();
  const react = new Set();
  const functions = new Map();
  for (const [, block] of fn.body.blocks) {
    for (const { lvalue: lvalue, value: value } of block.instructions) {
      switch (value.kind) {
        case "LoadGlobal": {
          if (value.binding.name === "useMemo") {
            useMemos.add(lvalue.identifier.id);
          } else if (value.binding.name === "React") {
            react.add(lvalue.identifier.id);
          }
          break;
        }
        case "PropertyLoad": {
          if (react.has(value.object.identifier.id)) {
            if (value.property === "useMemo") {
              useMemos.add(lvalue.identifier.id);
            }
          }
          break;
        }
        case "FunctionExpression": {
          functions.set(lvalue.identifier.id, value);
          break;
        }
        case "MethodCall":
        case "CallExpression": {
          const callee =
            value.kind === "CallExpression"
              ? value.callee.identifier.id
              : value.property.identifier.id;
          const isUseMemo = useMemos.has(callee);
          if (!isUseMemo || value.args.length === 0) {
            continue;
          }
          const [arg] = value.args;
          if (arg.kind !== "Identifier") {
            continue;
          }
          const body = functions.get(arg.identifier.id);
          if (body === undefined) {
            continue;
          }
          if (body.loweredFunc.func.params.length > 0) {
            CompilerError.throwInvalidReact({
              reason: "useMemo callbacks may not accept any arguments",
              description: null,
              loc: body.loc,
              suggestions: null,
            });
          }
          if (body.loweredFunc.func.async || body.loweredFunc.func.generator) {
            CompilerError.throwInvalidReact({
              reason:
                "useMemo callbacks may not be async or generator functions",
              description: null,
              loc: body.loc,
              suggestions: null,
            });
          }
          break;
        }
      }
    }
  }
}
function* run(
  func,
  config,
  fnType,
  useMemoCacheIdentifier,
  logger,
  filename,
  code
) {
  const contextIdentifiers = findContextIdentifiers(func);
  const env = new Environment(
    fnType,
    config,
    contextIdentifiers,
    logger,
    filename,
    code,
    useMemoCacheIdentifier
  );
  yield {
    kind: "debug",
    name: "EnvironmentConfig",
    value: prettyFormat$1(env.config),
  };
  const ast = yield* runWithEnvironment(func, env);
  return ast;
}
function* runWithEnvironment(func, env) {
  const hir = lower$1(func, env).unwrap();
  yield log({ kind: "hir", name: "HIR", value: hir });
  pruneMaybeThrows(hir);
  yield log({ kind: "hir", name: "PruneMaybeThrows", value: hir });
  validateContextVariableLValues(hir);
  validateUseMemo(hir);
  if (
    !env.config.enablePreserveExistingManualUseMemo &&
    !env.config.disableMemoizationForDebugging &&
    !env.config.enableChangeDetectionForDebugging
  ) {
    dropManualMemoization(hir);
    yield log({ kind: "hir", name: "DropManualMemoization", value: hir });
  }
  inlineImmediatelyInvokedFunctionExpressions(hir);
  yield log({
    kind: "hir",
    name: "InlineImmediatelyInvokedFunctionExpressions",
    value: hir,
  });
  mergeConsecutiveBlocks(hir);
  yield log({ kind: "hir", name: "MergeConsecutiveBlocks", value: hir });
  assertConsistentIdentifiers(hir);
  assertTerminalSuccessorsExist(hir);
  enterSSA(hir);
  yield log({ kind: "hir", name: "SSA", value: hir });
  eliminateRedundantPhi(hir);
  yield log({ kind: "hir", name: "EliminateRedundantPhi", value: hir });
  assertConsistentIdentifiers(hir);
  constantPropagation(hir);
  yield log({ kind: "hir", name: "ConstantPropagation", value: hir });
  inferTypes(hir);
  yield log({ kind: "hir", name: "InferTypes", value: hir });
  if (env.config.validateHooksUsage) {
    validateHooksUsage(hir);
  }
  if (env.config.validateNoCapitalizedCalls) {
    validateNoCapitalizedCalls(hir);
  }
  analyseFunctions(hir);
  yield log({ kind: "hir", name: "AnalyseFunctions", value: hir });
  inferReferenceEffects(hir);
  yield log({ kind: "hir", name: "InferReferenceEffects", value: hir });
  deadCodeElimination(hir);
  yield log({ kind: "hir", name: "DeadCodeElimination", value: hir });
  if (env.config.enableInstructionReordering) {
    instructionReordering(hir);
    yield log({ kind: "hir", name: "InstructionReordering", value: hir });
  }
  pruneMaybeThrows(hir);
  yield log({ kind: "hir", name: "PruneMaybeThrows", value: hir });
  inferMutableRanges(hir);
  yield log({ kind: "hir", name: "InferMutableRanges", value: hir });
  if (env.config.assertValidMutableRanges) {
    assertValidMutableRanges(hir);
  }
  if (env.config.validateRefAccessDuringRender) {
    validateNoRefAccessInRender(hir);
  }
  if (env.config.validateNoSetStateInRender) {
    validateNoSetStateInRender(hir);
  }
  inferReactivePlaces(hir);
  yield log({ kind: "hir", name: "InferReactivePlaces", value: hir });
  leaveSSA(hir);
  yield log({ kind: "hir", name: "LeaveSSA", value: hir });
  inferReactiveScopeVariables(hir);
  yield log({ kind: "hir", name: "InferReactiveScopeVariables", value: hir });
  alignMethodCallScopes(hir);
  yield log({ kind: "hir", name: "AlignMethodCallScopes", value: hir });
  alignObjectMethodScopes(hir);
  yield log({ kind: "hir", name: "AlignObjectMethodScopes", value: hir });
  memoizeFbtAndMacroOperandsInSameScope(hir);
  yield log({
    kind: "hir",
    name: "MemoizeFbtAndMacroOperandsInSameScope",
    value: hir,
  });
  if (env.config.enableReactiveScopesInHIR) {
    pruneUnusedLabelsHIR(hir);
    yield log({ kind: "hir", name: "PruneUnusedLabelsHIR", value: hir });
    alignReactiveScopesToBlockScopesHIR(hir);
    yield log({
      kind: "hir",
      name: "AlignReactiveScopesToBlockScopesHIR",
      value: hir,
    });
    mergeOverlappingReactiveScopesHIR(hir);
    yield log({
      kind: "hir",
      name: "MergeOverlappingReactiveScopesHIR",
      value: hir,
    });
    assertValidBlockNesting(hir);
    buildReactiveScopeTerminalsHIR(hir);
    yield log({
      kind: "hir",
      name: "BuildReactiveScopeTerminalsHIR",
      value: hir,
    });
    assertValidBlockNesting(hir);
    flattenReactiveLoopsHIR(hir);
    yield log({ kind: "hir", name: "FlattenReactiveLoopsHIR", value: hir });
    flattenScopesWithHooksOrUseHIR(hir);
    yield log({
      kind: "hir",
      name: "FlattenScopesWithHooksOrUseHIR",
      value: hir,
    });
  }
  const reactiveFunction = buildReactiveFunction(hir);
  yield log({
    kind: "reactive",
    name: "BuildReactiveFunction",
    value: reactiveFunction,
  });
  assertWellFormedBreakTargets(reactiveFunction);
  pruneUnusedLabels(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "PruneUnusedLabels",
    value: reactiveFunction,
  });
  if (!env.config.enableReactiveScopesInHIR) {
    alignReactiveScopesToBlockScopes(reactiveFunction);
    yield log({
      kind: "reactive",
      name: "AlignReactiveScopesToBlockScopes",
      value: reactiveFunction,
    });
    mergeOverlappingReactiveScopes(reactiveFunction);
    yield log({
      kind: "reactive",
      name: "MergeOverlappingReactiveScopes",
      value: reactiveFunction,
    });
    buildReactiveBlocks(reactiveFunction);
    yield log({
      kind: "reactive",
      name: "BuildReactiveBlocks",
      value: reactiveFunction,
    });
    flattenReactiveLoops(reactiveFunction);
    yield log({
      kind: "reactive",
      name: "FlattenReactiveLoops",
      value: reactiveFunction,
    });
    flattenScopesWithHooksOrUse(reactiveFunction);
    yield log({
      kind: "reactive",
      name: "FlattenScopesWithHooks",
      value: reactiveFunction,
    });
  }
  assertScopeInstructionsWithinScopes(reactiveFunction);
  propagateScopeDependencies(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "PropagateScopeDependencies",
    value: reactiveFunction,
  });
  pruneNonEscapingScopes(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "PruneNonEscapingScopes",
    value: reactiveFunction,
  });
  pruneNonReactiveDependencies(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "PruneNonReactiveDependencies",
    value: reactiveFunction,
  });
  pruneUnusedScopes(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "PruneUnusedScopes",
    value: reactiveFunction,
  });
  mergeReactiveScopesThatInvalidateTogether(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "MergeReactiveScopesThatInvalidateTogether",
    value: reactiveFunction,
  });
  pruneAlwaysInvalidatingScopes(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "PruneAlwaysInvalidatingScopes",
    value: reactiveFunction,
  });
  if (env.config.enableChangeDetectionForDebugging != null) {
    pruneInitializationDependencies(reactiveFunction);
    yield log({
      kind: "reactive",
      name: "PruneInitializationDependencies",
      value: reactiveFunction,
    });
  }
  propagateEarlyReturns(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "PropagateEarlyReturns",
    value: reactiveFunction,
  });
  promoteUsedTemporaries(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "PromoteUsedTemporaries",
    value: reactiveFunction,
  });
  pruneTemporaryLValues(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "PruneUnusedLValues",
    value: reactiveFunction,
  });
  extractScopeDeclarationsFromDestructuring(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "ExtractScopeDeclarationsFromDestructuring",
    value: reactiveFunction,
  });
  stabilizeBlockIds(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "StabilizeBlockIds",
    value: reactiveFunction,
  });
  const uniqueIdentifiers = renameVariables(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "RenameVariables",
    value: reactiveFunction,
  });
  pruneHoistedContexts(reactiveFunction);
  yield log({
    kind: "reactive",
    name: "PruneHoistedContexts",
    value: reactiveFunction,
  });
  if (env.config.validateMemoizedEffectDependencies) {
    validateMemoizedEffectDependencies(reactiveFunction);
  }
  if (
    env.config.enablePreserveExistingMemoizationGuarantees ||
    env.config.validatePreserveExistingMemoizationGuarantees
  ) {
    validatePreservedManualMemoization(reactiveFunction);
  }
  const ast = codegenFunction(reactiveFunction, uniqueIdentifiers).unwrap();
  yield log({ kind: "ast", name: "Codegen", value: ast });
  if (env.config.throwUnknownException__testonly) {
    throw new Error("unexpected error");
  }
  return ast;
}
function compileFn(
  func,
  config,
  fnType,
  useMemoCacheIdentifier,
  logger,
  filename,
  code
) {
  let generator = run(
    func,
    config,
    fnType,
    useMemoCacheIdentifier,
    logger,
    filename,
    code
  );
  while (true) {
    const next = generator.next();
    if (next.done) {
      return next.value;
    }
  }
}
function log(value) {
  switch (value.kind) {
    case "ast": {
      logCodegenFunction(value.name, value.value);
      break;
    }
    case "hir": {
      logHIRFunction(value.name, value.value);
      break;
    }
    case "reactive": {
      logReactiveFunction(value.name, value.value);
      break;
    }
    case "debug": {
      logDebug(value.name, value.value);
      break;
    }
    default: {
      assertExhaustive$1(value, "Unexpected compilation kind");
    }
  }
  return value;
}
function isComponentDeclaration(node) {
  return Object.prototype.hasOwnProperty.call(node, "__componentDeclaration");
}
function isHookDeclaration(node) {
  return Object.prototype.hasOwnProperty.call(node, "__hookDeclaration");
}
function filterSuppressionsThatAffectFunction(suppressionRanges, fn) {
  const suppressionsInScope = [];
  const fnNode = fn.node;
  for (const suppressionRange of suppressionRanges) {
    if (
      suppressionRange.disableComment.start == null ||
      fnNode.start == null ||
      fnNode.end == null
    ) {
      continue;
    }
    if (
      suppressionRange.disableComment.start > fnNode.start &&
      (suppressionRange.enableComment === null ||
        (suppressionRange.enableComment.end != null &&
          suppressionRange.enableComment.end < fnNode.end))
    ) {
      suppressionsInScope.push(suppressionRange);
    }
    if (
      suppressionRange.disableComment.start < fnNode.start &&
      (suppressionRange.enableComment === null ||
        (suppressionRange.enableComment.end != null &&
          suppressionRange.enableComment.end > fnNode.end))
    ) {
      suppressionsInScope.push(suppressionRange);
    }
  }
  return suppressionsInScope;
}
function findProgramSuppressions(programComments, ruleNames, flowSuppressions) {
  const suppressionRanges = [];
  let disableComment = null;
  let enableComment = null;
  let source = null;
  const rulePattern = `(${ruleNames.join("|")})`;
  const disableNextLinePattern = new RegExp(
    `eslint-disable-next-line ${rulePattern}`
  );
  const disablePattern = new RegExp(`eslint-disable ${rulePattern}`);
  const enablePattern = new RegExp(`eslint-enable ${rulePattern}`);
  const flowSuppressionPattern = new RegExp(
    "\\$(FlowFixMe\\w*|FlowExpectedError|FlowIssue)\\[react\\-rule"
  );
  for (const comment of programComments) {
    if (comment.start == null || comment.end == null) {
      continue;
    }
    if (disableComment == null && disableNextLinePattern.test(comment.value)) {
      disableComment = comment;
      enableComment = comment;
      source = "Eslint";
    }
    if (
      flowSuppressions &&
      disableComment == null &&
      flowSuppressionPattern.test(comment.value)
    ) {
      disableComment = comment;
      enableComment = comment;
      source = "Flow";
    }
    if (disablePattern.test(comment.value)) {
      disableComment = comment;
      source = "Eslint";
    }
    if (enablePattern.test(comment.value) && source === "Eslint") {
      enableComment = comment;
    }
    if (disableComment != null && source != null) {
      suppressionRanges.push({
        disableComment: disableComment,
        enableComment: enableComment,
        source: source,
      });
      disableComment = null;
      enableComment = null;
      source = null;
    }
  }
  return suppressionRanges;
}
function suppressionsToCompilerError(suppressionRanges) {
  var _a;
  if (suppressionRanges.length === 0) {
    return null;
  }
  const error = new CompilerError();
  for (const suppressionRange of suppressionRanges) {
    if (
      suppressionRange.disableComment.start == null ||
      suppressionRange.disableComment.end == null
    ) {
      continue;
    }
    let reason, suggestion;
    switch (suppressionRange.source) {
      case "Eslint":
        reason =
          "React Compiler has skipped optimizing this component because one or more React ESLint rules were disabled";
        suggestion =
          "Remove the ESLint suppression and address the React error";
        break;
      case "Flow":
        reason =
          "React Compiler has skipped optimizing this component because one or more React rule violations were reported by Flow";
        suggestion = "Remove the Flow suppression and address the React error";
        break;
      default:
        assertExhaustive$1(
          suppressionRange.source,
          "Unhandled suppression source"
        );
    }
    error.pushErrorDetail(
      new CompilerErrorDetail({
        reason: `${reason}. React Compiler only works when your components follow all the rules of React, disabling them may result in unexpected or incorrect behavior`,
        description: suppressionRange.disableComment.value.trim(),
        severity: ErrorSeverity.InvalidReact,
        loc:
          (_a = suppressionRange.disableComment.loc) !== null && _a !== void 0
            ? _a
            : null,
        suggestions: [
          {
            description: suggestion,
            range: [
              suppressionRange.disableComment.start,
              suppressionRange.disableComment.end,
            ],
            op: CompilerSuggestionOperation.Remove,
          },
        ],
      })
    );
  }
  return error;
}
function findDirectiveEnablingMemoization(directives) {
  for (const directive of directives) {
    const directiveValue = directive.value.value;
    if (directiveValue === "use forget" || directiveValue === "use memo") {
      return directive;
    }
  }
  return null;
}
function findDirectiveDisablingMemoization(directives, options) {
  for (const directive of directives) {
    const directiveValue = directive.value.value;
    if (
      (directiveValue === "use no forget" ||
        directiveValue === "use no memo") &&
      !options.ignoreUseNoForget
    ) {
      return directive;
    }
  }
  return null;
}
function isCriticalError(err) {
  return !(err instanceof CompilerError) || err.isCritical();
}
function isConfigError(err) {
  if (err instanceof CompilerError) {
    return err.details.some(
      (detail) => detail.severity === ErrorSeverity.InvalidConfig
    );
  }
  return false;
}
function handleError(err, pass, fnLoc) {
  var _a, _b;
  if (pass.opts.logger) {
    if (err instanceof CompilerError) {
      for (const detail of err.details) {
        pass.opts.logger.logEvent(pass.filename, {
          kind: "CompileError",
          fnLoc: fnLoc,
          detail: detail.options,
        });
      }
    } else {
      let stringifiedError;
      if (err instanceof Error) {
        stringifiedError =
          (_a = err.stack) !== null && _a !== void 0 ? _a : err.message;
      } else {
        stringifiedError =
          (_b = err === null || err === void 0 ? void 0 : err.toString()) !==
            null && _b !== void 0
            ? _b
            : "[ null ]";
      }
      pass.opts.logger.logEvent(pass.filename, {
        kind: "PipelineError",
        fnLoc: fnLoc,
        data: stringifiedError,
      });
    }
  }
  if (
    pass.opts.panicThreshold === "all_errors" ||
    (pass.opts.panicThreshold === "critical_errors" && isCriticalError(err)) ||
    isConfigError(err)
  ) {
    throw err;
  }
}
function createNewFunctionNode(originalFn, compiledFn) {
  var _a, _b, _c;
  let transformedFn;
  switch (originalFn.node.type) {
    case "FunctionDeclaration": {
      const fn = {
        type: "FunctionDeclaration",
        id: compiledFn.id,
        loc: (_a = originalFn.node.loc) !== null && _a !== void 0 ? _a : null,
        async: compiledFn.async,
        generator: compiledFn.generator,
        params: compiledFn.params,
        body: compiledFn.body,
      };
      transformedFn = fn;
      break;
    }
    case "ArrowFunctionExpression": {
      const fn = {
        type: "ArrowFunctionExpression",
        loc: (_b = originalFn.node.loc) !== null && _b !== void 0 ? _b : null,
        async: compiledFn.async,
        generator: compiledFn.generator,
        params: compiledFn.params,
        expression: originalFn.node.expression,
        body: compiledFn.body,
      };
      transformedFn = fn;
      break;
    }
    case "FunctionExpression": {
      const fn = {
        type: "FunctionExpression",
        id: compiledFn.id,
        loc: (_c = originalFn.node.loc) !== null && _c !== void 0 ? _c : null,
        async: compiledFn.async,
        generator: compiledFn.generator,
        params: compiledFn.params,
        body: compiledFn.body,
      };
      transformedFn = fn;
      break;
    }
  }
  ALREADY_COMPILED.add(transformedFn);
  return transformedFn;
}
const ALREADY_COMPILED = new (
  WeakSet !== null && WeakSet !== void 0 ? WeakSet : Set
)();
const DEFAULT_ESLINT_SUPPRESSIONS = [
  "react-hooks/exhaustive-deps",
  "react-hooks/rules-of-hooks",
];
function isFilePartOfSources(sources, filename) {
  if (typeof sources === "function") {
    return sources(filename);
  }
  for (const prefix in sources) {
    if (filename.indexOf(prefix) !== -1) {
      return true;
    }
  }
  return false;
}
function compileProgram(program, pass) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  if (pass.opts.sources) {
    if (pass.filename === null) {
      const error = new CompilerError();
      error.pushErrorDetail(
        new CompilerErrorDetail({
          reason: `Expected a filename but found none.`,
          description:
            "When the 'sources' config options is specified, the React compiler will only compile files with a name",
          severity: ErrorSeverity.InvalidConfig,
          loc: null,
        })
      );
      handleError(error, pass, null);
      return;
    }
    if (!isFilePartOfSources(pass.opts.sources, pass.filename)) {
      return;
    }
  }
  if (
    findDirectiveDisablingMemoization(program.node.directives, pass.opts) !=
    null
  ) {
    return;
  }
  const environment = parseEnvironmentConfig(
    (_a = pass.opts.environment) !== null && _a !== void 0 ? _a : {}
  );
  const useMemoCacheIdentifier = program.scope.generateUidIdentifier("c");
  const moduleName =
    (_b = pass.opts.runtimeModule) !== null && _b !== void 0
      ? _b
      : "react/compiler-runtime";
  if (hasMemoCacheFunctionImport(program, moduleName)) {
    return;
  }
  const suppressions = findProgramSuppressions(
    pass.comments,
    (_c = pass.opts.eslintSuppressionRules) !== null && _c !== void 0
      ? _c
      : DEFAULT_ESLINT_SUPPRESSIONS,
    pass.opts.flowSuppressions
  );
  const lintError = suppressionsToCompilerError(suppressions);
  let hasCriticalError = lintError != null;
  const compiledFns = [];
  const traverseFunction = (fn, pass) => {
    var _a, _b, _c, _d, _e, _f;
    const fnType = getReactFunctionType(fn, pass);
    if (fnType === null || ALREADY_COMPILED.has(fn.node)) {
      return;
    }
    ALREADY_COMPILED.add(fn.node);
    fn.skip();
    if (lintError != null) {
      const suppressionsInFunction = filterSuppressionsThatAffectFunction(
        suppressions,
        fn
      );
      if (suppressionsInFunction.length > 0) {
        handleError(
          lintError,
          pass,
          (_a = fn.node.loc) !== null && _a !== void 0 ? _a : null
        );
      }
    }
    let compiledFn;
    try {
      if (environment.isErr()) {
        CompilerError.throwInvalidConfig({
          reason:
            "Error in validating environment config. This is an advanced setting and not meant to be used directly",
          description: environment.unwrapErr().toString(),
          suggestions: null,
          loc: null,
        });
      }
      const config = environment.unwrap();
      compiledFn = compileFn(
        fn,
        config,
        fnType,
        useMemoCacheIdentifier.name,
        pass.opts.logger,
        pass.filename,
        pass.code
      );
      (_b = pass.opts.logger) === null || _b === void 0
        ? void 0
        : _b.logEvent(pass.filename, {
            kind: "CompileSuccess",
            fnLoc: (_c = fn.node.loc) !== null && _c !== void 0 ? _c : null,
            fnName:
              (_e =
                (_d = compiledFn.id) === null || _d === void 0
                  ? void 0
                  : _d.name) !== null && _e !== void 0
                ? _e
                : null,
            memoSlots: compiledFn.memoSlotsUsed,
            memoBlocks: compiledFn.memoBlocks,
            memoValues: compiledFn.memoValues,
            prunedMemoBlocks: compiledFn.prunedMemoBlocks,
            prunedMemoValues: compiledFn.prunedMemoValues,
          });
    } catch (err) {
      hasCriticalError || (hasCriticalError = isCriticalError(err));
      handleError(
        err,
        pass,
        (_f = fn.node.loc) !== null && _f !== void 0 ? _f : null
      );
      return;
    }
    if (!pass.opts.noEmit && !hasCriticalError) {
      compiledFns.push({ originalFn: fn, compiledFn: compiledFn });
    }
  };
  program.traverse(
    {
      ClassDeclaration(node) {
        node.skip();
        return;
      },
      ClassExpression(node) {
        node.skip();
        return;
      },
      FunctionDeclaration: traverseFunction,
      FunctionExpression: traverseFunction,
      ArrowFunctionExpression: traverseFunction,
    },
    Object.assign(Object.assign({}, pass), {
      opts: Object.assign(Object.assign({}, pass.opts), pass.opts),
      filename: (_d = pass.filename) !== null && _d !== void 0 ? _d : null,
    })
  );
  if (pass.opts.gating != null) {
    const error = checkFunctionReferencedBeforeDeclarationAtTopLevel(
      program,
      compiledFns.map(({ originalFn: originalFn }) => originalFn)
    );
    if (error) {
      handleError(error, pass, null);
      return;
    }
  }
  const externalFunctions = [];
  let gating = null;
  try {
    if (pass.opts.gating != null) {
      gating = tryParseExternalFunction(pass.opts.gating);
      externalFunctions.push(gating);
    }
    const enableEmitInstrumentForget =
      (_e = pass.opts.environment) === null || _e === void 0
        ? void 0
        : _e.enableEmitInstrumentForget;
    if (enableEmitInstrumentForget != null) {
      externalFunctions.push(
        tryParseExternalFunction(enableEmitInstrumentForget.fn)
      );
      if (enableEmitInstrumentForget.gating != null) {
        externalFunctions.push(
          tryParseExternalFunction(enableEmitInstrumentForget.gating)
        );
      }
    }
    if (
      ((_f = pass.opts.environment) === null || _f === void 0
        ? void 0
        : _f.enableEmitFreeze) != null
    ) {
      const enableEmitFreeze = tryParseExternalFunction(
        pass.opts.environment.enableEmitFreeze
      );
      externalFunctions.push(enableEmitFreeze);
    }
    if (
      ((_g = pass.opts.environment) === null || _g === void 0
        ? void 0
        : _g.enableEmitHookGuards) != null
    ) {
      const enableEmitHookGuards = tryParseExternalFunction(
        pass.opts.environment.enableEmitHookGuards
      );
      externalFunctions.push(enableEmitHookGuards);
    }
    if (
      ((_h = pass.opts.environment) === null || _h === void 0
        ? void 0
        : _h.enableChangeDetectionForDebugging) != null
    ) {
      const enableChangeDetectionForDebugging = tryParseExternalFunction(
        pass.opts.environment.enableChangeDetectionForDebugging
      );
      externalFunctions.push(enableChangeDetectionForDebugging);
    }
  } catch (err) {
    handleError(err, pass, null);
    return;
  }
  for (const {
    originalFn: originalFn,
    compiledFn: compiledFn,
  } of compiledFns) {
    const transformedFn = createNewFunctionNode(originalFn, compiledFn);
    if (gating != null) {
      insertGatedFunctionDeclaration(originalFn, transformedFn, gating);
    } else {
      originalFn.replaceWith(transformedFn);
    }
  }
  if (compiledFns.length > 0) {
    let needsMemoCacheFunctionImport = false;
    for (const fn of compiledFns) {
      if (fn.compiledFn.memoSlotsUsed > 0) {
        needsMemoCacheFunctionImport = true;
        break;
      }
    }
    if (needsMemoCacheFunctionImport) {
      updateMemoCacheFunctionImport(
        program,
        moduleName,
        useMemoCacheIdentifier.name
      );
    }
    addImportsToProgram(program, externalFunctions);
  }
}
function getReactFunctionType(fn, pass) {
  var _a, _b, _c, _d, _e, _f, _g;
  const hookPattern =
    (_b =
      (_a = pass.opts.environment) === null || _a === void 0
        ? void 0
        : _a.hookPattern) !== null && _b !== void 0
      ? _b
      : null;
  if (fn.node.body.type === "BlockStatement") {
    const useNoForget = findDirectiveDisablingMemoization(
      fn.node.body.directives,
      pass.opts
    );
    if (useNoForget != null) {
      (_c = pass.opts.logger) === null || _c === void 0
        ? void 0
        : _c.logEvent(pass.filename, {
            kind: "CompileError",
            fnLoc:
              (_d = fn.node.body.loc) !== null && _d !== void 0 ? _d : null,
            detail: {
              severity: ErrorSeverity.Todo,
              reason: 'Skipped due to "use no forget" directive.',
              loc: (_e = useNoForget.loc) !== null && _e !== void 0 ? _e : null,
              suggestions: null,
            },
          });
      return null;
    }
    if (findDirectiveEnablingMemoization(fn.node.body.directives) != null) {
      return (_f = getComponentOrHookLike(fn, hookPattern)) !== null &&
        _f !== void 0
        ? _f
        : "Other";
    }
  }
  let componentSyntaxType = null;
  if (fn.isFunctionDeclaration()) {
    if (isComponentDeclaration(fn.node)) {
      componentSyntaxType = "Component";
    } else if (isHookDeclaration(fn.node)) {
      componentSyntaxType = "Hook";
    }
  }
  switch (pass.opts.compilationMode) {
    case "annotation": {
      return null;
    }
    case "infer": {
      return componentSyntaxType !== null && componentSyntaxType !== void 0
        ? componentSyntaxType
        : getComponentOrHookLike(fn, hookPattern);
    }
    case "syntax": {
      return componentSyntaxType;
    }
    case "all": {
      if (fn.scope.getProgramParent() !== fn.scope.parent) {
        return null;
      }
      return (_g = getComponentOrHookLike(fn, hookPattern)) !== null &&
        _g !== void 0
        ? _g
        : "Other";
    }
    default: {
      assertExhaustive$1(
        pass.opts.compilationMode,
        `Unexpected compilationMode \`${pass.opts.compilationMode}\``
      );
    }
  }
}
function hasMemoCacheFunctionImport(program, moduleName) {
  let hasUseMemoCache = false;
  program.traverse({
    ImportSpecifier(path) {
      const imported = path.get("imported");
      let importedName = null;
      if (imported.isIdentifier()) {
        importedName = imported.node.name;
      } else if (imported.isStringLiteral()) {
        importedName = imported.node.value;
      }
      if (
        importedName === "c" &&
        path.parentPath.isImportDeclaration() &&
        path.parentPath.get("source").node.value === moduleName
      ) {
        hasUseMemoCache = true;
      }
    },
  });
  return hasUseMemoCache;
}
function isHookName(s, hookPattern) {
  if (hookPattern !== null) {
    return new RegExp(hookPattern).test(s);
  }
  return /^use[A-Z0-9]/.test(s);
}
function isHook(path, hookPattern) {
  if (path.isIdentifier()) {
    return isHookName(path.node.name, hookPattern);
  } else if (
    path.isMemberExpression() &&
    !path.node.computed &&
    isHook(path.get("property"), hookPattern)
  ) {
    const obj = path.get("object").node;
    const isPascalCaseNameSpace = /^[A-Z].*/;
    return obj.type === "Identifier" && isPascalCaseNameSpace.test(obj.name);
  } else {
    return false;
  }
}
function isComponentName(path) {
  return path.isIdentifier() && /^[A-Z]/.test(path.node.name);
}
function isReactAPI(path, functionName) {
  const node = path.node;
  return (
    (node.type === "Identifier" && node.name === functionName) ||
    (node.type === "MemberExpression" &&
      node.object.type === "Identifier" &&
      node.object.name === "React" &&
      node.property.type === "Identifier" &&
      node.property.name === functionName)
  );
}
function isForwardRefCallback(path) {
  return !!(
    path.parentPath.isCallExpression() &&
    path.parentPath.get("callee").isExpression() &&
    isReactAPI(path.parentPath.get("callee"), "forwardRef")
  );
}
function isMemoCallback(path) {
  return (
    path.parentPath.isCallExpression() &&
    path.parentPath.get("callee").isExpression() &&
    isReactAPI(path.parentPath.get("callee"), "memo")
  );
}
function isValidPropsAnnotation(annot) {
  if (annot == null) {
    return true;
  } else if (annot.type === "TSTypeAnnotation") {
    switch (annot.typeAnnotation.type) {
      case "TSArrayType":
      case "TSBigIntKeyword":
      case "TSBooleanKeyword":
      case "TSConstructorType":
      case "TSFunctionType":
      case "TSLiteralType":
      case "TSNeverKeyword":
      case "TSNumberKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSTupleType":
        return false;
    }
    return true;
  } else if (annot.type === "TypeAnnotation") {
    switch (annot.typeAnnotation.type) {
      case "ArrayTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
        return false;
    }
    return true;
  } else if (annot.type === "Noop") {
    return true;
  } else {
    assertExhaustive$1(annot, `Unexpected annotation node \`${annot}\``);
  }
}
function isValidComponentParams(params) {
  if (params.length === 0) {
    return true;
  } else if (params.length > 0 && params.length <= 2) {
    if (!isValidPropsAnnotation(params[0].node.typeAnnotation)) {
      return false;
    }
    if (params.length === 1) {
      return !params[0].isRestElement();
    } else if (params[1].isIdentifier()) {
      const { name: name } = params[1].node;
      return name.includes("ref") || name.includes("Ref");
    } else {
      return false;
    }
  }
  return false;
}
function getComponentOrHookLike(node, hookPattern) {
  const functionName = getFunctionName(node);
  if (functionName !== null && isComponentName(functionName)) {
    let isComponent =
      callsHooksOrCreatesJsx(node, hookPattern) &&
      isValidComponentParams(node.get("params")) &&
      !returnsNonNode(node);
    return isComponent ? "Component" : null;
  } else if (functionName !== null && isHook(functionName, hookPattern)) {
    return callsHooksOrCreatesJsx(node, hookPattern) ? "Hook" : null;
  }
  if (node.isFunctionExpression() || node.isArrowFunctionExpression()) {
    if (isForwardRefCallback(node) || isMemoCallback(node)) {
      return callsHooksOrCreatesJsx(node, hookPattern) ? "Component" : null;
    }
  }
  return null;
}
function skipNestedFunctions(node) {
  return (fn) => {
    if (fn.node !== node.node) {
      fn.skip();
    }
  };
}
function callsHooksOrCreatesJsx(node, hookPattern) {
  let invokesHooks = false;
  let createsJsx = false;
  node.traverse({
    JSX() {
      createsJsx = true;
    },
    CallExpression(call) {
      const callee = call.get("callee");
      if (callee.isExpression() && isHook(callee, hookPattern)) {
        invokesHooks = true;
      }
    },
    ArrowFunctionExpression: skipNestedFunctions(node),
    FunctionExpression: skipNestedFunctions(node),
    FunctionDeclaration: skipNestedFunctions(node),
  });
  return invokesHooks || createsJsx;
}
function returnsNonNode(node) {
  let hasReturn = false;
  let returnsNonNode = false;
  node.traverse({
    ReturnStatement(ret) {
      hasReturn = true;
      const argument = ret.node.argument;
      if (argument == null) {
        returnsNonNode = true;
      } else {
        switch (argument.type) {
          case "ObjectExpression":
          case "ArrowFunctionExpression":
          case "FunctionExpression":
          case "BigIntLiteral":
          case "ClassExpression":
          case "NewExpression":
            returnsNonNode = true;
        }
      }
    },
    ArrowFunctionExpression: skipNestedFunctions(node),
    FunctionExpression: skipNestedFunctions(node),
    FunctionDeclaration: skipNestedFunctions(node),
  });
  return !hasReturn || returnsNonNode;
}
function getFunctionName(path) {
  if (path.isFunctionDeclaration()) {
    const id = path.get("id");
    if (id.isIdentifier()) {
      return id;
    }
    return null;
  }
  let id = null;
  const parent = path.parentPath;
  if (parent.isVariableDeclarator() && parent.get("init").node === path.node) {
    id = parent.get("id");
  } else if (
    parent.isAssignmentExpression() &&
    parent.get("right").node === path.node &&
    parent.get("operator") === "="
  ) {
    id = parent.get("left");
  } else if (
    parent.isProperty() &&
    parent.get("value").node === path.node &&
    !parent.get("computed") &&
    parent.get("key").isLVal()
  ) {
    id = parent.get("key");
  } else if (
    parent.isAssignmentPattern() &&
    parent.get("right").node === path.node &&
    !parent.get("computed")
  ) {
    id = parent.get("left");
  }
  if (id !== null && (id.isIdentifier() || id.isMemberExpression())) {
    return id;
  } else {
    return null;
  }
}
function checkFunctionReferencedBeforeDeclarationAtTopLevel(program, fns) {
  const fnIds = new Set(
    fns
      .map((fn) => getFunctionName(fn))
      .filter((name) => !!name && name.isIdentifier())
      .map((name) => name.node)
  );
  const fnNames = new Map([...fnIds].map((id) => [id.name, id]));
  const errors = new CompilerError();
  program.traverse({
    TypeAnnotation(path) {
      path.skip();
    },
    TSTypeAnnotation(path) {
      path.skip();
    },
    TypeAlias(path) {
      path.skip();
    },
    TSTypeAliasDeclaration(path) {
      path.skip();
    },
    Identifier(id) {
      var _a;
      const fn = fnNames.get(id.node.name);
      if (!fn) {
        return;
      }
      if (fnIds.has(id.node)) {
        fnIds.delete(id.node);
        fnNames.delete(id.node.name);
        return;
      }
      const scope = id.scope.getFunctionParent();
      if (scope === null) {
        errors.pushErrorDetail(
          new CompilerErrorDetail({
            reason: `Encountered a function used before its declaration, which breaks Forget's gating codegen due to hoisting`,
            description: `Rewrite the reference to ${fn.name} to not rely on hoisting to fix this issue`,
            loc: (_a = fn.loc) !== null && _a !== void 0 ? _a : null,
            suggestions: null,
            severity: ErrorSeverity.Invariant,
          })
        );
      }
    },
  });
  return errors.details.length > 0 ? errors : null;
}
function hasModule(name) {
  try {
    return !!require.resolve(name);
  } catch (error) {
    if (
      error.code === "MODULE_NOT_FOUND" &&
      error.message.indexOf(name) !== -1
    ) {
      return false;
    }
    throw error;
  }
}
function pipelineUsesReanimatedPlugin(plugins) {
  if (Array.isArray(plugins)) {
    for (const plugin of plugins) {
      if (hasOwnProperty(plugin, "key")) {
        const key = plugin.key;
        if (
          typeof key === "string" &&
          key.indexOf("react-native-reanimated") !== -1
        ) {
          return true;
        }
      }
    }
  }
  return hasModule("react-native-reanimated");
}
function injectReanimatedFlag(options) {
  return Object.assign(Object.assign({}, options), {
    environment: Object.assign(Object.assign({}, options.environment), {
      enableCustomTypeDefinitionForReanimated: true,
    }),
  });
}
function BabelPluginReactCompiler(_babel) {
  return {
    name: "react-forget",
    visitor: {
      Program(prog, pass) {
        var _a, _b;
        let opts = parsePluginOptions(pass.opts);
        const isDev =
          (typeof __DEV__ !== "undefined" && __DEV__ === true) ||
          process.env["NODE_ENV"] === "development";
        if (
          opts.enableReanimatedCheck === true &&
          pipelineUsesReanimatedPlugin(pass.file.opts.plugins)
        ) {
          opts = injectReanimatedFlag(opts);
        }
        if (isDev) {
          opts = Object.assign(Object.assign({}, opts), {
            environment: Object.assign(Object.assign({}, opts.environment), {
              enableResetCacheOnSourceFileChanges: true,
            }),
          });
        }
        compileProgram(prog, {
          opts: opts,
          filename: (_a = pass.filename) !== null && _a !== void 0 ? _a : null,
          comments:
            (_b = pass.file.ast.comments) !== null && _b !== void 0 ? _b : [],
          code: pass.file.code,
        });
      },
    },
  };
}
function assertExhaustive(_, errorMsg) {
  throw new Error(errorMsg);
}
function isReactCompilerError(err) {
  return err.name === "ReactCompilerError";
}
const DEFAULT_REPORTABLE_LEVELS = new Set([
  ErrorSeverity.InvalidReact,
  ErrorSeverity.InvalidJS,
]);
let reportableLevels = DEFAULT_REPORTABLE_LEVELS;
function isReportableDiagnostic(detail) {
  return (
    reportableLevels.has(detail.severity) &&
    detail.loc != null &&
    typeof detail.loc !== "symbol"
  );
}
const COMPILER_OPTIONS = {
  noEmit: true,
  compilationMode: "infer",
  panicThreshold: "all_errors",
};
const rule = {
  meta: {
    type: "problem",
    docs: {
      description: "Surfaces diagnostics from React Forget",
      recommended: true,
    },
    fixable: "code",
    hasSuggestions: true,
    schema: [{ type: "object", additionalProperties: true }],
  },
  create(context) {
    var _a, _b, _c, _d, _e, _f, _g;
    const sourceCode =
      (_b =
        (_a = context.sourceCode) === null || _a === void 0
          ? void 0
          : _a.text) !== null && _b !== void 0
        ? _b
        : context.getSourceCode().text;
    const filename =
      (_c = context.filename) !== null && _c !== void 0
        ? _c
        : context.getFilename();
    const userOpts =
      (_d = context.options[0]) !== null && _d !== void 0 ? _d : {};
    if (
      userOpts["reportableLevels"] != null &&
      userOpts["reportableLevels"] instanceof Set
    ) {
      reportableLevels = userOpts["reportableLevels"];
    } else {
      reportableLevels = DEFAULT_REPORTABLE_LEVELS;
    }
    const options = Object.assign(
      Object.assign({}, parsePluginOptions(userOpts)),
      COMPILER_OPTIONS
    );
    try {
      options.environment = validateEnvironmentConfig(
        (_e = options.environment) !== null && _e !== void 0 ? _e : {}
      );
    } catch (err) {
      (_f = options.logger) === null || _f === void 0
        ? void 0
        : _f.logEvent("", err);
    }
    function hasFlowSuppression(nodeLoc, suppression) {
      const sourceCode = context.getSourceCode();
      const comments = sourceCode.getAllComments();
      const flowSuppressionRegex = new RegExp(
        "\\$FlowFixMe\\[" + suppression + "\\]"
      );
      for (const commentNode of comments) {
        if (
          flowSuppressionRegex.test(commentNode.value) &&
          commentNode.loc.end.line === nodeLoc.start.line - 1
        ) {
          return true;
        }
      }
      return false;
    }
    let babelAST;
    if (filename.endsWith(".tsx") || filename.endsWith(".ts")) {
      try {
        const { parse: babelParse } = require("@babel/parser");
        babelAST = babelParse(sourceCode, {
          filename: filename,
          sourceType: "unambiguous",
          plugins: ["typescript", "jsx"],
        });
      } catch (_h) {}
    } else {
      try {
        babelAST = HermesParser__namespace.parse(sourceCode, {
          babel: true,
          enableExperimentalComponentSyntax: true,
          sourceFilename: filename,
          sourceType: "module",
        });
      } catch (_j) {}
    }
    if (babelAST != null) {
      try {
        core$2.transformFromAstSync(babelAST, sourceCode, {
          filename: filename,
          highlightCode: false,
          retainLines: true,
          plugins: [
            [PluginProposalPrivateMethods, { loose: true }],
            [BabelPluginReactCompiler, options],
          ],
          sourceType: "module",
          configFile: false,
          babelrc: false,
        });
      } catch (err) {
        if (isReactCompilerError(err) && Array.isArray(err.details)) {
          for (const detail of err.details) {
            if (!isReportableDiagnostic(detail)) {
              continue;
            }
            if (hasFlowSuppression(detail.loc, "react-rule-hook")) {
              continue;
            }
            let suggest = [];
            if (Array.isArray(detail.suggestions)) {
              for (const suggestion of detail.suggestions) {
                switch (suggestion.op) {
                  case CompilerSuggestionOperation.InsertBefore:
                    suggest.push({
                      desc: suggestion.description,
                      fix(fixer) {
                        return fixer.insertTextBeforeRange(
                          suggestion.range,
                          suggestion.text
                        );
                      },
                    });
                    break;
                  case CompilerSuggestionOperation.InsertAfter:
                    suggest.push({
                      desc: suggestion.description,
                      fix(fixer) {
                        return fixer.insertTextAfterRange(
                          suggestion.range,
                          suggestion.text
                        );
                      },
                    });
                    break;
                  case CompilerSuggestionOperation.Replace:
                    suggest.push({
                      desc: suggestion.description,
                      fix(fixer) {
                        return fixer.replaceTextRange(
                          suggestion.range,
                          suggestion.text
                        );
                      },
                    });
                    break;
                  case CompilerSuggestionOperation.Remove:
                    suggest.push({
                      desc: suggestion.description,
                      fix(fixer) {
                        return fixer.removeRange(suggestion.range);
                      },
                    });
                    break;
                  default:
                    assertExhaustive(
                      suggestion,
                      "Unhandled suggestion operation"
                    );
                }
              }
            }
            context.report({
              message: detail.reason,
              loc: detail.loc,
              suggest: suggest,
            });
          }
        } else {
          (_g = options.logger) === null || _g === void 0
            ? void 0
            : _g.logEvent("", err);
        }
      }
    }
    return {};
  },
};
var ReactCompilerRule = rule;
module.exports = { rules: { "react-compiler": ReactCompilerRule } };
